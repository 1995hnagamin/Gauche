@node Library modules - SRFIs, Library modules - Utilities, Library modules - Gauche extensions, Top
@chapter Library modules - SRFIs
@c NODE ライブラリモジュール - SRFI

@c EN
This chapter lists modules that provides SRFI functionalities.
Note that some of SRFI features are built in Gauche core and
not listed here.  @xref{Standard conformance}, for entire list
of supported SRFIs.
@c JP
この章ではSRFIの機能を提供するモジュールをリストします。
一部のSRFIはGaucheのコアに組み込まれており、
この章には挙げられていないことに注意して下さい。
サポートされている全てのSRFIのリストは@ref{Standard conformance}にあります。
@c COMMON

@c ----------------------------------------------------------------------
@menu
* srfi-0 - Feature conditional::  
* srfi-1 - List library::       
* srfi-2 - And-let*::           
* srfi-4 - Homogeneous vectors::  
* srfi-9 - Record types::       
* srfi-11 - Let-values::        
* srfi-13 - String library::    
* srfi-14 - Character-set library::  
* srfi-19 - Time data types and procedures::  
* srfi-27 - Sources of random bits::  
* srfi-37 - a program argument processor::  
@end menu

@node srfi-0 - Feature conditional, srfi-1 - List library, Library modules - SRFIs, Library modules - SRFIs
@section @code{srfi-0} - Feature conditional
@c NODE @code{srfi-0} - 機能条件式

@deftp {Module} srfi-0
@mdindex srfi-0
@c EN
Provides SRFI-0 @code{cond-expand} macro form.
Now this module is autoloaded when @code{cond-expand} is used,
so you don't need to say @code{(use srfi-0)} explicitly.
Portable programs can't use 'use' form anyway.
@c JP
このモジュールは SRFI-0 の @code{cond-expand} マクロ形式を提供します。
現在、このモジュールは @code{cond-expand} を使用したときに、自動的に
ロードされますので、明示的に @code{(use srfi-0)} を書く必要はありません。
ポータブルなプログラムにするには、'use' 形式を使わない方が良いでしょう。
@c COMMON
@end deftp

@defmac cond-expand (feature-requirement command-or-definition @dots{}) @dots{}
[SRFI-0]
@c EN
This macro expands to @var{command-or-definition} @dots{} if Gauche
supports @var{feature-requirement}.
In a way, it can be used to absorb the different feature sets supported by
different Scheme implementations.

@var{feature-requiremnt} must be in the following syntax:
@c JP
Gauche が @var{feature-requirement} をサポートしていれば、このマクロは
@var{command-or-definition} @dots{} を展開します。
異るScheme の実装による機能の差異を吸収するのに使えると言えるでしょう。

@var{feature-requiremnt} は以下のような構文でなければなりません。
@c COMMON
@example
@var{feature-requirement}
  : @var{feature-identifier}
  | (and @var{feature-requirement} @dots{})
  | (or  @var{feature-requirement} @dots{})
  | (not @var{feature-requirement})
@end example

@c EN
@var{feature-identifier} is a symbol that indicates a feature.
If such a feature is supported in Gauche, it satisfies the
@var{feature-requirement}.  You can do boolean combination
of @var{feature-requirement}s to compose more complex conditions.

The macro tests each @var{feature-requirement} in order, and
if one is satisfied, the macro itself expands to the
corresponding @var{command-or-definition} @dots{}.

The last clause may begin with a symbol @code{else} instead of
@var{feature-requirement}.  If no condition is fulfilled before
it, then the macro expands to the @var{command-or-definition}s
of the else clause.  If there's no else clause and no condition
is fulfilled, an error is signalled.

Currently, Gauche recognizes srfi names (e.g. @code{srfi-1})
that it supports (@xref{Standard conformance}, for the list of
supported SRFIs), and a symbol @code{gauche} as @var{feature-identifier}.

Suppose you are writing a program that requires srfi-13 (string library).
In Gauche, the standard way to use srfi-13 is like this:
@c JP
@var{feature-identifier} は機能を示すシンボルです。ある機能が Gauche で
サポートされているなら、それは、@var{feature-requirement} を満します。
より複雑な条件を構成するために、@var{feature-requirement} の真理値の組合せ
を使う事ができます。

このマクロは @var{feature-requirement} をその順でテストし、そのひとつが
満たされたら、対応する @var{command-or-definition} @dots{} に展開されます。

最後の節は、@var{feature-requirement} ではなく、@code{else} で始めることも
できます。これ以前に満された条件がない場合には、このマクロは else 節の
@var{command-or-definition} に展開されます。もし、else 節がなく、
満される条件節がひとつもなければ、エラーが発生します。

現時点の Gauche では、サポートされている SRFI の機能は、srfi 名
(たとえば、@code{srfi-1})で識別されます(サポートされている SRFI に
ついては @ref{Standard conformance} を参照してください)。
また、シンボル @code{gauche} も @var{feature-identifier} として認識されます。

srfi-13 (文字列ライブラリ)を必要とするプログラムを書いているとしましょう。
Gauche では、標準的には、以下のようにします。
@c COMMON

@example
(use srfi-13)

@c EN
;; ... your program ...
@c JP
;; ... あなたのプログラム ...
@c COMMON
@end example

@c EN
However, the 'use' macro is Gauche specific and won't work
on other Scheme implementations.  You can write instead:
@c JP
しかし、この 'use' マクロは Gauche 専用で、他の Scheme の実装では
動作しません。代りに以下のように書くことができます。
@c COMMON

@example
(cond-expand
  (srfi-13
@c EN
    ;; ... your program ...
@c JP
    ;; ... あなたのプログラム ...
@c COMMON
  ))
@end example

@c EN
If the implementation supports @code{srfi-13}, the form expands
to your program.  Note that Gauche issues @code{(use srfi-13)}
for you in this case.

The above form signals an error if the implementation doesn't support
srfi-13.  However, you might want to run your program on such implentations
as well, by providing alternative library definitions.
@c JP
その実装が @code{srfi-13} をサポートしていれば、この形式は「あなたの
プログラム」に展開されます。Gauche では、この場合に
内部で@code{(use srfi-13)}を呼び出します。

上記のフォームは実装がsrfi-13をサポートしていなければエラーとなります。
そのような実装の上でもプログラムを走らせたい時は、
代替となるライブラリ定義を提供すると良いでしょう。
@c COMMON

@example
(cond-expand
 (srfi-13
@c EN
   ;; ... your program ...
@c JP
   ;; ... あなたのプログラム ...
@c COMMON
 )
 (else
   (load "my-srfi-13-implementation")
@c EN
   ;; ... your program ...
@c JP
   ;; ... あなたのプログラム ...
@c COMMON
 ))
@end example
@end defmac

@c ----------------------------------------------------------------------
@node srfi-1 - List library, srfi-2 - And-let*, srfi-0 - Feature conditional, Library modules - SRFIs
@section @code{srfi-1} - List library

@deftp {Module} srfi-1
@mdindex srfi-1
@c EN
SRFI-1 is a rich collection of list manipulation library
(@ref{srfi-1,[SRFI-1],SRFI-1}).
It is available by saying @code{(use srfi-1)}.
The implementation is based on Olin Shivers's reference implementation.
I splitted it into number of subfiles that will be autoloaded on demand.
@c JP
SRFI-1 は、リスト操作ライブラリのリッチなコレクションです
(@ref{srfi-1,[SRFI-1],SRFI-1})。
このライブラリを使うには、@code{(use srfi-1)} として下さい。
Olin Shivers氏のリファレンス実装に基づいて実装されています。
要求されたときに自動的にロードされるいくつかのサブファイルに分割して
あります。
@c COMMON
@end deftp

@menu
* SRFI-1 List constructors::    
* SRFI-1 List predicates::      
* SRFI-1 List selectors::       
* SRFI-1 List miscellaneous routines::  
* SRFI-1 Fold::                 
* SRFI-1 Filtering & Partitioning::  
* SRFI-1 Searching::            
* SRFI-1 Deletion::             
* SRFI-1 Association lists::    
* SRFI-1 Set operations::       
@end menu

@node SRFI-1 List constructors, SRFI-1 List predicates, srfi-1 - List library, srfi-1 - List library
@subsection List constructors
@c NODE リストの構築子

@defun xcons cd ca
@c EN
[SRFI-1] Equivalent to @code{(cons ca cd)}.  Useful to pass to
higher-order procedures.
@c JP
[SRFI-1] @code{(cons ca cd)} と同等です。公開手続きへ渡すのに便利です。
@c COMMON
@end defun

@defun cons* elt1 elt2 @dots{}
@c EN
[SRFI-1] Like @code{list}, but the last argument provides the tail of
the constructed list.  This is just a synonym of Gauche built-in procedure
@code{list*}.
@c JP
[SRFI-1] @code{list} と似ていますが、最後の引数が構築されたリストの
末尾になります。Gauche の組み込み手続き @code{list*} と同意です。
@c COMMON
@example
(cons* 1 2 3 4) @result{} (1 2 3 . 4)
(cons* 1) @result{} 1
@end example
@end defun

@defun list-tabulate n init-proc
@c EN
[SRFI-1] Constructs an @var{n}-element list, in which
each element is generated by @code{(@var{init-proc} @i{i})}.
@c JP
[SRFI-1] @var{n}個の要素をもつリストを構築し、それぞれの要素を
@code{(@var{init-proc} @i{i})} で生成します。
@c COMMON
@example
(list-tabulate 4 values) @result{} (0 1 2 3)
@end example
@end defun

@defun circular-list elt1 elt2 @dots{}
@c EN
[SRFI-1] Constructs a circular list of the elements.
@c JP
[SRFI-1] 指定した要素をもつ循環リストを構築します。
@c COMMON
@example
(circular-list 'z 'q) @result{} (z q z q z q @dots{})
@end example
@end defun

@defun iota count &optional (start 0) (step 1)
@c EN
[SRFI-1] Returns a list of numbers, starting from @var{start},
increasing by @var{step}.
@c JP
[SRFI-1] @var{start}から始まり、@var{step}ずつ増加する、
@var{count} 個の要素からなる数値のリストを返します。
@c COMMON
@example
(iota 5) @result{} (0 1 2 3 4)
(iota 5 0 -0.1) @result{} (0 -0.1 -0.2 -0.3 -0.4)
@end example
@end defun

@node SRFI-1 List predicates, SRFI-1 List selectors, SRFI-1 List constructors, srfi-1 - List library
@subsection List predicates
@c NODE リストの述語

@defun proper-list? x
@c EN
[SRFI-1] Returns @code{#t} if x is a proper list.
@c JP
[SRFI-1] @var{x} が真性リストであれば @code{#t} を返します。
@c COMMON
@end defun

@defun circular-list? x
@c EN
[SRFI-1] Returns @code{#t} if x is a circular list.
@c JP
[SRFI-1] @var{x} が循環リストであれば @code{#t} を返します。
@c COMMON
@end defun

@defun dotted-list? x
@c EN
[SRFI-1] Returns @code{#t} if x is a finite, non-nil-terminated list.
This includes non-pair, non-() values (e.g. symbols, numbers),
which are considered to be dotted lists of length 0.
@c JP
[SRFI-1] @var{x} が有限の大きさで、空リストで終端していないリストなら
@code{#t} を返します。これには、ペアではなく、空リストもない値(たとえば
シンボルや数値)のような長さ0のドットリストと考えられるものを含みます。
@c COMMON
@end defun

@defun null-list? list
@c EN
[SRFI-1] Returns @code{#t} if @var{list} is the empty list @code{()},
and @var{#f} otherwise.
@c JP
[SRFI-1] @var{list} が空リスト @code{()} なら @code{#t} を返します。
それ以外のときは @var{#f} を返します。
@c COMMON
@end defun

@defun not-pair? x
@c EN
[SRFI-1] @code{(lambda (x) (not (pair? x)))}.

SRFI-1 says: Provided as a procedure as it can be useful as
the termination condition for list-processing procedures that wish to
handle all finite lists, both proper and dotted. 
@c JP
[SRFI-1] @code{(lambda (x) (not (pair? x)))}と同じです。

SRFI-1 では、「真性リストおよびドットリストの両方で、すべての有限リストを
扱う手続き用の終端条件として便利なように用意した」とあります。
@c COMMON
@end defun

@defun list= elt= list @dots{}
@c EN
[SRFI-1] Determines list equality by comparing every n-th element
of given lists by the procedure @var{elt=}.

It is an error to apply @code{list=} to anything except proper lists.

The equality procedure must be consistent with @code{eq?}, i.e.
@c JP
[SRFI-1] @var{elt=} を用いて、n番目の要素をそれぞれ比較することで、
与えられたリストの同値性を決定します。

@code{list=} を真性リスト以外に適用するとエラーになります。

同値性判定の手続きは @code{eq?} と整合性がなければなりません。すなわち
@c COMMON
@example
(eq? x y) @result{} (elt= x y).
@end example
@end defun

@node SRFI-1 List selectors, SRFI-1 List miscellaneous routines, SRFI-1 List predicates, srfi-1 - List library
@subsection List selectors
@c NODE リスト選択子

@defun  first pair
@defunx second pair
@defunx third pair
@defunx fourth pair
@defunx fifth pair
@defunx sixth pair
@defunx seventh pair
@defunx eighth pair
@defunx ninth pair
@defunx tenth pair
@c EN
[SRFI-1] Returns n-th element of the (maybe improper) list.
@c JP
[SRFI-1] リスト(非真性でも可)のn番目の要素を返します。
@c COMMON
@end defun

@defun car+cdr pair
@c EN
[SRFI-1] Returns two values, @code{(car pair)} and @code{(cdr pair)}.
@c JP
[SRFI-1] @code{(car pair)} および @code{(cdr pair)} の二つの値を返します。
@c COMMON
@end defun

@defun take x i
@defunx drop x i
@c EN
[SRFI-1] @code{take} returns the first i elements of list x.
@code{drop} returns all but the first i elements of list x. 
@c JP
[SRFI-1]
@code{take} はリスト @var{x} の最初のi個の要素を返します。
@code{drop} はリスト @var{x} の最初のi個の要素以外を返します。
@c COMMON
@example
(take '(a b c d e)  2) => (a b)
(drop '(a b c d e)  2) => (c d e)
@end example
@c EN
@var{x} may be any value:
@c JP
@var{x} はあらゆる値をとりえます。
@c COMMON
@example
(take '(1 2 3 . d) 2) => (1 2)
(drop '(1 2 3 . d) 2) => (3 . d)
(drop '(1 2 3 . d) 3) => d
@end example
@c EN
@code{drop} is exactly equivalent to performing @var{i} cdr operations
on @var{x}.  The returned value shares a common tail with @var{x}.
On the other hand, take always allocates a new list 
for result if the argument is a list of non-zero length.

An error is signalled if @var{i} is past the end of list @var{x}.
@xref{util.list - Additional list library}, for more tolerant version
of @code{take} and @code{drop}.

For generic subsequence extranction from any sequence, see @code{subseq}
in @ref{Slicing sequence}.
@c JP
@code{drop} は @var{x} に @var{i} 回 cdr 操作をおこなうのと全く
同じです。返される値は、@var{x} と共通の末尾を共有します。一方、
take は、引数のリストが長さ0でないリストなら必ず新しいリストの
領域を確保します。

@var{i} がリスト @var{x} の終端を超えたらエラーが発生します。
より丈夫なバージョンの @code{take} と @code{drop} については、
@xref{util.list - Additional list library} を参照してください。

あらゆる並びからの部分並びを抽出するということについては、
@ref{Slicing sequence} にある @code{subseq} を参照してください。
@c COMMON
@end defun

@defun take-right flist i
@defunx drop-right flist i
@c EN
[SRFI-1] @code{take-right} returns the last @var{i} elements of @var{flist}.
@code{drop-right} returns all but the last @var{i} elements of @var{flist}. 
@c JP
[SRFI-1] @code{take-right} は @var{flist} の最後の @var{i}個の要素を
返します。@code{drop-right} は @var{flist} の最後の @var{i}個の要素以外を
返します。
@c COMMON
@example
(take-right '(a b c d e) 2) => (d e)
(drop-right '(a b c d e) 2) => (a b c)
@end example
@c EN
@var{flist} may be any finite list.
@c JP
@var{flist} は有限リストであればmay be any finite list.
@c COMMON
@example
(take-right '(1 2 3 . d) 2) => (2 3 . d)
(drop-right '(1 2 3 . d) 2) => (1)
(take-right '(1 2 3 . d) 0) => d
(drop-right '(1 2 3 . d) 0) => (1 2 3)
@end example
@c EN
@code{take-right}'s return value always shares a common
tail with @var{flist}.
@code{drop-right} always allocates a new list
if the argument is a list of non-zero length.

An error is signalled if @var{i} is larger than the length of @var{flist}.
@xref{util.list - Additional list library}, for more tolerant version
of @code{take-right} and @code{drop-right}.
@c JP
@code{take-right} の返す値はいつでも @var{first} の共通の末尾を共有します。
@code{drop-right} は、引数が長さが0でないリストなら、必ず新しいリストの
領域を確保します。

@var{i} がリスト @var{flist} の長さより大きければエラーが発生します。
より丈夫なバージョンの @code{take-right} と @code{drop-right} については、
@xref{util.list - Additional list library} を参照してください。
@c COMMON
@end defun

@defun take! x i
@defunx drop-right! x i
@c EN
[SRFI-1]  Linear update variants of @var{take} and @var{drop-right}.
Those procedures may destructively modifies @var{x}.

If @var{x} is circular, @code{take!} may return a list
shorter than expected.
@c JP
[SRFI-1] @var{take} および @var{drop-right} の
その場で更新されるバージョンです。これらの
手続きは @var{x} を破壊的に変更します。

@var{x} が循環リストなら、@code{take!} は期待よりも短いリストを返す
可能性があります。
@c COMMON
@end defun

@defun split-at x i
@defunx split-at! x i
@c EN
[SRFI-1] @code{split-at} splits the list @var{x} at index @var{i},
returning a list of the first @var{i} elements, and the remaining tail.
@c JP
[SRFI-1] @code{split-at} はリスト @var{x} をインデックス @var{i} の
位置で分割し、最初の @var{i} 個の要素からなるリストと、残りの末尾とを
返します。
@c COMMON
@example
(split-at '(a b c d e) 2) @result{} (a b) (c d e)
@end example
@c EN
@code{split-at!} is the linear-update variant. It may destructively
modifes @var{x} to produce the result. 
@c JP
@code{split-at!} はその場で更新されるバージョンです。
これは @var{x} を破壊的に更新します。
@c COMMON
@end defun

@defun last pair
@c EN
[SRFI-1] Returns the last element of the non-empty, finite list @var{pair}.
It is equivalent to @code{(car (last-pair pair))}.
Note that @code{last-pair} is Gauche built-in procedure.
@c JP
[SRFI-1] 空ではない有限リスト @var{pair} の最後の要素を返します。
これは、@code{(car (last-pair pair))} と同等です。

註: @code{last-pair} は Gauche の組み込み手続きです。
@c COMMON
@end defun

@node SRFI-1 List miscellaneous routines, SRFI-1 Fold, SRFI-1 List selectors, srfi-1 - List library
@subsection List miscellaneous routines
@c NODE 種々のルーチン

@defun length+ x
@ EN
[SRFI-1] If @var{x} is a proper list, returns its length.
Otherwise, returns @code{#f}.
@c JP
[SRFI-1] @var{x} が真性リストなら、その長さを返します。さもなければ、
@code{#f} を返します。
@c COMMON
@end defun

@defun concatenate list-of-lists
@defunx concatenate! list-of-lists!
@c EN
[SRFI-1] Equivalent to @code{(apply append @var{list-of-lists})} and
@code{(apply append! @var{list-of-lists})}, respectively.
@c JP
[SRFI-1] それぞれ、@code{(apply append @var{list-of-lists})} および
@code{(apply append! @var{list-of-lists})} と同等です。
@c COMMON
@end defun

@defun append-reverse rev-head tail
@defunx append-reverse! rev-head tail
@c EN
[SRFI-1] @code{append-reverse} returns @code{(append (reverse rev-head) tail)}.
@code{append-reverse!} is the linear-update variant.
@c JP
[SRFI-1] @code{append-reverse} は @code{(append (reverse rev-head) tail)} を
返します。@code{append-reverse!} はその場で更新されるバージョンです。
@c COMMON
@end defun

@defun zip clist1 clist2 @dots{}
@c EN
[SRFI-1] Equivalent to @code{(map list clist1 clist2 @dots{})}.
If @code{zip} is passed @var{n} lists, it returns a list as long as
the shortest of these lists, each element of which is an @var{n}-element list
comprised of the corresponding elements from the parameter lists. 
@c JP
[SRFI-1] @code{(map list clist1 clist2 @dots{})} と同等です。
@var{n} 本のリストが @code{zip} に渡された場合には、そのなかで一番短いものと
同じながさのリストを返します。返されたリストは、要素が @var{n} 要素のリストで、
そのそれぞれが、引数として渡ってリストの対応する要素になっています。
@c COMMON
@example
(zip '(one two three) 
     '(1 2 3)
     '(odd even odd even odd even odd even))
     @result{} ((one 1 odd) (two 2 even) (three 3 odd))

(zip '(1 2 3)) @result{} ((1) (2) (3))
@end example
@c EN
At least one of the argument lists must be finite: 
@c JP
引数のリストのうち、少くともひとつは有限のリストでなければなりません。
@c COMMON
@example
(zip '(3 1 4 1) (circular-list #f #t)) 
     @result{} ((3 #f) (1 #t) (4 #f) (1 #t))
@end example
@end defun

@defun unzip1 list
@defunx unzip2 list
@defunx unzip3 list
@defunx unzip4 list
@defunx unzip5 list
@c EN
[SRFI-1] @code{unzip1} takes a list of lists, where every list must
contain at least one element, and returns a list containing the
initial element of each such list.
@code{unzip2} takes a list of lists, where every list
must contain at least two elements, and returns two values:
a list of the first elements, and a list of the second
elements. @code{unzip3} does the same for the first
three elements of the lists, and so on.
@c JP
[SRFI-1] @code{unzip1} はリストのリストを引数としてとります。それぞれの
リストは少くとも一つの要素を含むものでなくてはなりません。結果として
それぞれのリストの最初の要素のリストを返します。
@code{unzip2} はリストのリストを引数としてとります。それぞれのリストは
少くとも二つの要素を含むものでなくてはなりません。結果として二つの値を
返します。最初の要素のリストと二番目の要素のリストです。@code{unzip3} は
3番目までの要素について同様です。以下も同様です。
@c COMMON
@example
(unzip2 '((1 one) (2 two) (3 three))) @result{}
   (1 2 3) @r{and}
   (one two three)
@end example
@end defun

@defun count pred clist1 clist2 @dots{}
@c EN
[SRFI-1] A procedure @var{pred} is applied to the @var{n}-th element
of given lists, from @var{n} is zero to the length of the
the shortest finite list in the given lists,
and the count of times @var{pred} returned true is returned.
@c JP
[SRFI-1] @var{pred} 手続きは与えられたリストの @var{n} 番目の要素に
適用します。@var{n} はゼロから与えられたリストのうち最も短いリストの
長さまでです。@var{pred} が真を返した数が返ります。
@c COMMON
@example
(count even? '(3 1 4 1 5 9 2 5 6)) @result{} 3
(count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)) @result{} 3
@end example
@c EN
At least one of the argument lists must be finite: 
@c JP
引数で与えられるリストの少くともひとつは有限でなければなりません。
@c COMMON
@example
(count < '(3 1 4 1) (circular-list 1 10)) @result{} 2
@end example
@end defun

@defun count$ pred
@c EN
Partial application version of @code{count}
@c JP
@code{count} の部分適用バージョンです。
@c COMMON
@example
((count$ pred) arg @dots{}) === (count pred arg @dots{})
@end example
@end defun

@node SRFI-1 Fold, SRFI-1 Filtering & Partitioning, SRFI-1 List miscellaneous routines, srfi-1 - List library
@subsection List fold, unfold & map
@c NODE リストの畳み込み(fold)、解きほぐし(unfold)、および写像(map)

@defun fold kons knil clist1 clist2 @dots{}
@c EN
[SRFI-1] The fundamental list iterator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@c JP
[SRFI-1] 基本リスト反復演算子です。単一のリスト
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}) 
を与えられたときには、以下を返します。
@c COMMON
@example
(@var{kons} @var{en} @dots{} (@var{kons} @var{e2} (@var{kons} @var{e1} @var{knil})) @dots{} ) 
@end example

@c EN
If @var{n} list arguments are provided, then the @var{kons}
function must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples:
@c JP
@var{n} 本のリストが与えられた場合には、@var{kons} 関数は @var{n}+1 個の引数
をとる関数でなければなりません。それぞれのリストから要素をひとつずつと、
初期値 @var{knil} である「種」あるいは畳み込み状態とよばれものです。
この畳み込み演算は、もっとも短いリストの要素がなくなったところで終了します。
与えられるリストの少くともひとつは有限でなければなりません。

例:
@c COMMON
@example
(fold + 0 '(3 1 4 1 5 9)) @result{} 23 ;@r{sum up the elements}
(fold cons '() '(a b c d e)) @result{} (e d c b a) ;@r{reverse}
(fold cons* '() '(a b c) '(1 2 3 4 5))
    @result{} (c 3 b 2 a 1) ;@r{n-ary case}
@end example
@end defun

@defun fold-right kons knil clist1 clist2 @dots{}
@c EN
[SRFI-1] The fundamental list recursion operator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@c JP
[SRFI-1] 基本リスト再帰演算子です。単一のリスト
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}) 
を与えられたときには、以下を返します。
@c COMMON
@example
(@var{kons} @var{e1} (@var{kons} @var{e2} @dots{} (@var{kons} @var{en} @var{knil})))
@end example

@c EN
If @var{n} list arguments are provided, then the @var{kons} function
must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples: 
@c JP
@var{n} 本のリストが与えられた場合には、@var{kons} 関数は @var{n}+1 個の引数
をとる関数でなければなりません。それぞれのリストから要素をひとつずつと、
初期値 @var{knil} である「種」あるいは畳み込み状態とよばれものです。
この畳み込み演算は、もっとも短いリストの要素がなくなったところで終了します。
与えられるリストの少くともひとつは有限でなければなりません。

例:
@c COMMON
@example
(fold-right cons '() '(a b c d e))
   @result{} (a b c d e) ;@r{copy list}
(fold-right cons* '() '(a b c) '(1 2 3 4 5))
   @result{} (a 1 b 2 c 3) ;@r{n-ary case}
@end example
@end defun

@defun pair-fold kons knil clist1 clist2 @dots{}
@defunx pair-fold-right kons knil clist1 clist2 @dots{}
@c EN
[SRFI-1] 
Like @code{fold} and @code{fold-right}, but the procedure @var{kons}
gets each @code{cdr} of the given @var{clist}s, instead of @code{car}.
@c JP
[SRFI-1]
@code{fold} および @code{fold-right} と同様ですが、@var{kons} 手続き
は与えられた @var{clist} の @code{car} ではなく、@code{cdr} をとります。
@c COMMON
@end defun

@defun reduce f ridentity list
@defunx reduce-right f ridentity list
@c EN
[SRFI-1]
Variant of @code{fold} and @code{fold-right}.   @var{f} must be a
binary operator, and @var{ridentity} is the value such that for
any value @var{x} that is valid as @var{f}'s input,
@c JP
[SRFI-1]
@code{fold} および @code{fold-right} の変形バージョンです。
@var{f} は二項演算子でなければなりません。
また、@var{ridentity} は @var{f} の入力として許される
あらゆる値 @var{x} について以下を満していなければなりません。
@c COMMON
@example
 (f x ridentity) @equiv{} ridentity
@end example

@c EN
These functions effectively do the same thing as @code{fold} or
@code{fold-right}, respectively, but omit application of @var{f}
when @var{list} contains exactly one element, using the nature of
@var{ridentity}.
@c JP
これらの関数は同じことを @code{fold} や @code{fold-right} で行うよりも、
効率よく行います。@var{list} がひとつしか要素をもたない場合には、
@var{ridentity} の性質を利用して @var{f} の適用を省略します。
@c COMMON
@end defun

@defun unfold p f g seed &optional tail-gen
@c EN
[SRFI-1]
Fundamental recursive list constructor.
Defined by the following recursion.
@c JP
[SRFI-1]
基本リスト再帰構築子です。
以下のように再帰的に定義されています。
@c COMMON

@example
(unfold p f g seed tail-gen) @equiv{}
   (if (p seed)
       (tail-gen seed)
       (cons (f seed)
             (unfold p f g (g seed))))
@end example
@c EN
That is, @var{p} determines where to stop, @var{g} is used to generate
successive seed value from the current seed value, and @var{f} is used
to map each seed value to a list element.
@c JP
ここでは、@var{p} は終了位置の判定、@var{g} は現在の「種」から次の「種」
を生成するのに用い、@var{f} はそれぞれの「種」をリストの要素に変換する
のに用いられます。
@c COMMON
@end defun

@defun unfold-right p f g seed &optional tail
@c EN
[SRFI-1]
Fundamental iterative list constructor.
Defined by the following recursin.
@c JP
[SRFI-1]
基本リスト反復構築子です。
以下のように再帰的に定義されています。
@c COMMON

@example
(unfold-right p f g seed tail) @equiv{}
  (let lp ((seed seed) (lis tail))
    (if (p seed)
        lis
        (lp (g seed) (cons (f seed) lis))))
@end example
@end defun

@defun append-map f clist1 clist2 @dots{}
@defunx append-map! f clist1 clist2 @dots{}
@c EN
[SRFI-1]
Equivalent to
@c JP
[SRFI-1]
以下と同等です。
@c COMMON

@example
  (apply append (map @var{f} @var{clist1} @var{clist2} @dots{}))
  (apply append! (map @var{f} @var{clist1} @var{clist2} @dots{}))
@end example
@c EN
At least one of the list arguments must be finite. 
@c JP
引数のリストのうち少くともひとつは有限でなければなりません。
@c COMMON
@end defun

@defun map! f clist1 clist2 @dots{}
@c EN
[SRFI-1]
The procedure @var{f} is applied to each element of @var{clist1} and
corresponding elements of @var{clist2}s, and the result is collected
to a list.  Cells in @var{clist1} is reused to construct the result list.
@c JP
[SRFI-1]
手続き @var{f} は @var{clist1} の各要素と @var{clist2} の対応する要素
に適用され、結果なひとつのリストに集められます。@var{clist1} のセルは
結果のリストを構築するのに再利用されます。
@c COMMON
@end defun

@defun map-in-order f clist1 clist2 @dots{}
@c EN
[SRFI-1] A variant of @code{map}, but it guarantees to apply @var{f}
on each elements of arguments in a left-to-right order.
Since Gauche's @code{map} implementation follows the same order,
this function is just a synonym of @code{map}.
@c JP
[SRFI-1] @code{map} の変形バージョンですが、@var{f} の適用順序が、引数として
与えられたリストの要素の左から右への順であることを保証します。
Gauche では @code{map} の実装はこの順になっているので、@code{map} と
同意です。
@c COMMON
@end defun

@defun pair-for-each f clist1 clist2 @dots{}
@c EN
[SRFI-1]
Like @code{for-each}, but the procedure @var{f} is applied on each @code{cdr}
of @var{clist}s.
@c JP
@code{for-each} と似ていますが、手続き @var{f} は各リスト @var{clist} の
@code{cdr} に適用されます。
@c COMMON
@end defun

@defun filter-map  f clist1 clist2 @dots{}
@c EN
[SRFI-1]
Like @code{map}, but only true values are saved.
At least one of the list arguments must be finite. 
@c JP
@code{map} と似ていますが、真になる場合の値のみが保存されます。
引数として与えられるリストの少くともひとつは有限でなければなりません。
@c COMMON
@example
(filter-map (lambda (x) (and (number? x) (* x x)))
            '(a 1 b 3 c 7))
  @result{} (1 9 49)
@end example
@end defun

@defun fold$ kons &optional knil
@defunx fold-right$ kons &optional knil
@defunx reduce$ f &optional ridentity
@defunx reduce-right$ f &optional ridentity
@c EN
Partial application versions of @code{fold}, @code{fold-right},
@code{reduce}, and @code{reduce-right}.
@c JP
それぞれ、@code{fold}、@code{fold-right}、@code{reduce}、
@code{reduce-right} の部分適用バージョンです。
@c COMMON
@end defun

@node SRFI-1 Filtering & Partitioning, SRFI-1 Searching, SRFI-1 Fold, srfi-1 - List library
@subsection List filtering & partitioning
@c NODE リストのフィルタおよび分割

@defun filter pred list
@defunx filter! pred list
@c EN
[SRFI-1] A procedure @var{pred} is applied on each element of @var{list},
and a list of elements that @var{pred} returned true on it is returned.
@c JP
[SRFI-1] 手続き @var{pred} が @var{list} の各要素に適用され、
@var{pred} が真を返す要素のリストが返されます。
@c COMMON
@example
(filter odd? '(3 1 4 5 9 2 6)) @result{} (3 1 5 9)
@end example
@c EN
@code{filter!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@c JP
@code{filter!} はその場で更新されるバージョンです。結果を生成するために
@var{list} を破壊的に変更します。
@c COMMON
@end defun

@defun remove pred list
@defunx remove! pred list
@c EN
[SRFI-1] A procedure @var{pred} is applied on each element of @var{list},
and a list of elements that @var{pred} returned false on it is returned.
@c JP
[SRFI-1] 手続き @var{pred} が @var{list} の各要素に適用され、
@var{pred} が偽を返す要素のリストが返されます。
@c COMMON
@example
(remove odd? '(3 1 4 5 9 2 6)) @result{} (4 2 6)
@end example
@c EN
@code{remove!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@c JP
@code{remove!} はその場で更新されるバージョンです。結果を生成するために
@var{list} を破壊的に更新します。
@c COMMON
@end defun

@defun partition pred list
@defunx partition! pred list
@c EN
[SRFI-1] @code{filter} and @code{remove} simultaneously, i.e. 
returns two lists, the first is the result of filtering elements of
@var{list} by @var{pred}, and the second is the result of
removing elements of @var{list} by @var{pred}.
@c JP
[SRFI-1] @code{filter} と @code{remove} は同時に、すなわち2つのリストを
返しますが、一つ目は @var{pred} により @var{list} の要素をフィルタリング
した結果で、二つ目は @var{pred} により @var{list} の要素を削除した結果
です。 
@c COMMON
@example
(partition odd? '(3 1 4 5 9 2 6))
  @result{} (3 1 5 9) (4 2 6)
@end example
@c EN
@code{partition!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@c JP
@code{partition!} はその場で更新されるバージョンです。結果を生成するために
@var{list} を破壊的に更新します。
@c COMMON
@end defun

@defun filter$ pred
@defunx remove$ pred
@defunx partition$ pred
@c EN
Partial application versions of @code{filter}, @code{remove} and
@code{partition}.
@c JP
@code{filter}、@code{remove}、@code{partition}の部分的に適用するバージョンです。
@c COMMON
@end defun


@node SRFI-1 Searching, SRFI-1 Deletion, SRFI-1 Filtering & Partitioning, srfi-1 - List library
@subsection List searching
@c NODE リストの探索

@defun find pred clist
@c EN
[SRFI-1] Applies @var{pred} for each element of @var{clist}, from 
left to right, and returns the first element that @var{pred} returns
true on.
@c JP
[SRFI-1] @var{clist} の各要素に対して左から右に @var{pred} を適用し、
@var{pred} が真を返す最初の要素を返します。
@c COMMON
@end defun

@defun find-tail pred clist
@c EN
[SRFI-1]
Applies @var{pred} for each element of @var{clist}, from left to right,
and when @var{pred} returns a true value, returns the pair whose car
is the element.
@c JP
[SRFI-1]
@var{clist} の各要素に対して左から右に @var{pred} を適用し、@var{pred} が
真を返す場合、その car がその要素であるペアを返します。
@c COMMON
@end defun

@defun take-while pred clist
@defunx take-while! pred list
@c EN
[SRFI-1]
Returns the longest initial prefix of @var{clist} whose elements all
satisfy @var{pred}.
@c JP
[SRFI-1]
@var{clist} の最初から、@var{pred} を満足する限りの最長部分要素を返します。
@c COMMON
@end defun

@defun drop-while pred clist
@c EN
[SRFI-1]
Drops the longest initial prefix of @var{clist} whose elements all
satisfy @var{pred}, and returns the rest.
@c JP
[SRFI-1]
@var{clist} の最初から、@var{pred} を満足する限りの最長部分要素を削除し、
残りを返します。
@c COMMON
@end defun

@defun span pred clist
@defunx span! pred list
@defunx break pred clist
@defunx break! pred list
@c EN
[SRFI-1]
@code{span} is equivalent to
@code{(values (take-while pred clist) (drop-while pred clist))}.
@code{break} inverts the sense of @var{pred}.
@c JP
[SRFI-1]
@code{span} は @code{(values (take-while pred clist) (drop-while pred clist))} を
等価です。@code{break} は @var{pred} の意味を反転します。
@c COMMON
@end defun

@defun any pred clist1 clist2 @dots{}
@c EN
[SRFI-1]
Applies @var{pred} across each element of @var{clist}s, and
returns true if any application of @var{pred} returns true.
The returned value is the true value @var{pred} returned.
@c JP
[SRFI-1]
@var{clist} の各要素に @var{pred} を適用し、その @var{pred} の
いずれかの適用が真を返した場合、真を返します。
戻り値は、@var{pred} が返した真の値です。
@c COMMON
@end defun

@defun every pred clist1 clist2 @dots{}
@c EN
[SRFI-1]
Applies @var{pred} across each element of @var{clist}s, and
returns true if every application of @var{pred} returns true.
If all applications returns a true value until one of the lists
is exhausted, @code{every} returns the value the last @var{pred}
returned.
@c JP
[SRFI-1]
@var{clist} の各要素に @var{pred} を適用し、@var{pred} の全ての
適用が真を返した場合、真を返します。リストのうちの1つが全て
消費されるまでの全ての適用が真を返す場合、@code{every} は最後の
@var{pred} が返した値になります。
@c COMMON
@end defun

@defun list-index pred clist1 clist2 @dots{}
@c EN
[SRFI-1]
Returns the index of the leftmost element that satisfies @var{pred}.
@c JP
[SRFI-1]
@var{pred} を満足する最も左の要素のインデックスを返します。
@c COMMON
@end defun

@defun member$ item
@defunx find$ pred
@defunx find-tail$ pred
@defunx any$ pred
@defunx every$ pred
@c EN
Partial application version of @code{member}, @code{find}, @code{find-tail},
@code{any} and @code{every}.
@c JP
@code{member}、@code{find}、@code{find-tail}、@code{any}、@code{every}の部分的適用
バージョンです。
@c COMMON
@end defun

@node SRFI-1 Deletion, SRFI-1 Association lists, SRFI-1 Searching, srfi-1 - List library
@subsection List deletion
@c NODE リストの削除

@defun delete x list &optional elt=
@defunx delete! x list &optional elt=
@c EN
[SRFI-1]
Equivalent to
@c JP
[SRFI-1]
以下と同等です。
@c COMMON
@example
  (remove (lambda (y) (elt= x y)) list)
  (remove! (lambda (y) (elt= x y)) list)
@end example
@c EN
The comparison procedure, @var{elt=}, defaults to @code{equal?}.
@c JP
比較手続き @var{elt=} はデフォルトでは @code{equal?} です。
@c COMMON
@end defun

@defun delete$ x
@c EN
Partial application version of @code{delete}.
@c JP
@code{delete} の部分適用バージョンです。
@c COMMON
@end defun

@defun delete-duplicates list &optional elt=
@defunx delete-duplicates! list &optional elt=
@c EN
[SRFI-1]
Removes duplicate elements from @var{list}.
If there are multiple equal elements in @var{list},
the result list only contains the first or leftmost of these
elements in the result. The order of these surviving elements
is the same as in the original list.
The comparison procedure, @var{elt=}, defaults to @code{equal?}.
@c JP
[SRFI-1]
@var{list} から重複した要素を取り除きます。@var{list} 中に等しい要素が
複数ある場合、一番左がわにある最初のものだけが残ります。これらの
生き残った要素間の順番は最初のリストの順番が保存されます。
比較手続き @var{elt=} のデフォルト値は、@code{equal?} です。
@c COMMON
@end defun

@node SRFI-1 Association lists, SRFI-1 Set operations, SRFI-1 Deletion, srfi-1 - List library
@subsection Association lists
@c NODE 連想リスト

@defun alist-cons key datum alist
@c EN
[SRFI-1] Returns @code{(cons (cons @var{key} @var{datum}) @var{alist})}.
This is an alias of the Gauche builtin procedure @code{acons}.
@c JP
[SRFI-1] @code{(cons (cons @var{key} @var{datum}) @var{alist})} を返します。
これは、Gauche の組み込み手続き @code{acon} の別名です。
@c COMMON
@end defun

@defun alist-copy alist
@c EN
[SRFI-1] Returns a fresh copy of @var{alist}.
The spine of @var{alist} and each cell that points a key and a value
is copied.
@c JP
[SRFI-1] @var{alist} の新しい複製を返します。@var{alist} の背骨の部分、
およびキーと値を指す各セルは複製されます。
@c COMMON
@example
(define a (list (cons 'a 'b) (cons 'c 'd)))
a @result{} ((a . b) (c . d))

(definea b (alist-copy a))
b @result{} ((a . b) (c . d))

(set-cdr! (car a) 'z)
a @result{} ((a . z) (c . d))
b @result{} ((a . b) (c . d))
@end example
@end defun

@defun alist-delete key alist &optional =
@defunx alist-delete! key alist &optional =
@c EN
[SRFI-1]
Deletes all cells in @var{alist} whose key is the same as @var{key}.
Comparison is done by a procedure @var{=}.  The default is @code{eqv?}.

The linear-update version @code{alist-delete!} may or may not modify
@var{alist}.
@c JP
[SRFI-1]
@var{alist} から @var{key}と同じキーをもつすべてのセルを削除します。
比較は @var{=} で行います。これのデフォルト値は @code{eqv?} です。

その場で更新を行うバージョン @code{alist-delete!} は元の
@var{alist} を変更してしまうことがあります。
@c COMMON
@end defun

@defun assoc$ item
@c EN
Partial application version of @code{assoc}.
@c JP
@code{assoc} の部分適用バージョンです。
@c COMMON
@end defun

@node SRFI-1 Set operations,  , SRFI-1 Association lists, srfi-1 - List library
@subsection Lists as sets
@c NODE 集合としてのリスト

@c EN
These procedures use a list as a set, that is,
the elements in a list matter, but their order doesn't.

All procedures in this category takes a comparison procedure
@var{elt=}, as the first argument, which is used to determine
two elements in the given sets are the same.

See also @ref{util.combinations - Combination library}, which
concerns combinations of elements in the set.
@c JP
これらの手続きはリストを集合としてあつかいます。すなわち、どのような
要素があるかは重要ですが、その順序は重要ではありません。

この範疇にあるすべての手続きは、比較手続き @var{elt=} を最初の引数として
とります。この比較手続きは与えられた二つの集合の要素が等しいかどうかを
判定します。

集合の要素の組み合せについては @ref{util.combinations - Combination library}
も参照してください。
@c COMMON

@defun lset<= elt= list1 @dots{}
@c EN
[SRFI-1]
Returns @code{#t} iff all elements in @var{list1} are also included
in @var{list2}, and so on.
If no lists are given, or a single list is given,
@code{#t} is returned.
@c JP
[SRFI-1]
@var{list1} のすべての要素が @var{list2} (以降の集合)に含まれている
ときに限り @code{#t} を返します。リストが与えられなかった場合
および一つだけしか与えられなかった場合には、@code{#t} を返します。
@c COMMON
@end defun

@defun lset= elt= list1 list2 @dots{}
@c EN
[SRFI-1]
Returns @code{#t} if all elements in @var{list1} are in @var{list2},
and all elements in @var{list2} are in @var{list1}, and so on.
@c JP
[SRFI-1]
@var{list1} のすべての要素が @var{list2} に含まれており、かつ、
@var{list2} のすべての要素が @var{list1} に含まれていれば、@code{#t}
を返します。
@c COMMON

@example
(lset= eq? '(b e a) '(a e b) '(e e b a)) @result{} #t
@end example
@end defun

@defun lset-adjoin elt= list elt @dots{}
@c EN
[SRFI-1]
Adds @var{elt} @dots{} to the set @var{list}, if each one is not
already a member of @var{list}.  (The order doesn't matter).
@c JP
[SRFI-1]
@var{elt} @dots{} を集合 @var{list} にまだなければ、追加します。
(順序はとくに決っていません。)
@c COMMON

@example
(lset-adjoin eq? '(a b c) 'a 'e) @result{} '(e a b c)
@end example
@end defun

@defun lset-union elt= list1 @dots{}
@c EN
[SRFI-1]
Returns the union of the sets @var{list1} @dots{}.
@c JP
[SRFI-1]
@var{list1} @dots{} の和集合を返します。
@c COMMON
@end defun

@defun lset-intersection elt= list1 list2 @dots{}
@c EN
[SRFI-1]
Returns a set of elements that are in every @var{list}s.
@c JP
[SRFI-1]
すべての @var{list} に含まれる要素の集合を返します。
@c COMMON
@end defun

@defun lset-difference elt= list1 list2 @dots{}
@c EN
[SRFI-1]
Returns a set of elements that are in @var{list1} but not
in @var{list2}.  In n-ary case, binary differece operation is
simply folded.
@c JP
[SRFI-1]
@var{list1} には含まれていて、@var{list2} には含まれていない要素の集合を
返します。引数が n 個与えれらた場合には、差分をとる二項演算が
畳み込まれます。
@c COMMON
@end defun

@defun lset-xor elt= list1 @dots{}
@c EN
[SRFI-1]
Returns the exclusive-or of given sets; that is, the returned
set consists of the elements that are in either @var{list1} or @var{list2},
but not in both.   In n-ary case, binary xor operation is simply folded.
@c JP
[SRFI-1]
与えられた集合の排他的論理和を返します。すなわち、@var{list1} および
@var{list2} のどちらか一方にのみ属する要素からなる集合を返します。
引数が n 個の場合には、xor の二項演算が畳み込まれます。
@c COMMON
@end defun

@defun lset-diff+intersection elt= list1 list2 @dots{}
@c EN
[SRFI-1]
Returns two sets, a difference and an intersection of given sets.
@c JP
[SRFI-1]
与えられた集合の差集合と積集合のふたつの集合を返します。
@c COMMON
@end defun

@defun lset-union! elt= list @dots{}
@defunx lset-intersection! elt= list1 list2 @dots{}
@defunx lset-difference! elt= list1 list2 @dots{}
@defunx lset-xor! elt= list1 @dots{}
@defunx lset-diff+intersection! elt= list1 list2 @dots{}
@c EN
[SRFI-1]
Linear update variant of the corresponding procedures.
The cells in the first list argument may be reused to construct the result.
@c JP
[SRFI-1]
それぞれ対応する手続きのその場で更新するバージョンです。
最初の引数のリストのセルが結果を構築するのに再利用されます。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node srfi-2 - And-let*, srfi-4 - Homogeneous vectors, srfi-1 - List library, Library modules - SRFIs
@section @code{srfi-2} - And-let*

@deftp {Module} srfi-2
@mdindex srfi-2
@c EN
Provides SRFI-2 @code{and-let*} macro.
@c JP
SRFI-2の@code{and-let*}マクロを提供します。
@c COMMON
@end deftp

@defmac and-let* (binding @dots{}) body @dots{}
[SRFI-2]
@c EN
In short, it works like @code{let*}, but returns #f immediately
whenever the expression in @var{binding}s evaluates to #f.
@c JP
簡単に言うと、このフォームは@code{let*}のように動作しますが、
@var{bindings}中の式が@code{#f}に評価されたらそこで評価を打ち切り
@code{#f}を返します。
@c COMMON

@c EN
Each @var{binding} should be one of the following form:
@c JP
各@var{binding}は以下のいずれかの形式でなければなりません。
@c COMMON
@table @var
@item (variable expression)
@c EN
The @var{expression} is evaluated; if it yields true value, the value
is bound to @var{variable}, then proceed to the next binding.  If
no more bindings, evaluates @var{body} @dots{}.   If @var{expression}
yieds @code{#f}, stops evaluation and returns @code{#f} from @code{and-let*}.
@c JP
@var{expression}が評価されます。それが真の値を返したら、その値が@var{variable}
に束縛され、次の@var{binding}へと進みます。もう@var{binding}が無ければ
@var{body} @dots{}が評価されます。もし@var{expression}が@code{#f}を返したら、
評価を打ち切り、@code{and-let*}から@code{#f}を返します。
@c COMMON
@item (expression)
@c EN
In this form, @var{variable} is omitted.  @var{Expression} is evaluated
and the result is used just to determine whether we continue or
stop further evaluation.
@c JP
この形式では@var{variable}が省略されています。@var{Expression}が評価され、
その結果は評価を続行するか打ち切るかを判断するためにのみ使われます。
@c COMMON
@end table

@c EN
Let's see some examples.  The following code searches @var{key}
from an assoc-list @var{alist} and returns its value if found.
@c JP
いくつか例を挙げます。次のコードは連想リスト@var{alist}から@var{key}を
探し、見つかったらその値を返します。
@c COMMON
@example
(and-let* ((entry (assoc key alist))) (cdr entry))
@end example

@c EN
If @var{arg} is a string representation of an exact integer, returns its value;
otherwise, returns 0:
@c JP
もし@var{arg}が正確な整数の文字列表現だった場合は@var{num}を返し、そうでなければ
0を返します：
@c COMMON
@example
(or (and-let* ((num (string->number arg))
               ((exact? num))
               ((integer? num)))
      num)
    0)
@end example

@c EN
The following is a hypothetical code that searches a certain server port
number from a few possibilities (environment variable, configuration file,
...)
@c JP
以下のコードはとあるサーバーのポート番号をいくつかの可能性
(環境変数、設定ファイル…)の中から探す仮想的なコードです。
@c COMMON
@example
(or (and-let* ((val (sys-getenv "SERVER_PORT")))
      (string->number val))
    (and-let* ((portfile (expand-path "~/.server_port"))
               ((file-exists? portfile))
               (val (call-with-input-string portfile port->string)))
      (string->number val))
    8080) ; default
@end example

@end defmac

@c ----------------------------------------------------------------------
@node srfi-4 - Homogeneous vectors, srfi-9 - Record types, srfi-2 - And-let*, Library modules - SRFIs
@section @code{srfi-4} - Homogeneous vectors
@c NODE srfi-4 - 単一型のベクタ, @code{srfi-4} - 単一型のベクタ

@deftp {Module} srfi-4
@mdindex srfi-4
@c EN
SRFI-4 is now implemented in @code{gauche.uvector} module
@xref{gauche.uvector - Uniform vectors}.
This module simply inherits @code{gauche.uvector} for backward-compatibility.
@c JP
SRFI-4は、@code{gauche.uvector}モジュールとして実装されています。
@ref{gauche.uvector - Uniform vectors}参照。
このモジュールは後方互換性のために単に@code{gauche.uvector}を継承しています。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node srfi-9 - Record types, srfi-11 - Let-values, srfi-4 - Homogeneous vectors, Library modules - SRFIs
@section @code{srfi-9} - Record types
@c NODE @code{srfi-9} - レコード型

@deftp {Module} srfi-9
@mdindex srfi-9
@c EN
Contains a macro to use record types.  A record type is implemented on
top of Gauche's object system.

The SRFI-9 record type is not as powerful as the object system, but
it will be useful if you want your program to be portable.
@c JP
このモジュールはレコード型を使うマクロを含んでいます。レコード型は
Gauche のオブジェクトシステム上で実装されています。

SRFI-9 のレコード型はこのオブジェクトシステムほどには強力ではありませんが、
ポータブルなプログラムを書くときには役に立ちます。
@c COMMON
@end deftp

@defmac define-record-type name (constructor init-tag @dots{}) predicate (field accessor [modifier]) @dots{}
@c EN
Creates a record type and binds it to @var{name}.
In Gauche, a record type is just a subclass of @code{<record>}.

@var{constructor} is bound to a procedure that creates an instance
of the record type,
which takes as many arguments as @var{init-tag} @dots{}.  Each
@var{init-tag} corresponds to one of the field name, and the fields
of the created record instance is initialized accordingly.  Not all
of fields need to appear in @var{init-tag}; uninitialized fields remain
unbound.

@var{predicate} is bound to a procedure that takes one argument, and
returns #t if the argument is an instance of the defined record type,
#f otherwise.

Followings are field specifications.  The record has fields
@var{field} @dots{}, and each field can be accessed by a method
@var{accessor}.  If @var{modifier} is given to the field, it is bound
to a method that sets the value to the field.

Example:
@c JP
レコード型を作成し、それを @var{name} に束縛します。Gauche では、
レコード型は @code{<record>} のサブクラスです。

@var{constructor} はそのレコード型のインスタンスを作成する手続きに
束縛されており、@var{init-tag} @dots{} として多くの引数をとります。
それぞれの @var{init-tag} はフィールド名に対応しており、作成された
レコード型のインスタンスのフィールドはそれぞれの  @var{init-tag} 
にしたがって、初期化されます。@var{init-tag} には全てのフィールドが
ある必要なはく、初期化されないフィールドは、未束縛のままになります。

@var{predicate} は、一つの引数をとり、もしその引数が、定義された
レコード型のインスタンスであれば、@code{#t} を返し、さもなければ、
@code{#f} を返すような手続きに束縛されます。

そのあとは、フィールドの仕様です。レコードはフィールド
@var{field} @dots{} をもち、それぞれのフィールドはメソッド
@var{accessor} によってアクセス可能です。そのフィールドに対して
@var{modifier} が与えられていれば、それは、そのフィールドの
値をセットするメソッドに束縛されます。

例:
@c COMMON
@example
(define-record-type pare
  (kons x y) pare?
  (x kar set-kar!)
  (y kdr))
 @result{} #<class pare>

(pare? (kons 2 3)) @result{} #t
(pare? (cons 2 3)) @result{} #f

(kar (kons 2 3)) @result{} 2
(kdr (kons 2 3)) @result{} 3

(let ((x (kons 2 3)))
  (set-kar! x -1)
  (kar x)) @result{} -1
@end example

@c EN
Conceptually, the above example is expanded into the following
sequence of forms.
@c JP
概念的には、上の例は以下の形式のならびに展開されます。
@c COMMON
@example
(define-class pare (<record>) (x y))
(define (kons x y)
  (let ((obj (make pare)))
    (slot-set! obj 'x x) 
    (slot-set! obj 'y y)
    obj))
(define (pare? obj) (is-a? obj pare))
(define-method kar ((obj pare))
  (slot-ref obj 'x))
(define-method set-kar! ((obj pare) value)
  (slot-set! obj 'x value))
(define-method kdr ((obj pare))
  (slot-ref obj 'y))
@end example

@end defmac

@c ----------------------------------------------------------------------
@node srfi-11 - Let-values, srfi-13 - String library, srfi-9 - Record types, Library modules - SRFIs
@section @code{srfi-11} - Let-values
@c NODE @code{srfi-11} - Let-values

@deftp {Module} srfi-11
@mdindex srfi-11
@c EN
Defines two macros, @code{let-values} and @code{let*-values}.
They are convenient to use with multiple values (@ref{srfi-11,,[SRFI-11]}).

@c JP
二つのマクロ、code{let-values} と @code{let*-values} を定義しています。
これらは、多値とともに利用すると便利です。(@ref{srfi-11,,[SRFI-11]})

@c COMMON
@end deftp

@defmac let-values ((vars expr) @dots{}) body @dots{}
[SRFI-11]
@c EN
@var{vars} are a list of variables. @var{expr} is evaluated, and
its first return value is bound to the first variable in @var{vars},
its second return value to the second variable, and so on, then
@var{body} is evaluated.
The scope of @var{expr}s are the outside of @code{let-values} form,
like @code{let}.
@c JP
@var{vars} は変数のリストです。@var{expr} は評価され、最初の返り値は、
@var{vars} の最初の変数に束縛されます。二番目の返り値は、@var{vars} の
二番目の変数に束縛され、以下同様です。そのあと、@var{body} が評価されます。
@var{expr} のスコープは @code{let} と同様に、@code{let-values} の
外側になります。
@c COMMON

@example
(let-values (((a b) (values 1 2))
             ((c d) (values 3 4)))
  (list a b c d)) @result{} (1 2 3 4)

(let ((a 1) (b 2) (c 3) (d 4))
  (let-values (((a b) (values c d))
               ((c d) (values a b)))
    (list a b c d))) @result{} (3 4 1 2)
@end example

@c EN
@var{vars} can be a dotted list or a single symbol, like the
lambda parameters.
@c JP
@var{vars} lambda パラメータと同様に、ドット付リストでも、
単一のシンボルでもかまいません。
@c COMMON

@example
(let-values (((x . y) (values 1 2 3 4)))
  y) @result{} (2 3 4)

(let-values ((x (values 1 2 3 4)))
  x) @result{} (1 2 3 4)
@end example

@c EN
If the number of values returned by @var{expr} doesn't match
what @var{vars} expects, an error is signalled.
@c JP
@var{expr} によって返された値の数と @var{vars} が期待する数とが一致しない
場合にはエラーになります。
@c COMMON
@end defmac

@defmac let*-values ((vars expr) @dots{}) body @dots{}
[SRFI-11]
@c EN
Same as @code{let-values}, but each @var{expr}'s scope includes
the preceding @var{vars}.
@c JP
@code{let-values}と同じですが、各 @var{expr} のスコープが先行する @var{vars}
を含みます。
@c COMMON

@example
(let ((a 1) (b 2) (c 3) (d 4))
  (let*-values (((a b) (values c d))
                ((c d) (values a b)))
    (list a b c d))) @result{} (3 4 3 4)
@end example
@end defmac

@c ----------------------------------------------------------------------
@node srfi-13 - String library, srfi-14 - Character-set library, srfi-11 - Let-values, Library modules - SRFIs
@section @code{srfi-13} - String library
@c NODE @code{srfi-13} - 文字列ライブラリ

@deftp {Module} srfi-13
@mdindex srfi-13
@c EN
Defines a large set of string-related functions.
In Gauche, those functions are splitted to number of files
and the form @code{(use srfi-13)} merely sets up autoloading of
those files.  So it is not likely to slow down the script startup.
@c JP
文字列に関連する関数の大きなセットを定義しています。
Gaucheでは、それらの関数はいくつかのファイルに分割されており、
@code{(use srfi-13)}というフォームは単にそれらのファイルの
オートロードのセットアップをするだけです。
したがって、スクリプトのスタートアップを遅くするようなことは
ありません。
@c COMMON
@c EN
See SRFI-13 (@ref{srfi-13, [SRFI-13], SRFI-13})
for the detailed specification and discussion of design issues.
This manual serves as a reference of function API.
Some SRFI-13 functions are Gauche built-in and not listed here.
@c JP
詳細な仕様とデザインに関する議論については、SRFI-13 (@ref{srfi-13, [SRFI-13], SRFI-13})
を参照して下さい。
このマニュアルは、関数のAPIのリファレンスとして提供されます。
いくつかのSRFI-13の関数は、Gaucheのビルトインになっており、
ここにはリストされていないものもあります。
@c COMMON
@c EN
Note: SRFI-13 documents suggests the name of the module that
implements these functions to be ``string-lib'' and ``string-lib-internals''.
Gauche uses the name ``srfi-13'' for consistency.
@c JP
注意: SRFI-13のドキュメントは、これらの関数を実装するモジュールの
名前を``string-lib''と``string-lib-internals''とすることを推奨しています。
Gaucheでは、一貫性のために``srfi-13''と名付けています。
@c COMMON
@end deftp

@menu
* SRFI-13 General conventions::  
* SRFI-13 String predicates::   
* SRFI-13 String Constructors::  
* SRFI-13 String Selection::    
* SRFI-13 String Comparison::   
* SRFI-13 String Prefixes & Suffixes::  
* SRFI-13 String searching::    
* SRFI-13 String case mapping::  
* SRFI-13 String reverse & append::  
* SRFI-13 String mapping::      
* SRFI-13 String rotation::     
* SRFI-13 other string operations::  
* SRFI-13 String filtering::    
* SRFI-13 Low-level string procedures::  
@end menu

@node SRFI-13 General conventions, SRFI-13 String predicates, srfi-13 - String library, srfi-13 - String library
@subsection General conventions

@c EN
There are a few common factors in string library API, which I don't
repeat in each function description
@c JP
文字列ライブラリのAPIにはいくつか共通するものがありますが、
それぞれの関数の説明において繰り返しません。
@c COMMON

@table @emph
@c EN
@item argument convention
@c JP
@item 引数の仕様
@c EN
The following argument names imply their types.
@c JP
以下の引数名はその型を暗に表しています。
@c COMMON
@table @var
@item s, s1, s2
@c EN
Those arguments must be strings.
@c JP
これらの引数は文字列でなければなりません。
@c COMMON
@item char/char-set/pred
@c EN
This argument can be a character, a character-set object,
or a predicate that takes a single character and returns a boolean value.
``Applying @var{char/char-set/pred} to a character'' means,
if @var{char/char-set/pred} is a character, it is compared to the given
character; if @var{char/char-set/pred} is a character set, it is
checked if the character set contains the given character; if
@var{char/char-set/pred} is a procedure, it is applied
to the given character.  ``A character satisfies @var{char/char-set/pred}''
means such application to the character yields true value.
@c JP
この引数は、文字、文字セットオブジェクト、あるいは1つの文字を引数に取り
真偽値を返す述語のいずれかです。``文字に@var{char/char-set/pred}を適用する''
の意味はそれぞれ、@var{char/char-set/pred}が文字ならば与えられた文字と比較される、
@var{char/char-set/pred}が文字セットならばその文字セットに与えられた文字が
含まれるかを検査する、@var{char/char-set/pred}が述語ならばそれを与えられた
文字に適用する、となります。``ある文字が@var{char/char-set/pred}を満足する''
とは、その文字への前述のような適用が真値を返すという意味になります。
@c COMMON

@item start, end
@c EN
Lots of SRFI-13 functions takes these two optional arguments, which
limit the area of input string from @var{start}-th character
(inclusive) to @var{end}-th character (exclusive),
where the operation is performed.
When specified, the condition
0 <= @var{start} <= @var{end} <= @var{length of the string} must be
satisfied.  Default value of @var{start} and @var{end} is
0 and the length of the string, respectively.
@c JP
SRFI-13の関数の多くは、その操作が実行される対象入力文字列の
範囲を限定する開始インデックスと終了インデックスをオプショナルな
引数として取ります。開始(@var{start}番目)の文字は含まれ、
終了(@var{end}番目)の文字は含まれません。
これらが指定されるとき、0 <= @var{start} <= @var{end} <= @var{length of the string}が
満たされなければなりません。@var{start}と@var{end}のデフォルト値は、
それぞれ0と文字列の長さです。
@c COMMON
@end table

@c EN
@item `shared' variant
@c JP
@item `shared'バージョン
@c EN
Some functions have variants with ``/shared'' attached to its name.
SRFI-13 defines those functions to allow to share the part of input
string, for better performance.  Gauche doesn't have a concept of
shared string, and these functions are mere synonyms of their
non-shared variants.  However, Gauche @emph{internally} shares
the storage of strings, so generally you don't need to worry
about the overhead of copying substrings.
@c JP
いくつかの関数は、その名前に``/shared''が付きます。
SRFI-13では、それらの関数はより良いパフォーマンスのために
入力文字列の一部を共有しても良いと定義しています。
Gaucheは、共有文字列という概念を持っていませんし、
それらの関数は単に共有でないバージョンの変名に過ぎません。
しかし、Gaucheは@emph{内部的には}文字列の保存場所を共有しているので、
一般的には部分文字列をコピーするオーバヘッドについて心配する
必要はありません。
@c COMMON

@c EN
@item `right' variant
@c JP
@item `right'バージョン
@c EN
Most functions works from left to right of the input string.
Some functions have variants with ``-right'' to its name, 
that works from right to left.
@c JP
ほとんどの関数は、入力文字列を左から右へと扱います。
いくつかの関数は、その名前に``-right''が付き、右から左へと
扱うものがあります。
@c COMMON

@end table

@node SRFI-13 String predicates, SRFI-13 String Constructors, SRFI-13 General conventions, srfi-13 - String library
@subsection String predicates

@defun string-null? s
@c EN
[SRFI-13] Returns @code{#t} if @var{s} is an empty string, @code{""}.
@c JP
[SRFI-13] @var{s}が空文字列、@code{""}なら、@code{#t}を返します。
@c COMMON
@end defun

@defun string-every char/char-set/pred s &optional start end
@c EN
[SRFI-13] Sees if every character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-every} returns
the value that is returned at the last application of @var{char/char-set/pred}.
If any of the application returns @code{#f}, @code{string-every}
returns @code{#f} immediately.
@c JP
[SRFI-13] @var{s}に含まれる全ての文字が@var{char/char-set/pred}を
満足するかを検査します。満足するならば、@code{string-every}は
最後に適用された@var{char/char-set/pred}が返した値を戻り値とします。
どの適用も@code{#f}を返した場合は、@code{string-every}はすぐに
@code{#f}を返します。
@c COMMON
@end defun

@defun string-any char/char-set/pred s &optional start end
@c EN
[SRFI-13] Sees if any character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-any} returns
the value that is returned by the application.   If no character
satisfies @var{char/char-set/pred}, @code{#f} is returned.
@c JP
[SRFI-13] @var{s}に含まれるいずれかの文字が@var{char/char-set/pred}
を満足するかを検査します。いずれかの文字が満足するならば、
@code{string-any}はその適用が返した値を戻り値とします。
どの文字も@var{char/char-set/pred}を満たさなければ、@code{#f}が返ります。
@c COMMON
@end defun

@node SRFI-13 String Constructors, SRFI-13 String Selection, SRFI-13 String predicates, srfi-13 - String library
@subsection String Constructors

@defun string-tabulate proc len
@c EN
[SRFI-13] @var{proc} must be a procedure that takes an integer
argument and returns a character.  @code{string-tabulate}
creates a string, whose @var{i}-th character is calculated by
@code{(proc i)}.
@c JP
[SRFI-13] @var{proc}は整数を1つ引数として取り文字を返す手続きで
なければなりません。@code{string-tabulate}は、その@var{i}番目の
文字が@code{(proc i)}で計算されるような文字列を返します。
@c COMMON
@example
(string-tabulate
  (lambda (i) (integer->char (+ i #x30))) 10)
 @result{} "0123456789"
@end example

@end defun

@defun reverse-list->string char-list
[SRFI-13] @equiv{} @code{(list->string (reverse char-list))}.
@end defun

@node SRFI-13 String Selection, SRFI-13 String Comparison, SRFI-13 String Constructors, srfi-13 - String library
@subsection String selection

@defun substring/shared s start &optional end
@c EN
[SRFI-13] In Gauche, this is the same as @code{substring}, except
that the @var{end} argument is optional.
@c JP
[SRFI-13] Gaucheでは、引数@var{end}がオプショナルであることを除いて、
@code{substring}と同じです。
@c COMMON
@example
(substring/shared "abcde" 2) @result{} "cde"
@end example
@end defun

@defun string-copy! target tstart s &optional start end
@c EN
[SRFI-13] Copies a string @var{s} into a string
@var{target} from the position @var{tstart}.
Optional @var{start} and @var{end} arguments limits the range of @var{s}.
If the copied string run over the end of @var{target}, an error is
signalled.
@c JP
[SRFI-13] 文字列@var{s}を、文字列@var{target}の@var{tstart}番目以降へコピーします。
オプションの引数@var{start}と@var{end}は、@var{s}の範囲を制限します。
コピーされた文字列が@var{target}の終端を越えたらエラーが通知されます。
@c COMMON
@example
(define s (string-copy "abcde"))
(string-copy! s 2 "ZZ")
s @result{} "abZZe"
@end example
@end defun

@defun string-take s nchars
@defunx string-drop s nchars
@defunx string-take-right s nchars
@defunx string-drop-right s nchars
@c EN
[SRFI-13] Returns the first @var{nchars}-character string of @var{s}
(@code{string-take}) or the string without first @var{nchars}
(@code{string-drop}).  The @code{*-right} variation counts from
the end of string.  It is guaranteed that the returned string is
always a copy of @var{s}, even no character is dropped.
@c JP
[SRFI-13] @code{string-take}は、@var{s}の最初の@var{nchars}文字からなる文字列を返します。
@code{string-drop}は、@var{s}から最初の@var{nchars}文字からなる文字列を
除いた残りを返します。@code{*-right}バージョンは、文字列の最後から数えます。
返される文字列はいつも@var{s}のコピーであり、どの文字も削除されないことが
保証されています。
@c COMMON
@example
(string-take "abcde" 2) @result{} "ab"
(string-drop "abcde" 2) @result{} "cde"

(string-take-right "abcde" 2) @result{} "cde"
(string-drop-right "abcde" 2) @result{} "ab"
@end example
@end defun

@defun string-pad s len &optional char start end
@defunx string-pad-right s len &optional char start end
@c EN
[SRFI-13]
If a string @var{s} is shorter than @var{len}, 
returns a string of @var{len} where @var{char} is
padded to the left or right, respectively.
If @var{s} is longer than @var{len}, the rightmost
or leftmost @var{len} chars are taken.
@var{Char} defaults to @code{#\space}.
If @var{start} and @var{end} are provided, 
the substring of @var{s} is used as the source.
@c JP
[SRFI-13]
文字列@var{s}が@var{len}より短い場合は、@var{char}がそれぞれ左か
右にパディングされた長さ@var{len}の文字列を返します。
@var{s}が@var{len}よりも長い場合は、@var{len}文字が右端か左端から
取り除かれます。@var{Char}のデフォルト値は@code{#\space}です。
@var{start}と@var{end}が与えられると、@var{s}の部分文字列がソース
文字列として使われます。
@c COMMON

@example
(string-pad "abc" 10)    @result{} "       abc"
(string-pad "abcdefg" 3) @result{} "efg"

(string-pad-right "abc" 10) @result{} "abc       "

(string-pad "abcdefg" 10 #\+ 2 5)
  @result{} "+++++++cde"
@end example
@end defun

@defun string-trim s &optional char/char-set/pred start end
@defunx string-trim-right s &optional char/char-set/pred start end
@defunx string-trim-both s &optional char/char-set/pred start end
@c EN
[SRFI-13]
Removes characters that match @var{char/char-set/pred}
from @var{s}.  @code{String-trim} removes the characters from
left of @var{s}, @code{string-trim-right} does from right,
and @code{string-trim-both} does from both sides.
@c JP
[SRFI-13]
@var{s}から@var{char/char-set/pred}にマッチする文字を削除します。
@code{String-trim}は@var{s}の左から文字を削除し、
@code{string-trim-right}は右から、@code{string-trim-both}は
両端から削除します。
@c COMMON
@c EN
@var{Char/char-set/pred} defaults to @code{#[\s]}, i.e. a char-set
of whitespaces.
If @var{start} and @var{end} are provided, 
the substring of @var{s} is used as the source.
@c JP
@var{Char/char-set/pred}のデフォルト値は@code{#[\s]}、つまり空白文字の
文字セットです。@var{start}と@var{end}が与えられると、@var{s}の部分文字列が
ソース文字列として使われます。
@c COMMON

@example
(string-trim "   abc  ")       @result{} "abc  "
(string-trim-right "   abc  ") @result{} "   abc"
(string-trim-both "   abc  ")  @result{} "abc"
@end example
@end defun

@node SRFI-13 String Comparison, SRFI-13 String Prefixes & Suffixes, SRFI-13 String Selection, srfi-13 - String library
@subsection String comparison

@defun string-compare s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
@defunx string-compare-ci s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string= s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-ci@code{=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-hash s &optional bound start end 
@defunx string-hash-ci s &optional bound start end 
[SRFI-13]
@end defun

@node SRFI-13 String Prefixes & Suffixes, SRFI-13 String searching, SRFI-13 String Comparison, srfi-13 - String library
@subsection String Prefixes & Suffixes

@defun string-prefix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-length-ci s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length-ci s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-prefix? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix? s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-ci? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-ci? s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@node SRFI-13 String searching, SRFI-13 String case mapping, SRFI-13 String Prefixes & Suffixes, srfi-13 - String library
@subsection String searching

@defun string-index s char/char-set/pred &optional start end
@defunx string-index-right s char/char-set/pred &optional start end
@c EN
[SRFI-13] Looks for the first element in a string @var{s}
that matches @var{char/char-set/pred}, and returns its index.
If @var{char/char-set/pred} is not found in @var{s}, returns @code{#f}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@c JP
[SRFI-13] 文字列@var{s}の中で、@var{char/char-set/pred}にマッチする
最初の要素を探し、そのインデックスを返します。
@var{s}の中に@var{char/char-set/pred}が見つからない場合は、@code{#f}を
返します。オプションの@var{start}と@var{end}は、@var{s}の中で検索対象と
なる範囲を制限します。
@c COMMON
@example
(string-index "Aloha oe" #\a) @result{} 4
(string-index "Aloha oe" #[Aa]) @result{} 0
(string-index "Aloha oe" #[\s]) @result{} 5
(string-index "Aloha oe" char-lower-case?) @result{} 1
(string-index "Aloha oe" #\o 3) @result{} 6
@end example

@c EN
See also the Gauche built-in procedure @code{string-scan}
(@ref{String utilities}), if you need speed over portability.
@c JP
ポータビリティよりも速度を重視する場合は、Gaucheのビルトイン手続き
@code{string-scan}(@ref{String utilities})を参照して下さい。
@c COMMON
@end defun

@defun string-skip s char/char-set/pred &optional start end
@defunx string-skip-right s char/char-set/pred &optional start end
@c EN
[SRFI-13] Looks for the first element that does not match
@var{char/char-set/pred} and returns its index.
If such element is not found, returns @code{#f}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@c JP
[SRFI-13] @var{char/char-set/pred}にマッチしない最初の要素を探し、
そのインデックスを返します。そのような要素が見つからない場合、@code{#f}を
返します。オプションの@var{start}と@var{end}は、@var{s}の中で検索対象と
なる範囲を制限します。
@c COMMON
@end defun

@defun string-count s char/char-set/pred &optional start end
@c EN
[SRFI-13] Counts the number of elements in @var{s}
that matches @var{char/char-set/pred}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@c JP
[SRFI-13] @var{s}の中で、@var{char/char-set/pred}にマッチする要素の数を
カウントします。オプションの@var{start}と@var{end}は、@var{s}の中で検索対象と
なる範囲を制限します。
@c COMMON
@end defun

@defun string-contains s1 s2 &optional start1 end1 start2 end2
@defunx string-contains-ci s1 s2 &optional start1 end1 start2 end2
@c EN
[SRFI-13] Looks for a string @var{s2} inside another string @var{s1}.
If found, returns an index in @var{s1} from where the matching string
begins.  Returns @code{#f} otherwise.
Optional @var{start1}, @var{end1}, @var{start2} and @var{end2}
limits the range of @var{s1} and @var{s2}.

See also the Gauche built-in procedure @code{string-scan}
(@ref{String utilities}), if you need speed over portability.
@c JP
[SRFI-13] @var{s1}の中で、文字列@var{s2}を探します。見つかった場合は、
@var{s1}でマッチした文字列が始まるインデックスを返します。そうでなければ、
@code{#f}を返します。
オプションの@var{start1}、@var{end1}、@var{start2}、@var{end2}は、
@var{s1}と@var{s2}の範囲を制限します。

ポータビリティよりも速度を重視する場合は、Gaucheのビルトイン手続き
@code{string-scan}(@ref{String utilities})を参照して下さい。
@c COMMON
@end defun

@node SRFI-13 String case mapping, SRFI-13 String reverse & append, SRFI-13 String searching, srfi-13 - String library
@subsection String case mapping

@defun string-titlecase s &optional start end
@defunx string-titlecase! s &optional start end
[SRFI-13]
@end defun

@defun string-upcase s &optional start end
@defunx string-upcase! s &optional start end
[SRFI-13]
@end defun

@defun string-downcase s &optional start end
@defunx string-downcase! s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String reverse & append, SRFI-13 String mapping, SRFI-13 String case mapping, srfi-13 - String library
@subsection String reverse & append

@defun string-reverse s &optional start end
@defunx string-reverse! s &optional start end
@c EN
[SRFI-13] Returns a string in which the character positions are reversed
from @var{s}.  @code{string-reverse!} modifies @var{s}.
@c JP
[SRFI-13] @var{s}の文字の位置を逆順にした文字列を返します。
@code{string-reverse!}は@var{s}そのものを変更します。 
@c COMMON
@example
(string-reverse "mahalo") @result{} "olaham"
(string-reverse "mahalo" 3) @result{} "ola"
(string-reverse "mahalo" 1 4) @result{} "aha"

(let ((s (string-copy "mahalo")))
  (string-reverse! s 1 5)
  s)
  @result{} "mlahao"
@end example
@end defun

@defun string-concatenate string-list
@c EN
[SRFI-13] Concatenates list of strings.
@c JP
[SRFI-13] 文字列のリストを連結します。
@c COMMON
@example
(string-concatenate '("humuhumu" "nukunuku" "apua" "`a"))
  @result{} "humuhumunukunukuapua`a"
@end example
@end defun

@defun string-concatenate/shared string-list
@defunx string-append/shared s @dots{}
@c EN
[SRFI-13] ``Shared'' version of @code{string-concatenate} and
@code{string-append}.  In Gauche, these are just synonyms of them.
@c JP
[SRFI-13] @code{string-concatenate}と@code{string-append}の``共有''
バージョンです。Gaucheでは、これらは単に別名です。
@c COMMON
@end defun

@defun string-concatenate-reverse string-list
@defunx string-concatenate-reverse/shared string-list
@c EN
[SRFI-13] Reverses @var{string-list} before concatenation.
``Shared'' version works the same in Gauche.
@c JP
[SRFI-13] @var{string-list}を連結する前に逆順にします。
Gaucheでは、``共有''バージョンは全く同じ動作をします。
@c COMMON
@end defun

@node SRFI-13 String mapping, SRFI-13 String rotation, SRFI-13 String reverse & append, srfi-13 - String library
@subsection String mapping

@defun string-map proc s &optional start end
@defunx string-map! proc s &optional start end
@c EN
[SRFI-13] @code{string-map} applies @var{proc} on every character of @var{s},
and collects the results into a string and returns it.
On the other hand, @code{string-map!} modifies @var{s}.
@c JP
[SRFI-13] @code{string-map}は、@var{s}の全ての文字に対して@var{proc}を
適用し、その結果を文字列に集めそれを返します。
一方、@code{string-map!}は@var{s}そのものを変更します。
@c COMMON
@example
(string-map char-upcase "wikiwiki") @result{} "WIKIWIKI"
(string-map char-upcase "wikiwiki" 4) @result{} "WIKI"

(let ((s (string-copy "wikiwiki")))
  (string-map! char-upcase s 4)
  s)
  @result{} "wikiWIKI"
@end example
@end defun

@defun string-fold kons knil s &optional start end
@defunx string-fold-right kons knil s &optional start end
[SRFI-13]
@end defun

@defun string-unfold p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-unfold-right p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-for-each proc s &optional start end
[SRFI-13]
@end defun

@defun string-for-each-index proc s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String rotation, SRFI-13 other string operations, SRFI-13 String mapping, srfi-13 - String library
@subsection String rotation

@defun xsubstring s from &optional to start end
[SRFI-13]
@end defun

@defun string-xcopy! target tstart s sfrom &optional sto start end
[SRFI-13]
@end defun

@node SRFI-13 other string operations, SRFI-13 String filtering, SRFI-13 String rotation, srfi-13 - String library
@subsection Other string operations

@defun string-replace s1 s2 start1 end2 &optional start2 end2
[SRFI-13]
@end defun

@defun string-tokenize s &optional token-set start end
@c EN
[SRFI-13]
Splits the string @var{s} into a list of substrings,
where each substring is a maximal non-empty contiguous
sequence of characters from the character set @var{token-set}.
The default of @var{token-set} is @code{char-set:graphic}
(@xref{SRFI-14 Predefined character-set}).

See also Gauche's built-in @code{string-split} (@xref{String utilities}),
which provides similar features but different criteria.
@c JP
[SRFI-13]
文字列 @var{s} を、@var{token-set} で指定される文字セットで
構成される、空でない最大限連続した文字のシーケンスのそれぞれを
要素とするリストを返します。
@var{token-set} のデフォルト値は @code{char-set:graphic}
(@ref{SRFI-14 Predefined character-set}参照)。

同様の機能を提供する、しかし異なる基準を持つ、Gauche の組み込み手続き
@code{string-split} (@ref{String utilities} 参照) も見て下さい。
@c COMMON
@end defun

@node SRFI-13 String filtering, SRFI-13 Low-level string procedures, SRFI-13 other string operations, srfi-13 - String library
@subsection String filtering

@defun string-filter s char/char-set/pred &optional start end
@defunx string-delete s char/char-set/pred &optional start end
[SRFI-13]
@end defun

@node SRFI-13 Low-level string procedures,  , SRFI-13 String filtering, srfi-13 - String library
@subsection Low-level string procedures

@defun string-parse-start+end proc s args
@defunx string-parse-final-start+end proc s args
[SRFI-13]
@end defun

@defmac let-string-start+end (start end [rest]) proc-exp s-exp args-exp body @dots{}
[SRFI-13]
@end defmac

@defun check-substring-spec proc s start end
@defunx substring-spec-ok? s start end
[SRFI-13]
@end defun

@defun make-kmp-restart-vector s &optional c= start end
[SRFI-13]
@end defun

@defun kmp-step pat rv c i c= p-start
[SRFI-13]
@end defun

@defun string-kmp-partial-search pat rv s i &optional c= p-start s-start s-end
[SRFI-13]
@end defun

@c ----------------------------------------------------------------------
@node srfi-14 - Character-set library, srfi-19 - Time data types and procedures, srfi-13 - String library, Library modules - SRFIs
@section @code{srfi-14} - Character-set library
@c NODE @code{srfi-14} - 文字集合ライブラリ

@deftp {Module} srfi-14
@mdindex srfi-14
@c EN
Implements the character set library defined in SRFI-14
(@ref{srfi-14,,SRFI-14}).  Note that several basic character-set
operations are Gauche's build-in functions.  @xref{Character set}.
@c JP
SRFI-14で定義された文字セットライブラリを実装します
(@ref{srfi-14,,SRFI-14})。
基本的な文字セットの操作はGauche組み込みになっています(@ref{Character set}参照)。
このモジュールでは多くのユーティリティ手続きが追加されます。
@c COMMON
@end deftp

@menu
* SRFI-14 Character-set constructors::  
* SRFI-14 Character-set Comparison::  
* SRFI-14 Character-set iteration::  
* SRFI-14 Character-set query::  
* SRFI-14 Character-set algebra::  
* SRFI-14 Predefined character-set::  
@end menu

@node SRFI-14 Character-set constructors, SRFI-14 Character-set Comparison, srfi-14 - Character-set library, srfi-14 - Character-set library
@subsection Character-set constructors

@defun list->char-set char-list &optional base-cs
@defunx list->char-set! char-list base-cs
[SRFI-14]
@c EN
Constructs a character set from a list of characters @var{char-list}.
If @var{base-cs} is given, it must be a character set, and the characters
in it are added to the result character set.
@code{List->char-set!} is allowed, but not required, to reuse @var{base-cs}
to store the result.
@c JP
与えられた文字のリスト@var{char-list}から文字セットを構築して返します。
文字セット@var{base-cs}が与えられていた場合、返される文字セットは
その文字セットに@var{char-list}中の文字を追加したものとなります。
@code{list->char-set!}は、結果を格納するために@var{base-cs}を
変更するかもしれません。
@c COMMON
@end defun

@defun string->char-set s &optional base-cs
@defunx string->char-set! s base-cs
[SRFI-14]
@c EN
Like @code{list->char-set} and @code{list->char-set!}, 
but take a list of characters from a string @var{s}.
@c JP
追加する文字をリストでなく文字列@var{s}で与えることを除けば
@code{list->char-set}、@code{list->char-set!}と同じです。
@c COMMON
@end defun

@defun char-set-filter pred char-set &optional base-cs
@defunx char-set-filter! pred char-set base-cs
[SRFI-14]
@c EN
Returns a character set containing every character @var{c} in
@var{char-set} such that @code{(@var{pred} @var{c})} returns true.
If a character set @var{base-cs} is given, its content is added to 
the result.  The linear update version @code{char-set-filter!}
is allowed, but not required, to modify @var{base-cs} to store the result.
@c JP
@var{char-set}内の文字のうち、@code{(@var{pred} @var{c})} が真の値を
返すような@var{c}からなる文字セットを作成して返します。
文字セット@var{base-cs}が与えられた場合は、その内容が結果に追加されます。
@code{char-set-filter!}は、結果を格納するために@var{base-cs}を変更するかも
しれません。
@c COMMON
@end defun

@defun ucs-range->char-set lower upper &optional error? base-cs
@defunx ucs-range->char-set! lower upper error? base-cs
[SRFI-14]
@c EN

@c JP
@c COMMON
@end defun

@defun integer-range->char-set lower upper &optional error? base-cs
@defunx integer-range->char-set! lower upper error? base-cs
@c EN
@c JP
@c COMMON
@end defun

@defun ->char-set x
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@node SRFI-14 Character-set Comparison, SRFI-14 Character-set iteration, SRFI-14 Character-set constructors, srfi-14 - Character-set library
@subsection Character-set comparison

@defun char-set= char-set1 @dots{}
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set@code{<=} char-set1 @dots{}
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-hash char-set &optional bound
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@node SRFI-14 Character-set iteration, SRFI-14 Character-set query, SRFI-14 Character-set Comparison, srfi-14 - Character-set library
@subsection Character-set iteration

@defun char-set-cursor char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-ref char-set cursor
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-cursor-next char-set cursor
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun end-of-char-set? ccursor
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-fold kons knil char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-unfold pred fun gen seed &optional base-char-set
@defunx char-set-unfold! pred fun gen seed base-char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-for-each proc char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-map proc char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@node SRFI-14 Character-set query, SRFI-14 Character-set algebra, SRFI-14 Character-set iteration, srfi-14 - Character-set library
@subsection Character-set query

@defun char-set-size char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-count pred char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set->list char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set->string char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-every pred char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-any pred char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@node SRFI-14 Character-set algebra, SRFI-14 Predefined character-set, SRFI-14 Character-set query, srfi-14 - Character-set library
@subsection Character-set algebra

@defun char-set-adjoin char-set char1 @dots{}
@defunx char-set-adjoin! char-set char1 @dots{}
[SRFI-14]
@end defun

@defun char-set-delete char-set char1 @dots{}
@defunx char-set-delete! char-set char1 @dots{}
[SRFI-14]
@end defun

@defun char-set-complement char-set
@defunx char-set-complement! char-set
[SRFI-14]
@end defun

@defun char-set-union char-set @dots{}
@defunx char-set-union! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-intersection char-set @dots{}
@defunx char-set-intersection! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-difference char-set1 char-set2 @dots{}
@defunx char-set-difference! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-xor char-set @dots{}
@defunx char-set-xor! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-diff+intersection char-set1 char-set2 @dots{}
@defunx char-set-diff+intersection! char-set1 char-set2 char-set3 @dots{}
[SRFI-14]
@end defun



@node SRFI-14 Predefined character-set,  , SRFI-14 Character-set algebra, srfi-14 - Character-set library
@subsection Predefined character-set

@defvar char-set:letter
[SRFI-14]
@end defvar

@defvar char-set:blank
[SRFI-14]
@end defvar

@defvar char-set:iso-control
[SRFI-14]
@end defvar

@defvar char-set:digit
@defvarx char-set:hex-digit
[SRFI-14]
@end defvar

@defvar char-set:graphic
[SRFI-14]
@end defvar

@defvar char-set:lower-case
@defvarx char-set:upper-case
@defvarx char-set:title-case
[SRFI-14]
@end defvar

@defvar char-set:printing
[SRFI-14]
@end defvar

@defvar char-set:punctuation
[SRFI-14]
@end defvar

@defvar char-set:whitespace
[SRFI-14]
@end defvar

@defvar char-set:symbol
[SRFI-14]
@end defvar

@defvar char-set:ascii
[SRFI-14]
@end defvar

@defvar char-set:empty
[SRFI-14]
@end defvar

@defvar char-set:full
[SRFI-14]
@end defvar

@c ----------------------------------------------------------------------
@node srfi-19 - Time data types and procedures, srfi-27 - Sources of random bits, srfi-14 - Character-set library, Library modules - SRFIs
@section @code{srfi-19} - Time data types and procedures
@c NODE srfi-19 - 時間のデータ型と手続き, @code{srfi-19} - 時間のデータ型と手続き

@c EN
This SRFI defines various representations of time and date, and
conversion methods among them.
@c JP
このSRFIは、時間と日付に関する様々な表現と、それらの間の変換メソッドを提供します。
@c COMMON

@c EN
On Gauche, time object is supported natively by @code{<time>} class
(@xref{SRFI time}).  Date object is supported by @code{<date>} class
described below.
@c JP
Gaucheでは、timeオブジェクトは@code{<time>}クラスとして組み込みで
サポートされています(@ref{SRFI time}参照)。dateオブジェクトは以下で説明する
@code{<date>}クラスとしてサポートされます。
@c COMMON

@menu
* SRFI-19 Time types::          
* SRFI-19 Time queries::        
* SRFI-19 Time procedures::     
* SRFI-19 Date::                
* SRFI-19 Date reader and writer::  
@end menu

@node SRFI-19 Time types, SRFI-19 Time queries, srfi-19 - Time data types and procedures, srfi-19 - Time data types and procedures
@subsection Time types
@c NODE 時間のタイプ

@c EN
Time type is represented by a symbol.  This module defines
the following constant variables that is bound to its name, for
convenience.
@c JP
時間のタイプはシンボルで表現されます。
このモジュールでは以下の定数が自分の名前に束縛された形で提供されています。
@c COMMON

@defvr {Constant} time-utc
[SRFI-19]
@c EN
UTC time.  Gauche's built-in @code{current-time} always returns
this type (@xref{SRFI time}).
@c JP
UTC timeです。Gaucheの組み込みの@code{current-time}は常にこのタイプの時間を
返します (@ref{SRFI time}参照)。
@c COMMON
@end defvr

@defvr {Constant} time-tai
[SRFI-19]
@c EN
International Atomic Time.  This time is a bit larger than UTC, due to
the leap seconds.
@c JP
International Atomic Time。この時間は閏秒を計算に入れており、
UTCより若干大きな値を取ります。
@c COMMON
@end defvr

@defvr {Constant} time-monotonic
[SRFI-19]
@c EN
Implementation-dependent monotonically increasing time.
In Gauche, this is the same as @code{time-tai}.
@c JP
実装依存の、単調増加する時間。Gaucheの実装ではこれは@code{time-tai}と同じです。
@c COMMON
@end defvr

@defvr {Constant} time-duration
[SRFI-19]
@c EN
Duration between two absolute time points.
@c JP
二つの絶対的な時点の間の期間。
@c COMMON
@end defvr

@defvr {Constant} time-process
[SRFI-19]
@c EN
CPU time in current process.
Gauche calculates this from user time and system time returned by 
POSIX times(3).
@c JP
現在のプロセスのCPU時間。
Gaucheは、POSIX time(3)コールが返すユーザ時間とシステム時間の合計からこの値を
計算します。
@c COMMON
@end defvr

@defvr {Constant} time-thread
[SRFI-19]
@c EN
CPU time in current thread.
In the current implementation, this is the same as @code{time-process}.
@c JP
現在のスレッドのCPU時間。
現在の実装ではこれは@code{time-process}と同じです。
@c COMMON
@end defvr

@node SRFI-19 Time queries, SRFI-19 Time procedures, SRFI-19 Time types, srfi-19 - Time data types and procedures
@subsection Time queries
@c NODE 時間に関する問い合わせ

@defun current-time &optional time-type
[SRFI-19]
@c EN
Extends Gauche built-in @code{current-time} (@xref{SRFI time}) to take
optional @var{time-type} argument to specify the desired time type.
@var{time-type} must be one of the types described in @ref{SRFI-19 Time types}.
@c JP
Gauche組み込みの@code{current-time} (@ref{SRFI time}参照)を拡張して、
必要な時間のタイプを省略可能な引数@var{time-type}で指定できるようにしています。
可能な@var{time-type}の値は@ref{SRFI-19 Time types}で説明されているものです。
@c COMMON
@end defun

@defun current-date &optional tz-offset
[SRFI-19]
@c EN
Returns the current date as an instance of @code{<date>} class
(@xref{SRFI-19 Date}).  If @var{tz-offset} is given, it must be
an offset from UTC in number of seconds.  If @var{tz-offset} is
not given, returns the date in local time zone.
@c JP
現在の日付を@code{<date>}クラスのインスタンスとして返します(@ref{SRFI-19 Date}参照)。
@var{tz-offset}が与えられた場合、それがUTCからのオフセットを表す秒数として
使われます。@var{tz-offset}が与えられなかった場合はローカルタイムゾーンで
表現された日付が返されます。
@c COMMON
@end defun

@defun current-julian-day 
[SRFI-19]
@c EN
Returns the current julian day, a point in time as a real number of
days since -4714-11-24T12:00:00Z (November 24, -4714 at noon, UTC). 
@c JP
現在のJulian dayを返します。Julian dayは
-4714-11-24T12:00:00Z (November 24, -4714 at noon, UTC) からの日数を
実数で表現したものです。
@c COMMON
@end defun

@defun current-modified-julian-day
[SRFI-19]
@c EN
Returns the current modified julian day, a point in time as a real
number of days since 1858-11-17T00:00:00Z
(November 17, 1858 at midnight, UTC). 
@c JP
現在のModified julian dayを返します。Modified julian dayは
1858-11-17T00:00:00Z (November 17, 1858 at midnight, UTC)
からの日数を実数で表現したものです。
@c COMMON
@end defun

@defun time-resolution
[SRFI-19]
@end defun


@node SRFI-19 Time procedures, SRFI-19 Date, SRFI-19 Time queries, srfi-19 - Time data types and procedures
@subsection Time procedures
@c NODE 時間に関する手続き

@defun make-time type nanoseconds seconds
[SRFI-19]
@c EN
Returns an instance of @code{<time>} class with specified initial values.
Equivalent to @code{(make <time> :type type :second seconds :nanosecond nanoseconds)}.

(This funciton had been defined incorrectly before release 0.6.8; 
the arguments @var{seconds} and @var{nanoseconds} were switched.
Please check your code if it uses @code{make-time}).
@c JP
与えられた初期値を持つ@code{<time>}クラスのインスタンスを返します。
@code{(make <time> :type type :second seconds :nanosecond nanoseconds)}
と等価です。

(この関数は0.6.8より前のリリースでは間違って定義されていました。
@var{seconds}と@var{nanoseconds}の引数が逆になっていたのです。
@code{make-time}を使っているコードは注意して下さい)。
@c COMMON
@end defun

@defun time-type time
@defunx time-second time
@defunx time-nanosecond time
@defunx set-time-type! time type
@defunx set-time-second! time second
@defunx set-time-nanosecond! time nanosecond
[SRFI-19]
@c EN
Getter and setter of @code{<time>} object slots.
@c JP
@code{<time>}オブジェクトのスロットのアクセサです。
@c COMMON
@end defun

@defun copy-time time
[SRFI-19]
@c EN
Returns a new instance of @code{<time>} whose content is the same as
given @var{time}
@c JP
与えられた@var{time}と同じ内容の新しい@code{<time>}オブジェクトを返します。
@c COMMON
@end defun

@defun time=? time0 time1
@defunx time<? time0 time1
@defunx time<=? time0 time1
@defunx time>? time0 time1
@defunx time>=? time0 time1
[SRFI-19]
@c EN
Compares two times.  Types of both times must match.
@c JP
二つの時間を比較します。時間のタイプは一致していなければなりません。
@c COMMON
@end defun

@defun time-difference time0 time1
@defunx time-difference! time0 time1
[SRFI-19]
@c EN
Returns the difference of two times, in @code{time-duration} time.
Types of both times must match.  
@code{Time-difference!} modifies @var{time0} to store the result.
@c JP
二つの時間の差を@code{time-duration}タイプの時間として返します。
二つの時間のタイプは一致していなければなりません。
@code{Time-difference!}は結果を格納するために@var{time0}を変更します。
@c COMMON
@end defun

@defun add-duration time0 time-duration
@defunx add-duration! time0 time-duration
@defunx subtract-duration time0 time-duration
@defunx subtract-duration! time0 time-duration
[SRFI-19]
@c EN
Adds or subtracts @var{time-duration} to or from @var{time0}.
Type of returned time is the same as @var{time0}.  Type of
@var{time-duration} must be @code{time-duration}.
@code{add-duration!} and @code{subtract-duration!} reuse
@var{time0} to store the result.
@c JP
@var{time-duration}を@var{time0}に加算、または@var{time0}から減算します。
返される時間のタイプは@var{time0}と同じです。@var{time-duration}のタイプは
@code{time-duration}でなければなりません。
@code{add-duration!}と@code{subtract-duration!}は結果を格納するのに
@var{time0}を再利用します。
@c COMMON
@end defun

@node SRFI-19 Date, SRFI-19 Date reader and writer, SRFI-19 Time procedures, srfi-19 - Time data types and procedures
@subsection Date
@c NODE 日付

@deftp {Class} <date>
@clindex date
@c EN
Represents a date.
@c JP
日付を表現します。
@c COMMON

@defivar nanosecond
@c EN
Nanosecond portion of the date by an integer between 0 and 999,999,999,
inclusive.
@c JP
日付のナノ秒部分、0 から 999,999,999 までの整数です。
@c COMMON
@end defivar

@defivar second
@c EN
Second portion of the date by an integer between 0 and 60, inclusive.
(60 for leap second).
@c JP
日付の秒部分、0 から 60 までの整数です。(60 は閏秒)
@c COMMON
@end defivar

@defivar minute
@c EN
Minute portion of the date by an integer between 0 and 59, inclusive.
@c JP
日付の分部分、0 から 59 までの整数です。
@c COMMON
@end defivar

@defivar hour
@c EN
Hour portion of the date by an integer between 0 and 23, inclusive.
@c JP
日付の時部分、0 から 23 までの整数です。
@c COMMON
@end defivar

@defivar day
@c EN
Day portion of the date by an integer between 0 and 31, inclusive.
The actual upper bound of the day is determined by the year and the month.
(Note: 1 is for the first day; 0 is allowed by the specification,
but I don't see why).
@c JP
日付の日部分、0 から 31 日までの整数です。実際の上限は年と月によって決定
されます。(註: 1 は朔日(ついたち)、0 は仕様では認められていますが、
なぜなのかはわかりません。)
@c COMMON
@end defivar

@defivar month
@c EN
Month portion of the date by an integer between 1 and 12, inclusive.
1 for January, 2 for February, and so on.
(Note: this is different from POSIX's @code{<sys-tm>} convention).
@c JP
日付の月部分、1 から 12 までの整数です。1 は一月、2 は二月、以下同様です。
(註: これは POSIX の @code{<sys-tm>} の命名法とは異ります。)
@c COMMON
@end defivar

@defivar year
@c EN
Year portion of the date.
@c JP
日付の年部分です。
@c COMMON
@end defivar

@defivar zone-offset
@c EN
The number of seconds east of GMT for this timezone, by an integer.
@c JP
このタイムゾーンが GMT より何秒東にあるかを示す整数です。
@c COMMON
@end defivar
@end deftp

@defun make-date nanosecond second minute hour day month year zone-offset
[SRFI-19]
@c EN
Makes a @code{<date>} object from the given values.
Note: this procedure does not check if the values are in the valid range.
@c JP
与えられた値から @code{<date>} オブジェクトを作成します。
註: この手続きは与えられた値が正しい範囲であるかどうかをチェックしません。
@c COMMON
@end defun

@defun date? obj
[SRFI-19]
@c EN
Returns true iff @var{obj} is a @code{<date>} object.
@c JP
@var{obj} が @code{<date>} オブジェクトである場合にかぎり真を返します。
@c COMMON
@end defun

@defun date-nanosecond date
@defunx date-second date
@defunx date-minute date
@defunx date-hour date
@defunx date-day date
@defunx date-month date
@defunx date-year date
@defunx date-zone-offset date
[SRFI-19]
@c EN
Accessors.
@c JP
アクセサです。
@c COMMON
@end defun

@defun date-year-day date
@defunx date-week-day date
@defunx date-week-number date day-of-week-starting-week
[SRFI-19]
@c EN
Calculates the day number in the year (1 for January 1st),
the day number in the week (0 for Sunday, 1 for Monday, ...),
and the ordinal week of the year which holds this date,
ignoring a first partial week, respectively.

@var{Day-of-week-starting-week} is the integer corresponding to
the day of the week which is to be considered the first day of
the week (Sunday=0, Monday=1, etc.).
@c JP
それぞれ、一年の何日目(一月一日が 1)か、何曜日(日曜日が 0、月曜日が 1
など)か、一年のうち何週目(一年の最初の週が一週間に満たない場合はその
週は無視)かを計算します。
@c COMMON
@end defun

@defun date->julian-day date
@defunx date->modified-julian-day date
@defunx date->time-monotonic date
@defunx date->time-tai date
@defunx date->time-utc date
[SRFI-19]
@c EN
Conversions from date to various date/time types.
@c JP
日付から様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@defun julian-day->date jd &optional tz-offset
@defunx julian-day->time-monotonic jd
@defunx julian-day->time-tai jd
@defunx julian-day->time-utc jd
[SRFI-19]
@c EN
Conversions from julian-day to various date/time types.
@c JP
ユリウス暦からから様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@defun modified-julian-day->date jd &optional tz-offset
@defunx modified-julian-day->time-monotonic jd
@defunx modified-julian-day->time-tai jd
@defunx modified-julian-day->time-utc jd
[SRFI-19]
@c EN
Conversions from modified julian-day to various date/time types.
@c JP
改訂ユリウス暦から様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@defun time-monotonic->date time &optional tz-offset
@defunx time-monotonic->julian-day time
@defunx time-monotonic->modified-julian-day time
@defunx time-monotonic->time-tai time
@defunx time-monotonic->time-tai! time
@defunx time-monotonic->time-utc time
@defunx time-monotonic->time-utc! time
[SRFI-19]
@c EN
Conversions from time-monotonic to various date/time types.
@c JP
モノトニック形式から様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@defun time-tai->date time &optional tz-offset
@defunx time-tai->julian-day time
@defunx time-tai->modified-julian-day time
@defunx time-tai->time-monotonic time
@defunx time-tai->time-monotonic! time
@defunx time-tai->time-utc time
@defunx time-tai->time-utc! time
[SRFI-19]
@c EN
Conversions from time-tai to various date/time types.
@c JP
国際原子時形式から様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@defun time-utc->date time &optional tz-offset
@defunx time-utc->julian-day time
@defunx time-utc->modified-julian-day time
@defunx time-utc->time-monotonic time
@defunx time-utc->time-monotonic! time
@defunx time-utc->time-tai time
@defunx time-utc->time-tai! time
[SRFI-19]
@c EN
Conversions from time-utc to various date/time types.
@c JP
UTC 形式から様々な様式の日付/時間に変換します。
@c COMMON
@end defun

@node SRFI-19 Date reader and writer,  , SRFI-19 Date, srfi-19 - Time data types and procedures
@subsection Date reader and writer
@c NODE 日付の読み書き

@defun date->string date &optional format-string
[SRFI-19]
@end defun

@defun string->date string template-string
[SRFI-19]
@end defun

@c ----------------------------------------------------------------------
@node srfi-27 - Sources of random bits, srfi-37 - a program argument processor, srfi-19 - Time data types and procedures, Library modules - SRFIs
@section @code{srfi-27} - Sources of Random Bits
@c NODE srfi-27 - ランダムビットのソース, @code{srfi-27} - ランダムビットのソース

@deftp {Module} srfi-27
@mdindex srfi-27
This module provides SRFI-27 pseudo random generator interface,
using Mersenne Twister algorithm 
(@xref{math.mt-random - Mersenne-Twister random number generator}) as the backbone.
@end deftp

@defun random-integer n
[SRFI-27]
Returns a random exact integer between [0, @var{n}-1], inclusive,
using the default random source.
To set a random seed for this procedure, use @code{random-source-randomize!}
or @code{random-source-pseudo-randomize!} on @code{default-random-source}.
@end defun

@defun random-real
[SRFI-27]
Returns a random real number between (0, 1), exclusive,
using the default random source.
To set a random seed for this procedure, use @code{random-source-randomize!}
or @code{random-source-pseudo-randomize!} on @code{default-random-source}.
@end defun

@defvar default-random-source
[SRFI-27]
Keeps the default random source that is used by @code{random-integer}
and @code{random-real}.
@end defvar

@defun make-random-source
[SRFI-27]
Creates and returns a new random source.
In the current Gauche implementation, it is just a @code{<mersenne-twister>}
object.  It may be changed in the future implementation.
@end defun

@defun random-source? obj
[SRFI-27]
Returns @code{#t} if @var{obj} is a random source object.
@end defun

@defun random-source-state-ref s
@defunx random-source-state-set! s state
[SRFI-27]
Gets and sets the "snapshot" of the state of the random source @var{s}.
@var{State} is an opaque object whose content depends on the backbone
generator.
@end defun

@defun random-source-randomize! s
[SRFI-27]
Makes an effort to set the state of the random source @var{s} to 
a truly random state.  The current implementation uses the current
time and the process ID to set the random seed.
@end defun

@defun random-source-pseudo-randomize! s i j
[SRFI-27]
Changes the state of the random source @var{s} into the initial state 
of the (@var{i}, @var{j})-th independent random source, 
where @var{i} and @var{j} are non-negative integers. 
This procedure can be used to reuse a random source @var{s} as large 
number of independent random source, indexed by two non-negative integers.
Note that this procedure is entirely deterministic. 
@end defun

@defun random-source-make-integers s
[SRFI-27]
Returns a procedure, that takes one integer argument @var{n} and
returns a random integer between 0 and @var{n}-1 inclusive for every
invocation, from the random source @var{s}.
@end defun

@defun random-source-make-reals s &optional unit
[SRFI-27]
Returns a procedure, that takes no argument and
returns a random real between 0 and 1 exclusive for
every invocation, from the random source @var{s}.
If @var{unit} is given, the random real the returned procedure
generates will be quantized by the given @var{unit}, where 
0 < @var{unit} < 1.
@end defun

@c ----------------------------------------------------------------------
@node srfi-37 - a program argument processor,  , srfi-27 - Sources of random bits, Library modules - SRFIs
@section @code{srfi-37} - args-fold: a program argument processor

@deftp {Module} srfi-37
@mdindex srfi-37
This module implements @code{args-fold},
yet another procedure to process command-line
arguments, defined in SRFI-37 (@ref{srfi-37,[SRFI-37],SRFI-37}).

Unlike @code{gauche.parseopt}
(@xref{gauche.parseopt - Parsing command-line options}),
@code{args-fold} provides functional interface, i.e. 
the user's states are explicitly passed via parser's argument and
return values, and also follows POSIX and GNU getopt guidelines,
including long options.
@end deftp

@defun args-fold args options unrecognized-proc operand-proc &rest seeds
Processes program options @var{args} from left to right,
according to given option specification @var{options},
and two procedures @var{unrecognized-proc} and @var{operand-proc}.

@var{Options} is a list of option objects, explained below.
Each option object keeps the name(s) of the option, 
a flag to specify whether the option takes
an argument or not, and a procedure to process that option
(we'll call it @emph{option procedure}).  

@code{Args-fold} recognizes both single-character options (short options)
and long options.  A short option must begin with single hyphen
(e.g. @code{-a}), while long option must begin with double hyphens
(e.g. @code{--help}).   Short options can be
concatenated, e.g. @code{-abc} or @code{-a -b -c}.
Both a short option and a long option can take
required or optional arguments.   Required short-option argument
can appear with or without space after the option, e.g.
@code{-afoo} or @code{-a foo}.
Long-option argument can appear after character '@code{=}' or
space, e.g. @code{--long=foo} or @code{--long foo}.

When @code{args-fold} encounters a command-line argument that cannot
be an option argument, and doesn't begin with hyphen, the argument is
treated as an @emph{operand}.   @code{Args-fold} allows operands and
options to be interleaved.  However, if @code{args-fold} encounters
'@code{--}', the rest of arguments are treated as operands,
regardless of beginning with hyphen or not.

When the given option matches one of option object in @var{options},
the option procedure is called as follows:
@example
(@var{option-proc} @var{option} @var{name} @var{arg} @var{seed} @dots{})
@end example
where @var{option} is the matched option object, @var{name} is
the string actually used to specify the option, @var{arg} is
the option argument (or @code{#f} if there's none), and
@var{seed} @dots{} is the user's state information.
@var{Option-proc} must return as many arguments as @var{seed}s.

When @code{args-fold} encounters an option that doesn't match
any of the option objects, it creates a new option object
for the option and calls @var{unrecognized-proc}
with the same arguments as @var{option-proc}.  

When @code{args-fold} finds an operand, @var{operand-proc}
is called as follows:
@example
(@var{operand-proc} @var{operand} @var{seed} @dots{})
@end example
@var{Operand-proc} must return as many arguments as @var{seed}s.

The caller's state should be explicitly passed around seed arguments
and return values.  The initial seed values are @var{seed}s given
to @code{args-fold}.  The values returned from option procedure,
@var{unrecognized-proc} and @var{operand-proc} are used as the seed
arguments of next invocation of those procedures.  The values
returned from the last call to the procedures are returned
from @code{args-fold}.
@end defun

@defun option names require-arg? optional-arg? processor
Creates an option object with the passed properties.

@var{Names} is a list of characters and/or strings.
A character is used for a short option, and a string is used
for a long option.

Two flags, @var{require-arg?} and @var{optional-arg?}
indicates whether the option should take an option argument,
or may take an option argument.  

@var{Processor} is the option processor procedure.

Note that, if an option argument is passed using '@code{=}'
character, it is passed to the option procedure even if 
the option has @code{#f} in both @var{require-arg?}
and @var{optional-arg?}.  It is up to the option procedure
to deal with the argument.

It should also be noted that the optional option argument
for a short option is only recognized if it is given
without whitespace after the short option.  That is, if
a short option '@code{d}' is marked to take optional option argument,
then '@code{-dfoo}' is interpreted as '@code{-d}' with argument '@code{foo}',
but '@code{-d foo}' is interpreted as '@code{-d}' without argument
and an operand @code{foo}.  If '@code{d}' is marked to
take required option argument, however, both are interpreted
as '@code{-d}' with argument '@code{foo}'.
@end defun

@defun option? obj
Returns @code{#t} if @var{obj} is an option object,
@code{#f} otherwise.
@end defun

@defun option-names option
@defunx option-required-arg? option
@defunx option-optional-arg? option
@defunx option-processor
Returns the properties of an option object @var{option}.
@end defun

A simple example:

@example
(use srfi-37)

(define options
 (list (option '(#\d "debug") #f #t
               (lambda (option name arg debug batch paths files)
                 (values (or arg "2") batch paths files)))
       (option '(#\b "batch") #f #f
               (lambda (option name arg debug batch paths files)
                 (values debug #t paths files)))
       (option '(#\I "include") #t #f
               (lambda (option name arg debug batch paths files)
                 (values debug batch (cons arg paths) files)))))

(define (main args)
  (receive (debug-level batch-mode include-paths files)
    (args-fold (cdr args)
               options
               (lambda (option name arg . seeds)         ; unrecognized
                 (error "Unrecognized option:" name))
               (lambda (operand debug batch paths files) ; operand
                 (values debug batch paths (cons operand files)))
               0      ; default value of debug level
               #f     ; default value of batch mode
               '()    ; initial value of include paths
               '()    ; initial value of files
               )
     (print "debug level = " debug-level)
     (print "batch mode = " batch-mode)
     (print "include paths = " (reverse include-paths))
     (print "files = " (reverse files))
     0))
@end example



