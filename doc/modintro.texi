@node Library modules - Overview, Library modules - Gauche extensions, Object system, Top
@chapter Library modules - Overview
@c NODE ライブラリモジュール - 概要

@c EN
In the following chapters, we explain library modules bundled with Gauche's
distribution.
These modules should generally be loaded and imported (usually using @code{use}
- @xref{Using modules}, for details), unless otherwise noted.
@c JP
続くいくつかの章で、Gaucheのディストリビューションに含まれる
ライブラリモジュールを解説します。
これらのモジュールを使うにあたっては、特に断りのない限り、
モジュールをロードしてimportすることが必要です
(通常は@code{use}マクロが使えます。@ref{Using modules}参照)。
@c COMMON

@c EN
Some modules are described as "autoloaded".  That means you don't need
to @code{load} or @code{use} the module explicitly; at the first time
the bindings are used in the program, the module is automatically
loaded and imported.  See @ref{Autoload}, for the details of autoloading.
@c JP
いくつかのモジュールは「オートロードされる」と表記されています。
この場合は、そのモジュールを使うにあたってあらかじめモジュールをロードしたり
@code{use}しておく必要はありません。そのモジュールの束縛が使われた時点で、
モジュールが自動的にロードされインポートされます。オートロードの
詳細については@ref{Autoload}を参照してください。
@c COMMON

@c EN
As the number of bundled libraries grows, it becomes harder
to find the one you need.  If you feel lost, check
out the section @ref{Finding libraries you need}, in which
we categorized libraries by their purposes.
@c JP
付属ライブラリの数が増えるにつれ、必要なライブラリを探すのが難しく
なりつつあります。迷ったら、@ref{Finding libraries you need}を
見てみて下さい。目的に合わせてライブラリをカテゴライズしています。
@c COMMON

@c EN
The following three chapters describe bundled modules,
grouped by their names.  
@ref{Library modules - Gauche extensions} contains a description of
@code{gauche.*} modules, which are more or less considered
the core features of Gauche but separated since less frequently used.
(Some modules are rather ad-hoc, but here for historical reasons).
@ref{Library modules - SRFIs} describes the modules which
provide SRFI functionalities.  They have the names beginning
with @code{srfi-}.
Note that some of SRFI features are built in Gauche core and
not listed here.  @xref{Standard conformance}, for the entire list
of supported SRFIs.
@ref{Library modules - Utilities} describes other modules
---including database interface, filesystem utilities,
network protocol utilities, and more.
@c JP
この章に続く3つの章で、各ライブラリについて詳細に記述します。
各章は名前でグループ化されています。
@ref{Library modules - Gauche extensions}では@code{gauche.*}という
名前を持つモジュールを説明します。これらはある意味Gaucheの基本的な
機能なのですが、使われる頻度が少ないために別モジュールになったというものです。
(いくつかのモジュールはもっと付加的なものですが、歴史的理由からここにあります)。
@ref{Library modules - SRFIs}ではSRFIの機能を提供するモジュールを
扱います。@code{srfi-}で始まる名前を持ちます。
いくつかのSRFIについてはGaucheのコアに組み込みになっているため、
この章には現れないことに注意してください。サポートされているSRFIの
完全なリストについては@ref{Standard conformance}を見て下さい。
@ref{Library modules - Utilities}では残りのモジュールに
ついて説明します。データベースインタフェース、ファイルシステム、
ネットワークプロトコル、その他様々なライブラリがあります。
@c COMMON

@c EN
There are a few procedures that help your program to check
the existence of certain modules or libraries at run-time.
See @ref{Operations on libraries}, for the details.
@c JP
実行時にプログラムが特定のモジュールやライブラリの存在を検査できる
手続きがいくつか提供されています。
詳しくは@ref{Operations on libraries}を参照して下さい。
@c COMMON

@menu
* Finding libraries you need::  
* Naming convetion of libraries::  
@end menu

@node Finding libraries you need, Naming convetion of libraries, Library modules - Overview, Library modules - Overview
@section Finding libraries you need

Each module is named more or less after what it implements
rather than what it is implemented @emph{for}.  If the module solves
one problem, both are the same.  However, sometimes there
are multiple ways to solve a problem, or one implementation
of an algorithm can solve multiple different problems; thus
it is difficult to name the modules in problem-oriented
(or purpose-oriented) way.

Because of this, it may not be straightforward for a newcomer
to Gauche to find an appropriate Gauche module to solve your problem.
Since there may be multiple algorithms to do the job,
and each algorithm can be implemented in different modules.

The modules are also designed in layers; some low-level modules
provide direct interface to the system calls, while some
higher-level ones provide more abstract, easy-to-use interface, possibly
built on top of more than one low-level modules.   Which one
should you use?  Generally you want to use the highest level,
for the very purpose of libraries are to provide easy, abstract
interface.  However there are times that you have to break
the abstraction and to go down to tweak the machinery in
the basement; then you need to use low-level modules directly.

The purpose of this section is to group the libraries by
their purposes.  Each category lists relevant modules with
brief descriptions.


@menu
* Library directory - data containers::  
* Library directory - strings and characters::  
* Library directory - data exchange::  
* Library directory - files::   
* Library directory - processes::  
* Library directory - networking::  
* Library directory - input and output::  
* Library directory - time::    
* Library directory - bits and bytes::  
@end menu

@node Library directory - data containers, Library directory - strings and characters, Finding libraries you need, Finding libraries you need
@subsection Library directory - data containers

@subsubheading Generic container operations

Some data containers have similar properties; for example,
lists, vectors and hash tables can be seen as a collection
of data.  So it is handy to have generic operators, such
as applying a procedure to all the elements.

Gauche provides such mechanism to a certain degree, mainly using
its object system.

@itemize @bullet
@item
@emph{Collection} - Generic functions applicable for unordered
set of values.  @xref{Collection framework}.
@item
@emph{Sequence} - Generic functions applicable for ordered set
of values.  @xref{Sequence framework}.
@item
@emph{Relation} - Generic functions to handle relations
(in a sense of Codd's definition).  @xref{Relation framework}.
@item
@emph{Comprehension} - This is a collection of macros very handy
to construct and traverse collections/sequences in concise code.
@xref{Eager comprehensions}.
@end itemize

@subsubheading Container implementations

@itemize @bullet
@item
@emph{List} - the universal data structure.  You want to check
@ref{Pairs and Lists}, @ref{List library}, 
and @ref{Additional list library}.
@item
@emph{Vector} - a one-dimensional array of arbitrary Scheme values.
See @ref{Vectors} and @ref{Vector library}.
@item
@emph{Uniform vector} - a special kind of vectors that can hold
limited types of values (e.g. integers representable in 8bits).
It tends to be used in performance
sensitive applications, such as graphics.  See @ref{Uniform vectors}.
@item
@emph{Array} - multi-dimensional arrays that can hold
arbitrary Scheme values.  See @ref{Arrays}.
@item
@emph{Uniform array} - multi-dimensional arrays that can hold
limited types of values.  This is also supported by @ref{Arrays}.
@item
@emph{String} - a sequence of characters.  See @ref{Strings}
and @ref{String library}.  Gauche handles multibyte strings---
see @ref{Multibyte Strings} for the defatils.
@item
@emph{Character set} - a set of characters.  See @ref{Character set}
and @ref{Character-set library}.
@item
@emph{Hash table} - hash tables.  See @ref{Hashtables}.  There are
also some conversion functions in @ref{Additional list library}.
@item
@emph{Queue} - a simple queue is provided in @ref{Queue}.
@item
@emph{Record} - a simple data structure.  Although Gauche's object
system can be used to define arbitrary data structures, you might
want to look at @ref{Record types} and @ref{SLIB-compatible record type},
for they are more portable and potentially more efficient.
@item
@emph{Stream} - you can implement cool lazy algorithms with it.
See @ref{Stream library}.
@item
@emph{Database interface} - dbm interface can be used as a
persistent hash table; see @ref{Generic DBM interface}.
For generic RDBMS interface, see @ref{Database independent access layer}.
@end itemize

@node Library directory - strings and characters, Library directory - data exchange, Library directory - data containers, Finding libraries you need
@subsection Library directory - string and character

Basic string operations are covered in
@ref{Strings} and @ref{String library}.
A string is also a sequence of characters, so you can
apply methods in @ref{Collection framework} and
@ref{Sequence framework}.

Character and character set operations are covered in
@ref{Characters}, @ref{Character set}, and @ref{Character-set library}.

If you scan or build strings sequentially, do not use index
access.  String ports (see @ref{String ports}) provides more efficient,
and elegant way.

You can use regular expressions to search and extract
character sequences from strings; see @ref{Regular expression}.

If you need to deal with low-level (i.e. byte-level)
representation of strings, @ref{Uniform vectors} has some
tools to convert strings and byte vectors back and forth.

Are you dealing with a structure higher than a mere sequence
of characters?  Then take a look at @code{text.*} modules.
@ref{Parsing input stream} has some basic
scanners.  @ref{Transliterate characters} implements a
feature similar to Unix's @code{tr(1)}.  
You can take @code{diff} of two texts; see
@ref{Calculate difference of text streams}.
And if you want to construct large text from string fragments,
do not use @code{string-append}---see @ref{Lazy text construction}.

Last but not least, Gauche has support of various character
encoding schemes.  See @ref{Character code conversion} for
the basic utilities.  Most higher-level functions such as
@code{open-input-file} can take @code{:encoding} keyword argument
to perform character conversion implicitly.  Also see 
@ref{Multibyte scripts} if you write Scheme program in
non-ASCII characters.  If you want to process Gauche source code
which may contain "encoding" magic comment, see @ref{Coding-aware ports}.
Gauche also has GNU gettext compatible module (@ref{Localized messages})
if you need localization.

@node Library directory - data exchange, Library directory - files, Library directory - strings and characters, Finding libraries you need
@subsection Library directory - data exchange

Most useful programs need to communicate with outside world
(other programs or humans).  That involves reading the external data
into your program understanding whatever format the data is in, and
also writing the data in the format the others can understand.

Lots of network-related external formats are defined in RFC,
and there are corresponding @code{rfc.*} module that handle 
some of them.  See @ref{RFC822 message parsing}, for example,
to handle the pervasive RFC2822 message format.

When you exchange table-formatted data, one of the easiest way
may be the plain text, one row per line, and columns are separeted
by some specific characters (e.g. comma).  See @ref{CSV tables} for
basic parser/writer for them.

Oh, and nowadays every business user wants XML, right?  You know
they are just S-expressions with extra redundancy and pointy
parentheses.  So why don't you read XML as if they're S-exprs,
process them with familiar cars and cdrs and maps, then write them
out with extra redundancy and pointy parens?
Module @code{sxml.ssax} (@ref{Functional XML parser})
implements SAX XML parser, with which you
can parse XML and process them on the fly, or convert it to
SXML, S-expression XML.  You can query SXML usinv
SXPath, an XPath counterparts of S-expression (@ref{SXML Query Language}).
You can output all kinds of XML and HTML using the SXML serializer
(@ref{Serializing XML and HTML from SXML}).

It is planned that various file format handling routines would
be available as @code{file.*} modules, though we have none ready
yet.  If you plan to write one, please go ahead and let us know!


@node Library directory - files, Library directory - processes, Library directory - data exchange, Finding libraries you need
@subsection Library directory - files

Files and directories.  Roughly speaking, there are two places
you want to look at.

@ref{Filesystems}, in the core, has
routines close to the underlying OS provides.  If you have
experience with Unix system programming you'll find familiar
function names there.   The @code{fcntl} functionality is
splitted to @code{gauche.fcntl} (@ref{Low-level file operations}), FYI.

Also you definitely want to look at @code{file.util}
(@ref{Filesystem utilities}), which implements higher-level
routines on top of system-level ones.



@node Library directory - processes, Library directory - networking, Library directory - files, Finding libraries you need
@subsection Library directory - processes

Process-related routines also come in two levels.

The @code{gauche.process} module provides
high-level routines (@ref{High Level Process Interface}); 
you can pipe the data into and out of child processes easily, for example.

Gauche core provides the primitive @code{fork} and @code{exec} interface
as well as the convenient @code{system} call
(see @ref{Unix process management}).  Use them when you want a precise
control over what you're doing.


@node Library directory - networking, Library directory - input and output, Library directory - processes, Finding libraries you need
@subsection Library directory - networking

We have multi-layer abstraction here.  At the bottom, we have
APIs corresponding to socket-level system calls.  In the middle,
a convenience library that automates host name lookups, connection
and shutdown, etc.  On top of them we have several modules that
handles specific protocols (e.g. http).

The @code{gauche.net} module (@ref{Networking}) provides the bottom
and middle layer.  For the top layer, look for @code{rfc.*} modules,
e.g. @code{rfc.http} (@ref{HTTP}).
More protocol support is coming (there are @code{rfc.ftp} and
@code{rfc.imap4} written by users, which are waiting for being
integrated into Gauche---maybe in next release).

There's a plan of even higher level of libraries, under the name
@code{net.*}, which will abstract more than one network protocols.
The planned ones include sending emails, or
universal resource access by uri.  Code contributions are welcome.

@node Library directory - input and output, Library directory - time, Library directory - networking, Finding libraries you need
@subsection Library directory - input and output

@node Library directory - time, Library directory - bits and bytes, Library directory - input and output, Finding libraries you need
@subsection Library directory - time

@node Library directory - bits and bytes,  , Library directory - time, Finding libraries you need
@subsection Library directory - bits and bytes

@subsubheading Binary I/O

As the bottom level,
Gauche includes primitive byte I/O (@code{read-byte}, @code{write-byte})
as well as block I/O (@code{read-block!}, @code{write-block}) in its core.
(See @ref{Reading data}, @ref{Output}, and @ref{Uvector block I/O}).

As the middle level, the module @code{binary.io}
(@ref{Binary I/O}) has routines to retrieve specific datatype
with optional endian specification.

And as the top level, the module @code{binary.pack}
(@ref{Packing Binary Data}) allows packing and unpacking 
structured binary data, a la Perl's @code{pack}/@code{unpack}.

@subsubheading Bit manipulation

Gauche core provides bitshift and mask operations. 
See @ref{Bitwise operations}.


@node Naming convetion of libraries,  , Finding libraries you need, Library modules - Overview
@section Naming convetion of libraries

@c EN
The following table summarizes naming categories of the modules,
including external ones and planned ones.
@c JP
下の表は、モジュールの名前付けの分類を示します。
外部モジュール、及び将来予定されているモジュールも含みます。
@c COMMON

@table @code
@item binary.*
@c EN
Utilities to treat binary data.
@c JP
バイナリデータを扱うためのユーティリティ。
@c COMMON

@item compat.*
@c EN
Provides compatibility layers.
@c JP
互換性のためのレイヤを提供。
@c COMMON

@item dbi.*, dbd.*
@c EN
Database independent interface layer and drivers.
@c JP
データベース独立インタフェース層とドライバー。
@c COMMON

@item dbm.*
@c EN
DBM interface
@c JP
DBMインタフェース
@c COMMON

@item gauche.*
@c EN
Stuffs more or less considered as Gauche core features.
@c JP
Gauche本体の一部として考えられている機能。
@c COMMON

@item gl.*
@c EN
OpenGL binding and related libraries (external package).
@c JP
OpenGLバインディングと関連するライブラリ (外部パッケージ)。
@c COMMON

@item gtk.*
@c EN
GTk+ binding and related libraries (external package).
@c JP
GTk+バインディングと関連するライブラリ (外部パッケージ)。
@c COMMON

@item file.*
@c EN
Manipulating files and directories.
@c JP
ファイルとディレクトリの操作。
@c COMMON

@item lang.*
@c EN
Language-related libraries, artificial and/or natural (planned).
@c JP
言語に関するライブラリ(人工的なものも自然言語関連も)。(予定)
@c COMMON

@item math.*
@c EN
Mathematics.
@c JP
数学。
@c COMMON

@item compat.*
@c EN
Compatibility libraries
@c JP
他の実装とのコンパチビリティに関するライブラリ。 (予定)
@c COMMON

@item rfc.*
@c EN
Implementations of net protocols defined in RFC's.
@c JP
RFCで定義されているデータフォーマットやネットワークプロトコルの実装。
@c COMMON

@item srfi-*
@c EN
SRFI implementations.
@c JP
SRFIの実装
@c COMMON

@item sxml.*
@c EN
SXML libraries.
@c JP
SXMLライブラリ。
@c COMMON

@item text.*
@c EN
Libraries dealing with text data.
@c JP
テキストデータを扱うライブラリ
@c COMMON

@item util.*
@c EN
Generic implementations of various algorithms.
@c JP
汎用的なアルゴリズムの実装。
@c COMMON

@item www.*
@c EN
Implementations of various protocols and formats mainly used in WWW.
@c JP
WWWで主として使われるプロトコルやデータフォーマットの実装。
@c COMMON
@end table

