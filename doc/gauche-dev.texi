\input texinfo  @c -*-texinfo-*-
@comment %**start of header
@c EN
@setfilename gauche-deve.info
@settitle Gauche Developers' Reference
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche Developers' Reference: (gauche-deve.info).	Internals of Gauche
@end direntry
@c JP
@setfilename gauche-devj.info
@settitle Gauche 開発者リファレンス
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche Developers' Reference (ja): (gauche-devj.info).	Internals of Gauche
@end direntry
@c COMMON
@comment %**end of header

@c $Id: gauche-dev.texi,v 1.12 2006-10-24 01:41:17 shirok Exp $

@iftex
@finalout
@parskip 4pt plus 1pt
@end iftex

@titlepage
@c EN
@title Gauche Developers' Reference
@c JP
@title Gauche 開発者リファレンス
@c COMMON
@subtitle version @VERSION@
@author Shiro Kawai (shiro@@acm.org)

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2005 Shiro Kawai (shiro@@acm.org)

@end titlepage

@node Top, Introduction, (dir), (dir)

@ifnottex
@c EN
This document explains the internal guts of Gauche
for developers who want to extend Gauche functionality in C, 
or to embed Gauche to other applications.
This manual is for version @VERSION@.
@c JP
本書は、Gaucheの機能をCで拡張したり、Gaucheを他のアプリケーションに
埋め込むといったことを行う開発者のために、
Gaucheの内部構造を説明するものです。
Gaucheのバージョン@VERSION@に対応します。
@c COMMON
@end ifnottex

@menu
* Introduction::                
* Getting started::             
* Fundamental concepts::        
* Real-life examples::          
* C API reference::             
* Helper program reference::    
* Indices::                     
@end menu

@c ======================================================================
@node Introduction, Getting started, Top, Top
@chapter Introduction

The core part of the Gauche runtime is written in C and provided
as a library, @file{libgauche}.  This document explains how to
use it from C.  Using C API, you can extend Gauche's
functionality (e.g. providing bindinds to the existing C library),
and also link @file{libgauche} to your application, making
Gauche as an embedded scripting language.

Gauche's C API is designed for efficiency, consistency,
simplicity and safety, roughly in this order of precedence.
That is, simplicity and safety are sometimes compromized
by efficiency.  For example, sometimes you have to choose
from similar APIs to achieve a goal, where each API is designed
to be efficient for a particular case.  The API also assumes
the caller takes care not to break internal structure; there's
no much safety net that protects you from shooting your foot.
(By saying "safety is compromized" I don't mean @file{libgauche}
has security holes; I mean it assumes the programmer knows what
he's doing.)

That said, it won't be too difficult to use Gauche's C API
as far as you know some fundamental design concepts.

We intend this document to serve both a programmer's guide
that explains such design concepts, and a programer's reference
that describes every C API in detail.

The guide part begins with @ref{Getting started}, that shows
how to write a simple Gauche extension in C, as well as
a simple application that embeds Gauche.  It gives an overview
of the whole process.

The following chapter, @ref{Fundamental concepts}, describes
the design behind the API.  We strongly recommend you to 
understand this chapetr before trying to use Gauche C API
seriously.  As we mentioned above, it is very easy to break
something without knowing those concepts.

The guide part concludes with @ref{Real-life examples}, that
explains pitfalls in the practical situations using excerpt
of the actual Gauche extension code.

The reference part consists of two chapters: @ref{C API reference}
lists all the public C API.  @ref{Helper program reference}
explains several programs installed as a part of Gauche Scheme
system to help program development.

@c ======================================================================
@node Getting started, Fundamental concepts, Introduction, Top
@chapter Getting started

This chapter explains the basics of how to use Gauche C API
by several simple examples.

Although each example is too small to be practical value,
we try to present working code for each example, so that you
can actually play with it.  We recommend you to read through
all examples, for we introduce new concepts in each step.

We deal with the advanced topics that arises in the practical
situation in @ref{Real-life examples}.

The prerequisites for building Gauche extension, besides 
the basic compiler chain, are the followings.  We assume
these are installed in your system.  
@itemize @bullet
@item 
Gauche 0.8.8 or later
@item
GNU autoconf 2.54 or later
@end itemize

@menu
* A trivial extension::         
* Simple readline binding::     
@end menu

@node A trivial extension, Simple readline binding, Getting started, Getting started
@section A trivial extension

@menu
* Generating skeletons::        
* Building the trivial module::  
* The templates explained::     
* Introduction of the stub file::  
@end menu

@node Generating skeletons, Building the trivial module, A trivial extension, A trivial extension
@subsection Generating skeletons

Let's create a Gauche extension that does nothing.

Gauche can generate a skeleton of the extension code
by @code{gauche-package generate} command.  You give the
package name to the command-line argument (here we pick @code{trivial}).

@example
% @b{ls trivial}
ls: trivial: No such file or directory
% @b{gauche-package generate trivial}
% @b{ls trivial}
DIST	     configure.ac  trivial.c  trivial.scm
Makefile.in  test.scm	   trivial.h  triviallib.stub
@end example

The @code{gauche-package} command creates a directory @file{trivial},
and populates it with template files.  The role of each file is shown
below.

@table @emph
@item Glue code (@file{trivial.c} and @file{trivial.h})
If what you want to do is just to write C functions and make it
available from Scheme, the function definitions and declarations
would go to these files.

Even if what you want to do is just to write bindings to
an existing library, it is typical that you need small amount
of auxiliary management code, such as initializing the library
and allocating/freeing library-side data structures. 

@item Stub file (@file{trivial.stub})
This file is the bridge between C world and Scheme world.
You have to list C functions you want to make it visible from
Scheme world.  Because of its nature, this file looks like 
a mixture of Scheme code and C code fragments.

When the package is compiled, Gauche's helper scripts generates
a C file from a stub file, and compiles it with other glue code
to generate a dynamically loadable object code, called DLL
(dynamically loadable library) or SO (shared object), depending
on the platform.

@item Module file (@file{trivail.scm})
This file typically defines Gauche modules and set exported
symbols, and dynamically loads the compiled object code.
You may put auxiliary Scheme code in it.

@item Files to build the package (@file{configure.ac}, @file{Makefile.in}, @file{DIST})
Gauche relies on GNU @code{autoconf} and @code{make} to build
the package, that is, the package user can use the simple
@code{./configure}, @code{make} and @code{make install} sequence
to build and install the package.  

@file{DIST} is a small shell script that automates creating
a distribution tarball.

@item Unit test (@file{test.scm})
It is strongly encouraged to include unit test in your package,
and this file contains the skeleton of it.  The package user
can run the test by @code{make check}.
@end table

@node Building the trivial module, The templates explained, Generating skeletons, A trivial extension
@subsection Building, testing and installing the trivial module

These auto-generated files are already buildable.  
First, you need to run @file{autoconf} to generate a @file{configure}
script.

@example
% @b{cd trivial}
% @b{autoconf}
% @b{ls}
DIST	     autom4te.cache  configure.ac  trivial.c  trivial.scm
Makefile.in  configure	     test.scm	   trivial.h  triviallib.stub
@end example

The directory @file{autom4te.cache} is a temporary structure used
by autoconf.  You can safely remove it if it bothers you.

Once @file{configure} script is generated, you can run it to
generate @file{Makefile}, then run @code{make}.

@example
% @b{./configure}
checking for gosh... /usr/bin/gosh
checking for gauche-config... /usr/bin/gauche-config
checking for gauche-package... /usr/bin/gauche-package
checking for gauche-install... /usr/bin/gauche-install
checking for gauche-cesconv... /usr/bin/gauche-cesconv
configure: creating trivial.gpd
configure: creating ./config.status
config.status: creating Makefile
% @b{make}
/usr/bin/gauche-package compile --verbose trivial trivial.c triviallib.stub
@i{(... message truncated ...)}
% @b{ls}
DIST		config.log     trivial.c    trivial.so	    triviallib.o
Makefile	config.status  trivial.gpd  trivial_head.c  triviallib.stub
Makefile.in	configure      trivial.h    trivial_head.o
VERSION		configure.ac   trivial.o    trivial_tail.c
autom4te.cache	test.scm       trivial.scm  trivial_tail.o
@end example

The build process creates @file{trivial.so}, the dynamically loadable
object file (the actual suffix may differ on some OSes).

Now it's ready to load the extension into Gauche.  The skeleton code
defines a Scheme function @code{test-trivial}, which just returns
a string.   Run the Gauche interpreter, load the @code{trivial} module,
and call @code{test-trivial} function.  Note that you need to give
@code{-I.} option to @code{gosh}, so that Gauche can find the @file{trivial}
module files.

@example
% @b{gosh -I.}
gosh> @b{(use trivial)}
#<undef>
gosh> @b{(test-trivial)}
"trivial is working"
gosh>
@end example

You may have noticed a file @file{trivial.gpd}.  The unfamiliar
suffix @code{gpd} stands for ``Gauche package description''.
It is created by @file{configure}, and records the name and version
of the package, and the configure options.  It is installed as a part
of the package and will be used by @code{gauche-package} script
(e.g. @code{gauche-package list} lists the installed packages).

You can also run a unit test by @code{make check}.

@example
% make check
/usr/bin/gosh -I. test.scm > test.log
Testing trivial ...                                              passed.
@end example

For now, it just checks if the compiled extention can be loaded,
and the integrity of the module.  As you add APIs in the extension,
you're expected to add tests as well.

Finally, you can install the extension by @code{make install}.

@example
% make install
/usr/bin/gauche-install -m 444 -T /usr/lib/gauche/site/include 
/usr/bin/gauche-install -m 444 -T /usr/share/gauche/site/lib trivial.scm 
/usr/bin/gauche-install -m 555 -T /usr/lib/gauche/site/0.8.8/i686-pc-linux-gnu trivial.so
/usr/bin/gauche-install -m 444 -T /usr/share/gauche/site/lib/.packages trivial.gpd
@end example

By default, the files are installed in the site-specific area
reserved within the intalled Gauche.
If you want to change the install location, you can do the
same as typical autoconfiscated softwares; e.g. giving
@code{--prefix} option to the @code{configure} script,
or 






@node The templates explained, Introduction of the stub file, Building the trivial module, A trivial extension
@subsection The templates explained





@node Introduction of the stub file,  , The templates explained, A trivial extension
@subsection Introduction of the stub file



@node Simple readline binding,  , A trivial extension, Getting started
@section Simple readline binding









@c ======================================================================
@node Fundamental concepts, Real-life examples, Getting started, Top
@chapter Fundamental concepts

@menu
* Naming convention::           
* Scheme types and C types::    
* Memories::                    
* The VM::                      
* CPS API::                     
@end menu

@node Naming convention, Scheme types and C types, Fundamental concepts, Fundamental concepts
@section Naming convention

@node Scheme types and C types, Memories, Naming convention, Fundamental concepts
@section Scheme types and C types

@node Memories, The VM, Scheme types and C types, Fundamental concepts
@section Memories

@node The VM, CPS API, Memories, Fundamental concepts
@section The VM

@node CPS API,  , The VM, Fundamental concepts
@section CPS API


@c ======================================================================
@node Real-life examples, C API reference, Fundamental concepts, Top
@chapter Real-life examples


@c ======================================================================
@node C API reference, Helper program reference, Real-life examples, Top
@chapter C API reference

@menu
* Representation of Scheme objects::  
* Equivalence::                 
* Numbers::                     
* Booleans::                    
* Pairs and Lists::             
* Symbols::                     
* Keywords::                    
* Characters::                  
* Character sets::              
* Strings::                     
* Regular expressions::         
* Vectors::                     
* Hashtables::                  
* Weak pointers::               
* Exceptions::                  
* Calling back to Scheme::      
* Input and output::            
* Loading programs::            
* System interface::            
@end menu

@node Representation of Scheme objects, Equivalence, C API reference, C API reference
@section Representation of Scheme objects

Scheme objects are uniformly treated as of type @code{ScmObj},
which may be either a tagged pointer to a heap allocated object
or a tagged immediate value.

Querying the type of a Scheme object and accessing its fields
should be done via provided macros or APIs.  The user code must
treat @code{ScmObj} as an opaque word.





@node Equivalence, Numbers, Representation of Scheme objects, C API reference
@section Equivalence


@node Numbers, Booleans, Equivalence, C API reference
@section Numbers

@menu
* Scheme number objects::       
* Number predicates::           
* Converting C and Scheme numbers::  
* Generic arithmetics::         
* Subtype-specific number operations::  
* Reading and writing numbers::  
@end menu

@node Scheme number objects, Number predicates, Numbers, Numbers
@subsection Scheme number objects

@subsubheading C representation of numbers

Gauche uses several different structures to represent Scheme 
numbers.  Because of this polymorphic nature, the Scheme numbers
are almost always passed as @code{ScmObj}, except special occasions.
In Scheme level you usually don't need to think much
about different types of numbers, for Gauche automatically
converts them as needed.   There are C routines that accept
generic Scheme numbers like Scheme, but time to time 
you need to check the actual type of the number and cast it
from @code{ScmObj} to the actual structure.

Currently Gauche has the following C-level representations.
Note that this list may be extended in future (a rational number
is likely to be added).

@table @emph
@item Fixnum
For small Scheme exact integers (30 or 62 bit signed integer
in 32 or 64 bit
architectures, respectively), we encode its immediate value into
a machine word. 
@item Bignum
If a Scheme exact integer doesn't fit in fixnum, it is represented
as a bignum, by a @code{ScmBignum} structure.
@item Ratnum
A Scheme exact non-integral number is represented as a ratnum,
by a @code{ScmRatnum} structure.
@item Flonum
Scheme real numbers are represented as flonum, by @code{ScmFlonum}
structure.
@item Compnum
Scheme complex numbers are represented as compnum, by
a @code{ScmCompnum} structure.
@end table

It is important not to confuse these @emph{representations} and
Scheme numeric hierarchy: A Scheme real number can be represented
in either flonum, ratnum, bignum or fixnum, for example.
For each possible Scheme numeric type and exactness, the possible
C representation is shown in the table below:

@example
        |        exact         |    inexact    |
--------+----------------------+---------------+
integer |fixnum, bignum        |flonum         |
        |                      |               |
rational|fixnum, bignum, ratnum|flonum         |
        |                      |               |
real    |fixnum, bignum, ratnum|flonum         |
        |                      |               |
complex |fixnum, bignum, ratnum|flonum, compnum|
________|______________________|_______________|
@end example

(Note: Exact real and exact complex are supported in a sense
that exact rational number is always a real and complex number
as well.)

@subsubheading Normalized form

One Scheme number may be represented by more than
one C types; for example, an exact integer can also
be represented in ratnum with its denominator as 1.

To make things simple and clean, there's one important
rule C-routine writers should know:
If your routine returns a Scheme number, it must be in
a @emph{normalized} form, i.e.:

@itemize @bullet
@item
If the number is an exact integer, it should be either
fixnum or bignum; if the value fits in fixnum, it should be
fixnum.
@item
Denominator of ratnum is always greater than 1.  That is,
the sign of ratnum is the sign of its numerator.
@item
If the imaginary part of the number is 0.0, it must be
in flonum, rather than compnum.
@end itemize

(Note: here we use the term @emph{normalized} and @emph{denormalized}
in the sense that Scheme numbers should be represented in a simplest
possible C structure.  It is unrelated to the term in
IEEE floating point number.)

Most C APIs expect normalized numbers, and return normalized one.
As far as you're using those APIs, you don't need to care about
normalization, or even how the number is represented in Scheme.

If you ever need to peek into the representation, or deal with
denormalized numbers, see @ref{Subtype-specific number operations}.
Carrying around a denormalized Scheme number should be limited
for intermediate results, and only when you find the overhead of
conversion is a problem.  Generally such overhead is negligible
compared to other overheads.  If you use denormalized numbers,
make sure normalize them before passing it back to the rest
of the world, or bad things will happen.

@subsubheading Conversions and clamping

Converting a Scheme number to a C number is a 
tricky business.  It's always possible that the Scheme number
you got may not fit into the desired C variable.  There are several
options you can choose.

@itemize @bullet
@item
Error: Throws an error.
@item
Clamp: If the Scheme value falls out of the supported range
of C variable, use the closest representable value.
@item 
Convert only when possible.  If conversion is not possible, use
the Scheme value as-is.  It is useful to provide a shortcut path
to improve performance.
@end itemize

Some C APIs take @var{clamp} argument to specify the behavior.  The value
can be one of the following enums.

@deftp {Enum} ScmClampMode
@table @code
@item SCM_CLAMP_ERROR
An error is thrown if the given Scheme number doesn't fit
to the resulting C number.
@item SCM_CLAMP_HI
If the given Scheme number is too large to fit in the
resulting C number, the largest possible C number in the
result type is returned instead.  If the given Scheme number
is too small, an error is signalled.
@item SCM_CLAMP_LO
If the given Scheme number is too small to fit in the
resulting C number, the smallest possible C number in the
result type is returned instead.  If the given Scheme number
is too large, an error is signalled.
@item SCM_CLAMP_BOTH
Clamp both sides; with this argument, the API won't throw
an out-of-range error.
@item SCM_CLAMP_NONE
If the given Scheme number is out of the range, no conversion
is performed (an extra output argument tells you whether
it has happened or not).
@end table
@end deftp

See @var{Scm_GetIntegerClamp} below for a concrete example.

@node Number predicates, Converting C and Scheme numbers, Scheme number objects, Numbers
@subsection Number predicates

@deftypefn {Macro} int SCM_INTEGERP (ScmObj @var{obj})
Returns @code{TRUE} if @var{obj} is a Scheme exact integer; that is,
@var{obj} is either a fixnum or a bignum.
(The name is somewhat misleading; to check whether @var{obj} is
an integer, regardless of exact or inexact, use @code{Scm_IntegerP} below).
@end deftypefn

@deftypefn {Macro} int SCM_RATIONALP (ScmObj @var{obj})
Returns @code{TRUE} iff @var{obj} is a Scheme exact rational number; that is,
@var{obj} is either one of fixnum, bignum or ratnum.
@end deftypefn

@deftypefn {Macro} int SCM_REALP (ScmObj @var{obj})
Returns @code{TRUE} iff @var{obj} is a Scheme real number; that is,
@var{obj} is either one of fixnum, bignum, ratnum or flonum.
@end deftypefn

@deftypefn {Macro} int SCM_NUMBERP (ScmObj @var{obj})
Returns @code{TRUE} iff @var{obj} is a Scheme number,
that is, either a fixnum, bignum, ratnum, flonum, or compnum.
@end deftypefn

@deftypefun int Scm_IntegerP (ScmObj @var{num})
Returns @var{TRUE} iff @var{num} is (exact or inexact) integer.

Note: If @var{num} is a flonum with exponent larger than certain value,
@code{Scm_IntegerP} always returns @code{TRUE}, because of its limited
precision of mantissa.
@end deftypefun

@deftypefun int Scm_OddP (ScmObj @var{num})
Returns @code{TRUE} iff a Scheme (exact or inexact) integer is
an odd number.  This throws an error if @var{num} is not an integer.
@end deftypefun

@node Converting C and Scheme numbers, Generic arithmetics, Number predicates, Numbers
@subsection Converting C and Scheme numbers

@subsubheading Integers

@deftypefun ScmObj Scm_MakeInteger (long @var{i})
@deftypefunx ScmObj Scm_MakeIntegerU (u_long @var{i})
Convert C @code{long} and @code{unsigned long} to a Scheme integer.
Always returns a normalized number.
@end deftypefun

@deftypefun long Scm_GetInteger (ScmObj obj)
@deftypefunx u_long Scm_GetIntegerU (ScmObj obj)
Convert a Scheme number to C @code{long} and @code{unsigned long},
respectively.  If @var{obj} is a flonum, it is rounded
to the nearest integer.  If @var{obj} is too small or too large to
fit in the C integer, it is clamped to the smallest or largest
integer representable in the result type; i.e. @code{LONG_MIN} and
@code{LONG_MAX} in @code{Scm_GetInteger}, and 
@code{0} and @code{ULONG_MAX} in @code{Scm_GetIntegerU}.

If @var{obj} is not a Scheme real number, an error is signalled.

These routines are actually the case that you specify @code{SCM_CLAMP_BOTH}
in the following routines.
@end deftypefun

@deftypefun long Scm_GetIntegerClamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
@deftypefunx u_long Scm_GetIntegerUClamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
More precise conversion routines, where you can specify the behavior
when the input value isn't in the valid range.

The @var{clamp} argument can be one of the @code{ScmClampMode} constants.
If @var{clamp} is @code{SCM_CLAMP_NONE} and @var{oor} is not @code{NULL},
the pointed location is set to @code{FALSE} if the input argument is within
the valid range, and @code{TRUE} otherwise; for the latter case, 0 is
returned as the result.
@end deftypefun

@subsubheading 32bit and 64bit integers

Sometimes you need to be aware of the width of integers
(for example, when you're working on uniform integer vectors).
Sometimes you even need to deal with 64-bit integers explicitly.

Since the widths of @code{int} and @code{long} are platform-dependent,
and support of 64bit integers varies among platforms,
Gauche provides an abstraction layer to them.

@deftp {Type} ScmInt32
@deftpx {Type} ScmUInt32
@deftpx {Type} ScmInt64
@deftpx {Type} ScmUInt64
These are typedef-ed to the platform-specific 32bit signed integer,
32bit unsigned integer, 64bit signed integer and 64bit unsigned 
integer, respectively.   If the platform doesn't support 64bit
integer at all, @code{ScmInt64} and @code{ScmUInt64} are a struct
type consist of two 32bit integers.
@end deftp

@deftypefun ScmInt32 Scm_GetInteger32Clamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
@deftypefunx ScmUInt32 Scm_GetIntegerU32Clamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
@deftypefunx ScmInt64 Scm_GetInteger64Clamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
@deftypefunx ScmUInt64 Scm_GetInteger64UClamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
These work like their generic counterparts, @code{Scm_GetIntegerClamp}
and @code{Scm_GetIntegerUClamp}, except they specifically work on
32-bit and 64-bit integers.
@end deftypefun

@deftypefun ScmObj Scm_MakeInteger64 (ScmInt64 @var{i})
@deftypefunx ScmObj Scm_MakeIntegerU64 (ScmUInt64 @var{i})
Create Scheme integers from 64bit signed and unsigned integers,
respectively.
@end deftypefun

@deftypefun ScmInt64 Scm_GetInteger64 (ScmObj obj)
@deftypefunx ScmUInt64 Scm_GetIntegerU64 (ScmObj obj)
Convenience procedures for @code{Scm_GetInteger64Clamp} and
@code{Scm_GetIntegerU64Clamp}, where the clamp parameter is
fixed to @code{SCM_CLAMP_BOTH}.
@end deftypefun

@subsubheading Real numbers

@deftypefun ScmObj Scm_MakeFlonum (double @var{d})
Returns a flonum from C @code{double} value.
@end deftypefun

@deftypefun ScmObj Scm_MakeFlonumToNumber (double @var{d}, int exactp)
Returns a scheme number corresponds to C @code{double} value @var{d}.
Unlike @code{Scm_MakeFlonum}, this routine returns a Scheme exact
integer if @code{exactp} is not @code{FALSE},
and @var{d} is an integer.
@end deftypefun

@deftypefun double Scm_GetDouble (ScmObj @var{obj})
Returns a C @code{double} value of Scheme real number @var{obj}
(that means @var{obj} can be a Scheme integer as well).
If @var{obj} is not a Scheme real number, 0.0 is returned.
If @var{obj} is a bignum that can't be represented by @code{double},
an infinity (positive or negative, depends on @var{obj}'s sign)
is returned.
@end deftypefun

@subsubheading Complex numbers

@deftypefun ScmObj Scm_MakeComplex (double @var{real}, double @var{imag})
Returns a Scheme number @code{@var{real}+@var{imag}i}.
The return value is normalized, so it may be just a flonum
if @var{imag} is zero.
@end deftypefun

@deftypefun ScmObj Scm_MakeComplexPolar (double @var{mag}, double @var{angle})
Returns a Scheme number @code{@var{real}@@@var{imag}i}.
The return value is normalized, so it may be just a flonum
if the imaginary part of the number is zero.
@end deftypefun

@deftypefun double Scm_RealPart (ScmObj @var{obj})
@deftypefunx double Scm_ImagPart (ScmObj @var{obj})
@deftypefunx double Scm_Magnitude (ScmObj @var{obj})
@deftypefunx double Scm_Angle (ScmObj @var{obj})
Returns real part, imaginary part, magnitude and angle of a Scheme number
@var{obj}, which can be any number.
@end deftypefun

@node Generic arithmetics, Subtype-specific number operations, Converting C and Scheme numbers, Numbers
@subsection Generic arithmetics


@subsubheading Exact integer operations 

The folowing routines operates on Scheme exact integers.  If
the given @code{ScmObj} argument is not a Scheme exact integer,
an error is signalled.   For bitwise routines, an integer is
regarded in 2's complement form in case if it is negative.

@deftypefun ScmObj Scm_LogAnd (ScmObj @var{x}, ScmObj @var{y})
@deftypefunx ScmObj Scm_LogIor (ScmObj @var{x}, ScmObj @var{y})
@deftypefunx ScmObj Scm_LogXor (ScmObj @var{x}, ScmObj @var{y})
@deftypefunx ScmObj Scm_LogNot (ScmObj @var{x})
Bitwise operations.  Arguments must be Scheme exact integers.
Returns a Scheme exact integer, each bit of which is logical
@emph{and}, @emph{inclusive or}, @emph{exclusive or},
and @emph{not} of the corresponding bit(s) of the argument(s).
Correspond to Scheme @code{logand}, @code{logior},
@code{logxor} and @code{lognot}, respectively.
@end deftypefun

@deftypefun ScmObj Scm_Ash (ScmObj @var{x}, int @var{cnt})
Arithmetic left shift of a Scheme exact integer @var{x} by @var{cnt} bits.
If @var{cnt} is negative, it it shifts to right by @var{-cnt} bits.
Corresponds to Scheme @code{ash}.
@end deftypefun

@deftypefun int Scm_LogTest (ScmObj @var{x}, ScmObj @var{y})
Returns @code{FALSE} if bitwise @emph{and} of two Scheme exact
integers @var{x} and @var{y} yields zero, or @var{TRUE} otherwise.
Corresponds to Scheme @code{logtest}.
@end deftypefun

@deftypefun int Scm_LogBit (ScmObj @var{x}, int @var{b})
Returns @code{TRUE} or @code{FALSE} if @var{b}-th bit of
a Scheme exact integer @var{x} is set or not set, respectively.
0-th bit is the least siginificant bit.
Corresponds to Scheme @code{logbit}.
@end deftypefun

@subsubheading General operations

@deftypefun ScmObj Scm_Abs (ScmObj @var{num})
@end deftypefun

@deftypefun int Scm_Sign (ScmObj @var{num})
@end deftypefun

@deftypefun ScmObj Scm_Negate (ScmObj @var{num})
@end deftypefun

@deftypefun ScmObj Scm_Reciprocal (ScmObj @var{num})
@end deftypefun

@deftypefun ScmObj Scm_ExactToInexact (ScmObj @var{num})
@end deftypefun

@deftypefun ScmObj Scm_InexactToExact (ScmObj @var{num})
@end deftypefun

@deftypefun ScmObj Scm_Add (ScmObj @var{arg1}, ScmObj @var{arg2})
@deftypefunx ScmObj Scm_Sub (ScmObj @var{arg1}, ScmObj @var{arg2})
@deftypefunx ScmObj Scm_Mul (ScmObj @var{arg1}, ScmObj @var{arg2})
@deftypefunx ScmObj Scm_Div (ScmObj @var{arg1}, ScmObj @var{arg2})
@end deftypefun

@deftypefun ScmObj Scm_Quotient (ScmObj @var{arg1}, ScmObj @var{arg2}, ScmObj *@var{rem})
Returns @code{(quotient @var{arg1} @var{arg2})}.
If @var{rem} is not NULL, the remainder is stored in @code{*rem}.
@end deftypefun

@deftypefun ScmObj Scm_Modulo (ScmObj @var{arg1}, ScmObj @var{arg2}, int remainderp)
@end deftypefun

@deftypefun ScmObj Scm_Expt (ScmObj @var{x}, ScmObj @var{y})
@end deftypefun

@deftypefun int Scm_NumEq (ScmObj @var{x}, ScmObj @var{y})
Returns @code{TRUE} iff two Scheme numbers are equal
(same as Scheme's @code{=}).
@end deftypefun

@deftypefun int Scm_NumCmp (ScmObj @var{x}, ScmObj @var{y})
Returns @code{-1}, @code{0}, or @code{1}, where @code{x < y}, @code{x = y}
or @code{x > y}, respectively.  Arguments must be Scheme real numbers.
@end deftypefun

@deftypefun void Scm_MinMax (ScmObj @var{arg0}, ScmObj @var{args}, ScmObj *@var{min}, ScmObj *@var{max})
@end deftypefun

@deftp {Enum} ScmRoundMode
@example
enum ScmRoundMode @{
    SCM_ROUND_FLOOR,
    SCM_ROUND_CEIL,
    SCM_ROUND_TRUNC,
    SCM_ROUND_ROUND
@};
@end example
@end deftp

@deftypefun ScmObj Scm_Round (ScmObj @var{num}, int @var{mode})
@end deftypefun



@node Subtype-specific number operations, Reading and writing numbers, Generic arithmetics, Numbers
@subsection Subtype-specific number operations

@menu
* Fixnum operations::           
* Bignum operations::           
* Flonum operations::           
* Compnum operations::          
@end menu

@node Fixnum operations, Bignum operations, Subtype-specific number operations, Subtype-specific number operations
@subsubsection Fixnum operations

The following macros treat fixnums specifically.
In most cases you should use generic versions above, so that
you don't need to care about difference between fixnums and bignums,
and normalization.  However, if you know your Scheme number is
mostly small and you need speed, these macros will be handy.

@deftypefn {Macro} int SCM_INTP (ScmObj @var{obj})
Returns @code{TRUE} iff @var{obj} is a fixnum.
@end deftypefn

@deftypevr {Macro} int SCM_SMALL_INT_SIZE
Number of bits (excluding sign bit) of an integer representable
in fixnum.  Currently it is 29 and 61 for 32 and 64-bit architectures,
respectively.
@end deftypevr

@deftypevr {Macro} long SCM_SMALL_INT_MAX
@deftypevrx {Macro} long SCM_SMALL_INT_MIN
Maximum and minimum integer values representable in fixnum.
@end deftypevr

@deftypefn {Macro} int SCM_SMALL_INT_FITS (long @var{k})
Returns @code{TRUE} iff @var{k} fits in fixnum.
@end deftypefn

@deftypefn {Macro} int SCM_INT_VALUE (ScmObj @var{fixnum})
Extracts (unboxes) an integer value from @var{fixnum}.  You have to check
whether @var{fixnum} is a fixnum or not before applying this.
@end deftypefn

@deftypefn {Macro} ScmObj SCM_MAKE_INT (int @var{i})
Boxes an integer value @var{i} to a fixnum.  You have to make
sure @var{i} is in the range representable by fixnum.
@end deftypefn

@deftypefn {Macro} int SCM_UINTP (ScmObj @var{obj})
A convenience macro to check if @var{obj} is a fixnum 
@emph{and} non-negative.
@end deftypefn

@node Bignum operations, Flonum operations, Fixnum operations, Subtype-specific number operations
@subsubsection Bignum operations

Again, it should generally be avoided to use bignums explicitly;
generic integer routines should take care of most cases.

A bignum keeps the absolute value in array of @code{u_long}s,
least significant word first.
The sign is kept separately.  It also keeps the number of
words used.

There's one more constraint about normalization.  Normalized
bignum uses only as many words as necessary to represent the
given number.  That is, the most significant word should never
be zero for normalized bignums.   You may see denormalized
bignums only in limited occasions, such as the intermediate
results.  Denormalized bignums should never be leaked out
to other APIs or to the Scheme world.

@deftypefn {Macro} int SCM_BIGNUMP (ScmObj @var{obj})
Returns @code{TRUE} iff @var{obj} is a bignum.
@end deftypefn

@deftypefn {Macro} ScmBignum* SCM_BIGNUM (ScmObj @var{bignum})
Cast @var{bignum} to @code{ScmBignum*}.
@end deftypefn

@deftypefn {Macro} int SCM_BIGNUM_SIZE (ScmObj @var{bignum})
Returns the number of words used in the bignum.
@end deftypefn

@deftypefn {Macro} int SCM_BIGNUM_SIGN (ScmObj @var{bignum})
Returns the sign (-1 or 1) of the bignum.  If @var{bignum}
is denormalized and contains zero, this macro returns 0.
@end deftypefn

The following APIs are for internal use, and only available
when you include @file{gauche/bignum.h}.  You should need
these only if you're implementing some basic bignum arithmetics.

@deftypefun ScmObj Scm_MakeBignumFromSI (long @var{val})
@deftypefunx ScmObj Scm_MakeBignumFromUI (u_long @var{val})
Converts C @code{long} or @code{u_long} value to a bignum.
The result is always a bignum, even when @var{val} can fit
in fixnum (i.e. the result can be denormalized).
@end deftypefun

@deftypefun ScmObj Scm_MakeBignumFromUIArray (int @var{sign}, u_long *@var{values}, int @var{size})
Creates a (possibly denormalized) bignum from the given @code{u_long}
array of length @var{size}.  @var{Size} must be greater than 0.
The first word @var{Values} is for the least significant word.

If @var{sign} is not zero, its sign determines the sign of the bignum,
and @code{values} are taken as absolute values.  If @var{sign} is zero,
this routine assumes @code{values} contains 2's complement form of
the integer.
@end deftypefun

@deftypefun ScmObj Scm_MakeBignumFromDouble (double @var{val})
Returns a (possible denormalizeD) bignum that represents
the integral part of @var{val}.
@end deftypefun

@deftypefun ScmBignum *Scm_MakeBignumWithSize (int @var{size}, u_long @var{init})
@end deftypefun

@deftypefun ScmObj Scm_BignumCopy (ScmBignum *@var{bignum})
Copy the given @var{bignum}.  The return value can be
denormalized if @var{bignum} is denormalized.
@end deftypefun

@deftypefun ScmObj Scm_NormalizeBignum (ScmBignum *@var{bignum})
Returns a normalized Scheme integer from the given bignum.
That is, the returned value can be fixnum if @var{bignum}
is small enough.  This also adjust the size of bignum if
it contains leading zero words.

The routine that returns the number to the outside world should
always use this routine to ensure a denormalized bignum would
never be leaked out.
@end deftypefun

@deftypefun long Scm_BignumToSI (ScmBignum *@var{bignum}, ScmClampMode @var{clamp}, int *@var{oor})
@deftypefunx u_long Scm_BignumToUI (ScmBignum *@var{bignum}, ScmClampMode @var{clamp}, int *@var{oor})
Converts a bignum to C @code{long} and @code{u_long}, respectively.
The behavior when @var{bignum}
is out of range is determined by @var{clamp} argument.
The @code{bignum} argument must be a normalized bignum.
@end deftypefun

@deftypefun ScmInt64 Scm_BignumToSI64 (ScmBignum *@var{bignum}, ScmClampMode @var{clamp}, int *@var{oor})
@deftypefunx ScmUInt64 Scm_BignumToUI64 (ScmBignum *@var{bignum}, ScmClampMode @var{clamp}, int *@var{oor})
64-bit integer version of @code{Scm_BignumToSI} and 
@code{Scm_BignumToUI}.
The @code{bignum} argument must be a normalized bignum.
@end deftypefun

@deftypefun double Scm_BignumToDouble (ScmBignum *@var{bignum})
Converts a bignum to C @code{double} value.
The @code{bignum} argument must be a normalized bignum.
@end deftypefun

@deftypefun ScmObj Scm_BignumNegate (ScmBignum *@var{bignum})
Returns @code{-@var{bignum}}.  The argument may be denormalized.
The returned value is a normalized Scheme integer.
@end deftypefun

@deftypefun int Scm_BignumCmp (ScmBignum *@var{bx}, ScmBignum *@var{by})
Compares two normalized bignums.  Returns -1 if @code{@var{bx} < @var{by}},
0 if @code{@var{bx} = @var{by}}, and 1 if @code{@var{bx} > @var{by}}.
@end deftypefun

@deftypefun int Scm_BignumAbsCmp (ScmBignum *@var{bx}, ScmBignum *@var{by})
Compares absolute values of two normalized bignums.
Returns -1 if @code{abs(@var{bx}) < abs(@var{by})},
0 if @code{abs(@var{bx}) = abs(@var{by})},
and 1 if @code{abs(@var{bx}) > abs(@var{by})}.
@end deftypefun

@deftypefun ScmObj Scm_BignumAdd (ScmBignum *@var{bx}, ScmBignum *@var{by})
@deftypefunx ScmObj Scm_BignumSub (ScmBignum *@var{bx}, ScmBignum *@var{by})
@deftypefunx ScmObj Scm_BignumMul (ScmBignum *@var{bx}, ScmBignum *@var{by})
Returns
@code{(+ @var{bx} @var{by})},
@code{(- @var{bx} @var{by})},
and @code{(* @var{bx} @var{by})}, respectively.
Both argument should be normalized.
The return value is a normalized Scheme integer.
@end deftypefun

@deftypefun ScmObj Scm_BignumAddSI (ScmBignum *@var{bx}, long @var{y})
@deftypefunx ScmObj Scm_BignumSubSI (ScmBignum *@var{bx}, long @var{y})
@deftypefunx ScmObj Scm_BignumMulSI (ScmBignum *@var{bx}, long @var{y})
Returns
@code{(+ @var{bx} @var{y})},
@code{(- @var{bx} @var{y})},
and @code{(* @var{bx} @var{y})}, respectively.
@var{Bx} should be normalized.
The return value is a normalized Scheme integer.
@end deftypefun

@deftypefun ScmObj Scm_BignumDivRem (ScmBignum *@var{dividend}, ScmBignum *@var{divisor})
Returns a cons of quotient and remainder of two bignums.
Both bignums should be normalized.  Returns normalized numbers.
@end deftypefun

@deftypefun ScmObj Scm_BignumDivSI (ScmBignum *@var{dividend}, long @var{divisor}, long *@var{remainder})
Returns a quotient of @var{dividend} divided by @var{divisor}.
The remainder is stored in *@var{remainder}.
@var{Dividend} should be normalized.  Returns normalized number.
@end deftypefun

@node Flonum operations, Compnum operations, Bignum operations, Subtype-specific number operations
@subsubsection Flonum operations

@deftypefn {Macro} int SCM_FLONUMP (ScmObj @var{obj})
Returns @code{TRUE} iff @var{obj} is a flonum.

Note: in most cases, you may want to use @code{SCM_REALP} instead
of this; @code{Scm_GetDouble} can treat integers transparently.
@end deftypefn

@deftypefun ScmObj Scm_DecodeFlonum (double @var{d}, int *@var{pexp}, int *@var{psign})
Decompose C double value @var{d} into its mantissa, exponent and sign values.

The mantissa is returned as a Scheme integer (since it is 53bits in IEEE
double-precision floating format, we cannot return it as C integer
portably).  Values of exponent and sign (-1 or 1) are stored in
@code{*pexp} and @code{psign}.

Two special cases: If @var{d} is infinity, @code{SCM_TRUE} is returned,
and @code{*psign} contains its sign (-1 or 1).  If @var{d} is @code{NaN},
@code{SCM_FALSE} is returned.
@end deftypefun


@node Compnum operations,  , Flonum operations, Subtype-specific number operations
@subsubsection Compnum operations

@deftypefn {Macro} int SCM_COMPLEXP (ScmObj @var{obj})
Returns @code{TRUE} iff @var{obj} is a compnum.
@end deftypefn

@deftypefn {Macro} double SCM_COMPLEX_REAL (ScmObj @var{compnum})
@deftypefnx {Macro} double SCM_COMPLEX_IMAG (ScmObj @var{compnum})
Access to real and imaginary part of the complex number
@var{compnum}, which must be a compnum.
@end deftypefn

@deftypefun ScmObj Scm_MakeCompnum (double @var{real}, double @var{imag})
Returns a (possibly denormalized) compnum, whose real part is
@var{real} and imaginary part is @var{imag}.
@end deftypefun



@node Reading and writing numbers,  , Subtype-specific number operations, Numbers
@subsection Reading and writing numbers







@node Booleans, Pairs and Lists, Numbers, C API reference
@section Booleans

@node Pairs and Lists, Symbols, Booleans, C API reference
@section Pairs and Lists

@node Symbols, Keywords, Pairs and Lists, C API reference
@section Symbols

@node Keywords, Characters, Symbols, C API reference
@section Keywords


@node Characters, Character sets, Keywords, C API reference
@section Characters

@node Character sets, Strings, Characters, C API reference
@section Character sets

@node Strings, Regular expressions, Character sets, C API reference
@section Strings

@node Regular expressions, Vectors, Strings, C API reference
@section Regular expressions

@node Vectors, Hashtables, Regular expressions, C API reference
@section Vectors

@node Hashtables, Weak pointers, Vectors, C API reference
@section Hashtables

@node Weak pointers, Exceptions, Hashtables, C API reference
@section Weak pointers

@node Exceptions, Calling back to Scheme, Weak pointers, C API reference
@section Exceptions

@node Calling back to Scheme, Input and output, Exceptions, C API reference
@section Calling back to Scheme

@node Input and output, Loading programs, Calling back to Scheme, C API reference
@section Input and output

@menu
* Built-in ports::              
* Custom ports::                
* Input::                       
* Output::                      
@end menu

@node Built-in ports, Custom ports, Input and output, Input and output
@subsection Built-in ports

@subsubheading Opening and closing ports

@deftypefun ScmObj Scm_OpenFilePort (const char *path, int flags, int buffering, int perm)
Open a file named by @var{path}, and returns a newly created Scheme port
associated with the file.   The @code{name} slot of the created port
is set as @var{path}.

The @var{flags} and @var{perm} arguments are passed to @code{open(2)} 
as the second and third argument, respectively.  The @var{buffering}
argument may be either one of @code{SCM_PORT_BUFFER_FULL},
@code{SCM_PORT_BUFFER_LINE} or @code{SCM_PORT_BUFFER_NONE},
specifying the buffering mode.

If a file couldn't be opened, @code{SCM_FALSE} is returned.  The
reason can be obtained from @code{errno}.
@end deftypefun

@deftypefun ScmObj Scm_MakePortWithFd (ScmObj name, int direction, int fd, int bufmode, int ownerp)
Creates a Scheme port that read from or write to the specified file
descriptor @var{fd}.  The @var{name} argument is used for the
port's @var{name} slot.  You need to specify either
@code{SCM_PORT_INPUT} or @code{SCM_PORT_OUTPUT} as the direction.
The @var{buffering}
argument may be either one of @code{SCM_PORT_BUFFER_FULL},
@code{SCM_PORT_BUFFER_LINE} or @code{SCM_PORT_BUFFER_NONE},
specifying the buffering mode.

If @var{ownerp} is @code{TRUE}, the created Scheme port becomes the owner
of the file descriptor; that is, when the Scheme port is closed,
it closes the file descriptor, too.  
@end deftypefun

@deftypefun ScmObj Scm_MakeInputStringPort (ScmString *@var{str}, int @var{privatep})
Returns a Scheme string port that reads from the given Scheme string.
Corresponds to Scheme's @code{open-input-string}.

If @var{privatep} is @code{TRUE}, the port is pre-locked by the
current thread; i.e. no other threads can access this port, and
the current thread avoids locking overhead.  
@end deftypefun

@deftypefun ScmObj Scm_MakeOutputStringPort (int @var{privatep})
Returns a Scheme output string port that collects the stuff written to it.
You can retrieve the result string by @code{Scm_GetOutputString()} below.
Corresponds to Scheme's @code{open-output-string}.

The @var{privatep} flag is the same as @code{Scm_MakeInputStringPort}.
@end deftypefun

@deftypefun ScmObj Scm_GetRemainingInputString (ScmPort *@var{port})
@var{port} must be an input string port created by 
@code{Scm_MakeInputStringPort}.
Returns a newly-created Scheme string which contains the stuff
in the original string which hasn't been read.
@end deftypefun

@deftypefun ScmObj Scm_GetOutputstring (ScmPort *@var{port})
Returns a newly-created Scheme string from the output string port @var{port},
created by @code{Scm_MakeOutputStringPort}.
@end deftypefun



@deftypefun void Scm_ClosePort (ScmPort *@var{port})
Close the port.  If it is already closed, nothing is done.
Closing port invokes a cleanup handler associated to the port.
For example, buffered output port may flush its buffer in the
handler.  The cleanup handler may run a Scheme code, if the port
is a procedural port.  An error caused in a cleanup handler will
raises Scheme exception (i.e. Scm_ClosePort may not return if an error
is raised); such errors should be handled by Scheme error handling 
framework.
@end deftypefun

@subsubheading General port information

@deftypefun ScmObj Scm_PortName (ScmPort *@var{port})
Returns the value of @code{name} slot of the port.
If the port is a file port, its name contains the original pathname
of the file.  For other ports, the name field contains some
description of ports only useful for debug messages.
@end deftypefun

@deftypefun int Scm_PortLine (ScmPort *@var{port})
Returns the value of @var{line} slot of the port.
Most built-in port types keeps track of the line count,
as far as (1) only character I/O is performed, and
(2) no random-access opertaion is performed, on the port.
If either of such operation is done on the port, the number
returned from this function doesn't have meaning.

Port line count begins with 1.
@end deftypefun

@deftypefun int Scm_PortFileNo (ScmPort *@var{port})
Returns the port's associated file descriptor number, if any.
Returns -1 otherwise.
@end deftypefun

@subsubheading Locking ports

@subsubheading Pre-created ports

@deftypefn {Macro} ScmPort* SCM_CURIN
@deftypefnx {Macro} ScmPort* SCM_CUROUT
@deftypefnx {Macro} ScmPort* SCM_CURERR
These macro returns the current input, output, and error port
of the current VM, respectively.  Corresponds to Scheme's
@code{(current-input-port)}, @code{(current-output-port)},
and @code{(current-error-port)}.
@end deftypefn


@deftypefun ScmObj Scm_Stdin (void)
@deftypefunx ScmObj Scm_Stdout (void)
@deftypefunx ScmObj Scm_Stderr (void)
These functions returns ports associated to file descriptor
0, 1, or 2, respectively.  Generally you should use 
@code{SCM_CURIN} macro etc., described above, since they're
in sync with Scheme-world's current ports.  However, if you
have a reason to access to stdio specifically, you may use
these functions.
@end deftypefun


@node Custom ports, Input, Built-in ports, Input and output
@subsection Custom ports

There are two ways to extend port functionalities and creates
your own port types.  A @emph{fully virtual port} basically has
all basic port I/O operations as virutal functions, so you
can override those functionalities as you like.
A @emph{virtual buffered port}, on the other hand, implements
buffering by itself, and calls back your routines when it needs
more data to read or it needs to flush the buffer.

(See the @code{gauche.vport} entry of the Gauche Users' Reference
for the Scheme counterparts of these custom ports)

@subsubheading Fully virtual ports

@deftypefun ScmObj Scm_MakeVirtualport (ScmClass *@var{klass}, int @var{direction}, const ScmPortVTable *@var{vtable})
Returns a newly created fully virtual port of class @var{klass},
which must be a subclass of @code{SCM_CLASS_PORT}.

You need prepare the structure @var{vtable} to specify the behavior
of the port.   You can leave some of the fields NULL, if the
functionality is not needed in the port's operation.
The content of the @var{vtable} will be copied,
so you don't need to keep it after the call of @code{Scm_MakeVirtualPort}.

@example
typedef struct ScmPortVTableRec @{
    int       (*Getb)(ScmPort *p);
    int       (*Getc)(ScmPort *p);
    int       (*Getz)(char *buf, int buflen, ScmPort *p);
    int       (*Ready)(ScmPort *p, int charp);
    void      (*Putb)(ScmByte b, ScmPort *p);
    void      (*Putc)(ScmChar c, ScmPort *p);
    void      (*Putz)(const char *buf, int size, ScmPort *p);
    void      (*Puts)(ScmString *s, ScmPort *p);
    void      (*Flush)(ScmPort *p);
    void      (*Close)(ScmPort *p);
    off_t     (*Seek)(ScmPort *p, off_t off, int whence);
    void      *data;
@} ScmPortVTable;
@end example

For a character input port, you must provide at least @code{Getc}
procedure.  For a binary input port, you must provide at least
@code{Getb} and @code{Getz} procedures.  For a general input port,
on which binary or character input can be done, you must provide
at least those three procedures.

@code{Getb} should return an 8bit unsigned integer value read from
the port, or @code{EOF} if the port has already reached EOF.
@code{Getc} should return an @code{ScmChar} read from the port,
or @code{SCM_CHAR_INVALID} if the port has already reached EOF.
@code{Getz} should read at most @var{buflen} bytes from the port
and store it in @var{buf}, then returns the number of bytes
actually read.   Returning @code{0} indicates the port has
already reached EOF.

For a character output port you must provide at least @code{Putc}
and @code{Puts} procedures.  For a binary output port you must
provide at least @code{Putb} and @code{Putz} procedures.
For a general output port you must provide at least those four
procedures.   

@code{Putb} and @code{Putc} write a byte or a character
to the port, respectively.  @code{Putz} writes @var{size} bytes
in @var{buf} to the port.  @code{Puts} writes the content of
the given Scheme string to the port.

The @code{Ready} procedure is optional for an input port.
If provided, it is called when @code{char-ready?} or @code{byte-ready?}
Scheme procedure is called on the port (the @var{charp} is @code{TRUE}
for @code{char-ready?}, and @code{FALSE} for @code{byte-ready?}).
It must return @code{TRUE} if a character or a byte is ready to
be read from the port, @code{FALSE} otherwise.
If @code{Ready} procedure is not provided, the port is assumed to
be always ready.

The @code{Close} procedure is optional for a both input and output port.
It is called when the port is closed (either explicitly by
@code{Scm_ClosePort}, or implicitly by the port being garbage-collected).
For output port, @code{Flush} procedure is called just before @code{Close},
so you don't need to care about flushing in this procedure.

The @code{Flush} procedure is optional for an output port.
It is called when an explicit flushing is requested to the port
(such as @code{flush} Scheme procedure), or just before the
@code{Close} procedure when the port is closed.

It is important to note that @code{Close} and @code{Flush} procedures can
be called in finalization stage of the port.  That means (1) you
cannot predict in which thread these procedures are called, and
(2) at the time these procedures are called, the objects visible
from these procedures may already be finalized.  Extra care needs
to be taken to deal with those irregular situations.

The @code{Seek} procedure is called for seek operation (such as
@code{port-seek} Scheme procedure).   If you don't provide
this, the port becomes unseekable.

For all those procedures, error conditions should be reported
by Scheme exception mechanism.  Care should be taken not to leave
the port in inconsistent state in case an exception is thrown.

The @code{data} field may contain opaque data to be used in your
custom port operations.   Once the procedure port is created,
the value of this data pointer can be accessed by the macro
@code{SCM_PORT_VIRTUAL_DATA}.
@end deftypefun

@subsubheading Virtual buffered ports




@node Input, Output, Custom ports, Input and output
@subsection Input


@node Output,  , Input, Input and output
@subsection Output


@node Loading programs, System interface, Input and output, C API reference
@section Loading programs

@deftypefun ScmObj Scm_VMLoadFromPort (ScmPort *@var{port}, ScmObj @var{next_paths}, ScmObj @var{env}, int flags)
This is a CPS API.

The most basic function in the @code{load}-family.  Read an expression
from the given port and evaluates it repeatedly, until it reaches
EOF.  Then the port is closed.   The port is locked by the calling
thread until the operation terminates.

The result of the last evaluation remains on VM.

No matter how the load terminates, either normal or abnormal,
the port is closed, and the current module is restored to the
one when load is called.

@var{Flags} argument is ignored for now, but reserved for future
extension.  @code{SCM_LOAD_QUIET_NOFILE} and
@code{SCM_LOAD_IGNORE_CODING}
won't have any effect for @code{Scm_LoadFromPort}; 
see @code{Scm_Load} below.
@end deftypefun

@deftypefun ScmObj Scm_FindFile (ScmString *@var{filename}, ScmObj *@var{paths}, ScmObj @var{suffixes}, int @var{flags})
Core function to search specified file from the search paths *@var{path}.
Search rules are:

@enumerate
@item 
If given filename begins with @file{/}, @file{./} or @file{../},
the file is searched.
@item
If given filename begins with @file{~}, unix-style username
expansion is done, then the resulting file is searched.
@item
Otherwise, the file is searched for each directory in
*@var{paths}.
@end enumerate

If a file is found, it's pathname is returned.  *@var{Path} is modified
to contain the remains of load paths, which can be used again to
find next matching filename.

If @var{suffixes} is given, filename is assumed not to have suffix,
and suffixes listed in @var{suffixes} are tried one by one.
The elements in @var{suffixes} is directly appended to the @var{filename};
so usually it begins with dot.

The following flag is effective in @var{flags}.  Other flags are ignored.
@table @code
@item SCM_LOAD_QUIET_NOFILE
If this flag is set, @code{Scm_FindFile} returns @code{SCM_FALSE}
when it cannot find the file.  If this flag is not set (default),
@code{Scm_FindFile} raises an error.
@end table
@end deftypefun


@node System interface,  , Loading programs, C API reference
@section System interface

Gauche provides a few wrapper APIs for operating system interface
to allow applications written without concerning 



@c ======================================================================
@node Helper program reference, Indices, C API reference, Top
@chapter Helper program reference

Several executable scripts are installed along Gauche.
They are to help build and installation process.

@menu
* Managing packages::           
* Simplifying build process::   
* Gauche-config - configuration parameters::  
* Gauche-install - alternative install script::  
* Gauche-package - package manager::  
@end menu

@node Managing packages, Simplifying build process, Helper program reference, Helper program reference
@section Managing packages

@deffn {Command} gauche-package @var{operation} [@var{option} @dots{}] [@var{arg} ...]

The @code{gauche-package} command is the front-end of managing
Gauche extension packages.  It can perform the various operations
accoring to @var{operation} argument.

@table @asis
@item Download, compile and install packages
@code{install}, @code{build}, @code{compile}
@item Retrieve info about installed packages
@code{list}, @code{reconfigure}, @code{make-gpd}
@item Help package development
@code{generate}
@item Instruct @code{gauche-package} usage
@code{help}
@end table

Among those operations, usually @code{install}, @code{build}, 
@code{list}, @code{generate} and @code{help} are used directly from
the shell.
Other operations are mainly invoked by @code{make} command.
@end deffn

@menu
* gauche-package operations::   
* Customizing gauche-package ::  
@end menu

@node gauche-package operations, Customizing gauche-package , Managing packages, Managing packages
@subsection gauche-package operations

@deffn {Package Operation} gauche-package install [@var{options}] @var{tarball-path/url}

This opertaion obtains the package source specified by @var{tarball-path/url},
then extracts the source, configures and builds,
runs the tests, and installs the built package.
Most of the time this is the only command required to install a Gauche
extension package.

The argument @var{tarball-path/url} may be a URL (http, https, and ftp
are supported), or a path to the local file of gzip-compressed tarball
of the package source.   If it is a URL, @code{gauche-package} downloads
it first.  By default @code{gauche-package} uses the current working
directory, but you can make it use specific directory by customizing
@file{~/.gauche-package} (@xref{Customizing gauche-package}).

The following options are recognized by this opertaion.

@deffn {Option} -n, --dry-run
Shows shell commands to be executed, without running them.
@end deffn

@deffn {Option} -C, --configure-options=@var{options}
Pass @var{options} to the @code{./configure} script.  Overrides @code{-r}.
The following command configures the package with the option
@code{--prefix=/opt}.
@example
gauche-package install -C='--prefix=/opt' package.tgz
@end example

Those configure options are recorded in the package description
file
@end deffn


@end deffn


@node Customizing gauche-package ,  , gauche-package operations, Managing packages
@subsection Customizing gauche-package



@node Simplifying build process, Gauche-config - configuration parameters, Managing packages, Helper program reference
@section Simplifying build process



@deffn {Command} gauche-cesconv [options] [inputfile]
@end deffn

@node Gauche-config - configuration parameters, Gauche-install - alternative install script, Simplifying build process, Helper program reference
@section @code{gauche-config} - configuration parameters

@node Gauche-install - alternative install script, Gauche-package - package manager, Gauche-config - configuration parameters, Helper program reference
@section @code{gauche-install} - alternative install script




@node Gauche-package - package manager,  , Gauche-install - alternative install script, Helper program reference
@section @code{gauche-package} - package manager




@c ======================================================================
@node Indices,  , Helper program reference, Top
@appendix Indices
@c NODE 索引

@menu
* Function and Macro Index::    
* Type Index::                  
* Variable Index::              
@end menu

@node Function and Macro Index, Type Index, Indices, Indices
@appendixsec Function and Macro Index
@printindex fn


@node Type Index, Variable Index, Function and Macro Index, Indices
@appendixsec Type Index
@printindex tp

@node Variable Index,  , Type Index, Indices
@appendixsec Variable Index
@printindex vr

@contents
@bye

