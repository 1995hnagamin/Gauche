\input texinfo  @c -*-texinfo-*-
@comment %**start of header
@c EN
@setfilename gauche-deve.info
@settitle Gauche Developers' Reference
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche Developers' Reference: (gauche-deve.info).	Internals of Gauche
@end direntry
@c JP
@setfilename gauche-devj.info
@settitle Gauche 開発者リファレンス
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche Developers' Reference (ja): (gauche-devj.info).	Internals of Gauche
@end direntry
@c COMMON
@comment %**end of header

@c $Id: gauche-dev.texi,v 1.7 2006-05-30 00:19:30 shirok Exp $

@iftex
@finalout
@parskip 4pt plus 1pt
@end iftex

@titlepage
@c EN
@title Gauche Developers' Reference
@c JP
@title Gauche 開発者リファレンス
@c COMMON
@subtitle version @VERSION@
@author Shiro Kawai (shiro@@acm.org)

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2005 Shiro Kawai (shiro@@acm.org)

@end titlepage

@node Top, Introduction, (dir), (dir)

@ifnottex
@c EN
This document explains the internal guts of Gauche
for developers who want to extend Gauche functionality in C, 
or to embed Gauche to other applications.
This manual is for version @VERSION@.
@c JP
本書は、Gaucheの機能をCで拡張したり、Gaucheを他のアプリケーションに
埋め込むといったことを行う開発者のために、
Gaucheの内部構造を説明するものです。
Gaucheのバージョン@VERSION@に対応します。
@c COMMON
@end ifnottex

@menu
* Introduction::                
* Getting started::             
* Fundamental concepts::        
* C API reference::             
* Helper program reference::    
* Indices::                     
@end menu

@c ======================================================================
@node Introduction, Getting started, Top, Top
@chapter Introduction

The core part of the Gauche runtime is written in C and provided
as a library, @file{libgauche}.  This document explains how to
use it from C.  Using C API, you can extend Gauche's
functionality (e.g. providing bindinds to the existing C library),
and also link @file{libgauche} to your application, making
Gauche as an embedded scripting language.

Gauche's C API is designed for efficiency, consistency,
simplicity and safety, roughly in this order of precedence.
That is, simplicity and safety are sometimes compromized
by efficiency.  For example, sometimes you have to choose
from similar APIs to achieve a goal, where each API is designed
to be efficient for a particular case.  The API also assumes
the caller takes care not to break internal structure; there's
no much safety net that protects you from shooting your foot.
(By saying "safety is compromized" I don't mean @file{libgauche}
has security holes; I mean it assumes the programmer knows what
he's doing.)

That said, it won't be too difficult to use Gauche's C API
as far as you know some fundamental design concepts.

We intend this document to serve both a programmer's guide
that explains such design concepts, and a programer's reference
that describes every C API in detail.

The guide part begins with @ref{Getting started}, that shows
how to write a simple Gauche extension in C, as well as
a simple application that embeds Gauche.  It gives an overview
of the whole process.

The following chapter, @ref{Fundamental concepts}, describes
the design behind the API.  We strongly recommend you to 
understand this chapetr before trying to use Gauche C API
seriously.  As we mentioned above, it is very easy to break
something without knowing those concepts.

The guide part concludes with @ref{Real-life examples}, that
explains pitfalls in the practical situations using excerpt
of the actual Gauche extension code.

The reference part consists of two chapters: @ref{C API reference}
lists all the public C API.  @ref{Helper program reference}
explains several programs installed as a part of Gauche Scheme
system to help program development.

@c ======================================================================
@node Getting started, Fundamental concepts, Introduction, Top
@chapter Getting started

This chapter explains the basics of how to use Gauche C API
by several simple examples.

Although each example is too small to be practical value,
we try to present working code for each example, so that you
can actually play with it.  We recommend you to read through
all examples, for we introduce new concepts in each step.

We deal with the advanced topics that arises in the practical
situation in @ref{Real-life examples}.

The prerequisites for building Gauche extension, besides 
the basic compiler chain, are the followings.  We assume
these are installed in your system.  
@itemize @bullet
@item 
Gauche 0.8.6 or later
@item
GNU autoconf 2.54 or later
@end itemize

@menu
* A trivial extension::         
* Simple readline binding::     
@end menu

@node A trivial extension, Simple readline binding, Getting started, Getting started
@section A trivial extension

@menu
* Generating skeletons::        
* Building the trivial module::  
* The templates explained::     
* Introduction of the stub file::  
@end menu

@node Generating skeletons, Building the trivial module, A trivial extension, A trivial extension
@subsection Generating skeletons

Let's create a Gauche extension that does nothing.

Gauche can generate a skeleton of the extension code
by @code{gauche-package generate} command.  You give the
package name to the command-line argument (here we pick @code{trivial}).

@example
% @b{ls trivial}
ls: trivial: No such file or directory
% @b{gauche-package generate trivial}
% @b{ls trivial}
DIST	     configure.ac  trivial.c  trivial.scm
Makefile.in  test.scm	   trivial.h  triviallib.stub
@end example

The @code{gauche-package} command creates a directory @file{trivial},
and populates it with template files.  The role of each file is shown
below.

@table @emph
@item Glue code (@file{trivial.c} and @file{trivial.h})
If what you want to do is just to write C functions and make it
available from Scheme, the function definitions and declarations
would go to these files.

Even if what you want to do is just to write bindings to
an existing library, it is typical that you need small amount
of auxiliary management code, such as initializing the library
and allocating/freeing library-side data structures. 

@item Stub file (@file{trivial.stub})
This file is the bridge between C world and Scheme world.
You have to list C functions you want to make it visible from
Scheme world.  Because of its nature, this file looks like 
a mixture of Scheme code and C code fragments.

When the package is compiled, Gauche's helper scripts generates
a C file from a stub file, and compiles it with other glue code
to generate a dynamically loadable object code, called DLL
(dynamically loadable library) or SO (shared object), depending
on the platform.

@item Module file (@file{trivail.scm})
This file typically defines Gauche modules and set exported
symbols, and dynamically loads the compiled object code.
You may put auxiliary Scheme code in it.

@item Files to build the package (@file{configure.ac}, @file{Makefile.in}, @file{DIST})
Gauche relies on GNU @code{autoconf} and @code{make} to build
the package, that is, the package user can use the simple
@code{./configure}, @code{make} and @code{make install} sequence
to build and install the package.  

@file{DIST} is a small shell script that automates creating
a distribution tarball.

@item Unit test (@file{test.scm})
It is strongly encouraged to include unit test in your package,
and this file contains the skeleton of it.  The package user
can run the test by @code{make check}.
@end table

@node Building the trivial module, The templates explained, Generating skeletons, A trivial extension
@subsection Building, testing and installing the trivial module

These auto-generated files are already buildable.  
First, you need to run @file{autoconf} to generate a @file{configure}
script.

@example
% @b{cd trivial}
% @b{autoconf}
% @b{ls}
DIST	     autom4te.cache  configure.ac  trivial.c  trivial.scm
Makefile.in  configure	     test.scm	   trivial.h  triviallib.stub
@end example

The directory @file{autom4te.cache} is a temporary structure used
by autoconf.  You can safely remove it if it bothers you.

Once @file{configure} script is generated, you can run it to
generate @file{Makefile}, then run @code{make}.

@example
% @b{./configure}
checking for gosh... /usr/bin/gosh
checking for gauche-config... /usr/bin/gauche-config
checking for gauche-package... /usr/bin/gauche-package
checking for gauche-install... /usr/bin/gauche-install
checking for gauche-cesconv... /usr/bin/gauche-cesconv
configure: creating trivial.gpd
configure: creating ./config.status
config.status: creating Makefile
% @b{make}
/usr/bin/gauche-package compile --verbose trivial trivial.c triviallib.stub
@i{(... message truncated ...)}
% @b{ls}
DIST		config.log     trivial.c    trivial.so	    triviallib.o
Makefile	config.status  trivial.gpd  trivial_head.c  triviallib.stub
Makefile.in	configure      trivial.h    trivial_head.o
VERSION		configure.ac   trivial.o    trivial_tail.c
autom4te.cache	test.scm       trivial.scm  trivial_tail.o
@end example

The build process creates @file{trivial.so}, the dynamically loadable
object file (the actual suffix may differ on some OSes).

Now it's ready to load the extension into Gauche.  The skeleton code
defines a Scheme function @code{test-trivial}, which just returns
a string.   Run the Gauche interpreter, load the @code{trivial} module,
and call @code{test-trivial} function.  Note that you need to give
@code{-I.} option to @code{gosh}, so that Gauche can find the @file{trivial}
module files.

@example
% @b{gosh -I.}
gosh> @b{(use trivial)}
#<undef>
gosh> @b{(test-trivial)}
"trivial is working"
gosh>
@end example

You may have noticed a file @file{trivial.gpd}.  The unfamiliar
suffix @code{gpd} stands for ``Gauche package description''.
It is created by @file{configure}, and records the name and version
of the package, and the configure options.  It is installed as a part
of the package and will be used by @code{gauche-package} script
(e.g. @code{gauche-package list} lists the installed packages).

You can also run a unit test by @code{make check}.

@example
% make check
/usr/bin/gosh -I. test.scm > test.log
Testing trivial ...                                              passed.
@end example

For now, it just checks if the compiled extention can be loaded,
and the integrity of the module.  As you add APIs in the extension,
you're expected to add tests as well.

Finally, you can install the extension by @code{make install}.

@example
% make install
/usr/bin/gauche-install -m 444 -T /usr/lib/gauche/site/include 
/usr/bin/gauche-install -m 444 -T /usr/share/gauche/site/lib trivial.scm 
/usr/bin/gauche-install -m 555 -T /usr/lib/gauche/site/0.8.6/i686-pc-linux-gnu trivial.so
/usr/bin/gauche-install -m 444 -T /usr/share/gauche/site/lib/.packages trivial.gpd
@end example

By default, the files are installed in the site-specific area
reserved within the intalled Gauche.
If you want to change the install location, you can do the
same as typical autoconfiscated softwares; e.g. giving
@code{--prefix} option to the @code{configure} script,
or 






@node The templates explained, Introduction of the stub file, Building the trivial module, A trivial extension
@subsection The templates explained

@node 
@subsubsection 




@node Introduction of the stub file,  , The templates explained, A trivial extension
@subsection Introduction of the stub file



@node Simple readline binding,  , A trivial extension, Getting started
@section Simple readline binding









@c ======================================================================
@node Fundamental concepts, C API reference, Getting started, Top
@chapter Fundamental concepts

@menu
* Naming convention::           
* Scheme types and C types::    
* Memories::                    
* The VM::                      
@end menu

@node Naming convention, Scheme types and C types, Fundamental concepts, Fundamental concepts
@section Naming convention

@node Scheme types and C types, Memories, Naming convention, Fundamental concepts
@section Scheme types and C types

@node Memories, The VM, Scheme types and C types, Fundamental concepts
@section Memories

@node The VM,  , Memories, Fundamental concepts
@section The VM



@c ======================================================================
@node C API reference, Helper program reference, Fundamental concepts, Top
@chapter C API reference

@node Representation of Scheme objects
@section Representation of Scheme objects


@node Equivalence
@section Equivalence


@node Numbers
@section Numbers

@node Scheme number objects
@subsection Scheme number objects

@subsubheading C representation of numbers

Gauche uses several different structures to represent Scheme 
numbers.  Because of this polymorphic nature, the Scheme numbers
are almost always passed as @code{ScmObj}, except special occasions.
In Scheme level you usually don't need to think much
about different types of numbers, for Gauche automatically
converts them as needed.   There are C routines that accept
generic Scheme numbers like Scheme, but time to time 
you need to check the actual type of the number and cast it
from @code{ScmObj} to the actual structure.

Currently Gauche has the following C-level representations.
Note that this list may be extended in future (a rational number
is likely to be added), so it is always good to check for
any types, rather than assuming like "if it is not a fixnum, bignum,
or flonum, then it must be a complexnum!".

@table @emph
@item Fixnum
For small Scheme exact integers (30 or 62 bit signed integer
in 32 or 64 bit
architectures, respectively), we encode its immediate value into
a machine word.  You can test if an @code{ScmObj} is a fixnum
by @code{SCM_INTP}.
@item Bignum
If a Scheme exact integer doesn't fit in fixnum, it is represented
as a bignum, by a @code{ScmBignum} structure.  You can test
if @code{ScmObj} is a bignum by @code{SCM_BIGNUMP}, and then
cast the object to @code{ScmBignum*} for further treatment.
@item Flonum
Scheme real numbers are represented as flonum, by @code{ScmFlonum}
structure.  You can test if @code{ScmObj} is a flonum by @code{SCM_FLONUMP}.
@item Complexnum
Scheme complex numbers are represented as complexnum, by
a @code{ScmComplex} structure.  You can test if @code{ScmObj} is a
complexnum by @code{SCM_COMPLEXP}.
@end table

@subsubheading Normalized form

It is important for C-routine writers to know one rule:
If your routine returns a Scheme number, it must be in
a @emph{normalized} form, i.e.:

@itemize @bullet
@item
If the number is an exact integer and representable as
fixnum, it must be in fixnum, rather than bignum.
@item
If the imaginary part of the number is 0.0, it must be
in flonum, rather than complexnum.
@end itemize

(Note: here we use the term @emph{normalized} and @emph{denormalized}
in the sense that Scheme numbers should be represented in a simplest
possible C structure.  It is unrelated to the term in
IEEE floating point number.)

Some number constructors are guaranteed to return normalized
numbers (e.g. @code{Scm_MakeInteger} family and
@code{Scm_MakeComplexNormalized}).  It is always good to
use them as much as possible.

Carrying around a denormalized Scheme number should be limited
for intermediate results, and only when you find the overhead of
conversion is a problem.  Generally such overhead is negligible
compared to other overheads.

Especially, you don't need to touch @code{ScmBignum*} routines
for most of the times.  The generic integer API should cover
most cases.  If you ever need to touch bignums directly,
always make sure you return a normalized integers.

@subsubheading Conversions

Converting a Scheme number to a C number is a 
tricky business.  It's always possible that the Scheme number
you got may not fit into the desired C variable.  There are several
options you can choose.

@itemize @bullet
@item
Error: Throws an error.
@item
Clamp: If the Scheme value falls out of the supported range
of C variable, use the closest representable value.
@item 
Convert only when possible.  If conversion is not possible, use
the Scheme value as-is.  It is useful to provide a shortcut path
to improve performance.
@end itemize

Some C APIs take @var{clamp} argument to specify the behavior.  The value
can be one of the following enums.

@example
enum {
    SCM_CLAMP_ERROR = 0,       /* throws an error when out-of-range */
    SCM_CLAMP_HI = 1,
    SCM_CLAMP_LO = 2,
    SCM_CLAMP_BOTH = 3,
    SCM_CLAMP_NONE = 4         /* do not convert when out-of-range */
};
@end example

If an API supports @code{SCM_CLAMP_NONE},
it also takes an output argument to return a flag whether the argument
is out of range or not.  This output argument can be @code{NULL} if the caller 
doesn't specify @code{SCM_CLAMP_NONE} flag.

@node Integer numbers
@subsection Integer numbers

@subsubheading Type predicates and accessors

@deftypefn {Macro} int SCM_INTP (ScmObj @var{obj})
Returns @code{TRUE} iff @var{obj} is a fixnum.
@end deftypefn

@deftypevr {Macro} int SCM_SMALL_INT_SIZE
Number of bits (excluding sign bit) of an integer representable
in fixnum.  Currently it is 29 and 61 for 32 and 64-bit architectures,
respectively.
@end deftypevr

@deftypevr {Macro} int SCM_SMALL_INT_MAX
@deftypevrx {Macro} int SCM_SMALL_INT_MIN
Maximum and minimum integer values representable in fixnum.
@end deftypevr

@deftypefn {Macro} int SCM_SMALL_INT_FITS (int @var{k})
Returns @code{TRUE} iff @var{k} fits in fixnum.
@end deftypefn

@deftypefn {Macro} int SCM_INT_VALUE (ScmObj @var{fixnum})
Extracts (unboxes) an integer value from @var{fixnum}.  You have to check
whether @var{fixnum} is a fixnum or not before applying this.
@end deftypefn

@deftypefn {Macro} ScmObj SCM_MAKE_INT(int @var{i})
Boxes an integer value @var{i} to a fixnum.  You have to make
sure @var{i} is in the range representable by fixnum.
@end deftypefn

@deftypefn {Macro} int SCM_UINTP (ScmObj @var{obj})
A convenience macro to check if @var{obj} is a fixnum 
@emph{and} non-negative.
@end deftypefn

@deftypefn {Macro} int SCM_BIGNUMP (ScmObj @var{obj})
@end deftypefn

@deftypefn {Macro} ScmBignum* SCM_BIGNUM (ScmObj @var{obj})
@end deftypefn

@deftypefn {Macro} int SCM_BIGNUM_SIZE (ScmObj @var{bignum})
@deftypefnx {Macro} int SCM_BIGNUM_SIGN (ScmObj @var{bignum})
@end deftypefn

@subsubheading Conversion routines

@deftypefun ScmObj Scm_MakeInteger (long @var{i})
@deftypefunx ScmObj Scm_MakeIntegerU (u_long @var{i})
@end deftypefun

@deftypefun ScmObj Scm_MakeInteger64 (ScmInt64 @var{i})
@deftypefunx ScmObj Scm_MakeIntegerU64 (ScmUInt64 @var{i})
@end deftypefun

@deftypefun long Scm_GetIntegerClamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
@deftypefunx u_long Scm_GetIntegerClamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
@end deftypefun

@deftypefun long Scm_GetInteger (ScmObj obj)
@deftypefunx u_long Scm_GetIntegerU (ScmObj obj)
@end deftypefun

@deftypefun ScmInt32 Scm_GetInteger32Clamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
@deftypefunx ScmUInt32 Scm_GetInteger32Clamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
@end deftypefun

@deftypefun ScmInt64 Scm_GetInteger64Clamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
@deftypefunx ScmUInt64 Scm_GetInteger64Clamp (ScmObj @var{obj}, int @var{clamp}, int *@var{oor})
@end deftypefun

@deftypefun long Scm_GetInteger64 (ScmObj obj)
@deftypefunx u_long Scm_GetIntegerU64 (ScmObj obj)
@end deftypefun


@node Real and complex numbers
@subsection Real and complex numbers


@node Generic arithmetics
@subsection Generic arithmetics



@node Reading and writing numbers
@subsection Reading and writing numbers







@node Booleans
@section Booleans

@node Pairs and Lists
@section Pairs and Lists

@node Symbols
@section Symbols

@node Keywords
@section Keywords


@node Characters
@section Characters

@node Character sets
@section Character sets

@node Strings
@section Strings

@node Regular expressions
@section Regular expressions

@node Vectors
@section Vectors

@node Hashtables
@section Hashtables

@node Weak pointers
@section Weak pointers

@node Exceptions
@section Exceptions

@node Calling back to Scheme
@section Calling back to Scheme

@node Input and output
@section Input and output

@node Loading programs
@section Loading programs

@node System interface
@sectino System interface


@c ======================================================================
@node Helper program reference, Indices, C API reference, Top
@chapter Helper program reference


@c ======================================================================
@node Indices,  , Helper program reference, Top
@appendix Indices
@c NODE 索引

@menu
* Function and Macro Index::    
* Type Index::                  
* Variable Index::              
@end menu

@node Function and Macro Index, Type Index, Indices, Indices
@appendixsec Function and Macro Index
@printindex fn


@node Type Index, Variable Index, Function and Macro Index, Indices
@appendixsec Type Index
@printindex cl

@node Variable Index,  , Type Index, Indices
@appendixsec Variable Index
@printindex vr

@contents
@bye

