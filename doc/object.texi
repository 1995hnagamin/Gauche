@node Object system, Library modules - Overview, Core library, Top
@chapter Object system
@c NODE オブジェクトシステム

@c EN
Gauche's object system design is largely inspired by
STklos, whose design has come from TinyCLOS.
It supports multiple inheritance, multimethods,
and metaobject protocol.
@c JP
Gaucheのオブジェクトシステムのデザインは、TinyCLOSから
派生したSTklosから大きな影響を受けています。
多重継承、マルチメソッド、メタオブジェクトプトロコルを
サポートしています。
@c COMMON

@c EN
The type system is integrated to the object system,
that is, a string is an instance of the class @code{<string>},
and so on.
@c JP
型システムは、オブジェクトシステムに統合されています。
つまり、文字列は@code{<string>}クラスのインスタンスである、などです。
@c COMMON

@c ----------------------------------------------------------------------
@menu
* Introduction to the object system::  
* General Inquiry::             
* Defining class::              
* Defining methods::            
* Creating Instance::           
* Accessing Instance::          
* Metaobject protocol::         
@end menu

@node Introduction to the object system, General Inquiry, Object system, Object system
@section  Introduction to the object system
@c NODE オブジェクトシステムの紹介

This section briefly explains the basic structure of
Gauche's object system.   It is strongly influenced
by CLOS (Common-Lisp Object System).
If you have experience in CLOS or related systems
such as TinyCLOS, STklos or Guile's object system,
you may skip to the next section.

Three concepts play the central role in CLOS-like object systems:
A @emph{class}, a @emph{generic function}, and a @emph{method}.

A @emph{class} specifies a structure of object.
It also defines a datatype (strictly speaking,
it's not the same thing as a datatype,
but let's skip the complicated part for now).

For example, a point in 2D space can be represented by 
x and y coordinates.
A point class can be defined using @code{define-class} macro.
In the shortest form, it can be defined like this:

@example
(define-class <2d-point> () (x y))
@end example

The symbol @code{<2d-point>} is the name of the class, and also
the global variable @code{<2d-point>} is bound to a class object.
Surrounding a class name by @code{<} and @code{>} is just a
convention; you can pass any symbol to @code{define-class}.
(You can find the code of definitions in the examples of this section
in @code{examples/oointro.scm} of Gauche's source distribution.)

The second argument of @code{define-class} is a list of
direct superclasses, from which you can inherit your class.
We'll come back to it later.

The third argument of @code{define-class} is a list of
@emph{slots}.  A slot is a space, usually in each object,
where you can store a value.  It is something similar to
what is called a field or an instance variable in other
object-oriented languages; but slots can be configured more
than just a per-object storage space.

Now we defined a 2D point class, so we can create an instance
of a point.  You can pass a class to a generic function @code{make}
to create an instance.  (Don't worry about what generic function
is---think it as a special type of function, just for now).
@example
(define a-point (make <2d-point>))

a-point  @result{} #<<2d-point> 0x8117570>
@end example

If you are using @code{gosh} interactively, you can use
a generic function @code{describe} to inspect its internals.
A short alias, @code{d}, is defined to @code{describe} for
the convenience.  (See @ref{gauche.interactive - Interactive session}
for the details).

@example
gosh> (d a-point)
#<<2d-point> 0x8117570> is an instance of class <2d-point>
slots:
  x         : #<unbound>
  y         : #<unbound>
@end example

In order to access or modify the value of the slot, you can use
@code{slot-ref} and @code{slot-set!}, respectively.
These names are taken from STklos.
@example
(slot-ref a-point 'x)  ;; access to the slot x of a-point
  @result{} @r{error, since slot 'x doesn't have a value yet}

(slot-set! a-point 'x 10.0)  ;; set 10.0 to the slot x of a-point

(slot-ref a-point 'x)
  @result{} 10.0
@end example

Gauche also provides a shorter name, @code{ref}, which can also
be used in srfi-17's generalized @code{set!} syntax:
@example
(ref a-point 'x) @result{} 10.0

(set! (ref a-point 'y) 20.0)

(ref a-point 'y) @result{} 20.0
@end example

Now you can see slot values are set.
@example
gosh> (d a-point)
#<<2d-point> 0x8117570> is an instance of class <2d-point>
slots:
  x         : 10.0
  y         : 20.0
@end example

In practice, it is usually convenient if you can specify the default
value for a slot, or give values for slots when you create an instance.
Such information can be specified by @emph{slot options}.
Let's modify the definition of @code{<2d-point>} like this:

@example
(define-class <2d-point> ()
  ((x :init-value 0.0 :init-keyword :x :accessor x-of)
   (y :init-value 0.0 :init-keyword :y :accessor y-of)))
@end example

Note that each slot specification is now a list, instead of just
a symbol as in the previous example.
The list's car now specifies the slot name, and its cdr
gives various information.   The value after @code{:init-value}
defines a default value of the slot.  The keyword after @code{:init-keyword}
defines a keyword argument which can be passed to @code{make} to
initialize the slot at creation time.
The name after keyword @code{:accessor} is bound to a generic
function that can be used to access/modify the slot, instead of
using @code{slot-ref}/@code{slot-set!}.

Let's see some interactive session.  You create an instance
of the new @code{<2d-point>} class, and you can see the slots are
initialized by the default values.
@example
gosh> (define a-point (make <2d-point>))
a-point
gosh> (d a-point)
#<<2d-point> 0x8148680> is an instance of class <2d-point>
slots:
  x         : 0.0
  y         : 0.0
@end example

You create another instance, this time giving initialization values
by keyword arguments.
@example
gosh> (define b-point (make <2d-point> :x 50.0 :y -10.0))
b-point
gosh> (d b-point)
#<<2d-point> 0x8155b80> is an instance of class <2d-point>
slots:
  x         : 50.0
  y         : -10.0
@end example

Accessors are less verbose than @code{slot-ref}/@code{slot-set!}, thus
convenient.
@example
gosh> (x-of a-point)
0.0
gosh> (x-of b-point)
50.0
gosh> (set! (y-of a-point) 3.33)
#<undef>
gosh> (y-of a-point)
3.33
@end example

The full list of available slot options is described in 
@ref{Defining class}.
You might feel that the declarations of such slot options are overly
verbose.  Actually it depends on the applications.
Sometimes you find its flexibility convenient.  Besides,
using a mechanism called metaobject protocol, you can customize
how these slot options are interpreted, and you can add
your own slot options as well.
See @ref{Metaobject protocol}, for details.

We can also have @code{<2d-vector>} class in similar fashion.

@example
(define-class <2d-vector> ()
  ((x :init-value 0.0 :init-keyword :x :accessor x-of)
   (y :init-value 0.0 :init-keyword :y :accessor y-of)))
@end example

Yes, we can use the same accessor name like @code{x-of}, and
it is effectively overloaded.

If you are familiar with mainstream object-oriented languages,
you may wonder where methods are.  Here it is.
The following form defines a method @code{move-by!} of
three arguments, @var{pt}, @var{dy}, @var{dy}, where @var{pt} is
an instance of @code{<2d-point>}.

@example
(define-method move-by! ((pt <2d-point>) dx dy)
  (inc! (x-of pt) dx)
  (inc! (y-of pt) dy))
@end example

The second argument of @code{define-method} macro specifies a
@emph{method specializer}.  It indicates the first argument must be
an instance of @code{<2d-point>}, and the second and third
can be any type.   The syntax to call a method is just like
the one to call an ordinary function.

@example
gosh> (move-by! b-point 1.4 2.5)
#<undef>
gosh> (d b-point)
#<<2d-point> 0x8155b80> is an instance of class <2d-point>
slots:
  x         : 51.4
  y         : -7.5
@end example

You can overload the method by different specializers; here
you can move a point using a vector.

@example
(define-method move-by! ((pt <2d-point>) (delta <2d-vector>))
  (move-by pt (x-of delta) (y-of delta)))
@end example

Specialization isn't limited to a user-defined classes.
You can also specialize a method using Gauche's built-in type.

@example
(define-method move-by! ((pt <2d-point>) (c <complex>))
  (move-by! pt (real-part c) (imag-part c)))
@end example

And here's the example session:
@example
gosh> (define d-vector (make <2d-vector> :x -9.0 :y 7.25))
d-vector
gosh> (move-by! b-point d-vector)
#<undef>
gosh> (d b-point)
#<<2d-point> 0x8155b80> is an instance of class <2d-point>
slots:
  x         : 42.4
  y         : -0.25
gosh> (move-by! b-point 3+2i)
#<undef>
gosh> (d b-point)
#<<2d-point> 0x8155b80> is an instance of class <2d-point>
slots:
  x         : 45.4
  y         : -2.25
@end example

You see that a method is dispached not only by its primary
receiver (@code{<2d-point>}), but also other arguments.
In fact, there is no difference between the first argument and
the rest.  In CLOS-like system a method does not belong to
a particular class.

So what is actually a method?  Inspecting @code{move-by!}
reveals that it is an instance of @code{<generic>}, a generic function.
(Note that @code{describe} truncates the printed value in @code{methods}
slot for the sake of readability).

@example
gosh> move-by!
#<generic move-by! (3)>
gosh> (d move-by!)
#<generic move-by! (3)> is an instance of class <generic>
slots:
  name      : move-by!
  methods   : (#<method (move-by! <2d-point> <complex>)> #<method (move-
gosh> (ref move-by! 'methods)
(#<method (move-by! <2d-point> <complex>)>
 #<method (move-by! <2d-point> <2d-vector>)> 
 #<method (move-by! <2d-point> <top> <top>)>)
@end example

I said a generic function is a special type of function.
It is recognized by Gauche as an applicable object, but
when applied, it selects appropriate method(s) according to
its arguments and calls the selected method(s).

What the @code{define-method} macro actually does is (1) to create
a generic function of the given name if it does not exist yet,
(2) to create a method object with the given specializers
and the body, and (3) to add the method object to the generic function.

The accessors are also generic functions, created implicitly by the
@code{define-class} macro.
@example
gosh> (d x-of)
#<generic x-of (2)> is an instance of class <generic>
slots:
  name      : x-of
  methods   : (#<method (x-of <2d-vector>)> #<method (x-of <2d-point>)>)
@end example

In the mainstream dynamic object-oriented languages, a class
has many roles: it defines a structure and a type, creates a
namespace for its slots and methods, and is responsible for
method dispatch.  In Gauche, namespace is managed by modules,
and method dispatch is handled by generic functions.

The default printed representation of object is not very user-friendly.
Gauche's @code{write} and @code{display} function calls a generic
function @code{write-object} when it encounters an instance
it doesn't know how to print.  You can define its method
specialized to your class to customize how the instance is
printed.

@example
(define-method write-object ((pt <2d-point>) port)
  (format port "[[~a, ~a]]" (x-of pt) (y-of pt)))

(define-method write-object ((vec <2d-vector>) port)
  (format port "<<~a, ~a>>" (x-of vec) (y-of vec)))
@end example

And what you'll get is:
@example
gosh> a-point
[[0.0, 3.33]]
gosh> d-vector
<<-9.0, 7.25>>
@end example

If you customize the printed representation to conform srfi-10
format, and define a corresponding read-time constructor,
you can make your instances to be written-out and read-back
just like built-in objects.  See @ref{Read-time constructor} for
the details.

Several built-in functions have similar way to extend their
functionality for user-defined objects.  For example, if
you specialize a generic function @code{object-equal?}, 
you can compare the instances by @code{equal?}:

@example
(define-method object-equal? ((a <2d-point>) (b <2d-point>))
  (and (equal? (x-of a) (x-of b))
       (equal? (y-of a) (y-of b))))

(equal? (make <2d-point> :x 1 :y 2) (make <2d-point> :x 1 :y 2))
  @result{} #t

(equal? (make <2d-point> :x 1 :y 2) (make <2d-point> :x 2 :y 1))
  @result{} #f

(equal? (make <2d-point> :x 1 :y 2) 'a)
  @result{} #f

(equal? (list (make <2d-point> :x 1 :y 2)
              (make <2d-point> :x 3 :y 4))
        (list (make <2d-point> :x 1 :y 2)
              (make <2d-point> :x 3 :y 4)))
  @result{} #t
@end example

Let's proceed to more interesting examples.
Think of a class @code{<shape>}, 
which is an entity that can be drawn.
As a base class, it keeps
common attributes such as a color and line thickness in its slots.

@example
(define-class <shape> ()
  ((color     :init-value '(0 0 0) :init-keyword :color)
   (thickness :init-value 2 init-keyword :thickness)))
@end example

When an instance is created, @code{make} calls a generic function
@code{initialize}, which takes care of initializing slots
such as processing init-keywords and init-values.
You can customize the initialization behavior by specializing
the @code{initialize} method.   The @code{initialize} method
is called with two arguments, one is a newly created instance,
and another is a list of arguments passed to @code{make}.

We define a @code{initialize} method for @code{<shape>} class,
so that the created shape will be automatically recorded in a global
list.   Note that we don't want to replace system's
@code{initialize} behavior completely,
since we still need the init-keywords to be handled.

@example
(define *shapes* '())  ;; global shape list

(define-method initialize ((self <shape>) initargs)
  (next-method)  ;; let the system to handle slot initialization
  (push! *shapes* self)) ;; record myself to the global list
@end example

The trick is a special method, @code{next-method}.  It can only be
used inside a method body, and calls @emph{less specific method}
of the same generic function---generally, it means you call the
same method of @emph{superclass}.   
Most object-oriented languages have the concept of calling
superclass's method.  Because of multiple-argument
dispatching and multiple inheritance, @code{next-method} is
a little bit more complicated, but the basic idea is the same.

So, what's the superclass of @code{<shape>}?  In fact, all 
Scheme-defined class inherits a class called @code{<object>}.
And it is @code{<object>}'s initialize method which takes care
of slot initialization.  After calling @code{next-method}
within your @code{initialize} method, you can assume all
the slots are properly initialized.  So it is generally the
first thing in your @code{initialize} method to call @code{next-method}.

Let's inspect the above code.  When you call
@code{(make <shape> args @dots{})}, the system allocates
memory for an instance of @code{<shape>}, and calls
@code{initialize} generic funciton with the instance and
@code{args @dots{}}.  It is dispatched to the @code{initialize}
method you just defined.  In it, you call @code{next-method},
which in fact calls @code{<object>} class's @code{initialize}
method.  It initializes the instance with init-values and init-keywords.
After it returns, you register the new @code{<shape>} instance
to the global shape list @code{*shapes*}.

The @code{<shape>} class represents just an abstract concept of
shape.  Now we define some concrete drawable shapes, by
@emph{subclassing} the @code{<shape>} class.

@example
(define-class <point-shape> (<shape>)
  ((point  :init-form (make <2d-point>) :init-keyword :point)))

(define-class <polyline-shape> (<shape>)
  ((points :init-value '() :init-keyword :points)
   (closed :init-value #f  :init-keyword :closed)))
@end example

Note the second argument passed to @code{define-class}.
It indicates that @code{<point-shape>} and @code{<polyline-shape>}
inherits slots of @code{<shape>} class, and also instances of
those subclasses can be accepted wherever an instance of 
@code{<shape>} class is accepted.

The @code{<point-shape>} adds one slot, @code{point}, which
contains an instance of @code{<2d-point>} defined in the beginning
of this section.  The @code{<polyline-shape>} class stores
a list of points, and a flag, which specifies whether the end
point of the polyline is connected to its starting point or not.

Inheritance is a powerful mechanism that should be used with care,
or it easily result a code which is untractable
("Object-oriented programming offers a sustainable way to
write spaghetti code.", as Paul Graham says in his article
"The Hundred-Year Language").
The rule of thumb is to make a subclass when you need a subtype.
The inheritance of slots is just something that comes with,
but it shouldn't be the main reason to do subclassing.
You can always "include" the substructure, as is done in
@code{<point-shape>} class.

There appeared a new slot option in @code{<point-shape>} class.
The @code{:init-form} slot option specifies the default value of
the slot when init-keyword is not given to @code{make} method.
However, unlike @code{:init-value}, with which the value is
evaluated at the time the class is defined, 
the value with @code{:init-form} is evaluated when the system
actually needs the value.  So, in the @code{<point-shape>} instance,
the default @code{<2d-point>} instance is only created if the
@code{<point-shape>} instance is created without having @code{:point}
init-keyword argument.

A shape may be drawn in different formats for different devices.
For now, we just consider a PostScript output.  To make the @code{draw}
method polymorphic, we define a postscript output device class,
@code{<ps-device>}.

@example
(define-class <ps-device> () ())
@end example

Then we can write a @code{draw} method, specialized for
both @code{<shape>} and @code{<ps-device>}.

@example
(define-method draw ((self <shape>) (device <ps-device>))
  (format #t "gsave\n")
  (draw-path self device)
  (apply format #t "~a ~a ~a setrgbcolor\n" (ref self 'color))
  (format #t "~a setlinewidth\n" (ref self 'thickness))
  (format #t "stroke\n")
  (format #t "grestore\n"))
@end example

In this code, the @var{device} argument isn't
used within the method body.  It is just used for method dispatching.
If we eventually have different output devices, we can add
a @code{draw} method that is specialized for such devices.

The above @code{draw} method does the common work, but actual
drawing must be done in specialized way for each subclasses.

@example
(define-method draw-path ((self <point-shape>) (device <ps-device>))
  (apply format #t "newpath ~a ~a 1 0 360 arc closepath\n"
         (point->list (ref self 'point))))

(define-method draw-path ((self <polyline-shape>) (device <ps-device>))
  (let ((pts (ref self 'points)))
    (when (>= (length pts) 2)
      (format #t "newpath\n")
      (apply format #t "~a ~a moveto\n" (point->list (car pts)))
      (for-each (lambda (pt)
                  (apply format #t "~a ~a lineto\n" (point->list pt)))
                (cdr pts))
      (when (ref self 'closed)
        (apply format #t "~a ~a lineto\n" (point->list (car pts))))
      (format #t "closepath\n"))))
@end example

Finally, we do a little hack.  Let @code{draw} method work on
the list of shapes, so that we can draw multiple shapes within a page
in batch.

@example
(define-method draw ((shapes <list>) (device <ps-device>))
  (format #t "%%\n")
  (for-each (cut draw <> device) shapes)
  (format #t "showpage\n"))
@end example

Then we can write some simple figures @dots{}.

@example
(use srfi-1)      ;; for iota
(use math.const)  ;; for constant pi

(define (shape-sample)

  ;; creates 5 corner points of pentagon
  (define (make-corners scale)
    (map (lambda (i)
           (let ((pt (make <2d-point>)))
             (move-by! pt (make-polar scale (* i 2/5 pi)))
             (move-by! pt 200 200)
             pt))
         (iota 5)))

  (set! *shapes* '())  ;; clear the shape list
  (let* ((corners (make-corners 100)))
    ;; a pentagon in green
    (make <polyline-shape>
      :color '(0 1 0) :closed #t
      :points corners)
    ;; a star-shape in red
    (make <polyline-shape>
      :color '(1 0 0) :closed #t
      :points (list (list-ref corners 0)
                    (list-ref corners 2)
                    (list-ref corners 4)
                    (list-ref corners 1)
                    (list-ref corners 3)))
    ;; put dots in each corner of the star
    (for-each (cut make <point-shape> :point <>)
              (make-corners 90))
    ;; draw the shapes
    (draw *shapes* (make <ps-device>)))
  )
@end example

The function @code{shape-sample} writes out a PostScript code of
simple drawing to the current output port.  You can write it out
to file by the following expression, and then view the result
by PostScript viewer such as GhostScript.

@example
(with-output-to-file "oointro.ps" shape-sampe)
@end example


@c ----------------------------------------------------------------------
@node General Inquiry, Defining class, Introduction to the object system, Object system
@section  General Inquiry
@c NODE 一般的な問い合わせ

@defun class-of obj
@c EN
Returns a class metaobject of @var{obj}.
@c JP
@var{obj}のクラスを返します。
@c COMMON

@example
(class-of 3)         @result{} #<class <integer>>
(class-of "foo")     @result{} #<class <string>>
(class-of <integer>) @result{} #<class <class>>
@end example
@end defun

@defun is-a? obj class
@c EN
Returns true if @var{obj} is an instance of @var{class} or an instance
of descendants of @var{class}.
@c JP
@var{obj}が@var{class}のインスタンスであるか、@var{class}のサブクラスの
インスタンスである場合に、真を返します。
@c COMMON

@example
(is-a? 3 <integer>)   @result{} #t
(is-a? 3 <real>)      @result{} #t
(is-a? 5+3i <real>)   @result{} #f
(is-a? :foo <symbol>) @result{} #f
@end example
@end defun

If @var{obj}'s class has been redefined, these procedures
first updates @var{obj} to change its class to the new class.
So @code{class-of} always returns the new class.
This behavior is different from stklos 0.55, which @code{class-of}
returns an old class if @var{obj} hasn't been updated.
If you need to get the old class, you should use @code{current-class-of}
below.  
See @ref{Class redefinition} for the details of the semantics
of redefined class.

@defun current-class-of obj
Returns a class metaobject of @var{obj}.  If @var{obj}'s class
has been redefined, but @var{obj} is not updated for the change,
then this procedure returns the original class of @var{obj}
without updating @var{obj}.

You need this procedure in rare occasions, such as within
@code{change-class} method, in which you don't want to trigger
updating @var{obj} (which would cause infinite loop).
@end defun

@c ----------------------------------------------------------------------
@node Defining class, Defining methods, General Inquiry, Object system
@section Defining class
@c NODE クラスの定義

@c EN
A class is a first-class object in Gauche and you can create it
on the fly at run-time using procedure calls.
However, for convenience, a macro is defined to create a class
and bind it globally.
@c JP
クラスは、Gaucheではファーストクラスのオブジェクトなので、
手続き呼び出しを使って実行時に動的に作成することができます。
簡便のため、グローバルに束縛されたクラスを生成するマクロが
定義されています。
@c COMMON

@menu
* define-class macro::          
* Inheritance::        
* Class redefinition::          
@end menu

@node define-class macro, Inheritance, Defining class, Defining class
@subsection @code{define-class} macro
@c NODE define-class マクロ

@defmac define-class name supers (slot-spec @dots{}) option @dots{}
@c EN
Creates a class object according to the arguments, and globally
bind it to a variable @var{name}.   This macro should be used at toplevel.

@var{Supers} is a list of direct superclasses from which this class
inherits.   You can use multiple inheritance.
All Scheme-defined classes implicitly inherits @code{<object>}.
It is implicitly added to the right of @var{supers} list, so you
don't need to specify it.
See @ref{Inheritance}, for the details abount inheritance.

@var{Slot-spec} is a specification of a "slot", sometimes known as 
a "field" or an "instance variable" (but you can specify "class variable"
in @var{slot-spec} as well). 
The simplest form of @var{slot-spec} is just a symbol, which names
the slot.  Or you can give a list, whose first element is a symbol
and whose rest is an interleaved list of keywords and values.
The list form not only defines a name of the slot but specifies
behavior of the slot.  It is explained below.

Finally, @var{option} @dots{} is an interleaved list of keywords
and values, specifies how class object should be created.
This macro recognizes one keyword, @code{:metaclass}, whose
corresponding value is used for metaclass (class that instantiates
another class).   Other options are passed to the @code{make}
method to create the class object.  @xref{Class instantiation},
for the usage of metaclass.
@c JP
引数によって指定されたクラスオブジェクトを作成し、それを @var{name} に
グローバルに束縛します。このマクロはトップレベルでのみ使うことができます。

@var{Supers} はそのクラスが継承する直接のスーパークラスのリストです。
多重継承も使えます。継承の詳細については@ref{Inheritance} を参照して下さい。

@var{Slot-spec} は「スロット」の仕様で、他の言語ではよく
「フィールド」や「インスタンス変数」と呼ばれるものです 
(@var{slot-spec} を使って「クラス変数」を指定することもできます)。
@var{slot-spec} の最も単純なフォームはシンボルそのもので、その名前が
スロットであるものです。あるいは、最初の要素がシンボルで残りの要素が
キーワードと値が交互に来るリストを渡すこともできます。

このリストフォームは、スロットの名前を定義するだけでなく、そのスロットの
振る舞いも定義します。スロットの定義については以下で説明します。

最後に、@var{option} @dots{} は、クラスオブジェクトがどのように
作られるかを指定する、キーワードと値が交互に来るリストです。

このマクロでは1つのキーワード引数、@code{:metaclass} により、
メタクラス(他のクラスをインスタンス化するクラス)を指定できます。
他のオプションはクラスオブジェクトを作成するために、@code{make}
メソッドに渡されます。メタクラスの使用方法については、
@ref{Class instantiation}を参照。
@c COMMON
@end defmac

If a slot specification is a list, it should be in the following form:

@example
(@var{slot-name} :option1 value1 :option2 value2 @dots{})
@end example

Each keyword (@code{option1} etc.) gives a @emph{slot option}.
By default, the following slot options are recognized.
You can add more slot options by defining metaclass.

@table @code

@item :allocation
Specifies an allocation type of this slot, which specifies how the
value for this slot is stored.  The following keyword values are
recognized by the standard class.  A programmer can define his own
metaclass to extend the class to recognize other allocation types.
@table @code
@item :instance
A slot is allocated for each instance, so that every instance can have
distinct value.  This realizes so-called "instance variable" behavior.
If @code{:allocation} slot option is omitted, this is the default.
@item :class
A slot is allocated in per class object, so that every instance will
share the same value for this slot.  This realizes so-called
"class variable" behavior.  The slot value is also shared by all
subclasses (unless a subclass definition shadows the slot).
@item :each-subclass
Similar to @code{class} allocation, but a slot is allocated for each
class; that is, it is shared by every instance of the class, but
not shared by the instances of its subclasses.
@item :virtual
No storage is allocated for this type of slot.  Accessing the slot
calls procedures given in @code{:slot-ref} and @code{:slot-set!} options
described below.  In other words, you can make a procedural slot.
If a slot's allocation is specified as virtual, @code{:slot-ref} and
@code{:slot-set!} options have to be specified as well, or @code{define-class}
raises an error.
@end table

@item :init-keyword
A keyword value given to this slot option can be used to pass an
initial value to @code{make} method when an instance is created.

@item :init-value
Gives an initial value of the slot, if the slot is not initialized
by the keyword argument at the creation time.   The value is
evaluated when @code{define-class} is evaluated.

@item :init-form
Like @code{init-value}, but the value given is wrapped in a thunk,
and evaluated each time when the value is required.
If both @code{init-value} and @code{init-form} are given, @code{init-form}
is ignored.

@item :initform
A synonym of @code{init-form}.  This is kept for compatibility to
STk, and shouldn't be used in the new code.

@item :init-thunk
Gives a thunk, which will be evaluated to obtain an initial value
of the slot, if the slot is not initialized by the keyword argument
at the creation time.  To give a value to @code{:init-form}
is equivalent to give @code{(lambda () value)} to @code{:init-thunk}.

@item :getter
Takes a symbol, and a getter method is created and bound to the
generic function of that name.  The getter method takes an instance
of the class and returns the value of the slot.

@item :setter
Takes a symbol, and a setter method is created and bound to
the generic function of that name.  The setter method takes an instance
of the class and a value, and sets the value to the slot of the instance.

@item :accessor
Takes a symbol, and create two methods; a getter method and a setter method.
A getter method is bound to the generic function of the given name,
and a setter method is added as the @code{setter} of that generic function
(see @ref{Assignments} for generic setters).

@item :slot-ref
Specifies a value that evaluates to a procedure which takes one argument,
an instance.  This slot option must be specified if the allocation of
the slot is @code{virtual}.  Whenever a program tries to get the value
of the slot, either using @code{slot-ref} or the getter method,
the specified procedure is called, and its result is returned as
the value of the slot.  The procedure can return an undef value
(the return value of @code{undefined}) to indicate the slot doesn't
have a value.
If the slot allocation is not @code{virtual} this slot option is ignored.

@item :slot-set!
Specifies a value that evaluates to a procedure which takes two arguments,
an instance and a value.  This slot option must be specified if the
allocation of the slot is @code{virtual}.  Whenever a program tries
to set the value of the slot, either using @code{slot-set!} or the
setter method, the specified procedure is called with the value to be set.
If the slot allocation is not @code{virtual} this slot option is ignored.

@item :slot-bound?
Specifies a value that evaluates to a procedure which takes one argument,
an instance.  This slot option is only meaningful when the slot allocation
is @code{virtual}.  Whenever a program tries to determine whether
the slot has a value, this procedure is called.  It should return
a true value if the slot has a value, or @code{#f} otherwise.
If this slot option is omitted for a virtual slot, the system
calls the procedure given to @code{slot-ref} instead, and see whether
its return value is @code{#<undef>} or not.
@end table

@node Inheritance, Class redefinition, define-class macro, Defining class
@subsection Inheritance
@c NODE 継承

Inheritance has two roles.  First, you can @emph{extend} the existing
class by adding more slots.  Second, you can @emph{specialize} the
methods related to the existing class so that those methods will
do a little more specific task than the original methods.

Let's define some terms.  When a class @code{<T>} inherits a 
class @code{<S>}, we call @code{<T>} a @emph{subclass} of @code{<S>},
and @code{<S>} a @emph{superclass} of @code{<T>}.  This relation
is transitive: @code{<T>}'s subclasses are also @code{<S>}'s subclasses,
and @code{<S>}'s superclasses are also @code{<T>}'s superclasses.
Specifically, if @code{<T>} directly inherits @code{<S>}, that is,
@code{<S>} appeared in the superclass list when @code{<T>} is defined,
then @code{<S>} is a @emph{direct superclass} of @code{<T>}, 
and @code{<T>} is a @emph{direct subclass} of @code{<S>}.

When a class is defined, it and its superclasses are ordered from
subclasses to superclasses, and a list of classes is created in such
order.   It is called @emph{class precedence list}, or CPL.
A CPL of a class always begins with the class, and end with
@code{(<object> <top>)}.   @code{<object>} is a superclass of
all Scheme-defined classes, and @code{<top>} is a superclass of
all classes (including built-in classes).

If there's only single inheritance, CPL is straightforward:
you can just follow the class's super, its super's super, its
super's super's super, @dots{}, until you reach @code{<top>}.
When multiple inheritance is involved, a story becomes a bit
complicated.   I'll explain it later, but for now, you can
just assume you always have a linear list, not like a general graph
with branches and merges.
You can get a CPL of a class object using @code{class-precedence-list}
function.

The slots of defined class is calculated as follows:
the slot definitions are collected in the direction from superclasss
to subclass in CPL.  If a subclass has a slot definition of the same
name of the one in superclass, then the slot defintion of the subclass
is taken and superclass's is discarded.    Suppose a class @code{<S>}
defines slots @code{a}, @code{b}, and @code{c}, a class @code{<T>}
defines slots @code{c}, @code{d}, and @code{e}, and a class @code{<U>}
defines slots @code{b} and @code{e}.  When @code{<U>}'s CPL is
@code{(<U> <T> <S> <object> <top>)}, then @code{<U>}'s slots is
calculated as the chart below; that is, @code{<U>} gets five slots,
of which @code{b} and @code{e}'s definitions come from @code{<U>}'s
definitions, @code{c} and @code{d}'s come from @code{<T>}, and
@code{a}'s comes from @code{<S>}.

@example
   CPL      | slot definitions
            |  () indicates shadowed slot
 -----------+-------------------
   <top>    |
   <object> |
   <S>      | a  (b) (c)
   <T>      |         c   d  (e)
   <U>      |     b           e
 -----------+--------------------
 <U>'s slots| a   b   c   d   e
@end example

Note that this is a default behavior.
You can also be customized by defining metaclass.  For example,
you can write a metaclass that allows you to merge slot options
of the same slot names, instead of the one shadowing the other.
Or you can write a metaclass that forbids a subclass shadows
the superclass's slot.

You can get a list of slot definitions of a class object using
@code{class-slots} function.

Now, suppose you create an instance @code{u} from the class @code{<U>}:

@example
(define u (make <U>))

(is-a? u <U>) @result{} #t
@end example

Then, @code{u} can be passed to methods that expects argument of
class @code{<U>}, or any of superclasses of @code{<U>}.
The method dispatch mechanism is explained in @ref{Defining methods}.









@node Class redefinition,  , Inheritance, Defining class
@subsection Class redefinition
@c NODE クラスの再定義


@c ----------------------------------------------------------------------
@node Defining methods, Creating Instance, Defining class, Object system
@section Defining methods
@c NODE メソッドの定義

@defmac define-generic name
@end defmac

@defmac define-method name specs body
@end defmac

@c ----------------------------------------------------------------------
@node Creating Instance, Accessing Instance, Defining methods, Object system
@section Creating Instance
@c NODE インスタンスの作成

@deffn {Generic Function} make class arg @dots{}
@end deffn

@deffn {Method} make (class <class>) arg @dots{}
@end deffn

@deffn {Method} make (class <method>)  arg @dots{}
@deffnx {Method} make (class <generic>)  arg @dots{}
@end deffn

@deffn {Method} initialize (class <class>) initargs
@end deffn

@c ----------------------------------------------------------------------
@node Accessing Instance, Metaobject protocol, Creating Instance, Object system
@section Accessing Instance
@c NODE インスタンスへのアクセス

@defun slot-ref obj slot
@c EN
Returns a value of the slot @var{slot} of object @var{object}.

If the specified slot is not bound to any value, a generic function
@code{slot-unbound} is called with three arguments, @var{obj}'s class,
@var{obj}, and @var{slot}.  The default behavior of @code{slot-unbound}
is to signal an error.

If the object doesn't have the specified slot,
a generic function @code{slot-missing} is called with three
arguments, @var{obj}'s class,
@var{obj}, and @var{slot}.  The default behavior of @code{slot-missing}
is to signal an error.
@c JP
オブジェクト@var{object}のスロット@var{slot}の値を返します。

指定したスロットが値に束縛されていない場合、ジェネリック関数
@code{slot-unbound}が3つの引数、@var{obj}のクラス、@var{obj}、@var{slot}
を伴って呼び出されます。@code{slot-unbound}のデフォルトの振る舞いは、
エラーの通知です。

オブジェクトが指定されたスロットを持っていない場合は、ジェネリック関数
@code{slot-missing}が3つの引数、@var{obj}のクラス、@var{obj}、@var{slot}を
伴って呼び出されます。@code{slot-missing}のデフォルトの振る舞いは、
エラーの通知です。
@c COMMON
@end defun

@defun slot-set! obj slot value
@c EN
Alters the value of the slot @var{slot} of object @var{object} to
the value @var{value}.

If the object doesn't have the specified slot, a generic function
@code{slot-missing} is called with four arguments,
@var{obj}'s class, @var{obj}, @var{slot}, @var{value}.
@c JP
オブジェクト@var{object}のスロット@var{slot}の値を、@var{value}に
セットします。

オブジェクトが指定したスロットを持っていない場合は、ジェネリック関数
@code{slot-missing}が4つの引数、@var{obj}のクラス、@var{obj}、
@var{slot}、@var{value}を伴って呼び出されます。
@c COMMON
@end defun

@defun slot-bound? obj slot
@c EN
Returns true if object @var{obj}'s slot @var{slot} is bound, 
otherwise returns false.

If the object doesn't have the specified slot, a generic function
@code{slot-missing} is called with three arguments,
@var{obj}'s class, @var{obj}, @var{slot}.
@c JP
オブジェクト@var{obj}のスロット@var{slot}が束縛されていれば真を、
そうでなければ偽を返します。

オブジェクトが指定したスロットを持っていない場合は、ジェネリック関数
@code{slot-missing}が3つの引数、@var{obj}のクラス、@var{obj}、
@var{slot}を伴って呼び出されます。
@c COMMON
@end defun

@defun slot-exists? obj slot
@c EN
Returns true if @var{obj} has the slot named @var{slot}.
@c JP
@var{obj}が@var{slot}を持っていれば真を返します。
@c COMMON
@end defun

@defun slot-push! obj slot value
@c EN
This function implements the common idiom.
It can be defined like the following code
(but it may be optimized in the future versions).
@c JP
この関数は、一般的なイディオムの実装です。
これは以下のようなコードで定義できます(が、将来のバージョンでは
最適化されるでしょう)。
@c COMMON
@example
(define (slot-push! obj slot value)
  (slot-set! obj slot (cons value (slot-ref obj slot))))
@end example
@end defun

@deffn {Method} slot-unbound (class <class>) obj slot
@end deffn

@deffn {Method} slot-missing (class <class>) obj slot &optional value
@end deffn


@defun class-slot-ref class slot-name
@defunx class-slot-set! class slot-name obj
@end defun

@c ----------------------------------------------------------------------
@node Metaobject protocol,  , Accessing Instance, Object system
@section Metaobject protocol
@c NODE メタオブジェクトプロトコル

@menu
* System metaclasses::          
* Class introspection::         
* Class instantiation::         
* Customizing slot access::     
* Method instantiation::        
* Customizing method application::  
@end menu

@node System metaclasses, Class introspection, Metaobject protocol, Metaobject protocol
@subsection System metaclasses
@c NODE システムメタクラス

@deftp {Class} <top>
@clindex top
@end deftp

@deftp {Class} <class>
@clindex class
@end deftp

@deftp {Class} <generic>
@clindex generic
@end deftp

@deftp {Class} <method>
@clindex method
@end deftp

@deftp {Class} <object>
@clindex object
@end deftp


@node Class introspection, Class instantiation, System metaclasses, Metaobject protocol
@subsection Class introspection
@c NODE クラスのイントロスペクション

@menu
* Class metaobject::            
* Slot definition::             
@end menu

@node Class metaobject, Slot definition, Class introspection, Class introspection
@subsubsection Class metaobject
@c NODE クラスメタオブジェクト

@defun class-name class
@end defun

@defun class-precedence-list class
@end defun

@defun class-direct-supers class
@end defun

@defun class-direct-slots class
@end defun

@defun class-slots
@end defun

@node Slot definition,  , Class metaobject, Class introspection
@subsubsection Slot definition
@c NODE スロット定義

@deftp {Class} <slot-accessor>
@clindex slot-accessor
@end deftp


@defun class-slot-definition class slot-name
@end defun

@defun class-slot-accessor class slot-name
@end defun

@defun slot-definition-name slot-def
@end defun
@defun slot-definition-allocation slot
@end defun

@defun slot-definition-getter slot
@defunx slot-defininion-setter slot
@defunx slot-definition-accessor slot
@end defun

@defun slot-definition-options slot-def
@defunx slot-definition-option slot-def key &optional default
@end defun

@node Class instantiation, Customizing slot access, Class introspection, Metaobject protocol
@subsection Class instantiation
@c NODE クラスのインスタンシエーション

@deffn {Method} make (class <class>) &rest initargs
@end deffn


@node Customizing slot access, Method instantiation, Class instantiation, Metaobject protocol
@subsection Customizing slot access
@c NODE スロットアクセスのカスタマイズ


@deffn {Generic Function} compute-slots
@end deffn

@deffn {Generic Function} compute-get-n-set
@end deffn

@defun slot-ref-using-accessor obj slot-accessor
@defunx slot-set-using-accessor obj slot-accessor value
@end defun

@node Method instantiation, Customizing method application, Customizing slot access, Metaobject protocol
@subsection Method instantiation
@c NODE メソッドのインスタンシエーション

@deffn {Method} make (class <method>) &rest initargs
@end deffn

@node Customizing method application,  , Method instantiation, Metaobject protocol
@subsection Customizing method application
@c NODE メソッド適用のカスタマイズ

@deffn {Generic Function} apply-generic gf args
@end deffn

@deffn {Generic Function} sort-applicable-methods gf methods args
@end deffn

@deffn {Generic Function} method-more-specific? method1 method2 classes
@end deffn

@deffn {Generic Function} apply-methods gf methods args
@end deffn

@deffn {Generic Function} apply-method gf method build-next args
@end deffn

