\input texinfo  @c -*-texinfo-*-
@comment %**start of header
@c EN
@setfilename gauche-refe.info
@settitle Gauche Reference Manual
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche Reference: (gauche-refe.info).	An R5RS Scheme implementation.
@end direntry
@c JP
@setfilename gauche-refj.info
@settitle Gauche リファレンスマニュアル
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche Reference (ja): (gauche-refj.info).	An R5RS Scheme implementation.
@end direntry
@c COMMON
@comment %**end of header

@c $Id: gauche-ref.texi,v 1.355 2003-02-05 02:57:09 shirok Exp $

@c module and class index
@defcodeindex md
@defcodeindex cl

@iftex
@finalout
@parskip 4pt plus 1pt
@end iftex

@titlepage
@c EN
@title Gauche Reference Manual
@c JP
@title Gauche リファレンスマニュアル
@c COMMON
@subtitle version @VERSION@
@author Shiro Kawai (shiro@@acm.org)

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001-2003 Shiro Kawai (shiro@@acm.org)

@end titlepage

@node Top, Introduction, (dir), (dir)

@ifnottex
@c EN
This is a reference manual of Gauche, an R5RS Scheme implementation.
This manual is for version @VERSION@.
@c JP
本書は、R5RS準拠のScheme処理系、Gaucheのリファレンスマニュアルです。
Gaucheのバージョン@VERSION@に対応します。
@c COMMON
@end ifnottex

@menu
* Introduction::                
* Concepts::                    
* Programming in Gauche::       
* Core syntax::                 
* Macros::                      
* Core library::                
* Object system::               
* Library modules - Overview::  
* Library modules - Gauche extensions::  
* Library modules - SRFIs::     
* Library modules - Utilities::  
* References::                  
* C to Scheme mapping::         
* Indices::                     
@end menu

@node Introduction, Concepts, Top, Top
@chapter Introduction
@c NODE はじめに

@c EN
This is a programmers' guide and reference manual of
the Gauche Scheme system.
Here I tried to describe Gauche's implementation precisely,
sometimes referring to background design choices.
@c JP
本書はGauche Scheme systemに関する、プログラマーのためのガイドと
リファレンスです。なるべくGaucheの実装を正確に記述することを
目的として、時には背景となる設計上の選択も含めて説明しています。
@c COMMON

@c EN
The target readers are those who already know Scheme and
want to write useful programs in Gauche.
For those who are new to Scheme, it'll be easier to start
from some kind of tutorial.  I'm planning to write one.
@c JP
したがって、既にSchemeを知っていてGaucheの全機能を活用して
プログラムを書きたいという読者を対象にしています。
Schemeに触れるのが初めての読者は、何らかのチュートリアルを併用すると
良いでしょう。私もいずれチュートリアルめいたものを書くつもりです。
@c COMMON

@c EN
This manual only deals with Scheme side of things.  Gauche has
another face, a C interface.   Details of it will be discussed
in a separate document to be written.
Those who wants to use Gauche as an embedded language, or wants
to write an extension, need that volume.
@c JP
このマニュアルでは、GaucheのScheme言語としての面のみを扱います。
GaucheはC言語から呼べる汎用リスト処理ライブラリとしての側面も持っていますが、
それは別ドキュメントで解説する予定です。Gaucheを組み込み言語として使いたい、
もしくはGaucheをC言語で拡張したいという読者はそのドキュメントが必要となります。
@c COMMON

@c EN
For the Scheme side, I tried to make this manual self-contained
for reader's convenience, i.e. as far as you want to look up
Gauche's features you don't need to refer to other documents.
For example, description of functions defined in the standard
documents are included in this manual, instead of saying
``see the standard document''.   However, this document is not a verbatim
copy of the standard documents; sometimes I omit detailed
discussions in the standard documents for brevity.
I put pointers to the original documents, so please consult them if you
need to refer to the standards.
@c JP
Scheme言語としての側面に関しては、なるべくこのマニュアル一冊でリファレンスとしての
用が足りるように記述しました。標準に定められている関数でも、こちらのマニュアルだけで
使うのに必要な事項を知ることができます。但し、このマニュアルは標準文書の替わりには
なりません。記述を短くするために理論的な背景などは省略してあります。
オリジナルのドキュメントへのポインタを参考文献の項に上げておきましたので、
必要に応じて参照して下さい。
@c COMMON

@c EN
If you're reading this document off-line, you may find the most
recent version on the web:
@c JP
もしあなたがこのマニュアルをオフラインで読んでいるなら、
時々下記のURLをチェックしてみて下さい。更新があるかもしれません。
@c COMMON
@example
@uref{http://www.shiro.dreamhost.com/scheme/gauche/}.
@end example

@menu
* Overview of Gauche::          
* Notations::                   
@end menu

@node Overview of Gauche, Notations, Introduction, Introduction
@section Overview of Gauche
@c NODE  Gaucheの概要

@c EN
Gauche is a script interpreter based on Scheme.
Gauche conforms the language standard
"Revised^5 Report on the Algorithmic Language Scheme"
(@ref{r5rs,[R5RS],R5RS}),
and supports various common libraries defined in SRFIs
(@uref{http://srfi.schemers.org}).
@c JP
GaucheはScheme言語に基づくスクリプトインタプリタです。
Scheme言語の標準である、"Revised^5 Report on the Algorithmic Language Scheme"
(@ref{r5rs,[R5RS],R5RS})に準拠しています。また、SRFI
(@uref{http://srfi.schemers.org}) に規定されている数多くのライブラリを
サポートしています。
@c COMMON

@c EN
The goal of Gauche is to provide a handy tool for
programmers and system administrators to handle
daily works conveniently and efficiently in the production environment.
@c JP
Gaucheは、プログラマやシステム管理者がこなす日常の雑事を
効率よくSchemeで書けるようにすることを目的として設計されています。
@c COMMON

@c EN
There are lots of Scheme implementations available, and each
of them has its design emphasis and weeknesses.  Gauche is
designed with emphasis on the following criteria.
@c JP
世の中には多くのSchemeの実装がありますが、
それぞれの実装には長所と短所があります。
Gaucheが長所とするべく重点を置いているのは次のようなポイントです。
@c COMMON

@table @b
@c EN
@item Quick startup
@c JP
@item 立ち上りが速いこと
@c COMMON
@c EN
One of the situation Gauche is aiming at is in the production
environment, where you write ten-lines throw-away script that
may invoked very frequently.  This includes CGI scripts as well.
Gauche includes a set of most common features in its executable,
while splits less common stuffs into libraries which are to be loaded
on demand, to make itself start quickly.
@c JP
Gaucheが想定している用途のひとつは、プロダクション環境でちょろっと
10行スクリプトをでっちあげて、それが非常に頻繁に呼ばれるようなケースです。
CGIスクリプトなどもそうです。
Gaucheでは、言語のコアとスクリプトとして良く使いそうな機能に絞って
実行ファイルにコンパイルインし、使う分野が特定される機能は必要に応じて
読み込むようにしています。
@c COMMON

@c EN
@item Multibyte strings
@c JP
@item マルチバイト文字列
@c COMMON
@c EN
We can no longer live happily in ASCII-only or 1-byte-per-character world.
The practical language implementations are required to handle
multibyte (wide) characters.
Gauche supports multibyte strings natively, providing robust and
consistent support than @i{ad hoc} library-level implementation.
@xref{Multibyte Strings}, for details.
@c JP
文字列が1バイトキャラクタのみを扱っていれば良かった時代は過ぎ去りました。
現代のプログラミングシステムは、様々なエンコーディングによるマルチバイト文字／文字列を
自然に扱える必要があります。
Gaucheは内部的に文字列を全て、コンパイル時に選択したエンコーディングの
マルチバイト文字列として扱います。後から付け足したライブラリレベルでの
マルチバイト文字列のサポートよりも、一貫性がありロバストな文字列操作が可能になっています。
詳しくは@ref{Multibyte Strings}を参照してください。
@c COMMON

@c EN
@item Modular development
@c JP
@item モジュラー開発
@c COMMON
@c EN
Gauche has a simple module system to separate namespaces,
which allows the developers to work in parallel without
worrying name collision.  
@c JP
Gaucheは名前空間を分離する単純なモジュールシステムを備えており、
名前の衝突を心配せずに複数の開発者が並行して作業をすることができます。
@c COMMON

@c EN
@item Integrated object system
@c JP
@item 統合されたオブジェクトシステム
@c COMMON
@c EN
A powerful CLOS-like object system with MetaObject protocol
(mostly compatible with STklos and Guile) is provided.
@c JP
CLOSライクなメタオブジェクトプロトコルを備えた強力なオブジェクトシステム
が組み込んであります。STklosやGuileのオブジェクトシステムとかなり互換性があります。
@c COMMON

@c EN
@item System interface
@c JP
@item システムインタフェース
@c COMMON
@c EN
Although Scheme abstracts lots of details of the machine,
sometimes you have to bypass these high-level layers and
go down to the basement to make things work.
Gauche has built-in support of most of POSIX.1 system calls.
Other modules, such as networking module, usually provide
both high-level abstract interface and low-level interface
close to system calls.
@c JP
Schemeは計算機の詳細の多くを抽象化しますが、プログラムを書いていると、
それらの高レベル層をバイパスして地下室に降りて作業しなければならないような時が
あります。GaucheはPOSIX.1システムコールのほとんどを組み込みでサポートします。
また、ネットワーキングモジュールなど他のシステム関連モジュールは通常、
高レベルの抽象的なインタフェースと低レベルのシステムコールに近いインタフェースを
両方提供します。
@c COMMON

@c EN
@item Enhanced I/O
@c JP
@item 強化された入出力
@c COMMON
@c EN
No real application can be written without dealing with I/O.
Scheme neatly abstracts I/O as a port, but defines least operations on it.
Gauche uses a port object as a unified abstraction, providing
utility functions to operate on the underlying I/O system.
@xref{Input and output}, for the basic I/O support.
@c JP
本物のアプリケーションはI/O無しでは成り立ちません。
SchemeはI/Oをポートとして簡潔に抽象化していますが、
標準のSchemeには最低限の操作しか定義されていません。
Gaucheはポートオブジェクトを入出力のための統合された抽象化オブジェクトと考え、
それを通して下位のI/Oシステム層にアクセスするユーティリティ関数を提供しています。
@ref{Input and output}を参照して下さい。
@c COMMON
@end table

@c EN
On the other hand, Gauche is @emph{not} designed for 
applications such like high-performance number cruncher or
very large scale database handling.  It is an interpreter, after all.

You can still use Gauche as a "glue" language for such applications,
however.  For example, you can write a performance-critical part 
in another language that compiles to native code, and use Gauche to set up.
@c JP
一方、Gaucheは所詮インタプリタですから、高速に大量の計算をこなしたり
巨大なデータセットを扱ったりするのは苦手です。

但し、そのような場合でも、Gaucheを各コンポーネントをつなぐ「糊」言語として
使うことは可能です。例えば性能の要求の厳しい部分はネイティブコードにコンパイルする言語で
書いておき、セットアップにGaucheを使うといった方法があります。
@c COMMON


@node Notations,  , Overview of Gauche, Introduction
@section Notations
@c NODE 表記について

@c EN
In this manual, each entry is represented like this:

@deftp {Category} foo arg1 arg2
[spec] Description of foo @dots{}
@end deftp
@c JP
このマニュアルでは、各項目は次のようなフォーマットで表記されています。

@deftp {カテゴリ} foo arg1 arg2
[spec] fooの説明
@end deftp
@c COMMON

@c EN
@var{Category} denotes the category of the entry @b{foo}.
The following category will appear in this manual:
@c JP
@var{カテゴリ} は項目@b{foo}の種別を示します。
次のようなカテゴリがあります。
@c COMMON

@multitable @columnfractions .4 .6
@item Function
@c EN
@tab A Scheme function.
@c JP
@tab Scheme手続き
@c COMMON
@item Special Form
@c EN
@tab A special form (in the R5RS term, ``syntax'').
@c JP
@tab 特殊形式 (R5RSでは「構文」)
@c COMMON
@item Macro
@c EN
@tab A macro.
@c JP
@tab マクロ
@c COMMON
@item Module
@c EN
@tab A module
@c JP
@tab モジュール
@c COMMON
@item Class
@c EN
@tab A class.
@c JP
@tab クラス
@c COMMON
@item Generic Function
@c EN
@tab A generic function
@c JP
@tab ジェネリックファンクション
@c COMMON
@item Method
@c EN
@tab A method
@c JP
@tab メソッド
@c COMMON
@item Reader Syntax
@c EN
@tab A lexical syntax that is interpreted by the reader.
@c JP
@tab リーダによって解釈される構文要素
@c COMMON
@end multitable

@c EN
For functions, special forms and macros, the entry may followed
by one or more arguments.  In the argument list, the following notations
may appear:
@c JP
手続き、特殊形式、マクロに関しては、エントリの後に引数の仕様が示されます。
引数リストの中には次のような表記が現れることがあります。
@c COMMON

@table @var
@item arg @dots{}
@c EN
Indicates zero or more arguments.
@c JP
ゼロ個以上の可変個の引数。
@c COMMON
@item &optional x y z
@itemx &optional (x x-default) (y y-default) z
@c EN
Indicates it may take up to three optional arguments.
The second form specifies default values.
Note that Gauche doesn't really support Common-Lisp style
@code{&optional} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@c JP
省略可能な引数の表記。この例では3つまでの省略可能な引数が取られることを示します。
2番目の形式では省略された場合の既定値も示しています。
この表記はCommonLispのスタイルにならっていますが、Gauche自身がラムダリストに
@code{&optional}のような表記を受け付けるわけではないことに注意してください。
マニュアルの表記を簡潔にするためにこのような表現を用いているだけです。
@c COMMON
@item &keyword x y z
@itemx &keyword (x x-default) (y y-default) z
@c EN
Indicates it may take keyword arguments @var{x}, @var{y} and @var{z.}
Note that Gauche doesn't really support Common-Lisp style
@code{&keyword} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@c JP
キーワード引数の表記。この例では@var{x}、@var{y}、@var{z}の3つのキーワード引数を
取ることが示されます。2番目の形式では省略された場合の既定値も示されます。
この表記はCommonLispのスタイルにならっていますが、Gauche自身がラムダリストに
@code{&keyword}のような表記を受け付けるわけではないことに注意してください。
マニュアルの表記を簡潔にするためにこのような表現を用いているだけです。
@c COMMON
@item &rest args
@c EN
Indicates it may take rest arguements.
Note that Gauche doesn't really support Common-Lisp style
@code{&rest} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@c JP
残りの引数全てがリストになって@var{args}に束縛されることを示します。
この表記はCommonLispのスタイルにならっていますが、Gauche自身がラムダリストに
@code{&rest}のような表記を受け付けるわけではないことに注意してください。
マニュアルの表記を簡潔にするためにこのような表現を用いているだけです。
@c COMMON
@end table

@c EN
The description of the entry follows the entry line.
If the specification of the entry comes from some standard or
implementation, its origin is noted in the bracket at the beginning
of the description.  The following origins are noted:
@c JP
説明が項目の行に続きます。もし項目が特定の標準に準拠している場合は、
もととなった標準が次のような形式で示されます。
@c COMMON

@table @asis
@item [R5RS]
@itemx [R5RS+]
@c EN
The entry works as specified in ``Revised^5 Report of Algorithmic Language
Scheme.''.  If it is marked as "[R5RS+]", the entry has additional
functionality.
@c JP
この項目はR5RSに定義されるように動作します。"[R5RS+]"とマークされている場合は
R5RSの仕様に上位互換な形で追加の機能が実装されていることを示します。
@c COMMON
@item [SRFI-@var{n}]
@itemx [SRFI-@var{n}+]
@c EN
The entry works as specified in SRFI-@var{n}.  If it is marked as
"[SRFI-@var{n}+]", the entry has additional functionality.
@c JP
この項目はSRFI-@var{n}に定義されるように動作します。"[SRFI-@var{n}+]"とマークされている場合は
SRFI-@var{n}の仕様に上位互換な形で追加の機能が実装されていることを示します。
@c COMMON
@item [POSIX]
@c EN
The API of the entry reflects the API specified in POSIX.
@c JP
この項目はPOSIXのAPIを反映していることを示します。
@c COMMON
@end table

@c @node Structure of this document,  , Notations, Introduction
@c @section Structure of this document
@c @c NODE 本書の構成

@c @c EN
@c @c JP
@c @c COMMON

@c ======================================================================
@node Concepts, Programming in Gauche, Introduction, Top
@chapter Concepts
@c NODE 主要な概念

@c EN
In this chapter I describe a few Gauche's design concepts
that help you to understand how Gauche works.
@c JP
本章では、Gauche動作の背景となるいくつかの概念を説明します。
Gaucheの動作を正確に理解する助けになると思います。
@c COMMON

@menu
* Standard conformance::        
* Multibyte Strings::           
* Case-sensitivity::            
* Integerated Object System::   
* Module system::               
* Compilation::                 
@end menu

@node Standard conformance, Multibyte Strings, Concepts, Concepts
@section Standard conformance
@c NODE 標準への準拠

@c EN
Gauche conforms "Revised^5 Report of Algorithmic Language Scheme,"
including optional syntax and procedures, except the following features.
@c JP
Gaucheは、以下に挙げる点を除き、オプショナルな構文や手続きも含め
"Revised^5 Report of Algorithmic Language Scheme" に準拠しています。
@c COMMON

@itemize @bullet
@item
@c EN
By default, Gauche reads symbols by case-sensitive way.
A command-line option is provided to make the reader case-insensitive.
(@xref{Case-sensitivity}, for details).
@c JP
デフォルトで、Gaucheはシンボルの名前の大文字小文字を区別します。
コマンドラインオプションによって、大文字小文字を区別しないモードに
切替えることができます(@ref{Case-sensitivity}参照)。
@c COMMON
@item
@c EN
Continuations created in a certain situation
(specifcally, inside a Scheme code that is called from external
C routine) have limited extent (@xref{Continuation}, for details).
@c JP
ある条件下で作られた継続は限られたエクステントを持ちます
(具体的には、Cのコードからコールバックとして呼ばれるSchemeコード内で作られる継続
がこれにあたります)。詳しくは@ref{Continuation}を参照して下さい。
@c COMMON
@item
@c EN
Numeric tower of integer, real, and complex numbers are supported,
but rational numbers are not.  The reader can read rational numbers
but converts them to inexact real numbers.
The number format using '@code{#}' to show insignificant digits is
not supported.
@c JP
Numeric towerは整数、実数、複素数をサポートしていますが、
有理数はサポートしていません。リーダーは有理数の構文を認識しますが、
読む込むと不正確な実数になります。数字のフォーマットのうち、
精度に影響を与えない桁を '@code{#}' で表す構文はサポートされていません。
@c COMMON
@item
@c EN
Procedure @code{rationalize}, @code{transcript-on} and @code{transcript-of}
are not supported.
@c JP
手続き@code{rationalize}、@code{transcript-on}、及び@code{transcript-of}
はサポートされていません。
@c COMMON
@end itemize

@c EN
Gauche also supports the following SRFIs (Scheme Request for Implementation).
@c JP
Gaucheはまた、以下のSRFIをサポートしています。
@c COMMON

@table @asis
@item SRFI-0, Feature-based conditional expansion construct.
@c EN
As an autoloaded macro.   @xref{srfi-0 - Feature conditional}.
@c JP
オートロードされるマクロとしてサポートされます。@ref{srfi-0 - Feature conditional}参照。
@c COMMON

@item SRFI-1, List library.
@c EN
Supported by the module @code{srfi-1}.  @xref{srfi-1 - List library}.
(Some of SRFI-1 procedures are built-in).
@c JP
モジュール@code{srfi-1}でサポートされます。@ref{srfi-1 - List library}参照。
SRFI-1の手続きのうちいくつかは組み込みになっています。
@c COMMON

@item SRFI-2, AND-LET*: an AND with local bindings, a guarded LET* special form.
@c EN
Supported by the module @code{srfi-2}.  @xref{srfi-2 - And-let*}.
@c JP
モジュール@code{srfi-2}でサポートされます。@ref{srfi-2 - And-let*}参照。
@c COMMON

@item SRFI-4, Homogeneous numeric vector datatypes.
@c EN
The module @code{gauche.uvector} provides a superset of
@code{srfi-4} procedures, including arithmetic operations and
generic interface on the SRFI-4 vectors.  @xref{gauche.uvector - Uniform vectors}.
@c JP
モジュール@code{gauche.uvector}が、
@code{srfi-4}の手続きのスーパーセットを提供します。
同モジュールにはSRFI-4の手続きに加え、
算術演算やジェネリックなインタフェースが定義されています。@ref{gauche.uvector - Uniform vectors}参照。
@c COMMON

@item SRFI-6, Basic String Ports.
@c EN
SRFI-6 procedures are built-in.  @xref{String ports}.
@c JP
SRFI-6の手続きは組み込みになっています。@ref{String ports}参照。
@c COMMON


@item SRFI-8, receive: Binding to multiple values.
@c EN
Syntax @code{receive} is built-in.  @xref{Binding constructs}.
@c JP
構文@code{receive}は組み込みになっています。@ref{Binding constructs}参照。
@c COMMON

@item SRFI-9, Defining record types.
@c EN
Supported by the module @code{srfi-9}.  @xref{srfi-9 - Record types}.
@c JP
モジュール@code{srfi-9}でサポートされます。@ref{srfi-9 - Record types}参照。
@c COMMON

@item SRFI-10, Sharp-comma external form.
@c EN
Built-in.  @xref{Read-time constructor}.
@c JP
組み込みです。@ref{Read-time constructor}参照。
@c COMMON

@item SRFI-11, Syntax for receiving multiple values.
@c EN
Supported by the module @code{srfi-11}.  @xref{srfi-11 - Let-values}.
@c JP
モジュール@code{srfi-11}でサポートされます。@ref{srfi-11 - Let-values}参照。
@c COMMON

@item SRFI-13, String library
@c EN
Supported by the module @code{srfi-13}.  @xref{srfi-13 - String library}.
(Some of SRFI-13 procedures are built-in).
@c JP
モジュール@code{srfi-13}でサポートされます。@ref{srfi-13 - String library}参照。
(SRFI-13の手続きのいくつかは組み込みになっています)。
@c COMMON

@item SRFI-14, Character-set library
@c EN
Character-set object and a few SRFI-14 procedures are built-in.
@xref{Character set}.
Complete set of SRFI-14 is supported by the module @code{srfi-14}.
@xref{srfi-14 - Character-set library}.
@c JP
文字集合と基本的なSRFI-14手続きは組み込みになっています。
@ref{Character set}参照。SRFI-14の完全なサポートはモジュール@code{srfi-14}
で提供されています。@ref{srfi-14 - Character-set library}参照。
@c COMMON

@item SRFI-17, Generalized set!
@c EN
Built-in.  @xref{Assignments}.
@c JP
組み込みです。@ref{Assignments}参照。
@c COMMON

@item SRFI-18, Multithreading support
@c EN
Some SRFI-18 features are built-in, and the rest is in @code{gauche.threads}
module.  @xref{gauche.threads - Threads}.
@c JP
いくつかのSRFI-18の機能は組み込みであり、、残りのAPIは
@code{gauche.threads}モジュールで提供されます。@ref{gauche.threads - Threads}参照。
@c COMMON

@item SRFI-19, Time Data Types and Procedures.
@c EN
Time data type is Gauche built-in (@xref{SRFI time}).
Complete set of SRFI-19 is supported by the module @code{srfi-19}.
@xref{srfi-19 - Time data types and procedures}.
@c JP
時間のデータ型はGauche組み込みです(@ref{SRFI time}参照)。
SRFI-19の完全なサポートはモジュール@code{srfi-19}で提供されています。
@ref{srfi-19 - Time data types and procedures}参照。
@c COMMON

@item SRFI-22, Running Scheme scripts on Unix
@c EN
Supported.  @xref{Writing Scheme scripts}.
@c JP
サポートされています。@ref{Writing Scheme scripts}参照。
@c COMMON

@item SRFI-23, Error reporting mechanism.
@c EN
Built-in.   @xref{Signalling errors}.
@c JP
組み込みです。@ref{Signalling errors}参照。
@c COMMON

@item SRFI-25, Multi-dimensional array primitives. 
@c EN
Supported by the module @code{gauche.array}, which defines
superset of SRFI-25.  @xref{gauche.array - Arrays}.
@c JP
モジュール@code{gauche.array}が、SRFI-25のスーパーセットと
なっています。@ref{gauche.array - Arrays}参照。
@c COMMON

@item SRFI-26, Notation for specializing parameters without currying.
@c EN
As an autoloaded macro.  @xref{Making Procedures}.
@c JP
オートロードされるマクロとして定義されています。@ref{Making Procedures}参照。
@c COMMON

@item SRFI-27, Sources of Random Bits.
@c EN
Supported by the module @code{srfi-27}.  @xref{srfi-27 - Sources of random bits}.
@c JP
モジュール@code{srfi-27}でサポートされます。@ref{srfi-27 - Sources of random bits}参照。
@c COMMON

@item SRFI-28, Basic format strings.
@c EN
Gauche's built-in @code{format} procedure is a superset of
SRFI-28 @code{format}.  @xref{Output}.
@c JP
Gauche組み込みの@code{format}がSRFI-28のもののスーパーセットに
なっています。@ref{Output}参照。
@c COMMON

@item SRFI-30, Nested multi-line comments.
@c EN
Supported by the native reader.  @xref{Lexical structure}.
@c JP
ネイティブのリーダでサポートされています。@ref{Lexical structure}参照。
@c COMMON

@item SRFI-31, A special form rec for recursive evaluation
@c EN
Defined as an autoloaded macro.  @xref{Binding constructs}.
@c JP
オートロードされるマクロとして定義されています。@ref{Binding constructs}参照。
@c COMMON

@item SRFI-37, args-fold: a program argument processor
@c EN
Supported by the module @code{srfi-37}.
@xref{srfi-37 - a program argument processor}.
@c JP
モジュール@code{srfi-37}でサポートされます。
@ref{srfi-37 - a program argument processor}参照。
@c COMMON
@end table


@node Multibyte Strings, Case-sensitivity, Standard conformance, Concepts
@section Multibyte Strings
@c NODE マルチバイト文字列

@c EN
Traditionally, a string is considered as a simple array of bytes.
Programmers tend to imagine a string as a simple
array of characters (though a character may occupy more than one byte).
It's not the case in Gauche.
@c JP
伝統的に、文字列は単なるバイトの配列として長く扱われてきました。
一文字が複数バイトを占めるようになっても、
文字列は単純な文字の配列であると考えられがちです。
しかしGaucheにおいては、そうではありません。
@c COMMON

@c EN
Gauche supports @emph{multibyte string} natively,
which means characters are represented by variable number of bytes
in a string.   Gauche retains semantic compatibility of
Scheme string, so such details can be hidden, but it'll helpful
if you know a few points.
@c JP
Gaucheは内部的に@emph{マルチバイト文字列}をサポートします。
すなわち、文字列中の文字が占めるバイト数は一定していません。
Schemeの文字列プリミティブのセマンティクスは保たれているので、
詳細を気にしないでもプログラムは書けますが、
下にあげるいくつかの点を知っておいたほうが良いでしょう。
@c COMMON

@c EN
A string object keeps a type tag and a pointer to the storage
of the string body.  The storage of the body is managed in a sort of
``copy-on-write''
way---if you take substring, e.g. using directly by @code{substring}
or using regular expression matcher, or even if you copy a string
by @code{copy-string}, the underlying storage is shared
(the ``anchor'' of the string is different, so the copied string
is not @code{eq?} to the original string).
The actual string is copied only if you destructively modify it.
@c JP
文字列オブジェクトは型タグと文字列本体へのポインタを保持しています。
文字列本体は「copy-on-write」方式で管理されます。すなわち、@code{substring}
や正規表現を使って部分文字列を切り出したり、あるいは単に文字列をコピーした場合、
文字列オブジェクトそのものは別につくられますが、文字列本体は共有されます。
文字列が破壊的に変更される場合にのみ、文字列本体がコピーされます。
@c COMMON

@c EN
Consequently the algorithm like pre-allocating a string by
@code{make-string} and filling it with @code{string-set!}
becomes @emph{extremely} inefficient in Gauche.  Don't do it.
(It doesn't work with mulitbyte strings anyway).
Sequential access of string is much more efficient
using @emph{string ports} (@xref{String ports}).
@c JP
したがって、@code{make-string}である大きさの文字列をあらかじめアロケート
しておき、@code{string-set!}で順に埋めて行くようなアルゴリズムは
Gaucheでは非常に効率が悪くなります。そのようなアルゴリズムは使わない方が良いでしょう。
(そのようなアルゴリズムはマルチバイト文字列とも相性が良くありません)。
文字列を順に埋めて行く場合は@emph{string ports}を使うのが
効率の良い方法です (@ref{String ports}参照)。
@c COMMON

@c EN
String search primitives such as @code{string-scan} (@xref{String utilities})
and regular expression matcher (@xref{Regular expression})
can return a matched string directly, without
using index access at all.
@c JP
@code{string-scan} (@ref{String utilities}参照) や正規表現
(@ref{Regular expression}参照) など文字列を検索するプリミティブは、
インデックスを介さずに一致した文字列を直接返すことができます。
@c COMMON

@c EN
You can choose @emph{internal} encoding scheme at the time of compiling
Gauche.   At runtime, a procedure @code{gauche-character-encoding}
can be used to query the internal encoding.  Currently, the following
internal encodings are supported.
@c JP
Gaucheのコンパイル時に、文字の@emph{内部エンコーディング}を選択することができます。
実行時に手続き@code{gauche-character-encoding}によってどの内部エンコーディング
でコンパイルされたかを知ることが出来ます。
今のところ、以下のエンコーディングがサポートされています。
@c COMMON

@table @code
@item euc-jp
@c EN
EUC-JP encoding of ASCII, JIS X 0201 kana, JIS X 0212 and JIS X 0213:2000
Japanese character set.
@c JP
ASCII、JIS X 0201カナ、JIS X 0212及びJIS X 0213:2000文字集合のEUC-JP
エンコーディング
@c COMMON
@item sjis
@c EN
Shift-JIS encoding of JIS X 0201 kana and JIS X 0213:2000
Japanese character set.  For source-code compatibility, the character
code between 0 and 0x7f is mapped to ASCII.
@c JP
JIS X 0201カナ及びJIS X 0213:2000文字集合のShift-JISエンコーディング。
ソースコードの互換性のため、文字コード0から0x7fの範囲はJIS X 0201 roman
ではなくASCIIにマップされます。
@c COMMON
@item utf-8
@c EN
UTF-8 encoding of Unicode.
@c JP
UnicodeのUTF-8エンコーディング。
@c COMMON
@item none
@c EN
8-bit fixed-length character encoding, with the code between 0 and 0x7f
matches ASCII.  When converted to Unicode, ISO8859-1 encoding is assumed.
@c JP
8ビット固定長の文字エンコーディング。文字コード0から0x7fの範囲はASCIIと
みなします。Unicodeとの変換の際にはISO8859-1エンコーディングを仮定します。
@c COMMON
@end table

@c EN
Conversions from other encoding scheme is provided 
as a special port. @xref{gauche.charconv - Character code conversion}, for details.
@c JP
他の文字エンコーディングからの変換は特別なポートを使って行われます。
@ref{gauche.charconv - Character code conversion} を参照して下さい。
@c COMMON

@c EN
Gauche assumes the Scheme program is written in its internal
encoding scheme.
@c JP
Gaucheは、Schemeプログラムはその内部エンコーディングと同じエンコーディングで
書かれているものとして読み込みます。
@c COMMON

@node Case-sensitivity, Integerated Object System, Multibyte Strings, Concepts
@section Case-sensitivity
@c NODE 大文字小文字の区別

@c EN
Historically, most Lisp-family languages are case-insensitive
for symbols.  Scheme is no exception and R5RS defines symbols are
read in case-insensitive way.  (Note that symbols are case-sensitive
internally even in R5RS Scheme; case-insensitivity is about readers.)
@c JP
Lisp系の言語は歴史的にシンボルの大文字小文字を区別していませんでした。
Schemeもその流れを汲んでおり、R5RSでもシンボルは読み込まれる時に大文字小文字の
区別をしないと定義されています。(但し、R5RSの範囲内でも内部的なシンボル名は
大文字小文字の区別がなされます。ここで問題としているのは読み込み時の動作です)。
@c COMMON

@c EN
However, nowadays programming is hardly completed in one language.
When you have to interact with other languages that distinguishe uppercase
and lowercase characters, it is desirable that Scheme distinguishes them
as well.
@c JP
しかし現在では、プログラミングが一つの言語で完結することは滅多にありません。
他の言語とインタフェースを取る場合、Scheme側でも大文字小文字を区別するように
しておいた方が便利です。
@c COMMON

@c EN
So Gauche has two modes in reading and writing symbols.
@emph{By default, Gauche reads and writes symbols in case-sensitive manner}.
This behavior doesn't conform R5RS.
@c JP
そこでGaucheでは、シンボルの読み込みと書き出しに2つのモードを用意しました。
@emph{デフォルトのモードでは、Gaucheのリーダとライタはシンボルの大文字小文字を区別します}。
このふるまいは厳密にはR5RSに準拠しません。
@c COMMON

@example
; @r{In case-sensitive mode (default)}
(eq? 'a 'A) @result{} #f  ; #t @r{in R5RS}
(symbol->string 'ABC) @result{} "ABC"
(symbol->string 'abc) @result{} "abc"
(display (string->symbol "ABC")) @result{} @r{writes} ABC
(display (string->symbol "abc")) @result{} @r{writes} abc
@end example

@c EN
You can make Gauche case-insensitive by giving @code{-fcase-fold}
command-line option to the @code{gosh} interpreter (@xref{Invoking Gosh}).
In this mode, the reader folds uppercase characters in symbols to lowercase
ones.  If a symbol name contains uppercase characters, it is written
out using |-escape (@xref{Symbols}).
@c JP
@code{gosh}インタプリタの起動時に@code{-fcase-fold}コマンドライン引数を
与えると、Gaucheは大文字小文字を区別しないモードで動作します (@ref{Invoking Gosh}参照)。
このモードでは、リーダはシンボルの読み込みの際に大文字を小文字に変換します。
大文字を含んでいるシンボルに関しては、`|' 文字でエスケープされて書き出されます
(@ref{Symbols}参照)。
@c COMMON

@example
; @r{In case-insensitive mode (with -fcase-fold option)}
(eq? 'a 'A) @result{} #t
(symbol->string 'ABC) @result{} "abc"
(symbol->string 'abc) @result{} "abc"
(display (string->symbol "ABC")) @result{} @r{writes} |ABC|
(display (string->symbol "abc")) @result{} @r{writes} abc
@end example

@c EN
Right now, there's no way to switch these two modes back and forth
inside the intepreter; an API will be provided in the later versions.
@c JP
今のところ、インタプリタの中から両方のモードを切り替えることはできません。
将来のバージョンではその方法が提供されるでしょう。
@c COMMON


@node Integerated Object System, Module system, Case-sensitivity, Concepts
@section Integrated Object System
@c NODE 統合されたオブジェクトシステム

@c EN
Gauche has a STklos-style object system, similar to CLOS.
If you have used some kind of object oriented (OO) languages,
you'll find it easy to understand the basic usage:
@c JP
GaucheはCLOSに類似した、STklosスタイルのオブジェクトシステムを持っています。
あなたが何らかのオブジェクト指向(OO)言語を使ったことがあれば、
基本的な使い方は簡単にわかるでしょう。
@c COMMON
@example
@c EN
;; @r{Defines a class point, that has x and y coordinate}
@c JP
;; @r{x, y座標を持つpointクラスを定義}
@c COMMON
(define-class point ()
  ((x :init-value 0)
   (y :init-value 0))
  )

(define-method move ((p point) dx dy)
  (inc! (slot-ref p 'x) dx)
  (inc! (slot-ref p 'y) dy))

(define-method write-object ((p point) port)
  (format port "[point ~a ~a]"
          (slot-ref p 'x)
          (slot-ref p 'y)))
@end example

@c EN
However, if you are familiar with mainstream OO langauges but new to CLOS-style
object system, Gauche's object system may look strange
when you look deeper into it.
Here I describe several characteristics of Gauche object system quickly.
@xref{Object system}, for details.
@c JP
しかし、主流のオブジェクト指向言語に慣れてはいるがCLOSスタイルのオブジェクトシステムに
慣れていないプログラマは、Gaucheのオブジェクトシステムの詳細を見てゆくと
奇妙に感じることがあるのではないかと思います。
ここではGaucheのオブジェクトシステムの代表的な性質を簡単に述べておきます。
詳しくは@ref{Object system}の章を参照して下さい。
@c COMMON

@table @emph
@c EN
@item Everything is an object (if you care)
You have seen this tagline for the other languages.
And yes, in Gauche, everything is an object in the sense that you can
query its class, and get various meta information of
the object at run time.  You can also define a new method
on any class including built-in classes.

Note that, however, in CLOS-like paradigm it doesn't really matter
whether everything is an object or not, because of the following
characteristics:
@c JP
@item 全てはオブジェクトである (それが気になる人には)
このような主張は他のOO言語でも見たことがあるでしょう。
Gaucheもその例にもれず、実行時にクラスを得たりメソッドを呼び出したりといった
操作が任意のオブジェクトに対して出来るという意味で、全てはオブジェクトです。
また組込みクラスを含めたどんなクラスに対しても新しいメソッドを定義することができます。

しかし、CLOS系のパラダイムでは、全てがオブジェクトかどうかという議論はあまり
問題ではありません。というのは次のような性質があるからです。
@c COMMON

@c EN
@item Method is dispatched by all of its arguments.
Unlike other object-oriented languages such as C++, Objective-C,
Python, Ruby, etc., in which a method always belong to a single
class, a Gauche method doesn't belong to a specific class.

For example, suppose you define a numeric vector class
@code{<num-vector>} and a numeric matrix class @code{<num-matrix>}.
You can define a method @code{product} with all possible combinations
of those type of arguments:
@c JP
@item メソッドは全ての引数によってディスパッチされる
C++、Objective C、Python、RubyなどのOO言語では、メソッドは特定のクラスに
所属しています。Gaucheではメソッドはクラスに従属しません。

例えば、数値だけを要素に持つベクタークラス@code{<num-vector>}と
行列クラス@code{<num-matrix>}を定義したとします。
プログラマは、以下のようなあらゆる場合についてメソッド@code{product}を
別々に定義することができます。
@c COMMON

@example
  (product <num-vector> <num-matrix>)
  (product <num-matrix> <num-vector>)
  (product <num-vector> <num-vector>)
  (product <num-matrix> <num-matrix>)
  (product <number>     <num-vector>)
  (product <number>     <num-matrix>)
  (product <number>     <number>)
@end example

@c EN
Each method belongs to neither @code{<num-vector>} class nor
@code{<num-matrix>} class.

Since a method is not owned by a class, you can always define your
own method on the existing class (except a few cases
that the system prohibits altering pre-defined methods).  The above
example already shows it; you can make @code{product} method work
on the built-in class @code{<number>}.   That is why I said
it doesn't make much sense to discuss whether everything is object
or not in CLOS-style object system.
@c JP
これらの各メソッドは、@code{<num-vector>}クラスや@code{<num-matrix>}
クラスに所属するわけではありません。

メソッドがクラスに所有されているわけではないので、既に存在するクラスに対していつでも
独自のメソッドを定義することができます(但し、いくつかの組込みクラスの既定のメソッドには
変更できないものがあります)。上の例で既にこれは示されています。プログラマは
メソッド@code{product}を組込みクラス@code{<number>}に対して定義することが
できます。これが、全てはオブジェクトであるかどうかはCLOSスタイルのオブジェクトシステム
では問題にならないと言った理由です。
@c COMMON

@c EN
@item Class is also an instance.
By default, a class is also an instance of class
@code{<class>}, and a generic function is an instance of class
@code{<generic>}.  You can subclass @code{<class>} to customize
how a class is initialized or how its slots are accessed.
You can subclass @code{<generic>} to customize how the
applicable methods are selected, which order those methods are
called, etc.   The mechanism is called @emph{metaobject protocol}.
Metaobject protocol allows you to extend the language by
the language itself.  

To find examples, see the files @code{lib/gauche/singleton.scm} and
@code{lib/gauche/validator.scm} included in the distribution.
You can also read @code{lib/gauche/object.scm}, which actually
defines how a class is defined in Gauche.
For more details about metaobject protocol, see @ref{mop,[MOP],MOP}.
@c JP
@item クラスはインスタンスでもある
デフォルトでは、クラスは@code{<class>}というクラスのインスタンスであり、
ジェネリック関数は@code{<generic>}というクラスのインスタンスです。
しかし、@code{<class>}を継承したクラスを定義することにより、
オブジェクトの初期化がどのように行われるかとか、スロットがどのように
アクセスされるかといった動作をカスタマイズすることができます。
また、@code{<generic>}を継承したクラスを定義することにより、
適用可能なメソッドがどのように選択されて、どのような順序で適用されるか
といったことがカスタマイズ可能です。このメカニズムは@emph{メタオブジェクトプロトコル}
と呼ばれています。メタオブジェクトプロトコルは、言語をその言語そのもので拡張する方法と
言えるでしょう。

例として、ディストリビューションに含まれる@code{lib/gauche/singleton.scm}や
@code{lib/gauche/validator}等があります。@code{lib/gauche/object.scm}を
読めば、クラス自身がGaucheでどのように定義されているかがわかります。
メタオブジェクトプロトコルの更に詳しいことについては、
@ref{mop,[MOP],MOP}が参考になります。
@c COMMON

@c EN
@item Class doesn't create namespace
In the mainstream OO language, a class often creates its own namespace.
This isn't the case in CLOS-style object system.
In Gauche, a namespace is managed by the module system
which is orthogonal to the object system.
@c JP
@item クラスは名前空間を作らない
メインストリームのOO言語ではクラスが名前空間を作ることがよくあります。
CLOSスタイルのオブジェクトシステムはそうではありません。
Gaucheでは、名前空間はオブジェクトシステムとは直交する、
モジュールシステムによって管理されます。
@c COMMON

@end table

@node Module system, Compilation, Integerated Object System, Concepts
@section Module system
@c NODE モジュールシステム

@c EN
Gauche has a simple module system that allows
modularlized development of large software.
@c JP
Gaucheは大きなソフトウェアをモジュール化して開発するための、
単純なモジュールシステムを備えています。
@c COMMON

@c EN
A higher level interface is simple enough from the user's point
of view.   It works like this:
When you want to use the features provided by module
@code{foo}, you just need to say @code{(use foo)} in your code.
This form is a macro and interpreted at compile time.
Usually it loads the files that defines @code{foo}'s features,
and imports the external APIs into the calling module.
@c JP
高レベルのインタフェースを使うのはユーザにとっては非常に簡単です。
モジュール@code{foo}が提供する機能を使いたければ、
プログラム中で@code{(use foo)}と表記するだけです。
このフォームはマクロで、コンパイル時に解釈されます。
通常は、@code{foo}の機能を実装したファイルをロードし、
その外部APIを呼び出したモジュール中にインポートします。
@c COMMON

@c EN
The @code{use} mechanism is built on top of two independent
lower mechanisms, namespace separation and file loading mechanism.
Those two lower mechanisms can be used separately, although it is much more
convenient when used together.
@c JP
@code{use}メカニズムは、名前空間の分離とファイルローディングという
二つの独立な低レベルのメカニズムの上に実装されています。
これらの低レベルメカニズムはそれぞれ別々に使うこともできます。
@c COMMON

@c EN
The @code{use} mechanism is not transitive; that is,
if a module B uses a module A, and a module C uses the module B,
C doesn't see the bindings in A.  It is because B and A is not in the
@var{is-a} relationship.
Suppose the module A implements a low-level functionality and
the module B implements a high-level abstraction; if C is using
B, what C wants to see is just a high-level abstraction, and
doesn't concern how B implements such functionality.  If C wants
to access low-level stuff, C has to @var{use} A explicitly.
@c JP
@code{use}メカニズムは非遷移的です。すなわち、
モジュールBがモジュールAを'use'し、さらにモジュールCがモジュールBを
'use'している場合、モジュールCからはモジュールA内の束縛は見えません。
BとAは@var{is-a}関係ではないためです。
例えばモジュールAが低レベルの操作を実装し、
モジュールBがその上に高レベルの抽象的なインタフェースを実装しているとしましょう。
モジュールCがモジュールBを'use'しているということは、
CはBの提供する抽象レイヤに興味があるということです。
もしCがさらに低レベルの層にもアクセスしたいならば、CはAを明示的に'use'しなければ
なりません。
@c COMMON

@c EN
There is another type of relationship, though.  You might want to
take an exiting module A, and add some interface to it and provide
the resulting module B as an extension of A.  In such a case,
B is-a A, and it'd be natural that the module that uses B can also
see A's bindings.   In Gauche, it is called @emph{module inheritance}
and realized by @code{extend} form.
@c JP
しかし、別の形の関係が必要な場合もあります。例えば既存のモジュールAに
ちょっと新しいインタフェースを付け加えたモジュールBをAの拡張として
提供したいという場合です。この時、BとAは@var{is-a}関係であり、Bを'use'
しているモジュールからA内の束縛も見えるのが自然です。
Gaucheでは、これをモジュールの継承と呼び、
@code{extend}フォームにより実現しています。
@c COMMON

@c EN
The following sections in this manual describes
modules in details.
@itemize @bullet
@item
@ref{Writing Gauche modules} explains the convention of
writing modules.
@item
@ref{Modules} describes special forms and macros to
define and to use modules, along the built-in functions
to introspect module internals.
@end itemize
@c JP
以下のセクションでモジュールの機能について詳しく説明しています。
@itemize @bullet
@item
@ref{Writing Gauche modules} ではモジュールの書き方について
説明します。
@item
@ref{Modules} ではモジュールを定義したり使うための特殊形式とマクロ、
およびモジュールの内部を調べるための組込み手続きについて説明します。
@end itemize
@c COMMON

@node Compilation,  , Module system, Concepts
@section Compilation
@c NODE コンパイル

@c EN
Gauche is a Scheme interpreter, in the sense that it reads
a Scheme form at a time and evaluates it.   Actually,
Gauche compiles every toplevel form into an intermediate form
before executing.
@c JP
Gaucheは、Schemeフォームをひとつづつ読み込んでは評価するという意味では
インタプリタです。しかし内部では、Gaucheはひとつひとつのフォームを中間形式に
コンパイルして仮想マシンで実行しています。
@c COMMON

@c EN
Built-in sytanxes and macros are recognized and expanded
at the compilation time.  Some built-in procedures are
expanded in-line as far as the compiler can see the global
binding is not altered at the time the form is compiled.
@c JP
組み込みの構文とマクロはコンパイル時に認識されて展開されます。
よく使われる組み込み関数は、コンパイル時にグローバルな束縛が置き換わっていない場合に、
インライン展開されます。
@c COMMON

@c EN
This raises a few problems you should care.
@c JP
プログラマは通常、コンパイラの動作を気にする必要はほとんどありませんが、
いくつかの点に注意する必要があります。
@c COMMON

@table @emph
@c EN
@item load is done at run time.
@code{load} is a procedure in Gauche, therefore evaluated at run time.
If the loaded program defines a macro, which is available for the compiler
after the toplevel form containing @code{load} is evaluated.  So, suppose
@code{foo.scm} defines a macro @code{foo}, and you use the macro
like this:
@c JP
@item loadは実行時に評価される
@code{load}はGaucheでは一般の関数なので、実行時に評価されます。
ロードされるファイル中でマクロを定義している場合、そのマクロは
その@code{load}の呼び出しを含むトップレベルフォームが評価された後で
有効になります。例えば、@code{foo.scm}がマクロ@code{foo}を定義しているとして、
次のような用法を考えてみてください。
@c COMMON
@example
;; @r{in ``foo.scm''}
(define-syntax foo
  (syntax-rules () (_ arg) (quote arg)))

;; @r{in your program}
(begin (load "foo") (foo (1 2 3)))
  @result{} @r{error, bad procedure: `1'}

(load "foo")
(foo (1 2 3)) @result{} '(1 2 3)
@end example
@c EN
The @code{(begin (load ...))} form fails,  because the compiler
doesn't know @code{foo} is a special form at the compilation time
and compiles @code{(1 2 3)} as if it is a normal procedure call.
The latter example works, however, since the execution
of the toplevel form @code{(load "foo")} is done before
@code{(foo (1 2 3))} is compiled.
@c JP
@code{begin}で@code{load}と@code{foo}の呼び出しを囲んだ場合、
コンパイラはまず@code{begin}全体をコンパイルします。その時点でマクロ
@code{foo}は定義されていませんから、これは評価時にエラーになります。
一方、後者では@code{load}が評価されてから@code{foo}がコンパイルされるので、
問題は起きません。
@c COMMON

@c EN
To avoid this kind of subtleties, use @code{require} or @code{use}
to load a program fragments.  Those are recognized by the compiler.
@c JP
このような混乱を避けるために、別のプログラムファイルを読み込む必要がある時は
@code{require}か@code{use}を使うことを勧めます。これらは構文であり、
コンパイラに認識されます。
@c COMMON

@c EN
@item require is done at compile time
On the other hand, since @code{require} and @code{use} is recognized
by the compiler, the specified file is loaded even if the form
is in the conditional expression.   If you really need to load
a file on certain condition, use @code{load} or do dispatch in macro
(i.e. at compile time).
@c JP
@item require はコンパイル時に評価される
上記の裏返しですが、@code{require}と@code{use}はコンパイル時に
解釈されます。したがって、@code{if}などの条件文のボディにこれらのフォームを
置いておいても、指定されたファイルは条件にかかわらず読み込まれてしまいます。
どうしてももし条件によって読み込むかどうかを変えたい場合は、@code{load}を使うか、
条件判断自体をマクロで行うようにしてください。
@c COMMON
@end table

@c ======================================================================
@node Programming in Gauche, Core syntax, Concepts, Top
@chapter  Programming in Gauche
@c NODE Gaucheでのプログラミング

@menu
* Invoking Gosh::               
* Interactive development::     
* Debugging::                   
* Writing Scheme scripts::      
* Writing Gauche modules::      
@end menu

@node Invoking Gosh, Interactive development, Programming in Gauche, Programming in Gauche
@section Invoking Gosh
@c NODE Gaucheを起動する

@c EN
Gauche can be used either as an independent Scheme interpreter
or as an embedded Scheme library.   The interpreter
which comes with Gauche distribution is a program named @code{gosh}.
@c JP
Gaucheは独立したSchemeインタプリタとしても、組み込みのSchemeライブラリとしても
使うことができます。Gaucheのディストリビューションには、@code{gosh}という
インタプリタが附属しています。
@c COMMON

@deftp {Program} gosh [options] [scheme-file arg @dots{}]
@c EN
Gauche's interpreter.   Without @var{scheme-file}, @code{gosh} works
interactively, i.e. it reads a Scheme expression from the standard input,
evaluates it, and prints the result, and repeat that until it reads EOF or
is terminated.
@c JP
Gaucheのインタプリタです。  @var{scheme-file}が与えられなければ、
@code{gosh}はインタラクティブに動作します。すなわち、標準入力からScheme式を読み込み、
それを評価して結果をプリントするという動作を、EOFを読むか明示的に終了させられるまで
続けます。
@c COMMON

@c EN
If @code{gosh} is invoked without @var{scheme-file}, but the input
is not a terminal, it enters read-eval-print loop but not writes
out a prompt while waiting input form.  This is useful when you
pipe Scheme program into @code{gosh}.  You can force this behavior
or suppress this behavior by @code{-b} and @code{-i} options.
@c JP
もし@var{scheme-file}が与えられておらず、しかし入力が端末でない場合、
@code{gosh}はread-eval-printループに入りますが、入力待ちの際にプロンプトを
表示しません。これはScheme式をパイプで@var{gosh}に処理させる場合に便利です。
@code{-b}または@code{-i}オプションでこの動作を強制的にonまたはoffできます。
@c COMMON

@c EN
If @var{scheme-file} is specified, @code{gosh} runs it as a
Scheme program and exit.
@xref{Writing Scheme scripts}, for details.
@c JP
@var{scheme-file}が与えられた場合、@code{gosh}はそれをSchemeプログラムとして
ロードし、終了します。この動作に関しては@ref{Writing Scheme scripts}を参照して
下さい。
@c COMMON
@end deftp

@c EN
The following command line options are recognized by @code{gosh}.
The first command line argument which doesn't begin with `@minus{}'
is recognized as the script file.  If you want to specify a file
that begins with a minus sign, use a dummy option `@code{--}'.
@c JP
以下のコマンドラインオプションが@code{gosh}に認識されます。
`@minus{}' で始まらない最初のコマンドライン引数がスクリプトファイルと認識されます。
スクリプトファイル名が `@minus{}' で始まっている可能性がある場合は、ダミーオプション
`@code{--}' をスクリプトファイル名の前に置いて下さい。
@c COMMON

@deftp {Command Option} -I path
@c EN
Prepends @var{path} to the load path list.
You can specify this option more than once to add multiple paths.
@c JP
@var{path}をロードパスのリストの最初に加えます。このオプションは複数指定できます。
@c COMMON
@end deftp

@deftp {Command Option} -A path
@c EN
Appends @var{path} to the tail of the load path list.
You can specify this option more than once to add multiple paths.
@c JP
@var{path}をロードパスのリストの末尾に加えます。このオプションは複数指定できます。
@c COMMON
@end deftp

@deftp {Command Option} -q
@c EN
Makes @code{gosh} not to load the default initialization file.
@c JP
@code{gosh}が起動時にシステムの初期化ファイルを読まないようにします。
@c COMMON
@end deftp

@deftp {Command Option} -V
@c EN
Prints the @code{gosh} version and exits.
@c JP
@code{gosh}のバージョンを表示して終了します。
@c COMMON
@end deftp

@deftp {Command Option} -u module
@c EN
Use @var{module}.  Before starting execution of @var{scheme-file} or entering
the read-eval-print loop, the specified module is @var{use}d, i.e.
it is loaded and imported (@xref{Defining and selecting modules}, for details of @code{use}).
You can specify this option more than once to use multiple modules.
@c JP
起動後、インタラクティブなread-eval-printループに入る前、もしくは@var{scheme-file}
をロードする前に@var{module}を``use''します。つまりそのモジュールがロードされ
インポートされます。(@code{use}の詳細については@ref{Defining and selecting modules}を参照して下さい)。
このオプションは複数回指定できます。
@c COMMON
@end deftp

@deftp {Command Option} -l file
@c EN
Load @var{file} before starting execution of @var{scheme-file} or entering
the read-eval-print loop.   The file is loaded in the same way as
@code{load} (@xref{Loading Scheme file}).
You can specify this option more than once to load multiple files.
@c JP
起動後、インタラクティブなread-eval-printループに入る前、もしくは@var{scheme-file}
をロードする前に@var{file}をロードします(ロードの詳細については@ref{Loading Scheme file}
を参照して下さい)。このオプションは複数回指定できます。
@c COMMON
@end deftp

@deftp {Command Option} -e scheme-expression
@c EN
Evaluate @var{scheme-expression}
before starting execution of @var{scheme-file} or entering
the read-eval-print loop.   Evaluation is done in the
@var{interaction-environment} (@xref{Eval and repl}).
You can specify this option more than once to evaluate multiple experssions.
@c JP
起動後、インタラクティブなread-eval-printループに入る前、もしくは@var{scheme-file}
をロードする前に@var{scheme-expression}を評価します。評価は
@var{interaction-environment}中で行われます(@ref{Eval and repl}参照)。
このオプションは複数回指定できます。
@c COMMON
@end deftp

@deftp {Command Option} -E scheme-expression
@c EN
Same as -e, except the @var{scheme-experssion} is read
as if it is surrounded by parenthesis.  For example:
@c JP
オプション-eとほぼ同じですが、@var{scheme-expression}は
それが括弧で囲まれているかのように読まれます。
このオプションは複数回指定できます。例：
@c COMMON
@example
% gosh -umath.const -E"print (sin (* pi/180 15))" -Eexit
0.25881904510252074
@end example
@end deftp

@deftp {Command Option} -b
@c EN
Batch. Does not print prompts in read-eval-print loop even if
the input is a terminal.
@c JP
バッチ。入力が端末であっても、read-eval-printループがプロンプトを出さないようにします。
@c COMMON
@end deftp

@deftp {Command Option} -i
@c EN
Interactive. Print prompts in read-eval-print loop even if
the input is not a terminal.
@c JP
インタラクティブ。入力が端末で無くても、read-eval-printループが
プロンプトを出すようにします。
@c COMMON
@end deftp

@deftp {Command Option} -f compiler-option
@c EN
This option controls compiler and runtime behavior.  For now we have
following options available:
@table @asis
@item no-inline
Prohibits the compiler from inilining primitive Scheme procedures.
@item no-source-info
Don't keep source information for debugging.  Consumes less memory.
@item load-verbose
Reports whenever a file is loaded.
@item case-fold
Ignore case for symbols as specified in R5RS.
(It is distinguished by default).  @xref{Case-sensitivity}.
@item test
Adds "@code{../src}" and "@code{../lib}" to the load path before loading 
initialization file.  This is useful when you want to test the
compiled @code{gosh} interpreter inside source tree, without installing it.
@end table
@c JP
このオプションはコンパイラとランタイムの動作に影響を与えます。
今のところ、次のオプションのみが@var{compiler-option}として有効です。
@table @asis
@item no-inline
Schemeの基本関数のインライン展開を行いません。
@item no-source-info
デバッグのためのソースファイル情報を保持しません。メモリの使用量は小さくなります。
@item load-verbose
ファイルがロードされる時にそれを報告します。
@item case-fold
R5RSに示される通り、シンボルの大文字小文字を区別しません。
(デフォルトではこれらは区別されます)。 @ref{Case-sensitivity} を参照して下さい。
@item test
"@code{../src}" と "@code{../lib}" を、初期化ファイルを読む前に
ロードパスに加えます。これは、作成された@code{gosh}をインストールせずに
ソースツリーの中で実行してみるのに便利です。
@end table
@c COMMON
@end deftp

@deftp {Command Option} @code{--}
@c EN
When @code{gosh} sees this option, it stops processing the options
and takes next command line argument as a script file.  It is useful
in case if you have a script file that begins with a minus sign,
although it is not generally recommended.
@c JP
このオプションに出会うと、@code{gosh}はオプションの解析を止めて、その次の引数を
無条件に@var{scheme-file}であると見倣します。@var{scheme-file}がマイナス記号で
始まっている場合に必要です。
@c COMMON
@end deftp

@c EN
The options -I, -A, -l, -u, -e and -E are processes in the order
of appearance.  For example, adding a load path by -I affects the
-l and -u option after it but not before it.
@c JP
オプション-I, -A, -l, -u, -e 及び -E は、それらがコマンドライン引数として
出現した順に処理されます。例えば、-Iにより追加されるロードパスは
それ以降の-lや-uオプションに影響を与えますが、それ以前のものには影響を
与えません。
@c COMMON

@c ----------------------------------------------------------------------
@node Interactive development, Debugging, Invoking Gosh, Programming in Gauche
@section Interactive development
@c NODE  インタラクティブな開発

@c EN
When @code{gosh} is invoked without any script files,
it goes into interactive read-eval-print loop.
@c JP
スクリプトファイルが与えられなかった場合、
@code{gosh}はインタラクティブなread-eval-printループに入ります。
@c COMMON

@c EN
To exit the interpreter, type EOF (usually Control-D in Unix termials)
or evaluate @code{(exit)}.
@c JP
インタプリタを終了するには、EOF文字(Unix端末では通常Control-D)をタイプするか、
@code{(exit)}を評価します。
@c COMMON

@c EN
I recommend you to run @code{gosh} inside Emacs, for it has
rich features useful to interact with internal Scheme process.
Put the following line to your @file{.emacs} file:
@example
(setq scheme-program-name "gosh")
@end example
And you can run @code{gosh} by @key{M-x run-scheme}.
@c JP
@code{gosh}をEmacs内部で走らせることをお勧めします。
EmacsはSchemeサブプロセスを操作するための豊富な機能を持っています。
次の行を@file{.emacs}に加えておくと、@key{M-x run-scheme} で
Emacsのバッファ内で@code{gosh}が走ります。
@example
(setq scheme-program-name "gosh")
@end example
@c COMMON

@c EN
If you want to use multibyte characters in the interaction,
make sure your terminal's settings is in sync with @code{gosh}'s
internal character encodings.
@c JP
対話環境でマルチバイト文字を使う場合は、端末の文字エンコーディングを@code{gosh}の
内部エンコーディングと合わせるようにして下さい。
@c COMMON

@c EN
Currently @code{gosh} has no fancy features such as
line-editing or command history.   They'll be added in future.
@c JP
今のところ、@code{gosh}は行編集やコマンドヒストリなどの便利な機能を
備えていません。将来はこのへんも充実してゆくでしょう。
@c COMMON

@c EN
@xref{gauche.interactive - Interactive session}, for some procedures useful in
interactive session.
@c JP
インタラクティブセッションで便利な手続きが@ref{gauche.interactive - Interactive session}で定義されています。
@c COMMON

@c ----------------------------------------------------------------------
@node Debugging, Writing Scheme scripts, Interactive development, Programming in Gauche
@section Debugging
@c NODE デバッグ

@c EN
Gauche doesn't have much support for debugging yet.
The idea of good debugging interfaces are welcome.
@c JP
Gaucheにはまだデバッグをサポートする機能があまり実装されていません。
デバッギングのインタフェースに関して良いアイディアがあればお寄せください。
@c COMMON

@c EN
For now, the author uses the classic 'debug print stub' technique
when necessary.  A special reader syntax @code{#?=@var{expr}} is
defined, which is read as @code{(debug-print @var{expr})}.
The macro @code{debug-print} evaluates and returns the result(s),
printing messages before and after evaluation of @var{expr}.
@c JP
今のところ、作者は必要な時は古典的な「プリントスタブ」方式を使っています。
そのためのリーダーマクロ @code{#?=@var{expr}} が定義されています。
これは @code{(debug-print @var{expr})} のように読まれ、
マクロ @code{debug-print} は@var{expr}を評価してその値を返しますが、
評価前と評価後にメッセージを出力します。
@c COMMON

@example
gosh> #?=(+ 2 3)
#?="(stdin)":1:(+ 2 3)
#?-    5
5
gosh> #?=(begin (print "foo") (values 'a 'b 'c))
#?="(stdin)":2:(begin (print "foo") (values 'a 'b 'c))
foo
#?-    a
#?+    b
#?+    c
a
b
c
gosh> (define (fact n)
        (if (zero? n)
            1
            (* n #?=(fact (- n 1)))))
fact
gosh> (fact 5)
#?="(stdin)":6:(fact (- n 1))
#?="(stdin)":6:(fact (- n 1))
#?="(stdin)":6:(fact (- n 1))
#?="(stdin)":6:(fact (- n 1))
#?="(stdin)":6:(fact (- n 1))
#?-    1
#?-    1
#?-    2
#?-    6
#?-    24
120
@end example

@c EN
You can also use trace/untrace macros in Gauche, written by Shigenobu Kimura:
@url{http://homepage.mac.com/skimu/ggc/}.
@c JP
また、木村栄伸さんがGauche用のtrace/untraceマクロを書いてくれました：
@url{http://homepage.mac.com/skimu/ggc/}.
@c COMMON

@c ----------------------------------------------------------------------
@node Writing Scheme scripts, Writing Gauche modules, Debugging, Programming in Gauche
@section Writing Scheme scripts
@c NODE Schemeスクリプトを書く

@c EN
When a Scheme program file is given to @code{gosh}, it
bounds a global varialbe @code{*argv*} to the list of the remaining
command-line arguments, then loads the Scheme program.
If the first line of @var{scheme-file} begins with two character
sequence ``@code{#!}'', the entire line is ignored by @code{gosh}.
This is useful to write a Scheme program that works as an executable
script in unix-like systems.
@c JP
@code{gosh}のコマンドラインにSchemeプログラムのファイル名が渡された場合、
@code{gosh}はそれ以降のコマンドライン引数のリストをグローバル変数@code{*argv*}に束縛し、
Schemeプログラムをロードします。もし@var{scheme-file}の最初の行が``@code{#!}''で始まって
いたら、その行は無視されます。これにより、Unix系のシステムで実行可能なSchemeスクリプト
を書くことが出来ます。
@c COMMON

@c EN
Typical Gauche script has the first
line like these
@example
#!/usr/local/bin/gosh
  @r{or,}
#!/usr/bin/env gosh
  @r{or,}
#!/bin/sh
:; exec gosh -- $0 "$@@"
@end example
The second and third form uses a ``shell trampoline'' technique
so that the script works as far as @code{gosh} is in the PATH.
The third form is useful when you want to pass extra arguments
to @code{gosh}, for typically @code{#!}-magic of executable scripts
has limitations for the number of arguments to pass the interpreter.
@c JP
典型的なGaucheスクリプトの最初の行は次のようなものです。
@example
#!/usr/local/bin/gosh
  @r{または,}
#!/usr/bin/env gosh
  @r{または,}
#!/bin/sh
:; exec gosh -- $0 "$@@"
@end example
後の2つは「シェルトランポリン」テクニックを用いて、@code{gosh}がPATHにあるディレクトリの
どこかにあれば起動できるようにしています。3番目の方法は、
@code{gosh}にいくつかコマンドラインオプションを渡したい時に便利です。
@c COMMON

@c EN
After the file is successfully loaded, @code{gosh} calls a
procedure named `@code{main}' if it is defined in the user module.
@code{Main} receives a single argument, a list of command line
arguments.  Its first element is the script name itself.

When @code{main} returns, and its value is an integer, @code{gosh}
uses it for exit code of the program.
Otherwise, @code{gosh} exits with exit code 70 (@code{EX_SOFTWARE}).
This behavior is compatible with the SRFI-22.

(@emph{Note: this interface has been changed from Gauche release 0.5
in incompatible way.   @xref{Script compatibility before release 0.5},
for details.})

If the @code{main} procedure is not defined, @code{gosh} exits
after loading the script file.
@c JP
ファイルが正常にロードされたら、@code{gosh}は
userモジュールに `@code{main}' という手続きが定義されているかどうか調べ、
定義されていればそれを呼びます。@code{main}には、スクリプトへの引数のリストが
唯一の引数として渡されます。リストの最初の要素はスクリプトファイル名です。

@code{main}が整数の値を返したら、@code{gosh}はその値を終了ステータスとして終了します。
@code{main}が整数以外の値を返した場合は@code{gosh}は終了ステータス70
(@code{EX_SOFTWARE})で終了します。このふるまいはSRFI-22と互換です。

(@emph{注：このインタフェースはGauche release 0.5から非互換な形で
変更されました。@ref{Script compatibility before release 0.5}を参照して下さい。})

@code{main}が定義されていなければ@code{gosh}はロード後にそのままステータス0で
終了します。
@c COMMON

@c EN
Although you can still write the program
main body as toplevel expressions, like shell scripts or Perl scripts,
it is much convenient to use this `@code{main}' convention, for
you can load the script file interactively to debug.
@c JP
シェルスクリプトやPerlスクリプトと同じように、スクリプトのボディに直接
実行される式を書くこともできますが、なるべく `@code{main}' を使った方法を
使うことをお薦めします。そうすると、スクリプトをインタプリタにインタラクティブに
ロードしてデバッグすることもできます。
@c COMMON


@defvar *argv*
@c EN
The program arguments passed to the Scheme script is bound to this
variable.  If @code{gosh} is invoked in an interactive mode, this
variable always contains @code{()}.

STk uses this variable to pass the command line argument as well,
but other Scheme implementations use different ways.  It is better
to define @code{main} procedure and uses its argument to receive
command line arguments, for it is expected to be more portable.
@c JP
Schemeスクリプト以降のコマンドライン引数のリストは、スクリプトのロードの前に
この変数に束縛されます。@code{gosh}がインタラクティブモードで起動された場合は
この変数は@code{()}となります。

この変数はSTkと互換性がありますが、他のScheme実装は違った方法を使ってコマンドライン
引数を得ます。ポータブルなスクリプトを書くには、@code{main}手続きを使う方法を
お薦めします。
@c COMMON
@end defvar

@defvar *program-name*
@c EN
This variable is bound to the script file name passed to @code{gosh}.
If @code{gosh} is invoked in the interactive mode, this variable
contains the pathname of @code{gosh} itself.

STk uses the same variable to access the program/script name.
Other Scheme implementations use different ways.
@c JP
この変数はスクリプトファイル名に束縛されます。インタラクティブモードでは
この変数は@code{gosh}自身の名前を持っています。

この変数はSTkと互換性がありますが、他の実装は違った方法を使います。
@c COMMON
@end defvar

@c EN
Now I show several simple examples below.
First, this script works like @code{cat(1)}, without any command-line
option processing and error handling.
@c JP
いくつか簡単な例を示します。最初の例はUnixの@code{cat(1)}コマンドを模するものです。
エラー処理やコマンドラインオプションの処理は行っていません。
@c COMMON

@example
#!/usr/bin/env gosh

(define (main args)   ;@r{entry point}
  (if (null? (cdr args))
      (copy-port (current-input-port) (current-output-port))
      (for-each (lambda (file)
                  (call-with-input-file file
                    (lambda (in)
                      (copy-port in (current-output-port)))))
                (cdr args)))
  0)
@end example

@c EN
The following script is a simple grep command.
@c JP
次のスクリプトは簡単なgrepコマンドです。
@c COMMON

@example
#!/usr/bin/env gosh

(define (usage)
  (format (current-error-port)
          "Usage: ~a regexp file ...\n" *program-name*)
  (exit 2))

(define (grep rx port)
  (with-input-from-port port
    (lambda ()
      (port-for-each
       (lambda (line)
         (when (rxmatch rx line)
           (format #t "~a:~a: ~a\n"
                   (port-name port)
                   (- (port-current-line port) 1)
                   line)))
       read-line))))

(define (main args)
  (if (null? (cdr args))
      (usage)
      (let ((rx (string->regexp (cadr args))))
        (if (null? (cddr args))
            (grep rx (current-input-port))
            (for-each (lambda (f)
                        (call-with-input-file f
                          (lambda (p) (grep rx p))))
                      (cddr args)))))
  0)
@end example

@c EN
See also @ref{gauche.parseopt - Parsing command-line options}, for a convenient way to
parse command-line options.
@c JP
コマンドライン引数を処理するモジュールがあります。
@ref{gauche.parseopt - Parsing command-line options}を参照してください。
@c COMMON

@menu
* Script compatibility before release 0.5::  
@end menu

@node Script compatibility before release 0.5,  , Writing Scheme scripts, Writing Scheme scripts
@subsection Script compatibility before release 0.5
@c NODE リリース0.5以前とのスクリプトの互換性

@c EN
In order to conform final SRFI-22,
Gauche release 0.5.1 changes the way @code{main} is called.
Unfortunately, this makes the Scheme scripts that is written for older
Gauche no longer work.
I decided to take this change now, in the early stage of Gauche,
rather than keeping incomatibility to the standard (srfi).
@c JP
SRFI-22に準拠するために、Gaucheはリリース0.5.1から@code{main}の呼ばれ方を
変更しました。残念ながら、この変更によりそれ以前のGaucheのために書かれたスクリプトは
動作しなくなります。
標準(srfi)との非互換性を後々まで引きずるよりは、まだ開発の早い段階の今の時点で
変更をしておいたほうが良いと判断しました。
@c COMMON

@c EN
The incompatible changes are these two points.
@c JP
非互換な変更は以下の2点です。
@c COMMON
@itemize @bullet
@item
@c EN
The argument list passed to @code{main} now includes the script
name itself as the first element.  In older version, only the
arguments after the script file name are passed.
@c JP
@code{main}に渡されるコマンドライン引数リストは、その第一要素にスクリプトファイル名を
持つようになります。古いバージョンではスクリプトファイル名以降のコマンドライン引数だけが
渡されていました。
@c COMMON
@item
@c EN
When @code{main} returns non-integral value, @code{gosh} exits
with code 70.  In older version, @code{gosh} exits with code 0
in such case.
@c JP
@code{main}が整数でない値を返した場合、@code{gosh}は終了ステータス70で終了します。
古いバージョンではこのような場合、終了ステータス0で終了していました。
@c COMMON
@end itemize

@c ----------------------------------------------------------------------
@node Writing Gauche modules,  , Writing Scheme scripts, Programming in Gauche
@section Writing Gauche modules
@c NODE Gaucheのモジュールを書く

@c EN
Gauche's libraries are organized by modules.   Although Gauche
can load any valid Scheme programs, there is a convention that
Gauche library follows.    When you write a chunk of Scheme
code for Gauche, it is convenient to make it a module,
so that it can be shared and/or reused.
@c JP
Gaucheのライブラリはモジュール毎に整理されています。Gaucheはどんな形式でも、
有効なScheme式が書かれてさえいればロードすることができますが、
Gaucheのライブラリは一定の形式を保って書かれています。
Gauche用にまとまったSchemeコードを書いたら、それをモジュール形式にしておくと
再利用がしやすくなるでしょう。
@c COMMON

@c EN
Usually a module is contained in a file, but you can make
a multi-file module.   
First I explain the structure of a single-file module.
The following template is the convention used in Gauche's libraries.
@c JP
通常ひとつのファイルで
ひとつのモジュールを定義しますが、モジュールを複数のファイルに分けることもできます。
まずひとつのファイルでモジュールを定義する方法を説明します。
Gaucheのライブラリで使われているテンプレートは次のような形式です。
@c COMMON

@example
@c EN
;; Define the module interface
@c JP
;; モジュールのインタフェースの定義
@c COMMON
(define-module foo
  (use xxx)
  (use yyy)
  (export foo1 foo2 foo3)
  )
@c EN
;; Enter the module
@c JP
;; モジュール本体
@c COMMON
(select-module foo)

@dots{} module body @dots{}

@c EN
;; Make `require' happy
@c JP
;; `require' に対応するprovide
@c COMMON
(provide "foo")
@end example

@c EN
This file must be saved as ``foo.scm'' in some directory in the
@code{*load-path*}.
@c JP
このファイルは``foo.scm''という名で、@code{*load-path*}にあるディレクトリの
いずれかに置かれなければなりません。
@c COMMON

@c EN
The @code{define-module} form creates a module @code{foo}.
It also loads and imports some other modules by `@code{use}' macros,
and declares which symbols the @code{foo} module exports, by `@code{export}'
syntax.
(See section @ref{Defining and selecting modules}, for detailed specification of those
syntaxes).
@c JP
まず、@code{define-module}フォームがモジュール@code{foo}を作成します。
@code{define-module}フォーム内で、このモジュールが依存している他のモジュール
を `@code{use}' マクロを使ってロードし、このモジュールがエクスポートするシンボルを
`@code{export}' 構文を使って指定します。(これらの構文の詳細は@ref{Defining and selecting modules}を
参照して下さい)。
@c COMMON

@c EN
Those @code{use} forms or @code{export} forms are not required to appeare
in the @code{define-module} form, but it is a good convention to keep
them in there at the head of the file so that it is visually recognizable
which modules @code{foo} depends and which symbols it exports.
@c JP
これらの@code{use}フォームや@code{export}フォームは必ずしも@code{define-module}
フォームの先頭に置く必要はありませんが、このようにファイルの最初の方に固めておくことで、
@code{foo}が依存しているモジュール群や@code{foo}が提供するシンボル等が
一覧しやすくなります。
@c COMMON

@c EN
The second form, `@code{select-module}', 
specifies the rest of the file is evaluated in the
module @code{foo} you just defined.   Again, this is just a
convention; you can write entire module body inside @code{define-module}.
However, I think it is error-prone, for the closing parenthesis
can be easily forgotten or the automatic indentation mechanism of
editor will be confused.
@c JP
次の、`@code{select-module}' フォームにより、それ以降のScheme式が
モジュール@code{foo}の中で評価されます。モジュールの内容を全て@code{define-module}の中に
書いてしまうことも出来ますが、最後の括弧を閉じ忘れやすいことや、エディタのインデントが
狂うことなどから、あまりお薦めしません。
@c COMMON

@c EN
After @code{select-module} you can write whatever Scheme expression.
It is evaluated in the selected module, @code{foo}.   Only the bindings
of the exported symbols will be directly accessible from outside.
@c JP
@code{select-module}フォームの後には、モジュールの内容であるScheme式を自由に書けます。
それらはモジュール@code{foo}の中で評価されます。モジュール内で定義するトップレベルの
束縛のうち、明示的に`export'で指定されたシンボルのみが、このモジュールをインポートする他の
モジュールから見えます。
@c COMMON

@c EN
The last @code{provide} form is just a cliche.  It is needed since
the `use' mechanism uses traditional require-provide mechanism (if you
don't know about it, it's ok--just put it as a magic spell).
@c JP
最後の@code{provide}は一種の定型句です。`use'がrequire-provideメカニズムを
利用しているために必要です。
@c COMMON

@c EN
So, that's it.   Other programs can use your module by just saying
`@code{(use foo)}'.   If you want to make your module available on your site,
you can put it to the site library location, which can be obtained by
@example
(gauche-site-library-directory)
@end example
in gosh, or
@example
gauche-config --sitelibdir
@end example
from shell.
@c JP
これで、他のプログラムは `@code{(use foo)}' とするだけでこのモジュールの機能が
利用可能になります。もしモジュールをサイト全体で利用できるようにしたければ、@code{gosh}内で
@example
(gauche-site-library-directory)
@end example
を評価して得られるディレクトリに@code{foo.scm}を置いて下さい。
@c COMMON

@c EN
If you feel like to conserve global module name space, you can organize
modules hierarchically.   Some Gauche libraries already does so.
@xref{Library modules - Overview}, for examples.
For example, @code{text.tr} module is implemented in ``text/tr.scm'' file.
Note that the pathname separator `/' in the file becomes a period in the
module name.
@c JP
モジュールの名前空間のトップに新たなモジュールを追加するのに気が引ける場合は、
モジュールを階層的に構成することもできます。Gaucheのモジュールの多くは既に階層的に
構成されています。具体的なモジュール例は@ref{Library modules - Overview}を参照して下さい。
例えば、@code{text.tr}モジュールは ``@code{text/tr.scm}'' ファイルに
実装されています。パス名の区切り文字`/'がモジュール名ではピリオドになることに
注意して下さい。
@c COMMON

@c EN
@c JP
@c COMMON

@c ======================================================================
@node Core syntax, Macros, Programming in Gauche, Top
@chapter Core syntax
@c NODE 基本的な構文

@c ----------------------------------------------------------------------
@menu
* Lexical structure::           
* Literals::                    
* Making Procedures::           
* Assignments::                 
* Conditionals::                
* Binding constructs::          
* Sequencing::                  
* Iteration::                   
* Quasiquotation::              
* Definitions::                 
* Modules::                     
@end menu

@node Lexical structure, Literals, Core syntax, Core syntax
@section Lexical structure
@c NODE 字句構造

@c EN
Gauche extends R5RS Scheme parser in some ways:
@c JP
GaucheはR5RS Schemeのパーザをいくつかの点で拡張しています。
@c COMMON

@table @emph
@c EN
@item Nested block comments (SRFI-30)
A text surrounded by '@code{#|}' and '@code{|#}' becomes a comment.
It can be nested.
@c JP
@item ネスト可能なブロックコメント (SRFI-30)
'@code{#|}' と '@code{|#}' で囲まれたテキストはコメントになります。
ネスト可能です。
@c COMMON

@c EN
@item Numeric literals
Either integral part or fraction part of inexact real numbers can be omitted
if it is zero, i.e. @code{30.}, @code{.25}, @code{-.4} are read as 
real numbers.   Using '@code{#}' as insignificant digits is not supported.
@c JP
@item 数値リテラル
不正確な実数の整数部または小数部のいずれかが0の場合、それを省略することが
できます。例：@code{30.}, @code{.25}, @code{-.4}。
不正確な桁を '@code{#}' で表現する構文はサポートされていません。
@c COMMON

@c EN
@item Symbol names
Symbol names are case sensitive by default (@xref{Case-sensitivity}).
Symbol name can begin with digits, '@code{+}' or '@code{-}', as long as
the entire token doesn't consist valid number syntax.
Other weird characters can be included in a symbol name by surrounding
it with '|', e.g. '@code{|this is a symbol|}'.
@xref{Symbols}, for details.
@c JP
@item シンボル名
シンボル名はデフォルトで大文字小文字を区別します (@ref{Case-sensitivity}参照)。
数字や'@code{+}', '@code{-}' で始まるシンボル名も、
トークンが有効な数値リテラルを構成しない限り許されます。
また、他の変な文字も '|' でシンボルを囲むことによってシンボル名に含めることが
できます (例：'@code{|this is a symbol|}')。
@ref{Symbols}も参照して下さい。
@c COMMON

@c EN
@item Character literal by character code
Character literals can be written using its code, 
by @code{#\x@var{NN}} (Gauche internal code) or @code{#\u@var{NN}} (Unicode).
@xref{Characters}, for details.
@c JP
@item 文字コードによる文字リテラル
文字リテラルを文字コードにより表記することができます。
Gauche内部コードを使う @code{#\x@var{NN}} と、
Unicodeを使う @code{#\u@var{NN}}という表記があります。
@ref{Characters}を参照して下さい。
@c COMMON

@c EN
@item Extended sharp syntax
Many more special tokens begins with '@code{#}' is defined.
See the table below.
@c JP
@item 拡張された#構文
'@code{#}' で始まる特殊構文がたくさん定義されています。
下の表を参照して下さい。
@c COMMON
@end table

The table below lists sharp-syntaxes.

@multitable {aaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item @code{#!}
 @tab [SRFI-22] Specifies interpreter at the beginning of file.
      Scheme loader ignores the line.
@item @code{#"}, @code{##}, @code{#$}, @code{#%}, @code{#&}, @code{#'}
 @tab Unused.
@item @code{#(}
 @tab [R5RS] Introduces a vector.
@item @code{#)}
 @tab Unused.
@item @code{#*}
 @tab If followed by a double quote, denotes an incomplete string.  @xref{Strings}.
@item @code{#+}
 @tab Unused.
@item @code{#,}
 @tab [SRFI-10] Introduces reader constructor syntax.
@item @code{#-}, @code{#.}
 @tab Unused.
@item @code{#/}
 @tab Introduces a literal regular expression.  @xref{Regular expression}.
@item @code{#0} @dots{} @code{#9}
 @tab Reserved for shared structure reference.
@item @code{#:}, @code{#;}
 @tab Unused
@item @code{#<}
 @tab Introduces an unreadable object.
@item @code{#=}, @code{#>}
 @tab Unused.
@item @code{#?}
 @tab Introduces debug macros.  @xref{Debugging}.
@item @code{#@@}
 @tab Unused.
@item @code{#a}
 @tab Unused.
@item @code{#b}
 @tab [R5RS] Binary number prefix.
@item @code{#c}
 @tab Unused.
@item @code{#d}
 @tab [R5RS] Decimal number prefix.
@item @code{#e}
 @tab [R5RS] Exact number prefix.
@item @code{#f}
 @tab [R5RS] Boolean false, or
      introducing SRFI-4 uniform vector.  @xref{gauche.uvector - Uniform vectors}.
@item @code{#g}, @code{#h}
 @tab Unused.
@item @code{#i}
 @tab [R5RS] Inxact number prefix.
@item @code{#j}, @code{#k}, @code{#l}, @code{#m}, @code{#n}
 @tab Unused.
@item @code{#o}
 @tab [R5RS] Octal number prefix.
@item @code{#p}, @code{#q}, @code{#r}
 @tab Unused.
@item @code{#s}
 @tab [SRFI-4] introducing SRFI-4 uniform vector.  @xref{gauche.uvector - Uniform vectors}.
@item @code{#t}
 @tab [R5RS] Boolean true.
@item @code{#u}
 @tab [SRFI-4] introducing SRFI-4 uniform vector.  @xref{gauche.uvector - Uniform vectors}.
@item @code{#v}, @code{#w}
 @tab Unused.
@item @code{#x}
 @tab [R5RS] Hexadecimal number prefix.
@item @code{#y}, @code{#z}
 @tab Unused.
@item @code{#[}
 @tab Introduces a literal character set.  @xref{Character set}.
@item @code{#\}
 @tab [R5RS] Introduces a literal character.  @xref{Characters}.
@item @code{#]}, @code{#^}, @code{#_}
 @tab Unused.
@item @code{#`}
 @tab Introduces an interpolated string.  @xref{String interpolation}.
@item @code{#@{}
 @tab Unused.
@item @code{#|}
 @tab [SRFI-30] Introduces a block comment.  Comment ends by matching '@code{|#}'.
@item @code{#@}}, @code{#~}
 @tab Unused.
@end multitable

@c ----------------------------------------------------------------------
@node Literals, Making Procedures, Lexical structure, Core syntax
@section Literals
@c NODE リテラル

@defspec quote datum
[R5RS]
@c EN
Evaluates to @var{datum}.
@c JP
@var{datum}それ自身を返します。
@c COMMON
@example
(quote x) @result{} x
(quote (1 2 3)) @result{} (1 2 3)
@end example
@end defspec

@deftp {Reader Syntax} @code{'@var{datum}}
[R5RS]
@c EN
Equivalent to @code{(quote datum)}.
@c JP
@code{(quote datum)}の略記です。
@c COMMON
@example
'x @result{} x
'(1 2 3) @result{} (1 2 3)
@end example
@end deftp

@c EN
@emph{Note:}  R5RS says it is an error to alter the value of
a literal expression.
Gauche doesn't check constant-ness of pairs and vectors, so you can
alter them using the destructive procedures such as @code{set-car!}
and @code{vector-set!}.  Doing so will cause unexpected results.
Gauche does check constant-ness of strings, and signals an error
if you try to alter a constant string.
@c JP
@emph{注:} R5RSは、リテラル式の値を変更するのはエラーであるとしています。
しかしGaucheはペアとベクタについてはそれが定数であるかどうかをチェックしておらず、
@code{set-car!}や@code{vector-set!}等の破壊的手続きによってそれらの値を
変更できてしまいます。そうした場合の動作は不定です。
文字列に関しては定数かどうかのチェックを行っており、定数文字列を変更しようとすると
エラーが報告されます。
@c COMMON

@c ----------------------------------------------------------------------
@node Making Procedures, Assignments, Literals, Core syntax
@section Making Procedures
@c NODE  手続きを作る

@defspec lambda formals body @dots{}
[R5RS]
@c EN
Evaluates to a procedure.  The environment in effect when this expression
is evaluated is stored in the procedure.   When the procedure
is called, @var{body} is evaluated sequentially in the
stored environment extended by the bindings of the formal arguments,
and returns the value(s) of the last expression in the body.
@c JP
この式は評価されると手続きを生成します。この式が評価された時点の環境が手続き中に保持されます。
手続きが呼ばれると、記憶された環境に引数の束縛を追加した環境中で@var{body} が順に評価され、
最後の式の値が返されます。
@c COMMON

@c EN
@var{Formals} should have one of the following forms:
@itemize @bullet
@item
@code{(@var{variable} @dots{})} : The procedure takes a fixed number of
arguments.  The actual arguments are bound to the corresponding
variables.
@item
@code{@var{variable}} : The procedure takes any number of argumnets.
The actual arguments are collected to form a new list and bound to
the variable.
@item
@code{(@var{variable_0} @dots{} @var{variable_N-1}. @var{variable_N})} : 
The procedure takes at least @var{N} arguments.  The actual arguments
up to @var{N} is bound to the corresponding varibles.
If more than @var{N} arguments are given, the rest arguments are
collected to form a new list and bound to @var{variable_N}.
@end itemize
@c JP
@var{Formals} は以下のいずれかの形でなければなりません。
@itemize @bullet
@item
@code{(@var{variable} @dots{})} : 手続きは決まった数の引数を取ります。
実引数がそれぞれ対応する@var{variable}に束縛されます。
@item
@code{@var{variable}} : 手続きは不定個の引数を取ります。
実引数は新しいリストに集められて、そのリストが@var{varible}に束縛されます。
@item
@code{(@var{variable_0} @dots{} @var{variable_N-1}. @var{variable_N})} :
手続きは少なくとも@var{N}個の引数を取ります。@var{N}個までの実引数は対応する@var{variable}
に束縛されます。@var{N}個を越えた実引数は新しいリストに集められて
@var{variable_N}に束縛されます。
@end itemize
@c COMMON

@example
(lambda (a b) (+ a b))
@c EN
  @result{} @r{procedure that adds two arguments}
@c JP
  @result{} @r{二つの引数を加算する手続き}
@c COMMON

((lambda (a b) (+ a b)) 1 2)
  @result{} 3
@end example
@end defspec

@c EN
@emph{Note:} Some Scheme implementations extend the syntax of @var{formals}
to have notation of optional arguments or keyword arguments, similar to
CommonLisp's.  Gauche doesn't have such extensions now.
@c JP
@emph{注:} いくつかのSchemeの実装では@var{formals}の構文を拡張して、
CommonLispのように省略可能引数やキーワード引数などの表記を可能にしているものが
あります。Gaucheには今のところそのような拡張はありません。
@c COMMON

@defmac cut expr-or-slot expr-or-slot2 @dots{}
@defmacx cute expr-or-slot expr-or-slot2 @dots{}
[SRFI-26]
@c EN
Convenience macros to notate a procedure compactly.
This form can be used to realize partial application, 
a.k.a sectioning or projection.
@c JP
手続きを簡潔に書ける便利なマクロです。
いわゆる部分適用を実現するために使えます。
@c COMMON

@c EN
Each @var{expr-or-slot} must be either an expression or a symbol @code{<>},
indicating a 'slot'.
The last @var{expr-or-slot} can be a symbol @code{<...>},
indicating a 'rest-slot'.
@code{Cut} expands into a @code{lambda} form that takes as many arguments
as the number of slots in the given form, and 
whose body is an expression
@example
  (@var{expr-or-slot} @var{expr-or-slot2} @dots{})
@end example
where each occurrence of @code{<>} is replaced to the corresponding
argument.
In case there is a rest-slot symbol, the resulting procedure is also
of variable arity, and all the extra arguments are passed
to the call of @var{expr-or-slot}.  See the fourth example below.
@c JP
各@var{expr-or-slot}は式またはシンボル@code{<>}でなければなりません。
最後の@var{expr-or-slot}はシンボル@code{<...>}であっても構いません。
@code{cut}は、そのフォーム中にある@code{<>}と同じ数の引数を取る
@code{lambda}フォームに展開されます。そのフォームのボディには次の式が置かれます。
@example
  (@var{expr-or-slot} @var{expr-or-slot2} @dots{})
@end example
但し、各@code{<>}は対応する仮引数に置き換えられます。
もしシンボル@code{<...>}が与えられていた場合、展開された@code{lambda}フォームは
可変長引数を取る手続きとなり、作成される手続きに与えられたすべての引数が
@var{expr-or-slot}を呼び出すのに使われます(下の4番目の例を参照のこと)。
@c COMMON

@example
(cut cons (+ a 1) <>)  @equiv{} (lambda (x2) (cons (+ a 1) x2))
(cut list 1 <> 3 <> 5) @equiv{} (lambda (x2 x4) (list 1 x2 3 x4 5))
(cut list)             @equiv{} (lambda () (list))
(cut list 1 <> 3 <...>)
   @equiv{} (lambda (x2 . xs) (apply list 1 x2 3 xs))
(cut <> a b)           @equiv{} (lambda (f) (f a b))

;; Usage
(map (cut * 2 <>) '(1 2 3 4))
(for-each (cut write <> port) exprs)
@end example

@c EN
@code{Cute} is a variation of @code{cut} that evaluates @code{expr-or-slot}s
before creating the procedure.
@c JP
@code{cute}は@code{cut}とほぼ同じですが、@code{expr-or-slot}に与えられた
フォームが手続きを作る前に評価される点が異なります。
@c COMMON

@example
(cute cons (+ a 1) <>)
   @equiv{} (let ((xa (+ a 1))) (lambda (x2 (cons xa x2))))
@end example

@c EN
Gauche also has a built-in procedure @code{pa$} for partial application
(@xref{Combinators}).
@c JP
Gaucheはまた、部分適用を行う@code{pa$}という組み込み手続きを持っています
(@xref{Combinators}参照)。
@c COMMON
@end defmac


@c ----------------------------------------------------------------------
@node Assignments, Conditionals, Making Procedures, Core syntax
@section Assignments
@c NODE  代入

@defspec set! symbol expression
@defspecx set! (proc arg @dots{}) expression
[R5RS][SRFI-17]
@c EN
First, @var{expression} is evaluated.
In the first form, the binding of @var{symbol} is modified
so that next reference of @var{symbol} will return
the result of @var{expression}.
If @var{symbol} is not locally bound, the global variable named @var{symbol}
must already exist, or an error is signalled.
@c JP
まず@var{expression}が評価されます。最初の形式では、@var{symbol}への束縛が
@var{expression}の結果を指すように変更されます。
もし@var{symbol}がローカルに束縛されていない場合は、グローバルな変数@var{symbol}が
存在していなければなりません。そうでなければエラーが報告されます。
@c COMMON

@c EN
The second form is a ``generalized set!'' specified in SRFI-17.
It is a syntactic sugar of the following form.
@example
((setter @var{proc}) @var{arg} @dots{} @var{expression})
@end example
Note the order of the arguments of the setter method
differs from CommonLisp's @code{setf}.

Some examples:
@c JP
2番目の形式はSRFI-17に定義されている「一般化されたset!」です。
これは構文的な装飾であり、実際は以下のように解釈されます。
@example
((setter @var{proc}) @var{arg} @dots{} @var{expression})
@end example
CommonLispの@code{setf}とは、setter手続きに渡される引数の順序が異なることに注意して下さい。

例：
@c COMMON

@example
(define x 3)
(set! x (list 1 2))  @result{} @r{undefined}
x                    @result{} (1 2)

(set! (car x) 5)     @result{} @r{undefined}
x                    @result{} (5 2)
@end example
@end defspec

@defmac set!-values (var @dots{}) expr
@c EN
Sets values of multiple variables at once.  @var{Expr} must yield
as many values as @var{var} @dots{}.  Each value is set to
the corresponding @var{var}.
@c JP
複数の変数を同時に更新します。@var{Expr}は与えられた変数と同じ
数だけの値を生成しなけばなりません。各値が対応する@var{var}に
セットされます。
@c COMMON
@example
(define a 0)
(define b 1)
(set!-values (a b) (values 3 4)) @result{} @r{undefined}
a @result{} 3
b @result{} 4
(set!-values (a b) (values b a)) @result{} @r{undefined}
a @result{} 4
b @result{} 3
@end example
@end defmac

@defun setter proc
[SRFI-17]
@c EN
Returns a setter procedure associated to the procedure @var{proc}.
If no setter is associated to @var{proc}, its behavior is undefined.

A setter procedure @var{g} of a procedure @var{f} is such that when used
as @code{(g a b @dots{} v)}, the next evaluation of @code{(f a b @dots{})}
returns @var{v}.

To associate a setter procedure to another procedure, you can use
the setter of @code{setter}, like this:
@example
(set! (setter @var{f}) @var{g})
@end example

A procedure's setter can be ``locked'' to it.  System default setters,
like @code{set-car!} for @code{car}, is locked and can't be set by
the above way.   In order to lock a setter to a user defined procedure,
use @code{getter-with-setter} below.

If @var{proc} is not a procedure, a setter generic function
of @code{object-apply} is returned;
it allows the applicable object extension to work
seamlessly with the generalized @code{set!}.
@xref{Applicable objects}, for the details.
@c JP
手続き@var{proc}のsetter手続きを返します。
@var{proc}がsetter手続きを持たない場合の動作は不定です。

ある関数@var{f}のsetter手続き@var{g}とは、もし@code{(g a b @dots{} v)}のように
呼ばれた場合、次の@code{(f a b @dots{})}が@var{v}を返すようになる手続きのことです。

ある手続きにsetter手続きを関連付けるには、@code{setter}自身のsetter手続きを使うことが
できます。
@example
(set! (setter @var{f}) @var{g})
@end example

特定の手続きにsetter手続きを「ロック」することができます。システム既定のsetter手続き、
例えば@code{car}に対する@code{set-car!}等はロックされていて、上記のような方法で
変更することは出来ません。ユーザ定義手続きにsetter手続きをロックするには下記の
@code{getter-with-setter}を使います。

@var{proc}が手続きでない場合は、@code{object-apply}ジェネリックファンクションの
setterが返されます。これにより、適用可能オブジェクトが一般化された@code{set!}
でもうまく動作します。詳しくは@ref{Applicable objects}を参照して下さい。
@c COMMON
@end defun

@defun has-setter? proc
@c EN
Returns @code{#t} if a setter is associated to @var{proc}.
@c JP
@var{proc}がsetter手続きを持っている場合は@code{#t}を返します。
@c COMMON
@end defun

@defun getter-with-setter get set
[SRFI-17]
@c EN
Takes two procedure @var{get} and @var{set}.  Returns a new
procedure which does the same thing as @var{get}, and its setter is
locked to @var{set}.

The intention of this procedure is, according to the SRFI-17 document,
to allow implementations to inline setters efficiently.  Gauche
hasn't implement such optimization yet.
@c JP
2つの手続き、@var{get}と@var{set}を取り、新しい手続きを返します。
新しい手続きは@var{get}と同じ動作をし、そのsetter手続きは@var{set}にロックされて
います。

この手続きは、SRFI-17によれば、setter手続きのインライン展開を可能にするための
ものですが、Gaucheではまだそのような最適化は実装されていません。
@c COMMON
@end defun

@c EN
A few macros that adopts the same semantics of generalized @code{set!}
are also provided.  They are built on top of @code{set!}.
@c JP
Gaucheでは、一般化された@code{set!}と同じセマンティクスを持ついくつかのマクロが定義
されています。これらは@var{set!}を使った形に展開されます。
@c COMMON

@defmac push! place item
@c EN
Conses @var{item}
and the value of @var{place}, then sets the result to @var{place}.
@var{place} is either a variable or a form @var{(proc arg @dots{})}, 
as the second argument of @code{set!}.   The result of this form
is undefined.
@c JP
@var{item}と@var{place}の値をコンスし、その結果を再び@var{place}にセットします。
@var{place}は@code{set!}と同様に、
変数か@var{(proc arg @dots{})}という形式でなければなりません。このマクロの戻り値は
未定義です。
@c COMMON

@example
(define x (list 2))
(push! x 3) @result{} @r{undefined}
x @result{} (3 2)

(push! (cdr x) 4) @result{} @r{undefined}
x @result{} (3 4 2)
@end example

@c EN
When @var{place} is a list, it roughly expands like the following.
@c JP
@var{place}がリストの場合、だいたいこんなふうに展開されます。
@c COMMON

@example
(push! (foo x y) item)
 @equiv{}
 (let ((tfoo foo)
       (tx x)
       (ty y))
   ((setter tfoo) tx ty (cons item (tfoo tx ty))))
@end example

@c EN
Note: Common Lisp's @code{push} macro takes its argument reverse
order.   I adopted this order since it is consistent with other
destructive operations.  Perl's @code{push} function takes the same
argument order, but it appends @var{item} at the end of the array
(Perl's @code{unshift} is closer to @code{push!}).
You can use a queue (@xref{util.queue - Queue}) if you need a behavior of Perl's
@code{push}.
@c JP
註：Common Lispの@code{push}マクロは引数を逆の順番で取ります。
@code{push!}は他の副作用を持つ形式との互換性を考えてこの順番としました。
Perlの@code{push}関数は@code{push!}マクロと同じ引数順ですが、
@var{item}はシーケンスの末尾に追加されます (Perlの@code{unshift}の方が
@code{push!}の動作に近いです)。
Perlのpushオペレータの動作が必要ならQueueが使えます (@ref{util.queue - Queue}参照)。
@c COMMON
@end defmac

@defmac pop! place
@c EN
Retrieves the value of @var{place}, sets its cdr back to @var{place}
and returns its car.
@c JP
@var{place}の値を取り出し、その@code{cdr}を@var{place}にセットします。
元の値の@code{car}を返します。
@c COMMON

@example
(define x (list 1 2 3))
(pop! x) @result{} 1
x @result{} (2 3)

(define x (vector (list 1 2 3)))
x @result{} #((1 2 3))
(pop! (vector-ref x 0)) @result{} 1
x @result{} #((2 3))
@end example

@c EN
Note: This works the same as Common Lisp's @code{pop}.
Perl's @code{pop} pops value from the end of the sequence;
its @code{shift} does the same thing as @code{pop!}.
@c JP
註：この動作はCommon Lispの@code{pop}と同じです。
Perlの@code{pop}はシーケンスの末尾から値を取ります。
Perlなら@code{shift}が@code{pop!}の動作に近いです。
@c COMMON
@end defmac


@defmac inc! place &optional delta
@defmacx dec! place &optional delta
@c EN
Evaluates the value of @var{place}.  It should be a number.
Adds (@code{inc!}) or subtracts (@code{dec!}) @var{delta} to/from it,
and then stores the result to @var{place}.  The default value of
@var{delta} is 1.

This is Common Lisp's @code{incf} and @code{decf}.
@c JP
@var{place}の値を評価します。それは数値にならなければなりません。
その値に@var{delta}が加算(@code{inc!})もしくは減算(@code{dec!})され、
結果が@var{place}に格納されます。@var{delta}の既定値は1です。

Common Lispの@code{incf}と@code{decf}に当たります。
@c COMMON
@end defmac

@defmac update! place proc
@c EN
Generalized form of @code{push!} etc.  @var{Proc} must be a procedure
which takes one argument and returns one value.   The original value of
@var{place} is passed to the @var{proc}, then its result is set to
@var{place}.
@c JP
@code{push!}等のマクロの一般化された形式です。
@var{proc}は一つの引数を取り、一つの値を返す手続きでなければなりません。
@var{place}の値が@var{proc}に渡され、@var{proc}の結果が@var{place}に格納されます。
@c COMMON
@example
(define a (cons 2 3))
(update! (car a) (lambda (v) (* v 3))) @result{} @r{undefined}
a @result{} (6 . 3)

(update! (cdr a) (cut - <> 3))
a @result{} (6 . 0)
@end example
@end defmac

@c ----------------------------------------------------------------------
@node Conditionals, Binding constructs, Assignments, Core syntax
@section Conditionals
@c NODE 条件式

@defspec if test consequent alternative
@defspecx if test consequent
[R5RS]
@c EN
@var{Test} is evaluated.  If it yields a true value,
@var{consequent} is evaluated.  Otherwise, @var{alternative} is
evaluated.  If @var{alternative} is not provided, it results undefined value.
@c JP
まず@code{test}を評価し、それが真の値を返したら@var{consequent}を評価します。
そうでなければ@var{alternative}を評価します。もし@var{alternative}が与えられて
いなければ未定義の値を返します。
@c COMMON

@example
(if (number? 3) 'yes 'no) @result{} yes
(if (number? #f) 'yes 'no) @result{} no

(let ((x '(1 . 2)))
  (if (pair? x)
      (values (car x) (cdr x))
      (values #f #f)))
  @result{} 1 @r{and} 2
@end example
@end defspec

@defspec cond clause1 clause2 @dots{}
[R5RS]
@c EN
Each @code{clause} must be the form
@example
(@var{test} @var{expr} @dots{})
(@var{test} => @var{expr})
(else @var{expr} @var{expr2} @dots{})
@end example
The last form can appear only as the last clause.

@code{cond} evaluates @var{test} of each clauses in order, until
it yields a true value.   Once it yields true, if the clause
is the first form,  the corresponding @var{expr}s are evaluated
and the result(s) of last @var{expr} is(are) returned; if the clause
is the second form, the @var{expr} is evaluated and it must yield
a procedure that takes one argument.  Then the result of @var{test}
is passed to it, and the result(s) it returns will be returned.
If no test yields true, and the last clause is not the third form
(else clause), an undefined value is returned.

If the last clause is else clause and all tests are failed,
@var{expr}s in the else clause are evaluated, and its last
@var{expr}'s result(s) is(are) returned.
@c JP
各@code{clause}節は次のいずれかの形式でなければなりません。
@example
(@var{test} @var{expr} @dots{})
(@var{test} => @var{expr})
(else @var{expr} @var{expr2} @dots{})
@end example
最後の形式は最後の節のみに許されます。

最初の節から順に@var{test}が評価され、それが真の値を返すまで次の節の@var{test}が
評価されます。@var{test}が真の値を返したら、それが最初の形式であれば
その節の@var{expr}が順に評価され、最後の評価値が戻り値となります。
それが2番目の形式であれば、@var{expr}がまず評価されます。
@var{expr}は引数をひとつ取る手続きを返さねばなりません。
続いて、@var{test}の結果がその手続きに渡され、その手続きの戻り値が@code{cond}形式の
評価値となります。
もし全てのテストが偽の値を返し、最後の節が3番目の形式(else節)でなければ、未定義の値が返されます。

最後の節が@code{else}節で、他の全てのテストが失敗した場合、@code{else}節の@var{expr}
が順に評価され、その最後の値が@code{cond}形式の値となります。
@c COMMON

@example
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less)) @result{} greater
(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal)) @result{} equal
(cond ((assv 'b '((a 1) (b 2))) => cadr)
      (else #f)) @result{} 2
@end example
@end defspec


@defspec case key clause1 clause2 @dots{}
[R5RS]
@c EN
@var{Key} may be any expression. 
Each @var{clause} should have the form 
@example
((@var{datum} ...) @var{expr} @var{expr2} @dots{})
@end example
where each @var{datum} is an external representation of some object.
All the @var{datum}s must be distinct. The last @var{clause}
may be an ``else clause,'' which has the form 
@example
(else @var{expr} @var{expr2} @dots{})
@end example

First, @var{key} is evaluated and its result is compared against each
@var{datum}.  If the result of evaluating @var{datum} is equivalent
(using @code{eqv?}, @xref{Equivalence}), to a @var{datum},
then the expressions in the corresponding clause are evaluated
sequentially, and the result(s) of the last expression in the
@var{clause} is(are) returned from the case expression.
If the result of evaluating @var{key} is different from every @var{datum},
then if there is an else clause its expressions are evaluated and
the result(s) of the last is(are) the result(s) of the case expression;
otherwise the result of the case expression is unspecified.
@c JP
@var{key}は任意の式です。@var{clause}は以下の形式でなければなりません。
@example
((@var{datum} ...) @var{expr} @var{expr2} @dots{})
@end example
ここで、各@var{datum}はSchemeオブジェクトの外部表現であり、全ての@var{datum}は
異なっていなければなりません。最後の@var{clause}には次の形式を持つelse節が許されます。
@example
(else @var{expr} @var{expr2} @dots{})
@end example

まず@var{key}が評価され、その結果がそれぞれの@var{datum}と比較されます。
@var{key}の値と@code{eqv?}(@ref{Equivalence}参照)を使って一致する@var{datum}
が見つかれば、対応する@var{expr}が順に評価され、その最後の値が@code{case}の
値となります。もし一致する@var{datum}が見つからない場合、else節が与えられていれば
その@var{expr}が順に評価され、最後の値が返されます。else節がなければ@code{case}節
の値は未定義です。
@c COMMON
@example
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite)) @result{} composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b)) @result{} @r{undefined}
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant)) @result{} consonant
@end example
@end defspec


@defspec and test @dots{}
[R5RS] 
@c EN
The @var{test} expressions are evaluated from left to right,
and the value of the first expression that evaluates to a false
value is returned.
Any remaining expressions are not evaluated.
If all the expressions evaluate to true values,
the value of the last expression is returned.
If there are no expressions then @code{#t} is returned.
@c JP
@var{test}式が順に評価されます。最初に偽の値を返したところで評価が止まり、
偽の値が返されます。残りの式は評価されません。
もし全ての式が真の値を返した場合は、最後の式の値が返されます。
式が与えれない場合は@code{#t}が返されます。
@c COMMON

@example
(and (= 2 2) (> 2 1)) @result{} #t
(and (= 2 2) (< 2 1)) @result{} #f
(and 1 2 'c '(f g))   @result{} (f g)
(and)                 @result{} #t
@end example
@end defspec


@defspec or test @dots{}
[R5RS]
@c EN
The @var{test} expressions are evaluated from left to right,
and the value of the first expression that evaluates to a true
value is returned. Any remaining expressions are not evaluated.
If all expressions evaluate to false values, the value of the
last expression is returned. If there are no expressions then
@code{#f} is returned.
@c JP
@var{test}式が順に評価されます。最初に真の値を返したところで評価が止まり、
その値が返されます。残りの式は評価されません。
もし全ての式が偽の値を返した場合は、偽の値が返されます。
式が与えれない場合は@code{#f}が返されます。
@c COMMON

@example
(or (= 2 2) (> 2 1)) @result{} #t
(or (= 2 2) (< 2 1)) @result{} #t
(or #f #f #f)        @result{} #f
(or (memq 'b '(a b c)) 
    (/ 3 0)) @result{} (b c)
@end example
@end defspec

@defspec when test body @dots{}
@defspecx unless test body @dots{}
@c EN
Evaluates @var{test}.  If it yields true value (or false in case of
@code{unless}), @var{body} @dots{} are evaluated sequentially, and
the result(s) of the last evaluation is(are) returned.  Otherwise, undefined
value is returned.
@c JP
まず@var{test}が評価されます。それが真の値(@code{unless}の場合は偽の値)を返した場合、
引続き@var{body}が順に評価され、最後の@var{body}の評価値が返されます。
そうでなければ、未定義の値が返されます。
@c COMMON
@end defspec

@node Binding constructs, Sequencing, Conditionals, Core syntax
@section Binding constructs
@c NODE 変数束縛

@defspec let ((var expr) @dots{}) body @dots{}
@defspecx let* ((var expr) @dots{}) body @dots{}
@defspecx letrec ((var expr) @dots{}) body @dots{}
[R5RS]
@c EN
Creates a local scope where @var{var} @dots{} are bound to the
value of @var{expr} @dots{}, then evaluates @var{body} @dots{}.
@var{var}s must be symbols, and there shouldn't be a duplication.
The value(s) of the last expression of @var{body} @dots{} becomes
the value(s) of this form.
@c JP
各変数@var{var}が@var{expr}の値に束縛されているローカルな環境を作成し、
その中で@var{body} @dots{}を評価します。@var{var}はシンボルでなければ
ならず、重複があってはなりません。@var{body} @dots{}の最後の式の値が
このフォームの値となります。
@c COMMON

@c EN
The three forms differ in terms of the scope @var{expr}s are evaluated.
@code{Let} evaluates @var{expr}s before (outside of) @code{let} form.
@code{Let*} evaluates @var{expr}s in the scope where @var{var}s before
it are bound.   @code{Letrec} evaluates @var{expr}s in the environment
where @var{var}s are already bound (to an undefined value, initially).
@code{letrec} is necessary to define mutually recursive local procedures.
@c JP
これらの3つのフォームの違いは、@var{expr}が評価される時点のスコープにあります。
@code{let}は@var{expr}を@var{let}フォームに入る前の環境において評価します。
@code{let*}は@var{expr}を順に、それ以前の@var{var}が束縛された環境において評価して
ゆきます。@var{letrec}は全ての@var{var}が仮想的に不定の値に束縛された環境において
各@var{expr}を評価します。@var{letrec}は相互再帰的なローカル関数を定義する場合に
必要です。
@c COMMON
@example
(define x 'top-x)

(let  ((x 3) (y x)) (cons x y)) @result{} (3 . top-x)
(let* ((x 3) (y x)) (cons x y)) @result{} (3 . 3)

(let ((cons (lambda (a b) (+ a b)))
      (list (lambda (a b) (cons a (cons b 0)))))
  (list 1 2))  @result{} (1 2 . 0)

(letrec ((cons (lambda (a b) (+ a b)))
         (list (lambda (a b) (cons a (cons b 0)))))
  (list 1 2))  @result{} 3
@end example
@end defspec

@defmac let1 var expr body @dots{}
@c EN
A convenient macro when you have only one variable.
Expanded as follows.
@c JP
変数が一つしか無い場合の便利なマクロです。次のように展開されます。
@c COMMON

@example
(let ((@var{var} @var{expr})) @var{body} @dots{})
@end example
@end defmac

@defspec receive formals expression body @dots{}
[SRFI-8]
@c EN
This is the way to receive multiple values.
@var{Formals} can be a (maybe-improper) list of symbols.
@var{Expression} is evaluated, and the returned value(s)
are bound to @var{formals} like the binding of lambda formals,
then @var{body} @dots{} are evaluated.
@c JP
この構文により、多値を受け取ることができます。
@var{formals}はシンボルのリストです。不完全なリストであっても構いません。
@var{expression}が評価され、返された値がlambda形式の引数の束縛と
同じようにして@var{formals}内の変数と束縛され、その環境下で@var{body} @dots{}が
評価されます。
@c COMMON

@example
(define (divrem n m)
  (values (quotient n m) (remainder n m)))

(receive (q r) (divrem 13 4) (list q r))
  @result{} (3 1)

(receive all (divrem 13 4) all)
  @result{} (3 1)

(receive (q . rest) (divrem 13 4) (list q rest)
  @result{} (3 (1))
@end example

@c EN
See also @code{call-with-values} in @ref{Multiple values}
which is the procedural equivalent of @code{receive}.
You can use @code{define-values} (@xref{Definitions}) to
bind multiple values to the toplevel variables simultaneously.
Also @code{let-values} and @code{let*-values} 
in SRFI-11 (@ref{srfi-11 - Let-values}) provides
@code{let}-like syntax with multiple values.
@c JP
なお、@ref{Multiple values}の@code{call-with-values}は
@code{receive}と等価な手続き的インタフェースです。
多値を複数のトップレベル変数に束縛するには、@code{define-values}
(@ref{Definitions}参照) が使えます。
また、SRFI-11 (@ref{srfi-11 - Let-values}) の@code{let-values}と
@code{let*-values}は@code{let}のような形式で多値を扱うことができます。
@c COMMON
@end defspec

@defmac rec var expr
@defmacx rec (name . vars) expr @dots{}
[SRFI-31]
@c EN
A macro to evaluate an expression with recursive reference.

In the first form, evaluates expr while @var{var} in @var{expr} is
bound to the result of @var{expr}.
The second form is equivalent to the followings.
@c JP
再帰的な参照のある式の評価を行うマクロです。

最初の形式は、@var{var}が@var{expr}の結果に束縛される状態で@var{expr}を
評価します。
2番目の形式は以下の形式と等価です。
@c COMMON
@example
(rec @var{name} (lambda @var{vars} @var{expr} @dots{}))
@end example

@c EN
Some examples:
@c JP
例：
@c COMMON

@example
;; constant infinite stream
(rec s (cons 1 (delay s)))

;; factorial function
(rec (f n) 
  (if (zero? n)
      1 
      (* n (f (- n 1)))))
@end example
@end defmac

@node Sequencing, Iteration, Binding constructs, Core syntax
@section Sequencing
@c NODE 順次実行


@defspec begin form @dots{}
[R5RS]
@c EN
Evaluates @var{form}s sequentially, and returns the last result(s).
@c JP
@var{form}を順に評価し、最後の値を返します。
@c COMMON

@c EN
@code{Begin} doesn't introduce new "block" like @code{let}, that is,
you can't place "internal define" at the beginning of @var{form}s
generally.   Semantically @code{begin} behaves as if @var{form}s
are spliced into the surrounding context.
For example, topleve expression like the following is the same
as two toplevel definitions:
@c JP
@code{Begin}は@code{let}のような「ブロック」を作成するわけではありません。
すなわち、一般的には@var{form} @dots{}の先頭に「内部のdefine (internal define)」を
置くことはできません。意味的には、@code{begin}はまるで@var{form} @dots{}が
@code{begin}を囲むコンテクスト中に展開されているかのように振舞います。
例えば、トップレベルに次のような式があった場合、それは2つのトップレベルのdefineと
同等です。
@c COMMON

@example
(begin (define x 1) (define y 2))
@end example

@c EN
Here's a trickier example:
@c JP
よりトリッキーな例:
@c COMMON

@example
(let ()
  (begin 
    (define x 2)
    (begin
      (define y 3)
    ))
  (+ x y))

  @equiv{}

(let ()
  (define x 2)
  (define y 3)
  (+ x y))
@end example
@end defspec

@defmac begin0 exp0 exp1 @dots{}
@c EN
Evaluates @var{exp0}, @var{exp1}, @dots{}, then returns the result(s)
of @var{exp0}.   The name is taken from MzScheme.
This is called @code{prog1} in CommonLisp.   

Unlike @code{begin}, this @emph{does} creates a "block",
for the @code{begin0} form is expanded as follows.
@c JP
@var{exp0}, @var{exp1}, @dots{} を評価し、@var{exp0}の結果を返します。
この名前はMzSchemeから取られました。これはCommonLispで
@code{prog1}と呼ばれているものです。

@code{begin}と違って、これは「ブロック」を構成します。
@code{begin1}フォームは次のように展開されるからです。
@c COMMON

@example
(receive tmp @var{exp0}
  @var{exp1} @dots{}
  (apply values tmp))
@end example
@end defmac


@node Iteration, Quasiquotation, Sequencing, Core syntax
@section Iteration
@c NODE 繰り返し

@defspec do ((variable init [step]) @dots{}) (test expr @dots{}) body @dots{}
[R5RS]
@end defspec


@defspec let name bindings body @dots{}
[R5RS]
@end defspec



@defmac dotimes (variable limit [result]) body @dots{}
@defmacx dolist (variable lexpr [result]) body @dots{}
@c EN
Imported from Common Lisp.  These are equivalent to the following forms,
respectively.
@c JP
Common Lispからの輸入です。それぞれ以下のように展開されます。
@c COMMON
@example
(dotimes (variable limit result) body @dots{})
==>
(do ((tlimit limit)
     (variable 0 (+ variable 1)))
    ((>= variable tlimit) result)
  body @dots{})

(dolist (variable lexpr result) body @dots{})
==>
(begin
  (for-each (lambda (variable) body @dots{}) lexpr)
  (let ((variable '())) result))
@end example
@end defmac

@c ----------------------------------------------------------------------
@node Quasiquotation, Definitions, Iteration, Core syntax
@section Quasiquotation
@c NODE 準クオート, 準クオート(Quasiquote)

@defspec quasiquote template
[R5RS]
@end defspec


@c ----------------------------------------------------------------------
@node Definitions, Modules, Quasiquotation, Core syntax
@section Definitions
@c NODE 定義

@defspec define variable expression
@defspecx define (variable . formals) body @dots{}
[R5RS]
@c EN
This form has different meanings in the toplevel (without no
local bindings) or inside a local scope.

On toplevel, it defines a global binding to a symbol @var{variable}.
In the first form, it globally binds a symbol @var{variable}
to the value of @var{expression}, in the current module.
@c JP
この形式はトップレベル (ローカルな束縛が無い状態) とローカルスコープがある状態とで
別の意味を持ちます。

トップレベルでは、この形式は変数@var{variable}に対するグローバルな束縛を定義します。
最初の形式では、@var{expression}が評価され、その結果が変数@var{variable}の値となります。
@c COMMON
@example
(define x (+ 1 2))
x @result{} 3
(define y (lambda (a) (* a 2)))
(y 8) @result{} 16
@end example

@c EN
The second form is a syntactic sugar of defining a procedure.
It is equivalent to the following form.
@c JP
2番目の形式は手続きを定義するための構文的な修飾で、以下の形式と同じです。
@c COMMON
@example
(define (@var{name} . @var{args}) @var{body} @dots{})
  @equiv{} (define @var{name} (lambda @var{args} @var{body} @dots{}))
@end example

@c EN
If the form appears inside a local scope (internal define),
this introduce a local binding of the variable.

@c explanation of internal define here
@c JP
このフォームがローカルスコープの中に現われた場合、ローカル変数の束縛となります。
@c COMMON

@c EN
Note that @code{begin} (@xref{Sequencing}) doesn't introduce a new scope.
@code{Define}s in the @code{begin} act as if @code{begin} and surrounding
parenthesis are not there.  Thus these two forms are equivalent.
@c JP
@code{begin}は新しいスコープを作らないことに注意してください(@ref{Sequencing}参照)。
@code{begin}の中に現われる@code{define}は、あたかも@code{begin}とそれを囲む
括弧な無いかのように振舞います。すなわち、以下の2つの形式は等価です。
@c COMMON
@example
(let ((x 0))
  (begin
    (define (foo y) (+ x y)))
  (foo 3))
 @equiv{}
(let ((x 0))
  (define (foo y) (+ x y))
  (foo 3))
@end example
@end defspec

@defmac define-values (var @dots{}) expr
@c EN
@var{Expr} is evaluated, and it should return as many values as
@var{var}s.  Then each value of the results are
bound to each variable in @var{var} @dots{}.
@xref{srfi-11 - Let-values}.
@c JP
まず@var{expr}が評価されます。それは与えられた@var{var}と同数の値を
返さなければなりません。続いて各値が@var{var}に順に束縛されます。
@ref{srfi-11 - Let-values}も参照してください。
@c COMMON
@example
(define-values (lo hi) (min&max 3 -1 15 2))

lo @result{} -1
hi @result{} 15
@end example
@end defmac

@defspec define-constant variable expression
@defspecx define-constant (variable . formals) body @dots{}
@c EN
Like @code{define}, but that the compiler assumes
the value of @var{variable} won't change and generates 
optimized code.

An error is signalled when you use @code{set!} to change the value
of @var{variable}.   It is allowed to redefine @var{variable},
but a warning is printed.
@c JP
@code{define}と同じように動作しますが、
コンパイラは@var{variable}の値が今後変更されないものとして
最適化されたコードを生成します。

@var{variable}の値を@code{set!}で変更しようとするとエラーとなります。
@var{variable}を再定義することは許されますが、警告が表示されます。
@c COMMON
@end defspec

@defspec define-in-module module variable expression
@defspecx define-in-module module (variable . formals) body @dots{}
@c EN
This form creates a global binding of @var{variable} in
@var{module}, which must be either a symbol of the module name or
a module object.  If @var{module} is a symbol, the named module
must exist.

@var{Expression} is evaluated in the current module.

The second form is merely a syntactic sugar of:
@c JP
この形式は@var{variable}のグローバルな束縛を@var{module}中に作成します。
@var{module}はモジュール名を表すシンボルか、モジュールオブジェクトで
なければなりません。@var{module}がシンボルの場合、その名前を持つ
モジュールが既に存在している必要があります。

@var{expression}は現在のモジュール中で評価されます。

2番目の形式は次の形式の構文的修飾です。
@c COMMON
@example
(define-in-module module variable (lambda formals body @dots{}))
@end example
@end defspec

@c EN
Note: to find out if a symbol has definition (global binding) in
the current module, you can use @code{symbol-bound?}
(@xref{Module introspection}).
@c JP
註: シンボルが現在のモジュール中で定義されているか(グローバルな束縛を持つか)
を調べるには、@code{symbol-bound?}が使えます
(@ref{Module introspection}参照)。
@c COMMON

@c ----------------------------------------------------------------------
@node Modules,  , Definitions, Core syntax
@section Modules
@c NODE モジュール

@c EN
This section describes the semantics of Gauche modules and its API.
See also @ref{Writing Gauche modules}, for the conventions
Gauche is using for its modules.
@c JP
この章では、GaucheのモジュールのセマンティクスとAPIを述べます。
Gaucheで使われているモジュールの書法については@ref{Writing Gauche modules}も
併せて参照して下さい。
@c COMMON

@menu
* Module semantics::            
* Defining and selecting modules::  
* Using modules::               
* Module inheritance::          
* Module introspection::        
* Predefined modules::          
@end menu

@node Module semantics, Defining and selecting modules, Modules, Modules
@subsection Module semantics
@c NODE モジュールのセマンティクス

@c EN
Module is an object that maps symbols onto @emph{bindings},
and affects the resolution of global variable reference.
@c JP
モジュールは、シンボルを束縛へとマップするオブジェクトで、
グローバル変数の解決に影響を与えます。
@c COMMON

@c EN
Unlike CommonLisp's packages, which map names to symbols,
in Gauche symbols are always @code{eq?} if two have the
same name.  However, Gauche's symbol doesn't have a 'value'
slot in it.  Given symbol, a module finds its binding that
keeps a value.
Different modules can associate different bindings
to the same symbol, that yield different values.
@c JP
CommonLispのパッケージは名前からシンボルへのマッピングを行いますが、
Gaucheでは同じ名前を持つシンボルは常に@code{eq?}です。しかし、
Gaucheのシンボルは「値」のスロットを持っていません。
モジュールによってシンボルに対応する束縛が見付けられ、値はそこに
格納されています。
モジュールが違えば同じシンボルは別々の束縛へとマップされ、違う値を
返します。
@c COMMON

@example
@c EN
;; Makes two modules A and B, and defines a global variable 'x' in them
@c JP
;; 二つのモジュールAとBを作成し、グローバル変数'x'をその中で定義
@c COMMON
(define-module A (define x 3))
(define-module B (define x 4))

;;  #<symbol 'x'> ---[module A]--> #<binding that has 3>
(with-module A x) @result{} 3

;;  #<symbol 'x'> ---[module B]--> #<binding that has 4>
(with-module B x) @result{} 4
@end example

@c EN
A module can @emph{export} a part or all of its bindings
for other module to use.
A module can @emph{import} other modules, and their exported
bindings become visible to the module.
A module can import any number of modules.
@c JP
モジュールは、自身が持つ一部または全ての束縛を他のモジュールからも
使えるように@emph{export}することができます。モジュールが他の
モジュールを@emph{import}すると、それらのモジュールでexportされている
束縛が元もモジュールから見えるようになります。
モジュールはいくつでも他のモジュールをimportすることができます。
@c COMMON

@example
(define-module A
  (export pi)
  (define pi 3.1416))

(define-module B
  (export e)
  (define e 2.71828))

(define-module C
  (import A B))

(select-module C)
(* pi e) @result{} 8.539748448
@end example

@c EN
A module can also be @emph{inherited}, that is, you can extend
the existing module by inheriting it and adding new bindings
and exports.   From the new module, all ancestor's bindings (including
non-exported bindings) are visible.
(A new module inherits the @code{gauche} module by default, which is why
the built-in procedures and syntax of @code{gauche} are available
in the new module).
From outside, the new module looks like having
all exported bindings of the original module plus the newly
defined and exported bindings.
@c JP
また、モジュールは継承することもできます。
既存のモジュールを継承したモジュールに新しい束縛を足してexportすることにより、
既存のモジュールを拡張することができます。新しいモジュールの内部からは、
継承元のモジュールの束縛が(exportされていないものも含め)全て見えます。
(新しく作られるモジュールはデフォルトで@code{gauche}モジュールを継承しています。
新しいモジュールから@code{gauche}の組込み手続き等が使えるのはそのためです)。
外からは、新しいモジュールには元のモジュールの全てのexportされた束縛と
新たに追加されexportされた束縛が見えます。
@c COMMON

@example
;; Module A defines and exports deg->rad.
;; A binding of pi is not exported.
(define-module A
  (export deg->rad)
  (define pi 3.1416)   ;; not exported
  (define (deg->rad deg) (* deg (/ pi 180))))

;; Module Aprime defines and exports rad->deg.
;; The binding of pi is visible from inside Aprime.
(define-module Aprime
  (extend A)
  (export rad->deg)
  (define (rad->deg rad) (* rad (/ 180 pi))))

;; Module C imports Aprime.
(define-module C
  (import Aprime)
  ;; Here, both deg->rad and rad->deg are visible,
  ;; but pi is not visible.
  )
@end example

@c EN
At any moment of the compilation, there is one "current module" available,
and the global variable reference is looked for from the module.
If there is a visible binding of the variable, the variable
reference is compiled to the access of the binding.
If the compiler can't find a visible binding,
it marks the variable reference with the current module, and
delays the resolution of binding at the time the variable is
actually used.  That is, when the variable is referenced
at run time, the binding is again looked for from the marked module
(@emph{not} the current module at the run time) and if found,
the variable reference code is replaced for the the code to
access the binding.  If the variable reference is not found even
at run time, an 'undefined variable' error is signalled.
@c JP
コンパイル中のどの時点でも、「カレントモジュール」が一意に決定され、
グローバル変数の束縛はそのカレントモジュールを起点に探されます。
その変数の束縛が見付かれば、変数参照の式はその束縛へアクセスするコードとして
コンパイルされます。もしコンパイラが束縛を見付けられなかった場合、
変数参照の式はカレントモジュールでマークされ、束縛の解決はランタイムへと
先送りされます。すなわち、ランタイムにその変数が使われる時点で
再びマークされていたモジュールから束縛の探索が行われます
(ランタイムでのカレントモジュールからでは無いことに注意)。
束縛が見付かれば、束縛へアクセスするコードがコンパイルされたコード列に
挿入されます。見付からなければ'undefined variable'エラーが報告されます。
@c COMMON

@c EN
Once the appropriate binding is found for the global variable,
the access to the binding is hard-wired in the compiled code
and the global variable resolution will never take place again.
@c JP
グローバル変数に対して適切な束縛がひとたび発見されれば、
その束縛へのアクセスはコンパイルされたコードに埋め込まれ、
その変数の束縛の探索は二度と行われません。
@c COMMON

@c EN
The definition special form such as @code{define} and @code{define-syntax}
inserts the binding to the current module.   Thus it may shadow
the binding of imported or inherited modules.
@c JP
@code{define}や@code{define-syntax}等の定義を行う特殊形式は
カレントモジュールに束縛を挿入します。これは、importしたり継承したりしている
モジュールの同名の束縛をシャドウします。
@c COMMON

@c EN
The resolution of binding of a global variable happens like this.
First, the current module is searched.  Then, each
imported module is taken in the order of import, and searched,
including each module's ancestors.
Note that import is not transitive; imported module list is not
chased recursively.
Finally, ancestors of the current module are searched in order.
@c JP
グローバル変数の束縛の解決は次の手順で行われます。
まずカレントモジュールが探されます。次に、importしているモジュールが
importの順番に並べられ、それぞれについてそのモジュールおよびそのモジュールの先祖
(継承されているモジュール)が順に探されます。
importは遷移的ではありません；importされたモジュールがimportしているモジュール…
というふうに再帰的に辿ることはしません。
最後に、カレントモジュールの先祖が順に探されます。
@c COMMON

@node Defining and selecting modules, Using modules, Module semantics, Modules
@subsection Defining and selecting modules
@c NODE モジュールの定義と選択

@defspec define-module name body @dots{}
@c EN
@var{Name} must be a symbol.
If a module named @var{name} does not exist, create one.
Then evaluates @var{body} sequentially in the module.
@c JP
@var{name}はシンボルでなければなりません。
名前@var{name}を持つモジュールが存在しなければまず作成します。
それから、@var{body} @dots{} をモジュール@var{name}中で評価します。
@c COMMON
@end defspec

@defspec select-module name
@c EN
Makes a module named @var{name} as the current module.
It is an error if no module named @var{name} exists.

If @code{select-module} is used in the Scheme file, its effect is
limited inside the file, i.e. even if you load/require a file that uses
@code{select-module} internallly, the current module of requirer is
not affected.
@c JP
名前@var{name}を持つモジュールをカレントモジュールとします。
その名前を持つモジュールが無ければエラーとなります。

@code{select-module}がSchemeファイルの中で用いられた場合、
その効果はそのファイルの終了までに限られます。@code{select-module}を中で呼んでいる
ファイルをloadやrequireしても、呼んだ側のカレントモジュールは影響を受けません。
@c COMMON
@end defspec

@defspec with-module name body @dots{}
@c EN
Evaluates @var{body} sequentially in the module
named @var{name}.  Returns the last result(s).
If no moudle named @var{name}, an error is signalled.
@c JP
名前@var{name}を持つモジュールをカレントモジュールとした状態で@var{body} @dots{}
を順に評価し、最後の結果を返します。該当するモジュールが存在しなければエラーとなります。
@c COMMON
@end defspec

@defspec current-module
@c EN
Evaluates to the current module in the compile context.
Note that this is a special form, not a function.
Module in Gauche is statically determined at compile time.
@c JP
コンパイル時点でのカレントモジュールに評価されます。
これは手続きではなく特殊形式です。
Gaucheではモジュールはコンパイル時に静的に決定されます。
@c COMMON
@lisp
(define-module foo
  (export get-current-module)
  (define (get-current-module) (module-name (current-module))))

(define-module bar
  (import foo)
  (get-current-module)) @result{} foo @r{; not bar}
@end lisp
@end defspec


@node Using modules, Module inheritance, Defining and selecting modules, Modules
@subsection Using modules
@c NODE モジュールの使用

@defspec export symbol @dots{}
@c EN
Makes bindings of @var{symbol}s in the current module available
to modules that imports the current module.
@c JP
カレントモジュールの中で、シンボル@var{symbol}に対応する束縛をexportします。
exportされた束縛は、カレントモジュールをimportしたモジュール中で見えるようになります。
@c COMMON
@end defspec

@defspec export-all
@c EN
Makes all bindings in the current module available to modules
that imports it.
@c JP
カレントモジュール中の全ての束縛をexportします。
@c COMMON
@end defspec

@defspec import module-name @dots{}
@c EN
Makes all exported bindings in the module named @var{module-name}
available in the current module.   The named modules should exist
when the compiler sees this special form.

Note that imports are not transitive.  The modules that @var{module-name}s
are importing are not automatically imported to the current module.
This keeps modules' modularity; a library module can import whatever
modules it needs without worring about polluting the namespace of
the user of the module.
@c JP
名前@var{module-name}を持つモジュールがexportしている束縛を
カレントモジュール中で使えるようにします。該当するモジュールが既に定義されて
いなければなりません。

モジュールのimportは遷移的でないことに注意してください。
@code{module-name}で指定されるモジュール内でimportしているモジュールは、
カレントモジュールにはimportされません。
これはモジュールのモジュラリティを保つために必要です；
例えば、ライブラリモジュールは内部で使用するためにいくつも他のモジュールを
importするかもしれませんが、それがそのライブラリモジュールを使用するモジュールの
名前空間に影響することはないわけです。
@c COMMON
@end defspec

@defmac use name
@c EN
A convenience macro that combines module imports and on-demand
file loading.  Basically, @code{(use foo)} is equivalent
to the following two forms:
@example
(require "foo")
(import foo)
@end example
That is, it loads the library file named ``@code{foo}'' (if not yet
loaded) which defines a module named @code{foo} in it,
and then import the module
@code{foo} into the current module.
@c JP
モジュールのインポートとオンデマンドのファイルのロードを合わせて行う、
便利なマクロです。基本的に、@code{(use foo)} は以下のふたつのフォームと
等価です。
@example
(require "foo")
(import foo)
@end example
すなわち、まず名前``@code{foo}''を持つライブラリファイルが(まだロードされて
いなければ)ロードされ、その中で定義されているモジュール@code{foo}をカレントモジュールに
インポートします。
@c COMMON

@c EN
Although the files and modules are orthogonal concept,
it is practically convenient to separate files by modules.
Gauche doesn't force you to do so, and you can always use
@code{require} and @code{import} separately.  However, all
modules provided with Gauche are arranged so that they can be
used by @code{use} macro.
@c JP
ファイルのロードとモジュールとは直交する概念ですが、
現実にはモジュール毎にファイルを分割するのが便利です。
必ずしもそうする必要は無く、@code{require} と @code{import} を別々に
使っても構いません。が、Gaucheに附属してくるライブラリはすべて、
@code{use} マクロで使えるように書かれています。
@c COMMON

@c EN
If a module is too big to fit in one file, you can split them
into several subfiles and one main file.  The main file defines
the module, and either loads, requires, or autoloads subfiles.
@c JP
もしモジュールが一つのファイルに収めるには大きすぎる場合、一つのメインファイルと
いくつかのサブファイルに分けることも出来ます。メインファイルの中でモジュールを
定義し、サブファイルをまとめてロードするか、オートロードを設定します。
@c COMMON

@c EN
If @var{name} contains periods `@code{.}', it is replaced to `@code{/}'
in the file name.to be @code{require}d, for example,
@code{(use foo.bar.baz)} is expanded to:
@example
(require "foo/bar/baz")
(import foo.bar.baz)
@end example
This is not very Scheme-ish way, but nevertheless convenient.
(The alternative design is to use a list of symbols to represent
hierarchical file/module configuration, as in Guile.)
@c JP
もし@var{name}がピリオド`@code{.}'を含んでいる場合、@code{require}するファイル名
ではそれが`@code{/}'に置換されます。例えば@code{(use foo.bar.baz)}は
@example
(require "foo/bar/baz")
(import foo.bar.baz)
@end example
となります。これはあまりScheme風ではありませんが、便利ではあります。
(別の設計方針として、Gaucheでは採用していませんが、
例えばGuileで用いられているような、シンボルのリストを
階層的なモジュールに使用することも考えられます。)
@c COMMON
@end defmac

@node Module inheritance, Module introspection, Using modules, Modules
@subsection Module inheritance
@c NODE モジュールの継承

@c EN
The export-import mechanism doesn't work well in some cases, such as:
@c JP
export-importメカニズムは、次のような場合をうまく処理できません。
@c COMMON

@itemize @bullet
@c EN
@item You want to create a module that is mostly the same as the
existing one, but adding or altering some definitions.
@c JP
@item 既存のモジュールとほぼ同等の機能を持つが、若干定義を足したり変更したり
したモジュールを作りたい。
@c COMMON
@c EN
@item You wrote a bunch of related modules that are often used together,
and not want your users to repeat a bunch of 'use' forms every time
they use your module.
@c JP
@item 相互に関連するいくつものモジュールを作成した。
ユーザがこれらのモジュールを使う時に毎回いくつも 'use' を並べないで済むように
一つにまとめたい。
@c COMMON
@end itemize

@c EN
You can use module inheritance in these cases.
@c JP
このような場合にモジュールの継承が使えます。
@c COMMON

@defmac extend module-name @dots{}
@c EN
Makes the current module inherit from named modules.
The current inheritance information is altered by the
inheritance information calculated from given modules.
@c JP
カレントモジュールが、@var{module-name} @dots{}に挙げられたモジュールを
継承するようにします。それまでの継承の情報は捨てられ、@var{module-name} @dots{}
から計算される継承情報が有効になります。
@c COMMON

@c EN
A new module inherits from @code{gauche} module when created.
If you put @code{(extend scheme)} in that module, for example,
the module resets to inherit directly from @code{scheme} module
that has only bindings defined in R5RS, hence, after the export
form, you can't use 'import' or any other @code{gauche}-specific
bindings in the module.
@c JP
新たに作られるモジュールはデフォルトで@code{gauche}モジュールを継承しています。
例えばそのモジュールに@code{(extend scheme)}というフォームを入れた場合、
その時点でそのモジュールは@code{scheme}モジュール(R5RSで定義された束縛
のみを含む)を直接継承するようになります。したがって、そのフォームの後で
'import' やその他@code{gauche}特有の束縛はそのモジュール内では
使えなくなります。
@c COMMON

@c EN
If a named module is not defined yet, @code{extend}
tries to load it, using the same convention @code{use} macro does.
@c JP
@var{module-name}に挙げられたモジュールがまだ存在しなかった場合、
@code{extend}は@code{use}と同じメカニズムを使ってファイルをロードすることを
試みます。
@c COMMON

@c EN
A module can inherit multiple modules, exactly the same way as
a class can inherit from multiple classes.  The resolution of
order of inheritance needs to be explained a bit.
@c JP
モジュールは複数のモジュールを継承することができます。
丁度、クラスが複数のクラスを継承できるのと同じようにです。
多重継承の場合、次のようにしてモジュール間の優先順位が決められます。
@c COMMON

@c EN
Each module has a @emph{module precedence list}, which lists
modules in the order of how they are searched.  When the module
inherits multiple modules, module precedence lists of inherited
modules are merged into a single list, keeping the constraints
that: (1) if a module A appears before module B in some module
precedence list, A has to appear before B in the resulting module
precedence list; and (2) if a module A appears before module B
in @code{extend} form, A has to appear before B in the resulting
module precedence list.   If no precedence list can be constructed
with these constraints, an error is signalled.
@c JP
各モジュールは@emph{module precedence list}というモジュールのリストを
持っています。そこにリストされた順に束縛が探されます。
モジュールが複数のモジュールを多重継承した場合、継承される各モジュールの
module precedence listを、次に挙げる制約を満たすようにマージ
したものが新たなmodule precedence listとなります：
(1) あるmodule precedence listでモジュールAがモジュールBより前に現れていたら、
結果のmodule precedence listでもAはBより前に現れる：
(2) モジュールAがモジュールBより@code{extend}フォームで前に現れていたら、
結果のmodule precedence listでもAはBより前に現れる。
この条件を満たすようなmodule precedence listが構成できない場合はエラーとなります。
@c COMMON
@end defmac

@c EN
For example, suppose you wrote a library in modules
@code{mylib.base}, @code{mylib.util} and @code{mylib.system}.
You can bundle those modules into one module by creating
a module @code{mylib}, as follows:
@c JP
例えばあなたがライブラリを3つのモジュール、
@code{mylib.base}、@code{mylib.util}、@code{mylib.system}に分けて
書いたとしましょう。次のように書けば、これらのモジュールを
一つの@code{mylib}モジュールに見せることができます。
@c COMMON

@example
(define-module mylib
  (extend mylib.system mylib.util mylib.base))
@end example

@c EN
The user of your module just says @code{(use mylib)} and
all exported symbols from three submodules become available.
@c JP
このライブラリモジュールのユーザは @code{(use mylib)} とするだけで
全てのサブモジュールのexportされた束縛を利用することができるようになります。
@c COMMON

@node Module introspection, Predefined modules, Module inheritance, Modules
@subsection Module introspection
@c NODE モジュールイントロスペクション

@deftp {Builtin Class} <module>
@clindex module
@c EN
A module class.
@c JP
モジュールクラスです。
@c COMMON
@end deftp

@defun module? obj
@c EN
Returns true if @var{obj} is a module.
@c JP
@var{obj}がモジュールなら真の値を返します。
@c COMMON
@end defun

@defun find-module name
@c EN
Returns a module object whose name is a symbol @var{name}.
If the named module doesn't exist, @code{#f} is returned.
@c JP
名前がシンボル@var{name}であるようなモジュールを返します。
その名前をもつモジュールが存在しなければ、@code{#f}を返します。
@c COMMON
@end defun

@defun make-module name &keyword if-exists
@c EN
Creates and returns a module that has symbol @var{name}.
If the named module already exists, the behavior is specified by
@var{if-exists} keyword argument.  If it is @code{:error} (default),
an error is signalled.  If it is @code{#f}, @code{#f} is returned.
@c JP
シンボルの名前@var{name}を持つモジュールを作成して返します。
その名前を持つモジュールが既に存在していた場合、その動作は
@var{if-exists}キーワード引数で指定されます。
@var{if-exists}引数が@code{:error}である場合（デフォルト）、
エラーが報告されます。それが@code{#f}である場合は単に@code{#f}が返されます。
@c COMMON

@c EN
Note that creating modules on-the-fly isn't usually necessary
for ordinal scripts, since to execute already written program requires modules
to be specified by name, i.e. syntax @code{define-module}, @code{import},
@code{extend}, @code{with-module} all takes module names, not
modules.  It is because module are inherently compile-time structure.
However, there are some cases that dynamically created modules
are useful, especially the program itself is dynamically created.
You can pass a module to @code{eval} to compile and
evaluate such dynamically created
programs in it (@xref{Eval and repl}).
@c JP
モジュールを実行時に動的に生成することは、通常のスクリプトでは
あまり必要とはされません。既に書かれたプログラムの解釈においては、
モジュールは名前で指定されている必要があるからです。
構文@code{define-module}、@code{import}、@code{extend}、@code{with-module}
等はモジュールそのものではなくモジュール名を取ります。
これは、モジュールが本質的にコンパイル時の構造であるためです。
しかし、動的に作られるモジュールが有用な場合もあります---プログラムそのものが、
動的に作られる場合です。@code{eval}にモジュールを渡して、
そのような動的に作られたプログラムがそのモジュールの中で
コンパイルされ評価されるようにできます。
@c COMMON

@c EN
You can also pass @code{#f} to @var{name} to create
@emph{anonymous} module.   Anonymous modules can't be
looked up by @code{find-module}, nor can be imported
or inherited (since @code{import} and @code{extend} take
module names, not modules). 
It is useful when you want to have a temporary, segregated namespace
dynamically---for example, you can create an anonymous module
to evaluate code fragments sent from other program, and
discards the module when the connection is terminated.
Anonymous modules are not registered in the system dictionary
and are garbage collected when nobody keeps reference to it.
@c JP
また、@var{name}に@code{#f}を渡すことで無名のモジュールを作ることもできます。
無名のモジュールは@code{find-module}で探すことはできませんし、
他のモジュールから@code{import}することも@code{extend}されることも
できません（@code{import}や@code{extend}はモジュール名を必要とするからです）。
無名のモジュールは、一時的に隔離された名前空間を動的に作りたい時に
便利です。例えばネットワークで接続されたプログラムから送られた式を
その中で評価して、コネクションが終了したら名前空間ごと捨ててしまうという
ような場合です。無名のモジュールはシステムの内部辞書に登録されないので、
モジュールへの参照が無くなればガベージコレクトされます。
@c COMMON
@end defun

@defun all-modules
@c EN
Returns a list of all named modules.
Anonymous modules are not included.
@c JP
現在存在する全ての名前付きモジュールのリストを返します。
無名のモジュールは含まれません。
@c COMMON
@end defun

@defun module-name module
@defunx module-imports module
@defunx module-exports module
@defunx module-table module
@c EN
Accessors of a module object.  Returns the name of the module (a symbol),
list of imported modules, list of exported symbols, and a hash table
that maps symbols to bindings, of the @var{module} are returned,
respectively.
@c JP
モジュールオブジェクトのアクセスメソッドです。
@var{module}の名前(シンボル)、@var{module}がインポートしているモジュールのリスト、
エクスポートしているシンボルのリスト、そして
シンボルから束縛へのマップを行うハッシュテーブルを返します。
@c COMMON

@c EN
If the @var{module} exports all symbols, @code{module-exports} returns
@code{#t}.
@c JP
もし@var{module}が全てのシンボルをエクスポートしている場合は、@code{module-exports}
は@code{#t}を返します。
@c COMMON

@c EN
It is an error to pass a non-module object.
@c JP
モジュールオブジェクト以外が渡された場合はエラーになります。
@c COMMON
@end defun

@defun module-parents module
@defunx module-precedence-list module
@c EN
Returns the information of module inheritance.
@code{Module-parents} returns the modules @var{module} directly inherits
from.  @code{Module-precedence-list} returns the module precedence
list of @var{module} (@xref{Module inheritance}).
@c JP
モジュールの継承に関する情報を返します。
@code{module-parents}は@var{module}が直接継承しているモジュールのリストを
返します。@code{module-precedence-list}は@var{module}のmodule precedence
list (@ref{Module inheritance}参照) を返します。
@c COMMON
@end defun

@defun symbol-bound? symbol &optional module
Returns true iff @var{symbol}'s global binding is visible
from @var{module}.  If @var{module} is omitted, the current module
is used.
@end defun

@node Predefined modules,  , Module introspection, Modules
@subsection Predefined modules
@c NODE 組み込みモジュール

@c EN
Several modules are predefined in Gauche.
@c JP
Gauche起動時にいくつかのモジュールがあらかじめ定義されています。
@c COMMON

@deftp {Builtin Module} null
@mdindex null
@c EN
This module corresponds to the null environment referred in R5RS.
This module contains only syntactic bindings of R5RS syntax.
(With one exception in the current implementation:
Syntax @code{with-module} is in this module, since Gauche needed it
for certain internal setup.  It'll be removed in future.)
@c JP
このモジュールはR5RSで述べられている"null environment"に相当します。
R5RSの構文要素への束縛だけを含んだモジュールです。
(但し現在の実装では一つだけ例外があります：Gaucheが内部処理に必要とするために、
構文@code{with-module}がこのモジュールに含まれています。
将来これは除かれます。)
@c COMMON
@end deftp

@deftp {Builtin Module} scheme
@mdindex scheme
@c EN
This module contains all the binding of @code{null} module,
and the binding of procedures defined in R5RS.
@c JP
このモジュールは@code{null}モジュール内の束縛全てに加えて、
R5RSで定義されている全ての手続きの束縛を含みます。
@c COMMON
@end deftp

@deftp {Builtin Module} gauche
@mdindex gauche
@c EN
This module contains all the bindings of @code{scheme} module,
plus Gauche specific built-in procedures.
@c JP
このモジュールは@code{scheme}モジュール内の全ての束縛に加え、
Gaucheの組込み手続きや構文が含まれています。
@c COMMON
@end deftp

@deftp {Builtin Module} user
@mdindex user
@c EN
This module is the default module the user code is compiled.
all the bindings of @code{gauche} module is imported.
@c JP
このモジュールはユーザコードがコンパイルされる既定のモジュールです。
@code{gauche}モジュール内の全ての束縛がインポートされています。
@c COMMON
@end deftp


@c ======================================================================
@node Macros, Core library, Core syntax, Top
@chapter Macros
@c NODE マクロ

@c EN
Gauche supports both R5RS hygienic macros and
traditional macros.
@c JP
Gaucheでは、R5RSに定義される「健全な(hygienic)」マクロと
伝統的なマクロの両方が使えます。
@c COMMON

@c EN
Macro of Lisp-family language is very different feature from
ones of other languages, such as C preprocessor macros.
It allows you to extend the original language syntax.
You can use macros to change Gauche syntax
so that you can run a Scheme program written to other Scheme
implementations, and you can even design your own mini-language
to solve your problem easily.
@c JP
Lisp系言語のマクロは、他の言語に見られるマクロ(例えばCプリプロセッサマクロ)とは
大きく異なります。Lispのマクロは元の言語の構文を拡張する手段なのです。
例えば、Gaucheの構文を若干変えることで他のScheme実装用に書かれたSchemeプログラムを
走らせたり、あるいは自分の問題解決に適した「ミニ言語」をデザインすることさえできます。
@c COMMON

@menu
* Hygienic Macros::             
* Traditional Macros::          
* Macro expansion::             
* Macro utilities::             
@end menu

@node Hygienic Macros, Traditional Macros, Macros, Macros
@section Hygienic Macros
@c NODE 健全なマクロ

@c EN
R5RS hygienic macro is based on a special pattern language,
and guaranteed that no "variable capture" occurs.
"Variable catpture" means that if you insert new variable
bindings in the expanded form, the new bindings
shadows the bindings in the form passed to the macro.
@c JP
R5RSの健全なマクロは特別なパターン言語に基づいていて、
また「変数捕捉」が起こらないことが保証されています。
「変数捕捉」とは、マクロが新しい変数束縛を導入した時に、その束縛が
マクロに渡されたフォーム中の変数名と衝突して、その変数名の本来の束縛を隠して
しまうことを言います。
@c COMMON

@defspec define-syntax name transformer-spec
[R5RS]
@end defspec

@defspec let-syntax ((name transformer-spec) @dots{}) body
@defspecx letrec-syntax ((name transformer-spec) @dots{}) body
[R5RS]
@end defspec

@defspec syntax-rules literals clause1 clause2 @dots{}
[R5RS]
@end defspec


@node Traditional Macros, Macro expansion, Hygienic Macros, Macros
@section Traditional Macros
@c NODE 伝統的なマクロ

@defspec define-macro name procedure
@defspecx define-macro (name formals) body @dots{}
@c EN
Defines @var{name} to be a global macro whose transformer is @var{procedure}.
The second form is a shorthand notation of the following form:
@c JP
変換子が @var{procedure} である大域マクロ @var{name} を定義します。
2番目のフォームは、以下のフォームの簡易記法です。
@c COMMON
@example
(define-macro name (lambda formals body @dots{}))
@end example

@c EN
When a form @code{(name @var{arg} @dots{})} is seen by the compiler,
it calls @var{procedure} with @var{arg} @dots{}.  When @var{procedure}
returns, the compiler inserts the returned form in place of the original
form, and compile it again.
@c JP
コンパイラが @code{(name @var{arg} @dots{})} というフォームを見つけると、
@var{arg} @dots{} を引数として @var{procedure} を呼び出します。
@var{procedure} が戻ると、コンパイラは元のフォームの場所に返されたフォームを
挿入し、再度それをコンパイルします。
@c COMMON
@end defspec

@node Macro expansion, Macro utilities, Traditional Macros, Macros
@section Macro expansion
@c NODE マクロの展開

@defun macroexpand form
@defunx macroexpand-1 form
@c EN
If @var{form} is a list and its first element is a variable
globally bound to a macro, @code{macroexpand-1}
invokes its macro transformer and
returns the expanded form.  Otherwise, returns @var{form} as is.

@code{macroexpand} repeats @code{macroexpand-1} until the
@var{form} can't be expanded.

These procedures can be used to expand globally defined macros.
@c JP
@var{form} がリストで、その最初の要素が大域的にマクロに束縛された
変数であるならば、@code{macroexpand-1}はそのマクロ変換子を実行し、
展開されたフォームを返します。そうでなければ、@var{form} をそのまま
返します。

@code{macroexpand} は、@var{form} が展開できなくなるまで
@code{macroexpand-1} を繰り返します。

これらの手続きは、大域的に定義されたマクロを展開するために使うことが
できます。
@c COMMON
@end defun

@defspec %macroexpand form
@defspecx %macroexpand-1 form
@end defspec

@node Macro utilities,  , Macro expansion, Macros
@section Macro utilities
@c NODE マクロユーティリティ

@defmac syntax-error msg arg @dots{}
@defmacx syntax-errorf fmt arg @dots{}
@c EN
Signal an error.  They are same as
@code{error} and @code{errorf} (@xref{Signalling errors}),
except that the error is signalled at macro-expansion time
(i.e. compile time) rather than run time.

They are useful to tell the user the wrong usage of macro in
the comprehensive way, instead of the cryptic error from the macro
expander.   Because of the purpose, @var{arg} @dots{} are first
passed to @code{unwrap-syntax} described below, to strip off
the internal syntactic binding informations.
@c JP
エラーを通知します。
@c COMMON

@example
(define-syntax my-macro
  (syntax-rules ()
    ((_ a b)   (foo2 a b))
    ((_ a b c) (foo3 a b c))
    ((_ . ?)
     (syntax-error "malformed my-macro" (my-macro . ?)))))

(my-macro 1 2 3 4)
  @result{} @r{error: "malformed my-macro: (mymacro 1 2 3 4)"}
@end example

@end defmac

@defun unwrap-syntax form
Removes internal syntactic information from @var{form}.
In order to implement a hygienic macro, macro expander replaces
symbols in the macro form for identifiers, which captures the
syntactic environment where they are defined.  Although it is
necessary information for the compiler, it is rather confusing
for users if it appears in the messages.  This function
replaces occurrences of identifiers in @var{form} to the original
symbols.
@end defun

@c ======================================================================
@node Core library, Object system, Macros, Top
@chapter Core library
@c NODE 組み込みライブラリ

@c ----------------------------------------------------------------------
@menu
* Equivalence::                 
* Numbers::                     
* Booleans::                    
* Pairs and Lists::             
* Symbols::                     
* Keywords::                    
* Identifiers::                 
* Characters::                  
* Character set::               
* Strings::                     
* Regular expression::          
* Vectors::                     
* Hashtables::                  
* Weak pointers::               
* Control features::            
* Exceptions::                  
* Eval and repl::               
* Input and output::            
* Loading Programs::            
* Comparison and sorting::      
* System interface::            
@end menu

@node Equivalence, Numbers, Core library, Core library
@section Equivalence
@c NODE 等価

@c EN
Scheme has three different general equivalence test predicates.
Other than these, some types have their own comarison predicates.
@c JP
Schemeには等価性を判定する汎用的な述語が3つあります。
また、これらの他に、いくつかの型はその型同士で使える比較手続きを持っています。
@c COMMON

@defun eq? obj1 obj2
[R5RS]
@c EN
This is the fastest and finest predicate.
Returns @code{#t} if @var{obj1} and @var{obj2} are allocated objects of
the same types, and denote the same location.  Returns @code{#t}
if both objects are @code{#f}, @code{#t}, or @code{()}.
You can think @var{eq?} as a pointer comparison.
Note that the result is unspecified in Scheme standard when
both objects are characters or numbers.
@c JP
最も高速で、細かい区別ができる述語です。
@var{obj1}と@var{obj2}がアロケートされる同じ型のオブジェクトで、
かつ両者がメモリ上の全く同じ場所を占めるオブジェクトを指している場合に
@code{#t}を返します。また、@var{obj1}と@var{obj2}がともに
@code{#f}, @code{#t}あるいは@code{()}である場合も@code{#t}を返します。
ポインタ比較と考えても良いでしょう。
@var{obj1}と@var{obj2}がともに文字、あるいは数値であった場合の振るまいは
Schemeの標準では定められていません。
@c COMMON

@example
(eq? #t #t)               @result{} #t
(eq? #t #f)               @result{} #f
(eq? 'a 'a)               @result{} #t
(eq? 'a 'b)               @result{} #f
(eq? (list 'a) (list 'a)) @result{} #f
(let ((x (list 'a)))
  (eq? x x))              @result{} #t
@end example
@end defun

@defun eqv? obj1 obj2
[R5RS]
@c EN
When @var{obj1} and @var{obj2} are both exact or both inexact numbers,
@var{eqv?} returns @code{#t} iff @code{(= @var{obj1} @var{obj2})} is true.
When @var{obj1} and @var{obj2} are both characters,
@var{eqv?} returns @code{#t} iff @code{(char=? @var{obj1} @var{obj2})} is true.
Otherwise, @code{eqv?} is the same as @code{eq?} on Gauche.
@c JP
@var{obj1}と@var{obj2}がともに正確な数値、もしくはともに不正確な数値である場合、
@code{(= @var{obj1} @var{obj2})}が真であれば@code{#t}が、偽であれば@code{#f}が
返されます。
@var{obj1}と@var{obj2}がともに文字である場合、
@code{(char=? @var{obj1} @var{obj2})}が真であれば@code{#t}が、偽であれば@code{#f}が
返されます。
それ以外の場合は、Gaucheでは@code{eqv?}は@code{eq?}と同じです。
@c COMMON

@example
(eqv? #\a #\a)             @result{} #t
(eqv? #\a #\b)             @result{} #f
(eqv? 1.0 1.0)             @result{} #t
(eqv? 1 1)                 @result{} #t
(eqv? 1 1.0)               @result{} #f
(eqv? (list 'a) (list 'a)) @result{} #f
(let ((x (list 'a)))
  (eqv? x x))              @result{} #t
@end example
@end defun

@defun equal? obj1 obj2
[R5RS+]
@c EN
If @var{obj1} and @var{obj2} are both aggregate types,
@code{equal?} compares its elements recursively.
Otherwise, @code{equal?} behaves the same as @code{eqv?}.

If @var{obj1} and @var{obj2} are other than booleans, numbers,
characters, pairs, strings and vectors, and the class of both
objects are the same, @code{equal?} calls the generic
function @code{object-equal?}.
By defining the method, users can extend the behavior of @code{equal?}
for user-defined classes.
@c JP
@var{obj1}と@var{obj2}がリストやベクタなどの複合型である場合、
@code{equal?}は再帰的に対応する要素同士を@code{equal?}で比較してゆきます。
そうでなければ、@code{equal?}は@code{eqv?}と同じようにふるまいます。

もし@code{obj1}と@var{obj2}が論理値、数値、文字、ペア、文字列、
ベクタのいずれでもなく、かつ両者のクラスが等しい場合、@code{equal?}は
ジェネリックファンクション@code{object-equal?}を呼びます。
@code{object-equal?}にメソッドを定義することにより、
ユーザ定義のデータ型に対する@code{equal?}の振るまいを拡張することができます。
@c COMMON

@example
(equal? (list 1 2) (list 1 2)) @result{} #t
(equal? "abc" "abc")           @result{} #t
(equal? 100 100)               @result{} #t
(equal? 100 100.0)             @result{} #f
@end example

@end defun

@deffn {Generic Function} object-equal? obj1 obj2
@c EN
This generic function is called when @code{equal?} is called on the objects
it doesn't know about.  You can define this method on your class
so that @code{equal?} can check equivalence.   This method is supposed
to return @code{#t} if @var{obj1} is equal to @var{obj2}, @code{#f}
otherwise.  If you want to check equivalence of elements recursively,
do not call @code{object-equal?} directly; call @code{equal?} on each element.
@c JP
@code{equal?}が未知のオブジェクトに対して呼ばれた場合、
このジェネリックファンクションが呼ばれます。自分で定義したクラスに対して
このメソッドを定義することにより、@code{equal?}で等価判定が行えるように
なります。メソッドは、@var{obj1}と@var{obj2}が等価ならば@code{#t}を、
そうでなければ@code{#f}を返さねばなりません。
オブジェクトの各要素に対して再帰的に等価判定を行いたい場合は、
@code{object-equal?}を直接呼ぶのではなく、@code{equal?}を各要素に対して
呼ぶようにして下さい。
@c COMMON

@example
(define-class <foo> ()
  ((x :init-keyword :x)
   (y :init-keyword :y)))

(define-method object-equal? ((a <foo>) (b <foo>))
  (and (equal? (slot-ref a 'x) (slot-ref b 'x))
       (equal? (slot-ref a 'y) (slot-ref b 'y))))

(equal? (make <foo> :x 1 :y (list 'a 'b))
        (make <foo> :x 1 :y (list 'a 'b)))
  @result{} #t

(equal? (make <foo> :x 1 :y (make <foo> :x 3 :y 4))
        (make <foo> :x 1 :y (make <foo> :x 3 :y 4)))
  @result{} #t
@end example
@end deffn

@c EN
Sometimes you want to test if two aggregate structures
are topologically equal, i.e., if one has a shared substructure,
the other has a shared substructure in the same way.
@code{Equal?} can't handle it; module @code{util.isomorph} 
provides a procedure @code{isomorphic?} which does the job
(@xref{util.isomorph - Determine isomorphism}).
@c JP
しばしば、ふたつの複合型オブジェクトに関して、両者がトポロジー的に等しいこと、
すなわち一方が共有する部分構造を持っている場合にもう一方も同じように部分構造を
共有しているかどうかを調べたいことがあります。@code{equal?}はその目的には
使えません。モジュール@code{util.isomorph}の提供する@code{isomorphic?}が
その目的に使えます。(@ref{util.isomorph - Determine isomorphism}参照)。
@c COMMON

@c ----------------------------------------------------------------------
@node Numbers, Booleans, Equivalence, Core library
@section Numbers
@c NODE 数値

@c EN
Gauche supports the following types of numbers
@table @asis
@item multi-precision exact integer
There's no limit of the size of number except the memory of the machine.
@item inexact floating-point real number
Using @code{double}-type of underlying C compiler, usually IEEE 64-bit
floating point number.
@item inexact floating-point complex number
Real part and imaginary part are represented by inexact floating-point
real numbers.
@end table
@c JP
Gaucheは次のタイプの数値をサポートしています。
@table @asis
@item 多倍長の正確な整数
メモリの許す限りの精度が扱えます。
@item 浮動少数点の不正確な実数
実装に使われるC言語の@code{double}型で表現されます。通常IEEE 64bit浮動少数点数です。
@item 浮動少数点の不正確な複素数
実部と虚部はそれぞれ浮動少数点の不正確な実数で表現されます。
@end table
@c COMMON

@menu
* Number classes::              
* Numerical predicates::        
* Numerical comparison::        
* Arithmetics::                 
* Numerical conversions::       
* Bitwise operations::          
@end menu

@node Number classes, Numerical predicates, Numbers, Numbers
@subsection Number classes
@c NODE 数値クラス

@deftp {Builtin Class} <number>
@deftpx {Builtin Class} <complex>
@deftpx {Builtin Class} <real>
@deftpx {Builtin Class} <integer>
@clindex number
@clindex complex
@clindex real
@clindex integer
@c EN
These classes consist a class hierarchy of number objects.
@code{<complex>} inherits @code{<number>}, @code{<real>} inherits
@code{<complex>} and @code{<integer>} inherits @code{<real>}.

Note that these classes does not exactly corresponds to the
number hierarchy defined in R5RS.  Especially, 
only exact integers are the instances of the @code{<integer>}
class.  That is,
@c JP
数値オブジェクトのクラス階層を構成します。@code{<complex>}は
@code{<number>}を継承し、@code{<real>}は@code{<complex>}を継承し、
@code{<integer>}は@code{<real>}を継承します。

これらのクラスはR5RSで定義されている数値の階層とは必ずしも対応しません。
特に、@code{<integer>}クラスのインスタンスはR5RSでいうexact integerのみになります。
@c COMMON
@lisp
(integer? 1)        @result{} #t
(is-a? 1 <integer>) @result{} #t
(is-a? 1 <real>)    @result{} #t

(integer? 1.0)        @result{} #t
(is-a? 1.0 <integer>) @result{} #f
(is-a? 1.0 <real>)    @result{} #t

(class-of (expt 2 100)) @result{} #<class <integer>>
(class-of (sqrt -3)) @result{} #<class <complex>>
@end lisp
@end deftp

@node Numerical predicates, Numerical comparison, Number classes, Numbers
@subsection Numerical predicates
@c NODE 数値に関する述語

@defun number? obj
@defunx complex? obj
@defunx real? obj
@defunx rational? obj
@defunx integer? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a number, a complex number, a real number,
a rational number or an integer, respectively.   In Gauche, a set of
numbers is the same as a set of complex numbers, and a set of
rational numbers is the same as a set of integers.
@c JP
@var{obj}がそれぞれ数、複素数、実数、有理数、整数ならば@code{#t}を返します。
Gaucheでは、数の集合は複素数の集合と同一であり、有理数の集合は整数の集合と同一です。
@c COMMON

@example
(complex? 3+4i)   @result{} #t
(complex? 3)      @result{} #t
(real? 3)         @result{} #t
(real? -2.5+0.0i) @result{} #t
(real? #e1e10)    @result{} #t
(integer? 3+0i)   @result{} #t
(integer? 3.0)    @result{} #t
@end example
@end defun

@defun exact? obj
@defunx inexact? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is an exact number and an inexact number,
respectively.
@c JP
@var{obj}がそれぞれ正確な数、不正確な数ならば@code{#t}を返します。
@c COMMON

@example
(exact? 1)       @result{} #t
(exact? 1.0)     @result{} #f
(inexact? 1)     @result{} #f
(inexact? 1.0)   @result{} #t

(exact? (modulo 5 3)) @result{} #t
(inexact? (modulo 5 3.0)) @result{} #f
@end example
@end defun

@defun zero? z
[R5RS]
@c EN
Returns @code{#t} if a number @var{z} equals to zero.
@c JP
数値@var{z}がゼロに等しければ@code{#t}を返します。
@c COMMON

@example
(zero? 1)        @result{} #f
(zero? 0)        @result{} #t
(zero? 0.0)      @result{} #t
(zero? 0.0+0.0i) @result{} #t
@end example
@end defun

@defun positive? x
@defunx negative? x
[R5RS]
@c EN
Returns @code{#t} if a real number @var{x} is positive and negative,
respectively.  It is an error to pass a non-real number.
@c JP
実数@var{x}がそれぞれ正または負なら@code{#t}を返します。
非実数を渡すとエラーになります。
@c COMMON
@end defun

@defun odd? n
@defunx even? n
[R5RS]
@c EN
Returns @code{#t} if an integer @var{n} is odd and even, 
respectively.  It is an error to pass a non-integral number.
@c JP
整数@var{n}がそれぞれ奇数または偶数なら@code{#t}を返します。
非整数を渡すとエラーになります。
@c COMMON

@example
(odd? 3)     @result{} #t
(even? 3)    @result{} #f
(odd? 3.0)   @result{} #t
@end example
@end defun

@defun fixnum? n
@defunx bignum? n
@c EN
Returns @code{#t} iff @var{n} is an exact integer whose internal
representation is @var{fixnum} and @var{bignum}, respectively.
Portable Scheme programs don't need to care about the internal
representation of integer.   These are for certain low-level
routines that does particular optimization.
@c JP
@var{n}が正確な整数で、かつ内部的にそれぞれ@var{fixnum}もしくは@var{bignum}
で表現されているときに@code{#t}を返します。
通常のSchemeプログラムは整数の内部表現を気にする必要はありません。
これらの手続きは、ある種の最適化を行う低レベル手続きのために用意されています。
@c COMMON
@end defun

@node Numerical comparison, Arithmetics, Numerical predicates, Numbers
@subsection Numerical comparison
@c NODE 数値の比較

@defun @code{=} z1 z2 z3 @dots{}
[R5RS]
@c EN
If all the numbers @var{z} are equal, returns @code{#t}.
@c JP
与えられた全ての数値@var{z}が等しければ@code{#t}を返します。
@c COMMON

@example
(= 2 2)          @result{} #t
(= 2 3)          @result{} #f
(= 2 2.0)        @result{} #t
(= 2 2.0 2.0+0i) @result{} #t
@end example
@end defun

@defun @code{<} x1 x2 x3 @dots{}
@defunx @code{<=} x1 x2 x3 @dots{}
@defunx @code{>} x1 x2 x3 @dots{}
@defunx @code{>=} x1 x2 x3 @dots{}
[R5RS]
@c EN
Returns @code{#t} If all the real numbers @var{x} are
monotonically increasing,
monotonically nondecreasing, monotonically decreasing, or monotonically
nonincreasing, respectively.
@c JP
与えられた全ての実数@var{x}がそれぞれ単調増加、単調非減少、単調減少、単調非増加している
場合に@code{#t}を返します。
@c COMMON
@end defun


@defun max x1 x2 @dots{}
@defunx min x1 x2 @dots{}
[R5RS]
@c EN
Returns a maximum or minimum number in the given real numbers, respectively.
@c JP
与えられた実数のうち、それぞれ最大と最小のものを返します。
@c COMMON
@end defun

@defun min&max x1 x2 @dots{}
@c EN
Returns a maximum and minimum number in the given real numbers.
@c JP
与えられた実数から、最大値と最小値の二つの値を返します。
@c COMMON
@end defun

@node Arithmetics, Numerical conversions, Numerical comparison, Numbers
@subsection Arithmetics
@c NODE 数値の演算

@defun @code{+} z @dots{}
@defunx @code{*} z @dots{}
[R5RS]
@c EN
Returns the sum or the product of given numbers, respectively.
If no argument is given, @code{(+)} yields 0 and @code{(*)} yields 1.
@c JP
与えられた数の和と積をそれぞれ返します。引数が与えられない場合、
@code{(+)} は 0、 @code{(*)} は 1 となります。
@c COMMON
@end defun

@defun @code{-} z1 z2 @dots{}
@defunx @code{/} z1 z2 @dots{}
[R5RS]
@c EN
If only one number @var{z1} is given, returns its
negation and reciprocal, respectively.

If more than one number are given, returns:
@example
@var{z1} - @var{z2} - @var{z3} @dots{}
@var{z1} / @var{z2} / @var{z3} @dots{}
@end example
respectively.
@c JP
一つだけ数値が与えられた場合、それぞれnegationと逆数を返します。

2つ以上の数値が与えられた場合、それぞれ次の結果を返します。
@example
@var{z1} - @var{z2} - @var{z3} @dots{}
@var{z1} / @var{z2} / @var{z3} @dots{}
@end example
@c COMMON

@example
(- 3)       @result{} -3
(- -3.0)    @result{} 3.0
(- 5+2i)    @result{} -5.0-2.0i
(/ 3)       @result{} 0.333333333333333
(/ 5+2i)    @result{} 0.172413793103448-0.0689655172413793i

(- 5 2 1)     @result{} 2
(- 5 2.0 1)   @result{} 2.0
(- 5+3i -i)   @result{} 5.0+2.0i
(/ 6+2i 2)    @result{} 3.0+1.0i
@end example
@end defun

@defun abs z
[R5RS+]
@c EN
For real number @var{z}, returns an absolute value of it.
For complex number @var{z}, returns the magnitude of the number.
The complex part is Gauche extension.
@c JP
実数の@var{z}に対しては、その絶対値を返します。
複素数の@var{z}に対しては、そのmagnitudeを返します。
複素数を扱うのはGaucheの拡張です。
@c COMMON
@example
(abs -1)   @result{} 1
(abs -1.0) @result{} 1.0
(abs 1+i)  @result{} 1.4142135623731
@end example
@end defun

@defun quotient n1 n2
@defunx remainder n1 n2
@defunx modulo n1 n2
[R5RS]
@c EN
Returns the quotient, remainder and modulo of dividing an integer @var{n1}
by an integer @var{n2}.   The result is an exact number only if
both @var{n1} and @var{n2} are exact numbers.

Remainder and modulo differ when either one of the arguments is negative.
Remainder @var{R} and quotient @var{Q} have the following relationship.
@example
  @var{n1} = @var{Q} * @var{n2} + @var{R}
@end example
where @code{abs(@var{Q}) = floor(abs(@var{n1})/abs(@var{n2}))}.
Consequently, @var{R}'s sign is always the same as @var{n1}'s.

On the other hand, modulo works as expected for positive @var{n2},
regardless of the sign of @var{n1}
(e.g. @code{(modulo -1 @var{n2}) == @var{n2} - 1}).
If @var{n2} is negative, it is mapped to the positive case by
the following relationship.
@example
  modulo(@var{n1}, @var{n2}) = @minus{}modulo(@minus{}@var{n1}, @minus{}@var{n2})
@end example
Consequently, @var{modulo}'s sign is always the same as @var{n2}'s.
@c JP
整数@var{n1}を整数@var{n2}で割った商(quotient)および余り(remainder, modulo)
を返します。  @var{n1}と@var{n2}の両方が正確な数値の時のみ、戻り値は正確な数値になります。

@code{remainder}と@code{modulo} はどちらかの引数が負の時に異なる値を返します。
Remainder @var{R} と商 @var{Q} とは次の関係があります。
@example
  @var{n1} = @var{Q} * @var{n2} + @var{R}
@end example
ここで商について @code{abs(@var{Q}) = floor(abs(@var{n1})/abs(@var{n2}))}
ですから、@var{R}の符号は常に@var{n1}と同じになります。

一方、moduloは@var{n2}が正の時は@var{n1}の符号に関わらず期待したように動作します
(例: @code{(modulo -1 @var{n2}) == @var{n2} - 1})。
@var{n2}が負の場合は次の式によって正の場合にマップできます。
@example
  modulo(@var{n1}, @var{n2}) = @minus{}modulo(@minus{}@var{n1}, @minus{}@var{n2})
@end example
したがって、moduloの結果の符号は常に@var{n2}の符号と同じになります。
@c COMMON
@example
(remainder 10 3)    @result{} 1
(modulo 10 3)       @result{} 1

(remainder -10 3)   @result{} -1
(modulo -10 3)      @result{} 2

(remainder 10 -3)   @result{} 1
(modulo 10 -3)      @result{} -2

(remainder -10 -3)  @result{} -1
(modulo -10 -3)     @result{} -1
@end example
@end defun

@defun quotient&remainder n1 n2
@c EN
Calculates the quotient and the remainder of dividing integer @var{n1}
by integer @var{n2} simultaneously, and returns them as two values.
@c JP
整数@var{n1}を整数@var{n2}で割った商(quotient)および余り(remainder)
を同時に計算し、2つの値として返します。
@c COMMON
@end defun

@defun gcd n @dots{}
@defunx lcm n @dots{}
[R5RS]
@c EN
Returns the greatest common divisor or the least common multiplier
of the given integers, respectively
@c JP
与えられた整数の、最大公約数と最小公倍数をそれぞれ返します。
@c COMMON
@end defun

@defun numerator q
@defunx denominator q
[R5RS]
@c EN
Returns the numerator and denominator of a rational number @var{q}.
Since Gauche doesn't support full rational numbers, they actually
work only on integers; that is, given integer @var{q}, @code{numerator}
always returns @var{q} and @code{denominator} always return 1.
@c JP
有理数@var{q}の分子と分母をそれぞれ返します。Gaucheでは今のところ有理数を完全には
サポートしていないため、これらの手続きは実際には整数にしか使えません。すなわち、
整数@var{q}に対して@code{numerator}は常に@var{q}を返し、@code{denominator}
は常に1を返します。
@c COMMON
@end defun


@defun floor x
@defunx ceiling x
@defunx truncate x
@defunx round x
[R5RS]
@c EN
The argument @var{x} must be a real number.
@code{Floor} and @code{ceiling} return a minimum integer that
is greater than @var{x} and a maximim integer that is less than @var{x},
respectively.  @var{Truncate} returns an integer that truncates
@var{x} towards zero.  @var{Round} returns an integer that is closest
to @var{x}.  If fractional part of @var{x} is exactly 0.5, @var{round}
returns the closest even integer.
@c JP
引数@var{x}は実数でなければなりません。@code{floor}と@code{ceiling}はそれぞれ
@var{x}を越えない最大の整数と、@var{x}を下回らない最小の整数を返します。
@var{truncate}は@var{x}の小数部をゼロの方向に向かって切捨てた整数を返します。
@var{round}は@var{x}に最も近い(四捨五入した)整数を返します。@var{x}の
小数部が0.5ぴったりだった場合は@var{round}は最も近い偶数を返します。
@c COMMON
@end defun

@defun clamp x &optional min max
@c EN
Returns
@example
 @var{min} @r{if} @var{x} @code{<} @var{min}
 @var{x}   @r{if} @var{min} @code{<=} @var{x} @code{<=} @var{max}
 @var{max} @r{if} @var{max} @code{<} @var{x}
@end example
If @var{min} or @var{max} is omitted or @code{#f}, it is regarded
as @var{-infinity} or @var{+infinity}, respectively.
Returns an exact integer only if all the given numbers are exact integers.
@c JP
@example
 @var{min} @r{if} @var{x} @code{<} @var{min}
 @var{x}   @r{if} @var{min} @code{<=} @var{x} @code{<=} @var{max}
 @var{max} @r{if} @var{max} @code{<} @var{x}
@end example
を返します。もし@var{min}または@var{max}が省略されるか@code{#f}が与えられたら、
それぞれ @var{-∞} もしくは @var{+∞} と解釈されます。
与えられた全ての数値が正確な整数の場合に限り正確な整数を返します。
@c COMMON
@example
(clamp 3.1 0.0 1.0) @result{} 1.0
(clamp 0.5 0.0 1.0) @result{} 0.5
(clamp -0.3 0.0 1.0) @result{} 0.0
(clamp -5 0)        @result{} 0
(clamp 3724 #f 256) @result{} 256
@end example
@end defun


@defun exp z
@defunx log z
@defunx sin z
@defunx cos z
@defunx tan z
@defunx asin z
@defunx acos z
@defunx atan z
[R5RS]
@c EN
Transcedental functions.  Work for complex numbers as well.
@c JP
超越関数です。複素数も扱えます。
@c COMMON
@end defun

@defun atan x y
[R5RS]
@c EN
For real numbers @var{x} and @var{y}, returns @code{atan(@var{y}/@var{x})}.
@c JP
実数@var{x}と@var{y}に対して@code{atan(@var{y}/@var{x})}を返します。
@c COMMON
@end defun

@defun sinh z
@defunx cosh z
@defunx tanh z
@defunx asinh z
@defunx acosh z
@defunx atanh z
@c EN
Hyperbolic trigonometric functions.  Work for complex numbers as well.
@c JP
双曲線関数です。複素数も扱えます。
@c COMMON
@end defun

@defun sqrt z
[R5RS]
@c EN
Returns a square root of a complex number @var{z}.
The branch cut scheme is the same as Common Lisp.
For real numbers, it returns a positive root.
@c JP
複素数@var{z}の平方根のひとつを返します。枝刈りの定義はCommon Lispと同じです。
実数に対しては正の平方根を返します。
@c COMMON
@end defun

@defun expt z1 z2
[R5RS]
@c EN
Returns @var{z1}^@var{z2} (@var{z1} powered by @var{z2}),
where @var{z1} and @var{z2} are complex numbers.
@c JP
複素数@var{z1}, @var{z2}に対して、
@var{z1}^@var{z2} (@var{z1}の@var{z2}乗)を返します。
@c COMMON
@end defun

@node Numerical conversions, Bitwise operations, Arithmetics, Numbers
@subsection Numerical conversions
@c NODE 数値の変換

@defun make-rectangular x1 x2
@defunx make-polar x1 x2
[R5RS]
@c EN
Creates a complex number from two real numbers, @var{x1} and @var{x2}.
@code{make-rectangular} returns @var{x1} + @b{i}@var{x2}.
@code{make-polar} returns @var{x1}@b{e}^(@b{i}@var{x2}).
@c JP
二つの実数@var{x1}と@var{x2}から複素数を作ります。
@code{make-rectangular} は @var{x1} + @b{i}@var{x2} を返します。
@code{make-polar} は @var{x1}@b{e}^(@b{i}@var{x2}) を返します。
@c COMMON
@end defun

@defun real-part z
@defunx imag-part z
@defunx magnitude z
@defunx angle z
[R5RS]
@c EN
Decompose a complex number @var{z} and returns a real number.
@code{real-part} and @code{imag-part} return @var{z}'s real and imaginary
part, respectively.  @code{magnitude} and @code{angle} return
@var{z}'s magnitude and angle, respectively.
@c JP
複素数@var{z}を取り、実数を返します。
@code{real-part}と@code{imag-part}は@var{z}の実数部と虚数部をそれぞれ返し、
@code{magnitude}と@code{angle}は@var{z}の絶対値と偏角をそれぞれ返します。
@c COMMON
@end defun

@defun decode-float x
@c EN
Given floating-point number (inexact real number), returns
a vector of three exact integers, @code{#(@var{m}, @var{e}, @var{sign})},
where
@example
  @var{x} = (* @var{sign} @var{m} (expt 2.0 @var{e}))
  @var{sign} is either 1, 0 or -1.
@end example
The API is taken from ChezScheme.
@c JP
与えられた浮動小数点数(不正確な実数)@var{x}に対して、
3つの正確な整数からなるベクタ @code{#(@var{m}, @var{e}, @var{sign})}
を返します。ここで、
@example
  @var{x} = (* @var{sign} @var{m} (expt 2.0 @var{e}))
  @var{sign} は 1, 0 または -1.
@end example
です。このAPIはChezSchemeから取られました。
@c COMMON
@example
(decode-float 3.1415926)
 @result{} #(7074237631354954 -51 1)
(* 7074237631354954 (expt 2.0 -51))
 @result{} 3.1415926
@end example
@end defun

@defun fmod x y
@defunx modf x
@defunx frexp x
@defunx ldexp x n
[POSIX] 
@c EN
These procedures can be used to compose and decompose floating
point numbers.  @code{Fmod} computes the remainder of dividing @var{x}
by @var{y}, that is, it returns @var{x}-@var{n}*@var{y} where
@var{n} is the quotient of @var{x}/@var{y} rounded towards zero
to an integer.   @code{Modf} returns two values; a fractional
part of @var{x} and an integral part of @var{x}.   @code{Frexp}
returns two values, @var{fraction} and @var{exponent} of @var{x},
where @var{x} = @var{fraction} * 2^@var{exponent}, and
0 <= @var{fraction} <= 0.5.  @var{Ldexp} is a reverse operation of 
@code{frexp}; it returns a real number @var{x} * 2^@var{n}.
@c JP
これらの手続きは、浮動少数点数を分解したり合成するのに使えます。
@code{fmod}は実数@var{x}を実数@var{y}で割った余りを返します。すなわち、
@var{x}/@var{y}を0に近いほうの整数に丸めた値を@var{n}とするとき、
@var{x}-@var{n}*@var{y}を返します。
@code{modf}は@var{x}の少数部と整数部を返します。
@code{frexp}は実数@var{x}を、仮数部と指数部に分解して返します。すなわち、
@var{x} = @var{fraction} * 2^@var{exponent} かつ 0 <= @var{fraction} <= 0.5
であるところの@var{fraction}と@var{exponent}を返します。
@code{ldexp}は@code{frexp}の逆関数で、@var{x} * 2^@var{n} を返します。
@c COMMON
@example
(fmod 32.1 10.0)  @result{} 2.1
(fmod 1.5 1.4)    @result{} 0.1
(modf 12.5)       @result{} 0.5 @r{and} 12.0
(frexp 3.14)      @result{} 0.785 @r{and} 2
(ldexp 0.785 2)   @result{} 3.14
@end example
@end defun

@defun exact->inexact z
@defunx inexact->exact z
[R5RS]
@c EN
Converts an exact number to an inexact number, or vice versa.

Since Gauche doesn't support general rational numbers, 
the result of @code{inexact->exact} is always a whole number.
If the passed number is not an integer, the fraction part is
rounded.  Note that it is an implementation dependent behavior.
If you want to get a closest exact integer of the given inexact
real number, it's better to use @code{round} explicitly before
@code{inexact->exact}.

If you pass an inexact number to @code{exact->inexact} or
an exact number to @code{inexact->exact}, Gauche returns
the argument as is, instead of reporting an error.
This is also an implementation dependent behavior and
you shouldn't count on that.
@c JP
正確な数を不正確な数に変換、またその逆を行う手続きです。

Gaucheは一般的な有理数をサポートしないため、@code{inexact->exact}の結果は
常に整数となります。整数でない数を渡した場合は小数点以下が丸められます。但しこれは
実装依存の振舞いなので、ポータブルなプログラムで不正確な実数を正確な整数に丸めたい
時には@code{inexact->exact}の前に明示的に@code{round}を使うべきでしょう。

不正確な数を@code{exact->inexact}に渡したり、または正確な数を
@code{inexact->exact}に渡した場合、Gaucheでは今のところエラーにならず
引数がそのまま返されます。これも実装依存の振舞いなのでなるべく避けるようにして下さい。
@c COMMON
@end defun

@defun number->string z &optional radix use-upper?
@defunx string->number string &optional radix
[R5RS+]
@c EN
These procedurs convert a number and its string representation
in radix @var{radix} system.
@var{radix} must be between 2 and 36 inclusive.
If @var{radix} is omitted, 10 is assumed.

@code{Number->string} takes a number @var{z} and returns a string.
If @var{z} is not an exact integer, @var{radix} must be 10.
For the numbers with radix more than 10, lower case alphabet
character is used for digits, unless the optional argument
@var{use-upper?} is true, in that case upper case characters are used.
The argument @var{use-upper?} is Gauche's extension.

@code{String->number} takes a string @var{string} and parses it
as a number in radix @var{radix} system.  If the number looks like
non-exact number, only radix 10 is allowed.  If the given string
can't be a number, @code{#f} is returned.
@c JP
これらの手続きは数値とそれを@var{radix}進数で表現する文字列とを変換します。
@var{radix}は2から36の間でなければなりません。省略された場合は10進数とみなされます。

@code{number->string}は数値@var{z}を取り文字列を返します。
@var{z}が正確な整数以外の場合、@var{radix}は10でなければなりません。
10より大きい@var{radix}に関しては、小文字のアルファベットが桁として使われます。
但し、省略可能な引数@var{use-upper?}に真の値が与えられた場合は大文字のアルファベットが
使われます。@var{use-upper?}引数はGaucheの拡張です。

@code{string->number}は文字列@var{string}を取り数値を返します。
不正確な数値は10進数表記しか認識されません。与えられた文字列が数値を構成しない
場合は@code{#f}が返されます。
@c COMMON
@end defun

@deffn {Generic Function} x->number obj
@deffnx {Generic Function} x->integer obj
@c EN
Generic coercion functions.  Returns `natural' interpretation of @var{obj}
as a number or an exact integer, respectively.
The default methods are defined for numbers and strings; a string is
interpreted by @var{string->number}, and if the string can't be
interpreted as a number, 0 is returned.
Other @var{obj} is simply converted to 0.
If @var{obj} is naturally interpreted
as a number that is not an exact integer, @code{x->integer} uses
@code{round} and @code{inexact->exact} to obtain an integer.

Other class may provide a method to customize the behavior.
@c JP
数値への強制型変換手続きです。
@var{obj}をそれぞれ数値もしくは正確な整数と解釈して返します。
数値と文字列に対してのメソッドは定義されています
(文字列は@var{string->number}を使って変換されます。
数値として解釈できない文字列に関しては0が返されます)。
その他の@var{obj}については単に0が返されます。
@code{x->integer}は、@var{obj}が数値として表現できるけれど正確な整数では
ない場合、@code{round}と@code{inexact->exact}によって正確な整数に変換します。

他のクラスはこのメソッドを定義することにより、独自の変換関数を提供することができます。
@c COMMON
@end deffn

@node Bitwise operations,  , Numerical conversions, Numbers
@subsection Bitwise operations
@c NODE ビット演算

@c EN
These procedures treat integers as half-open bit vectors.
If an integer is positive, it is regarded as if infinite number
of zeros are padded to the left.  If an integer is negative,
it is regarded in 2's complement form, and infinite number of
1's are padded to the left.
@c JP
これらの手続きは整数を半無限のビットベクタとして扱います。
正の整数の場合、数値の左側に無限に0が続いていると見倣されます。
負の整数の場合、数値は2の補数で表現され、左側に無限に1が続いていると見倣されます。
@c COMMON

@c EN
The API is consisntent to SLIB's ``logical'' module.
@c JP
APIはSLIBの``logical''モジュールに合わせてあります。
@c COMMON

@defun ash n count
@c EN
Shifts integer @var{n} left with @var{count} bits.
If @var{count} is negative, @code{ash} shifts @var{n} right with
@minus{}@var{count} bits.
@c JP
整数@var{n}を左に整数@var{count}ビットだけシフトします。
@var{count}が負であれば、@minus{}@var{count}だけ@var{n}を右にシフトします。
@c COMMON

@example
; @r{Note: 6  @equiv{} [...00110], and}
; @r{      -6 @equiv{} [...11010]}
(ash 6 2)   @result{} 24  ;@r{[...0011000]}
(ash 6 -2)  @result{} 1   ;@r{[...0000001]}
(ash -6 2)  @result{} -24 ;@r{[...1101000]}
(ash -6 -2) @result{} -2  ;@r{[...1111110]}
@end example
@end defun
        
@defun logand n1 n2 @dots{}
@defunx logior n1 n2 @dots{}
@defunx logxor n1 n2 @dots{}
@c EN
Returns bitwise and, bitwise inclusive or and bitwise exclusive or
of two or more integers @var{n1}, @var{n2} @dots{}.
@c JP
2つ以上の整数@var{n1}, @var{n2} @dots{}の、それぞれ論理和、論理積、
排他的論理積を返します。
@c COMMON
@end defun

@defun lognot n
@c EN
Returns bitwise not of an integer @var{n}.
@c JP
整数@var{n}のビット否定を返します。
@c COMMON
@end defun

@defun logtest n1 n2 @dots{}
 @equiv{} @code{(not (zero? (logand @var{n1} @var{n2} @dots{})))}
@end defun

@defun logbit? index n
@c EN
Returns @code{#t} if @var{index}-th bit of integer @var{n} is 1, 
@var{#f} otherwise.
@c JP
整数@var{n}の@var{index}目のビットが1ならば@code{#t}を、0ならば@code{#f}を
返します。
@c COMMON
@end defun

@defun bit-field n start end
@c EN
Extracts (@var{start}+1)-th bit to @var{end}-th bit (inclusive) from
an exact integer @var{n}, where @var{start} < @var{end}.
@c JP
整数@var{n}の@var{start}+1ビット目から@var{end}ビット目(両端含む)までを
取り出した数値を返します。@var{start} < @var{end} でなければなりません。
@c COMMON
@end defun

@defun copy-bit index n bit
@c EN
If @var{bit} is true, sets @var{index}-th bit of an exact integer @var{n}.
If @var{bit} is false, resets @var{index}-th bit of an exact integer @var{n}.
@c JP
@var{bit}が真の値なら、整数@var{n}の@var{index}ビット目をセットした数値を
返します。
@var{bit}が偽の値なら、整数@var{n}の@var{index}ビット目をリセットした数値を
返します。
@c COMMON
@end defun

@defun copy-bit-field n start end from
@c EN
@c JP
@c COMMON
@end defun

@defun logcount n
@c EN
@c JP
@c COMMON
@end defun

@defun integer-length n
@c EN
@c JP
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Booleans, Pairs and Lists, Numbers, Core library
@section Booleans
@c NODE 論理値

@deftp {Builtin Class} <boolean>
@clindex boolean
@c EN
A boolean class.  Only @code{#t} and @code{#f} belong to this class.
@c JP
論理値のクラスです。@code{#t}と@code{#f}のみがこのクラスのインスタンスです。
@c COMMON
@end deftp

@defun not obj
[R5RS]
@c EN
Returns @code{#t} if and only if @var{obj} is @code{#f},
and returns @code{#f} otherwise.
@c JP
@var{obj}が@code{#f}の時のみ@code{#t}を返し、それ以外の場合は@code{#f}を
返します。
@c COMMON
@end defun

@defun boolean? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a boolean value.
@c JP
@var{obj}が論理値である場合に@code{#t}を返します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Pairs and Lists, Symbols, Booleans, Core library
@section Pairs and Lists
@c NODE ペアとリスト

@menu
* Pair and null class::         
* List predicates::             
* List constructors::           
* List accessors and modifiers::  
* Other list procedures::       
@end menu

@node Pair and null class, List predicates, Pairs and Lists, Pairs and Lists
@subsection Pair and null class
@c NODE pairクラスとnullクラス

@deftp {Builtin Class} <list>
@clindex list
@c EN
An abstract class respresents lists.   A parent class of @code{<null>}
and @code{<pair>}.   Inherits @code{<sequence>}.

Note that a cirular list is also an instance of the @code{<list>} class,
while R5RS procedure @code{list?} returns false on the circular lists and
dotted lists.
@c JP
リストを表す抽象クラスで、クラス@code{<null>}とクラス@code{<pair>}の親クラスです。
クラス@code{<sequence>}を継承します。

循環リストやドットリストも@code{<list>}クラスのインスタンスですが、
@code{list?}は偽の値を返すことに注意して下さい。
@c COMMON
@lisp
(use srfi-1)
(list? (circular-list 1 2)) @result{} #f
(is-a? (circular-list 1 2) <list>) @result{} #t
@end lisp
@end deftp

@deftp {Builtin Class} <null>
@clindex null
@c EN
A class of empty list.  @code{()} is the only instance.
@c JP
空リストのクラスです。@code{()}がこのクラスの唯一のインスタンスです。
@c COMMON
@end deftp

@deftp {Builtin Class} <pair>
@clindex pair
@c EN
A class of pairs.
@c JP
ペアのクラスです。
@c COMMON
@end deftp

@node List predicates, List constructors, Pair and null class, Pairs and Lists
@subsection List predicates
@c NODE リストに関する述語

@defun pair? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a pair, @code{#f} otherwise.
@c JP
@var{obj}がペアなら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun null? obj
[R5RS] 
@c EN
Returns @code{#t} if @var{obj} is an empty list, @code{#f} otherwise.
@c JP
@var{obj}が空リストなら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun list? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a proper list, @code{#f} otherwise.
This function returns @code{#f} if @var{obj} is a dotted or circular list.

See also @code{proper-list?}, @code{circular-list?} and
@code{dotted-list?} in @ref{SRFI-1 List predicates}.
@c JP
@var{obj}が正しいリストなら@code{#t}を、そうでなければ@code{#f}を返します。
この手続きは@var{obj}がドットリストや循環リストなら@var{#f}を返します。

SRFI-1(@ref{SRFI-1 List predicates})には更に、
@code{proper-list?}、@code{circular-list?}、@code{dotted-list?}
といった手続きが定義されています。
@c COMMON
@end defun

@node List constructors, List accessors and modifiers, List predicates, Pairs and Lists
@subsection List constructors
@c NODE リストの作成

@defun cons obj1 obj2
[R5RS] 
@c EN
Constructs a pair of @var{obj1} and @var{obj2} and returns it.
@c JP
@var{obj1}と@var{obj2}のペアを作成します。
@c COMMON
@lisp
(cons 'a 'b) @result{} (a . b)
@end lisp
@end defun

@defun acons obj1 obj2 obj3
@c EN
Returns @code{(cons (cons @var{obj1} @var{obj2}) @var{obj3})}.
Useful to put an entry at the head of an associative list.
@c JP
@code{(cons (cons @var{obj1} @var{obj2}) @var{obj3})} を返します。
連想リストの先頭に新しいエントリを加えるのに便利です。
@c COMMON
@lisp
(acons 'a 'b '((c . d))) @result{} ((a . b) (c . d))
@end lisp
@end defun

@defun make-list len &optional fill
[SRFI-1]
@c EN
Makes a proper list of length @var{len}.  If optional argument
@var{fill} is provided, each element is initialized by it.  Otherwise
each element is undefined.
@c JP
長さ@var{len}の正規のリストを返します。引数@var{fill}が与えられていれば、各要素は
@var{fill}になります。そうでなければ各要素の値は不定です。
@c COMMON
@lisp
(make-list 5 #t) @result{} (#t #t #t #t #t)
@end lisp
@end defun

@defun list obj @dots{}
[R5RS]
@c EN
Makes a list, whose elements are @var{obj} @dots{}.
@c JP
要素が@var{obj} @dots{}であるリストを作成します。
@c COMMON
@lisp
(list 1 2 3) @result{} (1 2 3)
(list) @result{} ()
@end lisp
@end defun

@defun list* obj1 obj2 @dots{}
@c EN
Like @code{list}, but the last argument becomes cdr of the last pair.
SRFI-1 defines the same function with the name @code{cons*}.
@c JP
@code{list}とほぼ同じですが、最後の引数が作成されるリストの最後のペアのcdrになります。
SRFI-1ではこの手続きが@code{cons*}という名で定義されています。
@c COMMON
@lisp
(list* 1 2 3) @result{} (1 2 . 3)
(list* 1) @result{} 1
@end lisp
@end defun

@defun list-copy list
[SRFI-1]
@c EN
Shallow copies @var{list}.  If @var{list} is circular,
this function diverges.
@c JP
@var{list}の浅いコピーを行います。
@var{list}が循環リストの場合、この手続きは停止しません。
@c COMMON
@end defun


@node List accessors and modifiers, Other list procedures, List constructors, Pairs and Lists
@subsection List accessors and modifiers
@c NODE リストへのアクセスと変更

@defun car pair
@defunx cdr pair
[R5RS] 
@c EN
Returns car and cdr of @var{pair}, respectively.
@c JP
それぞれ@var{pair}のcarとcdrを返します。
@c COMMON
@end defun

@defun set-car! pair obj
@defunx set-cdr! pair obj
[R5RS] 
@c EN
Modifies car and cdr of @var{pair}, by @var{obj}, respectively.

Note: @code{(setter car)} @equiv{} @code{set-car!}, and
@code{(setter cdr)} @equiv{} @code{set-cdr!}.
@c JP
@var{pair}のcarもしくはcdrを@var{obj}で置き換えます。

注： @code{(setter car)} @equiv{} @code{set-car!} であり、
@code{(setter cdr)} @equiv{} @code{set-cdr!} です。
@c COMMON
@end defun

@defun caar pair
@defunx cadr pair
@findex cdar
@findex cddr
@findex caaar
@findex caadr
@findex cadar
@findex caddr
@findex cdaar
@findex cdadr
@findex cddar
@findex cdddr
@findex caaaar
@findex caaadr
@findex caadar
@findex caaddr
@findex cadaar
@findex cadadr
@findex caddar
@findex cadddr
@findex cdaaar
@findex cdaadr
@findex cdadar
@findex cdaddr
@findex cddaar
@findex cddadr
@dots{}
@end defun
@defun cdddar pair
@defunx cddddr pair
[R5RS]
@c EN
@code{caar} @equiv{} @code{(car (car x))},
@code{cadr} @equiv{} @code{(car (cdr x))}, and so on.

The corresponding setters are also defined.
@c JP
@code{caar} @equiv{} @code{(car (car x))},
@code{cadr} @equiv{} @code{(car (cdr x))}, 等々。

対応するsetterも定義されています。
@c COMMON
@example
(let ((x (list 1 2 3 4 5)))
  (set! (caddr x) -1)
  x)
  @result{} (1 2 -1 4 5)
@end example
@end defun

@defun length list
[R5RS]
@c EN
Returns the length of a proper list @var{list}.
If @var{list} is a dotted list, an error is signalled.
If @var{list} is a circular list, this function diverges.

If you want to handle circular lists as well, 
See @code{length+} in @ref{SRFI-1 List miscellaneous routines}.
@c JP
正規のリスト@var{list}の長さを返します。
@var{list}がドットリストならばエラーが起きます。
@var{list}が循環リストの場合、この関数は無限ループします。

循環リストも取り扱う場合は、SRFI-1の@code{length+}を使って下さい
(@ref{SRFI-1 List miscellaneous routines}参照)。
@c COMMON
@end defun

@defun list-tail list k
[R5RS]
@c EN
Returns @var{k}-th cdr of @var{list}.
@var{list} can be a proper, dotted or circular list.
@c JP
@var{list}の@var{k}番目のcdrを返します。@var{list}は
正規のリストでもドットリストでも循環リストでも構いません。
@c COMMON
@end defun

@defun list-ref list k &optional fallback
[R5RS+]
@c EN
Returns @var{k}-th element of @var{list}.
@var{list} can be a proper, dotted or circular list.

By default, @code{list-ref} signals an error if @var{k} is
negative, or greater than or equal to the length of @var{list}.
However, if an optional argument @var{fallback} is given,
it is returned for such case.  This is an extension of Gauche.
@c JP
@var{list}の@var{k}番目の要素を返します。@var{list}は
正規のリストでもドットリストでも循環リストでも構いません。

もし@var{k}がリストの長さを超えていたり、負数であった場合は通常はエラーが起こります。
しかし、オプショナルな引数@var{fallback}が与えられていた場合は、エラーは起きず
@var{fallback}が返されます。これはGaucheの拡張です。
@c COMMON
@end defun

@defun last-pair list
[SRFI-1]
@c EN
Returns the last pair of @var{list}.
@var{list} can be a proper or dotted list.
@c JP
@var{list}の最後のペアを返します。@var{list}は
正規のリストかドットリストです。
@c COMMON
@end defun

@node Other list procedures,  , List accessors and modifiers, Pairs and Lists
@subsection Other list procedures
@c NODE 他のリスト手続き

@defun append list @dots{}
[R5RS]
@c EN
Returns a list consisting of the elements of the first @var{list} followed by
the elements of the other lists.  The resulting list is always newly
allocated, except that it shares structure with the last list argument.
The last argument may actually be any object; an improper list results
if the last argument is not a proper list. 
@c JP
渡されたリストの要素を繋げたリストを返します。最後の引数の部分以外は新しいセルがアロケート
されて使われます。最後の引数は正規のリストである必要がありません。その場合、結果は正規でない
リストとなります。
@c COMMON
@end defun

@defun append! list @dots{}
[SRFI-1]
@c EN
Returns a list consisting of the elements of the first @var{list} followed by
the elements of the other lists.  The cells in the lists except the last
one may be reused to construct the result.   The last argument may be
any object.
@c JP
渡されたリストの要素を繋げたリストを返します。最後の引数以外のリストのセルは、結果を
作成するために再利用されるかもしれません。
最後の引数は正規のリストである必要はありません。
@c COMMON
@end defun


@defun reverse list
[R5RS]
@c EN
Returns a newly allocated list consisting of the elements of @var{list}
in reverse order.
@c JP
@var{list}の各要素を逆順に持つリストを新しく作成して返します。
@c COMMON
@end defun

@defun reverse! list
[SRFI-1]
@c EN
Returns a list consisting of the elements of @var{list} in reverse order.
The cells of @var{list} may be reused to construct the returned list.
@c JP
@var{list}の各要素を逆順に持つリストを返します。結果を作成するために、
@var{list}のセルは再利用されるかもしれません。
@c COMMON
@end defun

@defun memq obj list
@defunx memv obj list
@defunx member obj list
[R5RS]
@c EN
Searches @var{obj} in the @var{list}.  If @code{n}-th element of
@var{list} equals to @var{obj} (in the sense of @code{eq?} for @code{memq},
@code{eqv?} for @code{memv}, and @code{equal?} for @code{member}), 
@code{(list-tail @var{list} @var{n})} is returned.
Otherwise, @code{#f} is returned.
@c JP
@var{list}から@var{obj}を探します。もし@var{list}の@var{n}番目の要素が
@var{obj}と同一ならば、@code{(list-tail @var{list} @var{n})}を返します。
@code{memq}は同一性の判定に@code{eq?}を、@code{memv}は@code{eqv?}を、
@code{member}は@code{equal?}を使います。
@var{obj}が@var{list}中に見つからなければ@code{#f}が返されます。
@c COMMON

@c EN
If you use SRFI-1 (@xref{srfi-1 - List library}), @code{member} is extended
to take optional argument for a equality procedure.
@c JP
SRFI-1 (@ref{srfi-1 - List library}) を使うと、@code{member}は
オプショナルな同一性判定手続きを取るように拡張されます。
@c COMMON
@example
(memq 'a '(a b c))          @result{} (a b c)
(memq 'b '(a b c))          @result{}  (b c)
(memq 'a '(b c d))          @result{} #f
(memq (list 'a) '(b (a) c)) @result{} #f
(memv 101 '(100 101 102))   @result{} (101 102)
@end example
@end defun

@defun assq obj list
@defunx assv obj list
@defunx assoc obj list
[R5RS]
@c EN
Each element in @var{list} must be a pair.
These procedures search a pair whose car matches @var{obj}
(in the sense of @code{eq?} for @code{assq},
@code{eqv?} for @code{assv}, and @code{equal?} for @code{assoc})
from left to right, and return the leftmost matched pair if any.
If no pair matches, these return @code{#f}.
@c JP
@var{list}の各要素はペアでなければなりません。
これらの手続きは、@var{list}の要素であるペアのうち、そのcarが
@var{obj}と一致するペアを左から探して行きます。もし見付かればそのペアが、
見付からなければ@code{#f}が返されます。
@code{assq}は比較関数に@code{eq?}を、@code{assv}は@var{eqv?}を、
@code{assoc}は@var{equal?}をそれぞれ用います。
@c COMMON

@c EN
If you use SRFI-1 (@xref{srfi-1 - List library}), @code{assoc} is extended
to take optional argument for a equality procedure.
@c JP
SRFI-1 (@ref{srfi-1 - List library}) を使うと、@code{assoc}は
オプショナルな同一性判定手続きを取るように拡張されます。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Symbols, Keywords, Pairs and Lists, Core library
@section Symbols
@c NODE シンボル

@deftp {Builtin Class} <symbol>
@clindex symbol
@c EN
A class for symbols.

In Gauche, all symbols are @emph{interned}, i.e. two symbols with
the same print name are always @code{eq?}.
@c JP
シンボルを表すクラスです。

Gaucheでは、全てのシンボルはintern、すなわち内部のテーブルに登録されています。
そのため、同じ外部表記を持つシンボルは常に@code{eq?}です。
@c COMMON
@end  deftp

@deftp {Reader Syntax} @code{|@i{name}|}
@c EN
Denotes a symbol that has weird name, i.e. the name including the
characters which is not allowed in the R5RS symbol syntax.
If the interpreter is running in case-insensitive mode, this syntax
can be used to include uppercase characters in a symbol
(@xref{Case-sensitivity}).

The syntax is taken from CommonLisp.  Some other Scheme implementation
use it as well.
@c JP
R5RSのシンボルの定義では許されていない文字を使った妙な名前のシンボルを表記するのに
使う構文です。インタプリタが大文字小文字を区別しないモードで走っている場合は、
大文字を含むシンボルを表記するときにも使えます (@ref{Case-sensitivity}参照)。

この表記はCommonLispから取られました。いくつかのSchemeでも同様の表記を採用しています。
@c COMMON
@end deftp

@defun symbol? obj
[R5RS] 
@c EN
Returns true if and only if @var{obj} is a symbol.
@c JP
@var{obj}がシンボルなら@code{#t}を返します。
@c COMMON
@example
(symbol? 'abc)     @result{} #t
(symbol? 0)        @result{} #f
(symbol? 'i)       @result{} #t
(symbol? '-i)      @result{} #f
(symbol? '|-i|)    @result{} #t
@end example
@end defun

@defun symbol->string symbol
[R5RS]
@c EN
Returns the name of @var{symbol} in a string.  Returned
string is immutable.
@c JP
@var{symbol}の名前を文字列で返します。返される文字列は変更不可です。
@c COMMON

@example
(symbol->string 'foo) @result{} foo
@end example
@end defun

@defun string->symbol string
[R5RS]
@c EN
Returns a symbol whose name is a string @var{string}.
@var{String} may contain weird characters.
@c JP
文字列@var{string}を名前に持つシンボルを返します。
@c COMMON

@example
(string->symbol "a") @result{} a
(string->symbol "A") @result{} A
(string->symbol "weird symbol name" @result{} |weird symbol name|
@end example
@end defun

@defun gensym &optional prefix
@end defun

@c ----------------------------------------------------------------------
@node Keywords, Identifiers, Symbols, Core library
@section Keywords
@c NODE キーワード

@deftp {Builtin Class} <keyword>
@clindex keyword
@c EN
A keyword is a sort of a special symbol that is automatically quoted.
It is extensively used in pass-by-name arguments (keyword arguments),
and keyword-value list.
Unlike CommonLisp, keywords and symbols are distinct types.

See also @code{let-keywords*} macro (@ref{Optional argument parsing})
for keyword argument processing.
@c JP
キーワードは特別なシンボルの一種で、自動的にクォートされます。
名前で渡す引数(キーワード引数)や、キーワード-値のリストで広く使われて
います。
CommonLisp とは異なり、キーワードとシンボルは明確に区別される型です。

キーワード引数の処理については、@code{let-keywords*} マクロ
(@ref{Optional argument parsing}) を参照して下さい。
@c COMMON
@end  deftp

@deftp {Reader syntax} @code{:@var{name}}
@c EN
Read to a keyword whose name is @var{name}.
(Note that the preceding ':' is not a part of the keyword's name.)
@c JP
名前が @var{name} であるキーワードとして読み込まれます。
(先行する ':' は、キーワードの名前の一部ではないことに注意してください。)
@c COMMON
@end deftp

@defun keyword? obj
@c EN
Returns @code{#t} if @var{obj} is a keyword.
@c JP
@var{obj} がキーワードであれば、@code{#t} を返します。
@c COMMON
@end defun

@defun make-keyword name
@c EN
Returns a keyword whose name is @var{name}.
@c JP
名前が @var{name} であるキーワードを返します。
@c COMMON
@end defun

@defun keyword->string keyword
@c EN
Returns the name of the keyword @var{keyword}.
@c JP
キーワード @var{keyword} の名前を返します。
@c COMMON
@end defun

@defun get-keyword key list &optional fallback
@c EN
A useful procedure to extract a value from key-value list.
A key-value list @var{list} must contains even number of elements;
the first, third, fifth @dots{} elements are regarded as keys,
and the second, fourth, sixth @dots{} elements are the values of
the preceding keys.

This procedure looks for @var{key} from the keys, and if it finds one,
it returns the corresponding value.
If there are more than one matching keys, the leftmost one is taken.
If there is no matching key, it returns @var{fallback} if provided,
or signals an error otherwise.

It is an error if @var{list} is not a proper, even-number element list.

Actually, `keywords' in the keyword-value list and the @var{key} argument
need not be a keyword---it can be any Scheme object.  Key comparison
is done by @code{eq?}.

This procedure is taken from STk.
@c JP
キー-値のリストから値を取り出すのに便利な手続きです。
キー-値のリスト @var{list} は偶数個の要素を持たなければなりません。
1つ目、3つ目、5つ目、@dots{} の要素はキーとして扱われ、
2つ目、4つ目、6つ目、@dots{} の要素は、その前の要素をキーとした値と
なります。

この手続きは、キーの集合から @var{key} を探して、それが見つかれば、
対応する値を返します。
2つ以上のキーにマッチしたら、最左のものとなります。
マッチするキーがない場合、@var{fallback} が与えられていればそれを
返し、さもなければエラーを通知します。

@var{list} が正しい偶数個の要素を持つリストでない場合は、エラーに
なります。

キーワード-値リストの `キーワード' と、@var{key} 引数は、実際には
キーワードである必要はありません。いかなる Scheme オブジェクトで
あっても良いです。キーの比較は、@code{eq?} によって行われます。

この手続きは、STk から導入されました。
@c COMMON
@end defun

@defmac get-keyword* key list &optional fallback
@c EN
Like @code{get-keyword}, but @var{fallback} is evaluated only
if @var{list} does not have @var{key}.
@c JP
@code{get-keyword} と同様ですが、@var{list} が @var{key} を
含まない場合にのみ @var{fallback} が評価されることだけが違います。
@c COMMON
@end defmac

@c ----------------------------------------------------------------------
@node Identifiers, Characters, Keywords, Core library
@section Identifiers
@c NODE Identifier

@deftp {Builtin Class} <identifier>
@clindex identifier
@end  deftp

@defun identifier? obj
@end defun

@defun identifier->symbol identiifer
@end defun


@c ----------------------------------------------------------------------
@node Characters, Character set, Identifiers, Core library
@section Characters
@c NODE 文字

@deftp {Builtin Class} <char>
@clindex char
@end  deftp

@deftp {Reader Syntax} @code{#\@i{charname}}
[R5RS]
@c EN
Denotes a literal character.

When the reader reads @code{#\}, it fetches a sbusequent character.
If it is one of @code{()[]@{@}" \|;#}, this is a character literal of itself.
Otherwise, the reader reads subsequent characters until it sees
a non word-constituent character.  If only one character is read,
it is the character.  Otherwise, the reader matches the read characters
with predefined character names.  If it doesn't match any, an error
is signalled.

The following character names are recognized.
These haracter names are case insensitive.
@table @code
@item space
Whitespace (ASCII #x20)
@item newline, nl, lf
Newline (ASCII #x0a)
@item return, cr
Carriage return (ASCII #x0d)
@item tab, ht
Horizontal tab (ASCII #x09)
@item page
Form feed (ASCII #x0c)
@item escape, esc
Escape (ASCII #x1b)
@item delete, del
Delete (ASCII #x7f)
@item null
NUL character (ASCII #x00)
@item x@var{N}
A character whose internal encoding is the integer @var{N},
when @var{N} is a hexadecimal integer.
Note that this notation is not portable among different
internal encoding schemes except ASCII character range.
@item u@var{N}
A character whose UCS character code is the integer @var{N},
where @var{N} is 4-digit or 8-digit hexadecimal number.
If Gauche is compiled with the internal encoding other than UTF-8,
the reader uses @code{gauche.charconv} module to convert Unicode
to the internal character code.  Note that the specified character
may not be defined in the internal encoding; in which case, either
a substitution character is used, or an error is signalled.
@end table
@c JP
リテラルの文字オブジェクトを表現します。

リーダーは@code{#\}に出会うと、まず次の文字を読み込みます。それが文字
@code{()[]@{@}" \|;#} のいずれかならば、その文字自身となります。
そうでなければ、単語を構成しない文字に出会うまで文字が続けて読み込まれます。
もし一文字しか読まれなければ、その文字自身となります。そうでなければ
その単語が文字の名前として解釈されます。
それが有効な文字の名前でなければエラーとなります。

以下の文字の名前が認識されます。これらの文字の名前は大文字小文字を区別しません。
@table @code
@item space
スペース (ASCII #x20)
@item newline, nl, lf
改行文字 (ASCII #x0a)
@item return, cr
復帰文字 (ASCII #x0d)
@item tab, ht
水平タブ (ASCII #x09)
@item page
フォームフィード、改ページ (ASCII #x0c)
@item escape, esc
エスケープ (ASCII #x1b)
@item delete, del
デリート (ASCII #x7f)
@item null
NUL文字 (ASCII #x00)
@item x@var{N}
@var{N} が16進表記の整数であるとき、内部エンコーディングが整数@var{N}
であるような文字。この表記はASCII文字の範囲の外では、内部エンコーディングが異なる
処理系間で互換性が無いことに注意して下さい。
@item u@var{N}
@var{N}が4桁または8桁の16進数整数であるとき、UCSコード@var{N}であるような文字。
Gaucheの内部エンコーディングがUTF-8以外でコンパイルされている場合には、
リーダーは@code{gauche.charconv}モジュールを使ってUnicodeを内部エンコーディングへと
変換します。Unicodeの該当する文字が内部エンコーディングで定義されていない場合、
代替文字に置換されるか、エラーとなります。
@end table
@c COMMON

@example
@c EN
#\newline @result{} #\newline ; @r{newline character}
#\x0a     @result{} #\newline ; @r{ditto}
#\x41     @result{} #\A       ; @r{ASCII letter 'A'}
#\u0041   @result{} #\A       ; @r{ASCII letter 'A', specified by UCS}
#\u3042   @result{} ; @r{Hiragana letter A, specified by UCS}
#\u0002a6b2 @result{} ; @r{JISX0213 Kanji 2-94-86, specified by UCS4}
@c JP
#\newline @result{} #\newline ; @r{改行文字}
#\x0a     @result{} #\newline ; @r{改行文字}
#\x41     @result{} #\A       ; @r{ASCII文字 'A'}
#\u0041   @result{} #\A       ; @r{ASCII文字 'A', UCSコード}
#\u3042   @result{} #\あ      ; @r{平仮名「あ」, UCSコード}
#\u0002a6b2 @result{} ; @r{JISX0213 2-94-86 UCS4コード}
@c COMMON
@end example

@c EN
You can denote multibyte characters with this syntax if
the program text is written in the same encoding as the internal
character encoding.
@c JP
プログラムテキストがGaucheの内部エンコーディングと同じエンコーディングで
書かれていれば、マルチバイト文字を直接表記することもできます。
@example
#\あ @result{} ; @r{文字「あ」}
@end example
@c COMMON
@end deftp

@defun char? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a character, @code{#f} otherwise.
@c JP
@var{obj}が文字なら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun char@code{=}? char1 char2
@defunx char@code{<}? char1 char2
@defunx char@code{<=}? char1 char2
@defunx char@code{>}? char1 char2
@defunx char@code{>=}? char1 char2
[R5RS]
@c EN
Compares characters.  Character comparison is done in internal
character encoding.
@c JP
文字を比較します。比較は内部の文字エンコーディングで行われます。
@c COMMON
@end defun

@defun char-ci@code{=}? char1 char2
@defunx char-ci@code{<}? char1 char2
@defunx char-ci@code{<=}? char1 char2
@defunx char-ci@code{>}? char1 char2
@defunx char-ci@code{>=}? char1 char2
[R5RS]
@c EN
Compares characters in case-insensitive way.
In the current version, character cases are not well defined
outside the ASCII character range.
@c JP
文字を、大文字小文字を区別せずに比較します。
現在のバージョンではASCII文字の範囲外における大文字小文字の扱いが
きちんと定義されていないことに注意して下さい。
@c COMMON
@end defun

@defun char-alphabetic? char
@defunx char-numeric? char
@defunx char-whitespace? char
@defunx char-upper-case? char
@defunx char-lower-case? char
[R5RS]
@c EN
Returns true if a character @var{char} is an alphabetic character
(@code{[A-Za-z]}), a numeric character (@code{[0-9]}), a whitespace
character, an upper case character or a lower case character, respectively.
Currently, these procedures works only for ASCII characters.  They
return @code{#f} for all other characters.
@c JP
文字@var{char}がそれぞれ英字(@code{[A-Za-z]})、数字(@code{[0-9]})、
空白文字、大文字および小文字の時に真の値を返します。
今のところ、これらの手続きはASCII文字のみで動作します。
それ以外の文字に対しては@code{#f}が返されます。
@c COMMON
@end defun

@defun char->integer char
@defunx integer->char n
[R5RS]
@c EN
@code{char->integer} returns an exact integer that represents
internal encoding of the character @var{char}.
@code{integer->char} returns a character whose internal encoding
is an exact integer @var{n}.  The following expression is always
true for valid charcter @var{char}:
@example
(eq? char (integer->char (char->integer char)))
@end example

The result is undefined if you pass @var{n} to @code{integer->char}
that doesn't have a corresponding character.
@c JP
@code{char->integer}は文字@var{char}の内部エンコーディングに対応する
整数値を返します。@code{integer->char}は数値@var{n}と内部エンコーディングが
同じ文字を返します。有効な文字@var{char}に対して以下の式は常に真となります。
@example
(eq? char (integer->char (char->integer char)))
@end example

対応する内部エンコーディングを持つ文字が無い数値を@code{integer->char}に渡した
場合の結果は不定です。
@c COMMON
@end defun

@defun char->ucs char
@defunx ucs->char n
@c EN
Converts a character @var{char} to integer UCS codepoint,
and integer UCS codepoint @var{n} to a character, respectively.

If Gauche is compiled with UTF-8 encoding, these procedures are the 
same as @code{char->integer} and @code{integer->char}.

When Gauche's internal encoding differs from UTF-8, these procedures
implicitly loads @code{gauche.charconv} module to convert internal
character code to UCS or vice versa (@xref{gauche.charconv - Character code conversion}).
If @var{char} doesn't have corresponding UCS codepoint, 
@code{char->ucs} returns @code{#f}.  If UCS codepoint @var{n} can't
be represented in the internal character encoding, @code{ucs->char}
returns @code{#f}, unless the conversion routine provides a substitution
character.
@c JP
それぞれ、文字@var{char}をUCSコードポイントを表す整数へ変換し、
またUCSコードポイントを表す整数@var{n}を文字へと変換する手続きです。

Gaucheの内部文字エンコーディングがUTF-8でコンパイルされている場合は、
これらの手続きはそれぞれ@code{char->integer}および@code{integer->char}
と等価です。

Gaucheの内部文字エンコーディングがUTF-8でない場合、
これらの手続きは@code{gauche.charconv}モジュールを使って
内部文字コードとUCSとの変換を行います (@ref{gauche.charconv - Character code conversion}参照)。
@var{char}が対応するUCSコードを持っていない場合、@code{char->ucs}は@code{#f}を
返します。UCSコード@code{n}に対応する文字が内部エンコーディングで定義されていない
場合、変換ルーチンが代替文字を提供していればそれを、そうでなければ@code{#f}
が返されます。
@c COMMON
@end defun

@defun char-upcase char
@defunx char-downcase char
[R5RS]
@c EN
Returns the upper case and lower case of @var{char}, respectively.
If @var{char} doesn't have such distinction of upper or lower case,
@code{char} itself is returned.

In the current version, character cases are not well defined
outside the ASCII character range.
@c JP
@var{char}の大文字と小文字をそれぞれ返します。@var{char}に大文字小文字の区別が
無ければ@var{char}がそのまま返されます。

現在のバージョンではASCII文字の範囲外における大文字小文字の扱いが
きちんと定義されていないことに注意して下さい。
@c COMMON
@end defun

@defun digit->integer char &optional (radix 10)
@c EN
If given character @var{char} is a valid digit character in radix
@var{radix} number, the corresponding integer is returned.  Otherwise
@code{#f} is returned.
@c JP
文字@var{char}が @var{radix}進数の数字を構成するのに有効な文字であれば、
対応する整数が、そうでなければ@code{#f}が返されます。
@c COMMON
@example
(digit->integer #\4) @result{} 4
(digit->integer #\e 16) @result{} 14
(digit->integer #\9 8) @result{} #f
@end example
@c EN
Note: CommonLisp has a similar function in rather confusing name,
@code{digit-char-p}.
@c JP
Common Lispには同様の手続きが@code{digit-char-p}というやや曖昧な名で定義されています。
@c COMMON
@end defun

@defun integer->digit integer &optional (radix 10)
@c EN
Reverse operation of @code{digit->integer}.  Returns a character that
represents the number @var{integer} in the radix @var{radix} system.
If @var{integer} is out of the valid range, @code{#f} is returned.
@c JP
@code{digit->integer}の逆です。整数@var{integer}を @var{radix}進数 ひと桁で
表現するのに使われる文字を返します。@var{integer}がひと桁で表現できない数値の場合は
@code{#f}が返されます。
@c COMMON
@example
(integer->digit 13 16) @result{} #\d
(integer->digit 10) @result{} #f
@end example
@c EN
Note: CommonLisp's @code{digit-char}.
@c JP
Common Lispの@code{digit-char}に当たります。
@c COMMON
@end defun

@defun gauche-character-encoding
@c EN
Returns a symbol designates the native character encoding, selected
at the compile time.
The possible return values are those:
@c JP
コンパイル時に選択された内部文字エンコーディングを表すシンボルを返します。
返される値は以下のいずれかです。
@c COMMON
@table @code
@item euc-jp
EUC-JP
@item utf-8
UTF-8
@item sjis
Shift JIS
@item none
No multibyte character support (8-bit fixed-length character).
@end table
@end defun

@defun supported-character-encodings
Returns a list of string names of character encoding schemes
that are supported in the native multibyte encoding scheme.
@end defun



@c ----------------------------------------------------------------------
@node Character set, Strings, Characters, Core library
@section Character Set
@c NODE 文字集合

@deftp {Builtin Class} <char-set>
@clindex char-set
@c EN
Character set class.  Character set object represents a set of characters.
Gauche provides built-in support of character set creation and
a predicate that tests whether a character is in the set or not.

Further operations, such as set algebra, is defined in SRFI-14
module (@xref{srfi-14 - Character-set library}).
@c JP
文字の集合を取り扱う、文字集合(キャラクタセット)のクラスです。
Gaucheは文字集合オブジェクトのサポートと、
ある文字がその集合に属するかどうかを調べる手続きを言語組み込みで持っています。

文字集合に関する他の操作、例えば集合演算などは、SRFI-14モジュール
(@ref{srfi-14 - Character-set library}参照) で提供されています。
@c COMMON
@end deftp

@deftp {Reader Syntax} @code{#[@i{char-set-spec}]}
@c EN
You can write a literal character set in this syntax.
@i{char-set-spec} is a sequence of characters to be included
in the set.  You can include the following special sequences:
@table @code
@item @var{x}-@var{y}
Characters between @var{x} and @var{y}, inclusive.
@var{x} must be smaller than @var{y} in the internal encoding.
@item ^
If @i{char-set-spec} begins with caret, the actual character set
is a complement of what the rest of @i{char-set-spec} indicates.
@item \x@var{NN}
A character whose internal code is a hexadecimal number @var{NN}.
@item \u@var{NNNN}
A character whose UCS-2 code is a 4-digit hexadecimal number @var{NNNN}.
@item \U@var{NNNNNNNN}
A character whose UCS-4 code is a 8-digit hexadecimal number @var{NNNNNNNN}.
@item \s
Whitespace characters.
@item \S
Complement of whitespace characters.
@item \d
Decimal digit characters.
@item \D
Complement of decimal digit characters.
@item \w
Alphanumeric characters.
@item \W
Complement of alphanumeric characters.
@item \\
A backslash character.
@item \-
A minus character.
@item \^
A caret character.
@item [:alnum:] @dots{}
Character set a la POSIX.  The following character set name is
recognized: @code{alnum}, @code{alpha}, @code{blank}, @code{cntrl},
@code{digit}, @code{graph}, @code{lower}, @code{print}, @code{punct},
@code{space}, @code{upper} and @code{xdigit}.
@end table

@example
#[aeiou]     ; @r{a character set consists of vowels}
#[a-zA-Z]    ; @r{alphabet}
#[[:alpha:]] ; @r{alphabet (using POSIX notation)}
#[\x0d\x0a]  ; @r{newline and carriage return}
#[\\\-]      ; @r{backslash and minus}
#[]          ; @r{empty charset}
@end example
@c JP
この構文で、リテラル文字集合を記述することができます。
@i{char-set-spec}には集合に含める文字を列挙します。
次の特殊なシーケンスを含めることができます。
@table @code
@item @var{x}-@var{y}
文字@var{x}と文字@code{y}の間の文字全て。@var{x}と@var{y}も含みます。
@var{x}は@var{y}よりも内部文字コードで比較して小さくなければなりません。
@item ^
カレットが@i{char-set-spec}の最初に来た場合、以降に示される文字集合の
補集合がこの文字集合となります。
@item \x@var{NN}
内部文字コード@var{NN}(16進数表記)の文字。
@item \u@var{NNNN}
UnicodeのUCS-2で@var{NNNN}(16進数表記4桁)の文字。
@item \U@var{NNNNNNNN}
UnicodeのUCS-4で@var{NNNNNNNN}(16進数表記8桁)の文字。
@item \s
空白文字。
@item \S
空白でない文字。(@code{\s}の補集合)
@item \d
10進数の数字
@item \D
@code{\d}の補集合
@item \w
アルファベットと数字
@item \W
@code{\w}の補集合
@item \\
バックスラッシュ文字
@item \-
マイナス文字
@item \^
カレット文字
@item [:alnum:] @dots{}
POSIX流文字集合表記。以下の文字集合名が認識されます:
@code{alnum}, @code{alpha}, @code{blank}, @code{cntrl},
@code{digit}, @code{graph}, @code{lower}, @code{print}, @code{punct},
@code{space}, @code{upper}, @code{xdigit}。
@end table

@example
#[aeiou]     ; @r{母音文字'a', 'e', 'i', 'o', 'u'の集合}
#[a-zA-Z]    ; @r{アルファベット}
#[[:alpha:]] ; @r{アルファベット (POSIX表記)}
#[\x0d\x0a]  ; @r{改行とリターン}
#[\\\-]      ; @r{バックスラッシュとマイナス文字}
#[]          ; @r{空の文字集合}
#[ぁ-ん]     ; @r{平仮名の集合}
@end example
@c COMMON
@end deftp

@defun char-set? obj
[SRFI-14]
@c EN
Returns true if and only if @var{obj} is a character set object.
@c JP
@var{obj}が文字集合であれば真の値を返します。
@c COMMON
@end defun

@defun char-set-contains? char-set char
[SRFI-14]
@c EN
Returns true if and only if a character set object
@var{char-set} contains a character @var{char}.
@c JP
文字集合@var{char-set}が文字@var{char}を含んでいれば真の値を返します。
@c COMMON
@example
(char-set-contains? #[a-z] #\y) @result{} #t
(char-set-contains? #[a-z] #\3) @result{} #f

(char-set-contains? #[^ABC] #\A) @result{} #f
(char-set-contains? #[^ABC] #\D) @result{} #t

@c JP
(char-set-contains? #[あ-お] #\う) @result{} #t
(char-set-contains? #[あ-お] #\ぷ) @result{} #f
@c COMMON
@end example
@end defun

@defun char-set char @dots{}
[SRFI-14]
@c EN
Creates a character set that contains @var{char} @dots{}.
@c JP
文字@var{char} @dots{} からなる文字集合を作成して返します。
@c COMMON
@example
(char-set #\a #\b #\c)   @result{} #[a-c]
@c JP
(char-set #\あ #\い #\う) @result{} #[あいう]
@c COMMON
@end example
@end defun

@defun char-set-copy char-set
[SRFI-14]
@c EN
Copies a character set @var{char-set}.
@c JP
@var{char-set}のコピーを作って返します。
@c COMMON
@end defun


@c ----------------------------------------------------------------------
@node Strings, Regular expression, Character set, Core library
@section Strings
@c NODE 文字列

@deftp {Builtin Class} <string>
@clindex string
@c EN
A string class.   In Gauche, a string can be viewed in two ways:
a sequence of characters, or a sequence of bytes.
@c JP
文字列のクラスです。Gaucheでは、文字列は文字のシーケンスともバイトのシーケンスとも
みなすことができます。
@c COMMON
@end deftp

@c EN
R5RS string operations are very minimal.  Gauche supports some
extra built-in operations, and also a rich string library
defined in SRFI-13.   @xref{srfi-13 - String library}, for details about SRFI-13.
@c JP
R5RSに定義されている文字列操作は非常に限られています。
Gaucheでは追加の組込み手続きのほか、
SRFI-13に定義されている豊富な文字列ライブラリを備えています。
SRFI-13については@ref{srfi-13 - String library}を参照してください。
@c COMMON

@menu
* String syntax::               
* String Predicates::           
* String Constructors::         
* String interpolation::        
* String Accessors & Modifiers::  
* String Comparison::           
* String utilities::            
* String Pointers::             
* Incomplete strings::          
@end menu

@node String syntax, String Predicates, Strings, Strings
@subsection String syntax
@c NODE 文字列の表記

@deftp {Reader syntax} @code{"}@dots{}@code{"}
[R5RS+]
@c EN
Denotes a literal string.  Inside the double quotes, the following
backslash escape sequences are recognized.
@c JP
リテラル文字列です。ダブルクオートの中では、
以下のエスケープシーケンスが認識されます。
@c COMMON

@table @code
@item \"
@c EN
[R5RS] Double-quote character
@c JP
[R5RS] ダブルクオート文字
@c COMMON
@item \\
@c EN
[R5RS] Backslash character
@c JP
[R5RS] バックスラッシュ文字
@c COMMON
@item \n
@c EN
Newline character (ASCII 0x0a).
@c JP
改行文字 (ASCII 0x0a)
@c COMMON
@item \r
@c EN
Return character (ASCII 0x0d).
@c JP
復帰文字 (ASCII 0x0d)
@c COMMON
@item \f
@c EN
Form-feed character (ASCII 0x0c).
@c JP
フォームフィード (ASCII 0x0c)
@c COMMON
@item \t
@c EN
Tab character (ASCII 0x09)
@c JP
タブ文字 (ASCII 0x09)
@c COMMON
@item \0
@c EN
ASCII NUL character (ASCII 0x00).
@c JP
NUL文字 (ASCII 0x00)
@c COMMON
@item \x@var{NN}
@c EN
A byte represented by two-digit hexadecimal number @var{NN}.
The byte is interpreted as the internal multibyte encoding.
@c JP
2桁の16進数@var{NN}で指定されるバイト。
このバイトは内部エンコーディングによって解釈されます。
@c COMMON
@item \u@var{NNNN}
@c EN
A character whose UCS2 code is represented by four-digit
hexadecimal number @var{NNNN}.
@c JP
4桁の16進数@var{NNNN}によって示されるUCS2コードを持つ文字。
@c COMMON
@item \U@var{NNNNNNNN}
@c EN
A character whose UCS4 code is represented by eight-digit
hexadecimal number @var{NNNNNNNN}.
@c JP
8桁の16進数@var{NNNNNNNN}によって示されるUCS4コードを持つ文字。
@c COMMON
@end table

@c EN
If Gauche is compiled with internal encoding other than UTF-8,
the reader uses @code{gauche.charconv} module to interpret
@code{\uNNNN} and @code{\UNNNNNNNN} escape sequence.
@c JP
GaucheがUTF-8以外の内部エンコーディングでコンパイルされていた場合、
リーダーは@code{gauche.charconv}モジュールを使って
エスケープシーケンス@code{\uNNNN}と@code{\UNNNNNNNN}の解釈を行います。
@c COMMON
@end deftp

@deftp {Reader syntax} @code{#*"}@dots{}@code{"}
@c EN
Denotes incomplete string.  The same escape sequences as the complete
string syntax are recognized.
@c JP
不完全な文字列のリテラル表記です。完全な文字列と同様のエスケープシーケンスが
使えます。
@c COMMON

@c EN
Note: literal incomplete strings used to be @code{#"..."}.
As of Gauche 0.6.3, the syntax switched to @code{#*"..."}.
The old syntax is still recognized, but eventually will fade away.
String interpolation will eventually take @code{#"..."} syntax.

Rationale of the syntax: '@code{#*}' is used for bit vector
in Common Lisp.  Since an incomplete strings is really a byte vector,
it has similarity.  (Bit vector can be added later, if necessary,
and two can coexist).
@c JP
註：以前は、不完全な文字列のリテラル表記には@code{#"..."}という構文が使われていました。
Gauche 0.6.3から構文は@code{#*"..."}に変更されました。
以前の構文もしばらくは認識されますが、いずれサポートされなくなります。
その後、文字列の補間機能が@code{#"..."}構文を使うようになります。

'@code{#*}' という構文はCommon Lispでビットベクタの表記に使われています。
不完全な文字列は実際はバイトベクタであることから、類似点を認めてこの構文を
採用しました。(もし将来必要になってビットベクタが実装されたとしても、
この構文と共存できます)。
@c COMMON
@end deftp


@node String Predicates, String Constructors, String syntax, Strings
@subsection String Predicates
@c NODE 文字列に関する述語

@defun string? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a string, @code{#f} otherwise.
@c JP
@var{obj}が文字列なら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun string-immutable? obj
@c EN
Returns @code{#t} if @var{obj} is an immutable string, @code{#f} otherwise
@c JP
@var{obj}が変更不可な文字列なら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun string-incomplete? obj
Returns @code{#t} if @var{obj} is an incomplete string, @code{#f} otherwise
@end defun

@node String Constructors, String interpolation, String Predicates, Strings
@subsection String Constructors
@c NODE 文字列の作成

@defun make-string k &optional char
[R5RS]
@c EN
Returns a string of length @var{k}.  If optional @var{char} is given,
the new string is filled with it.  Otherwise, the string is filled with
a whitespace.  The result string is always complete.

@example
(make-string 5 #\x) @result{} "xxxxx"
@end example

Note that the algorithm to allocate a string by @code{make-string} and
then fills it one character at a time is @emph{extremely} inefficient
in Gauche, and should be avoided.   That kind of algorithms unnecessarily
assumes underlying string allocation and representation mechanism,
which Gauche doesn't follow.
You can use an output string port for a string construction
(@xref{String ports}).
Even creating a list of characters and
using @code{list->string} is faster than using @code{make-string} and
@code{string-set!}.
@c JP
長さ@var{k}の文字列を作成して返します。
@var{char}が与えられればそれで内容を満たします。@var{char}が与えられなければ
空白文字で満たされます。常に完全な文字列が返されます。

@example
(make-string 5 #\x) @result{} "xxxxx"
(make-string 5 #\ふ) @result{} "ふふふふふ"
@end example

@code{make-string}で必要な長さの文字列をアロケートして、@code{string-set!}
で順番に埋めて行くアルゴリズムは、Gaucheでは@emph{極めて}非効率であることに
注意してください。そのようなアルゴリズムは、文字列の内部表現とアロケーションメカニズムに
関して不必要な仮定を置いており、Gaucheはその仮定とは合致しません。
文字列の順次作成に適しているのは文字列ポートです
(@ref{文字列ポート}参照)。それが使えない場合、
文字のリストを作成し、@code{list->string}で変換する方がまだ@code{make-string}と
@code{string-set!}を使うより良いでしょう。
@c COMMON
@end defun

@defun make-byte-string k &optional byte
@c EN
Creates and returns an incomplete string o size @var{k}.
If @var{byte} is given,
which must be an exact integer, and its lower 8 bits
are used to initialize every byte in the created string.
@c JP
大きさ@var{k}の不完全な文字列を作成して返します。
@var{byte}が与えられた場合は、その下位1バイトで文字列の各バイトを初期化します。
@var{byte}は正確な整数でなければなりません。
@c COMMON
@end defun

@defun string char @dots{}
[R5RS]
@c EN
Returns a string consisted by @var{char} @dots{}.
@c JP
文字@var{char} @dots{} から構成された文字列を返します。
@c COMMON
@end defun

@deffn {Generic Function} x->string obj
@c EN
A generic coercion function.
Returns a string representation of @var{obj}.
The default methods are defined as follows: strings are returned
as is, numbers are converted by @code{number->string}, symbols are
converted by @code{symbol->string}, and other objects are
converted by @code{display}.

Other class may provide a method to customize the behavior.
@c JP
文字列への強制型変換手続きです。
@var{obj}の文字列表現を返します。
デフォルトのメソッドでは、文字列はそのまま返され、数値は@code{number->string}で、
シンボルは@code{symbol->string}で変換され、その他のオブジェクトは@code{display}表現
が使われます。

他のクラスはこのメソッドを定義することにより、独自の変換関数を提供することができます。
@c COMMON
@end deffn

@node String interpolation, String Accessors & Modifiers, String Constructors, Strings
@subsection String interpolation
@c NODE 文字列の補間

@c EN
The term "string interpolation" is used in various scripting languages
such as Perl and Python to refer to the feature to embed expressions
in a string literal, which are evaluated and then their results are
inserted into the string literal at run time.
@c JP
「文字列の補間(string interpolation)」という用語は、
PerlやPythonなど様々なスクリプト言語で、文字列リテラル内に式を埋め込んでおき
実行時に式を評価した値をそのリテラル内に埋め込む機能を指します。
@c COMMON

@c EN
Scheme doesn't define such a feature, but Gauche implements it as a
reader macro.
@c JP
Schemeはそのような機能を定義していませんが、Gaucheではリーダーマクロを使って
文字列の補間を実装しました。
@c COMMON

@deftp {Reader syntax} @code{#`}@var{string-literal}
@c EN
Evaluates to a string.  If @var{string-literal} contains the
character sequence @code{,@var{expr}}, where 
@var{expr} is a valid external representation
of a Scheme expression, @var{expr} is evaluated and
its result is inserted in the original place (by using @code{x->string},
see @ref{String Constructors}).
@c JP
文字列に評価されます。@var{string-literal}内に、@code{,@var{expr}}
というシーケンス(ここで@var{expr}は有効なScheme式の外部表現)が
現われたら、@var{expr}が評価されてその結果がもとの位置に埋め込まれます。
結果の文字列化には@code{x->string}が使われます(@ref{String Constructors}参照)。
@c COMMON

@c EN
The comma and the following expression must be adjacent (without containing
any whitespace characters), or it is not recognized as a special sequence.
@c JP
コンマと続く式とは、空白文字等を入れずに隣接していなければなりません。
そうでない場合は置換されません。
@c COMMON

@c EN
Two adjacent commas are converted to a single comma.  You can embed
a comma before a non-whitespace character in @var{string-literal}
by this.
@c JP
二つの連続するコンマは一つのリテラルのコンマ文字に置き換えられます。
これによって、コンマと非空白文字の連続を@var{string-literal}に入れることができます。
@c COMMON

@c EN
Other characters in the @var{string-literal} are copied as is.
@c JP
それ以外の@var{string-literal}内の文字シーケンスはそのままコピーされます。
@c COMMON

@c EN
If you use a variable as @var{expr} and need to delimit it from the
subsequent string, you can use the symbol escape syntax
using `|' character, as shown in the last two examples below.
@c JP
@var{Expr}に単独の変数を使う場合で、それに続く文字列と変数名を区切りたい
場合は、`|'文字を使ったシンボルエスケープ構文が使えます。下の例の最後の
2つを見て下さい。
@c COMMON

@example
#`"This is Gauche, version ,(gauche-version)."
 @result{} "This is Gauche, version @VERSION@."

#`"Date: ,(sys-strftime \"%Y/%m/%d\" (sys-localtime (sys-time)))"
 @result{} "Date: 2002/02/18"

(let ((a "AAA")
      (b "BBB"))
 #`"xxx ,a ,b zzz")
 @result{} "xxx AAA BBB zzz"

#`"123,,456,,789"
 @result{} "123,456,789"

(let ((n 5)) #`"R,|n|RS")
 @result{} "R5RS"

(let ((x "bar")) #`"foo,|x|.")
 @result{} "foobar"
@end example

@c EN
In fact, the reader expands this syntax into a macro call,
which is then expanded into a call of @code{string-append}
as follows:
@c JP
実は、リーダーはこの構文をマクロ呼び出しへと変換し、それが最終的には
@code{string-append}への呼び出しへと変換されます。
@c COMMON
@example
#`"This is Gauche, version ,(gauche-version)."
 @equiv{}
(string-append "This is Gauche, version "
               (x->string (gauche-version))
               ".")
@end example
@end deftp

@c EN
@emph{Rationale of the syntax:}
Some other scripting languages use `@code{$expr}' or '@code{#@{...@}}'.
I chose this syntax with respect to the quasiquote (@xref{Quasiquotation}).
Althogh it may be awkward to delimit variable names by `|',
the comma syntax should be easier to read than the other exotic syntax
for seasoned Scheme programmers.

Note that Scheme allows wider range of characters for valid identifier names
than usual scripting languages.
Consequently, you will almost always need to use `|' delimiters
when you interpolate the value of a variable.
For example, while you can write
@code{"$year/$month/$day $hour:$minutes:$seconds"} in Perl,
you should write @code{#`",|year|/,|month|/,day ,|hour|:,|minutes|:,seconds"}.
It may be better always to delimit direct variable references
in this syntax to avoid confusion.
@c JP
@emph{この構文を採用した理由:} 
他のスクリプト言語では、`@code{$expr}' や '@code{#@{...@}}' が良く使われています。
準クオート (@ref{Quasiquotation}参照) との類似性からこの構文を採用しました。
変数名の区切りを明確にするのに`|'を使う必要があるのは少々奇妙ですが、
慣れたSchemeプログラマならコンマ構文を読むのは他の言語から借りた構文よりも
楽だと思います。

Schemeは他のスクリプト言語より一般的により多くの文字を変数名に使うことが出来ることに注意して下さい。
結果として、変数の値を文字列に挿入する際、ほとんどの場合において変数名を`|'で区切る
必要があるでしょう。例えば、Perlでは
@code{"$year/$month/$day $hour:$minutes:$seconds"}
と書けたものが、Gaucheでは
@code{#`",|year|/,|month|/,day ,|hour|:,|minutes|:,seconds"}
と書かねばなりません。
混乱を避けるためには、この構文内では常に直接の変数参照は`|'で区切るようにしておくのが良いかもしれません。
@c COMMON

@node String Accessors & Modifiers, String Comparison, String interpolation, Strings
@subsection String Accessors & Modifiers
@c NODE 文字列のアクセスと変更

@defun string-length string
[R5RS]
@c EN
Returns a length of (possibly incomplete) string @var{string}.
@c JP
文字列@var{string}の長さ(文字数)を返します。
@var{string}は不完全な文字列であっても構いません。
@c COMMON
@end defun

@defun string-size string
@c EN
Returns a size of (possibly incomplete) @var{string}.
A size of string is a number of bytes @var{string} occupies on memory.
The same string may have different sizes if the native encoding scheme
differs.

For incomplete string, its length and its size always match.
@c JP
文字列@var{string}の大きさを返します。文字列の大きさは、
@var{string}が占めるメモリ上のバイト数で、これは文字列の内部エンコーディングに
依存します。同じ文字列であっても内部エンコーディングが違えば違う大きさになる場合も
あります。

不完全な文字列では、文字列の長さと大きさは常に一致します。
@c COMMON
@end defun

@defun string-ref cstring k &optional fallback
[R5RS+]
@c EN
Returns @var{k}-th character of a complete string @var{cstring}.
It is an error to pass an incomplete string.

By default, an error is signalled if @code{k} is out of range
(negative, or greater than or equal to the length of @var{cstring}).
However, if an optional argument @var{fallback} is given,
it is returned in such case.  This is Gauche's extension.
@c JP
完全な文字列@var{cstring}の@var{k}番目の文字を返します。
不完全な文字列を渡すのはエラーです。

@var{k}が負数であったり@var{cstring}の長さと同じかそれ以上であった場合には
エラーが報告されます。但し、引数@var{fallback}が与えられている場合にはエラーを
報告せず@var{fallback}が返されます。これはGaucheの拡張です。
@c COMMON
@end defun

@defun string-byte-ref string k
Returns @var{k-th} byte of a (possibly incomplete) string @var{string}.
Returned value is an integer in the range between 0 and 255.
@var{k} must be greater than or equal to zero, and less than
@code{(string-size @var{string})}.
@end defun

@defun string-set! string k char
[R5RS] Substitute @var{string}'s @var{k}-th character by @var{char}.
@var{k} must be greater than or equal to zero, and less than
@code{(string-length @var{string})}.
Return value is undefined.

If @var{string} is an incomplete string, integer value of the lower 8 bits
of @var{char} is used to set @var{string}'s @var{k}-th byte.

See the notes in @code{make-string} about performance consideration.
@end defun

@defun string-byte-set! string k byte
Substitute @var{string}'s @var{k}-th byte by integer @var{byte}.
@var{byte} must be in the range between 0 to 255, inclusive.
@var{k} must be greater than or equal to zero, and less than
@code{(string-size @var{string})}.
If @var{string} is a complete string, it is turned to incomplete string
by this operation.
Return value is undefined.
@end defun

@node String Comparison, String utilities, String Accessors & Modifiers, Strings
@subsection String Comparison
@c NODE 文字列の比較

@defun string=? string1 string2
@defunx string-ci@code{=}? string1 string2
[R5RS]
@end defun

@defun string@code{<}? string1 string2
@defunx string@code{<=}? string1 string2
@defunx string@code{>}? string1 string2
@defunx string@code{>=}? string1 string2
@defunx string-ci@code{<}? string1 string2
@defunx string-ci@code{<=}? string1 string2
@defunx string-ci@code{>}? string1 string2
@defunx string-ci@code{>=}? string1 string2
[R5RS]
@end defun

@node String utilities, String Pointers, String Comparison, Strings
@subsection String utilities
@c NODE 文字列を扱うその他の手続き

@defun substring string start end
[R5RS]
@end defun

@defun string-append string @dots{}
[R5RS]
@end defun

@defun string->list string &optional start end
@defunx list->string list
[R5RS+][SRFI-13]
@end defun

@defun string-copy string &optional start end
[R5RS+][SRFI-13]
@end defun

@defun string-fill! string char &optional start end
[R5RS+][SRFI-13] Fills @var{string} by @var{char}.  Optional
@var{start} and @var{end} limits the effective area.
@example
(string-fill! "orange" #\X)
  @result{} "XXXXXX"
(string-fill! "orange" #\X 2 4)
  @result{} "orXXge"
@end example
@end defun

@defun string-join strs &optional delim grammer
[SRFI-13] Concatenate strings in the list @var{strs},
with a string @var{delim} as `glue'.

The argument @var{grammer} may be one of the following symbol
to specify how the strings are concatenated.
@table @code
@item infix
Use @var{delim} between each string.  This mode is default.
Note that this mode introduce ambiguity when @var{strs}
is an empty string or a list with a null string.
@example
(string-join '("apple" "mango" "banana") ", ") 
  @result{} "apple, mango, banana"
(string-join '() ":")
  @result{} ""
(string-join '("") ":")
  @result{} ""
@end example
@item strict-infix
Works like @code{infix}, but empty list is not allowed to @var{strs},
thus avoiding ambiguity.
@item prefix
Use @var{delim} before each string.
@example
(string-join '("usr" "local" "bin") "/" 'prefix)
  @result{} "/usr/local/bin"
(string-join '() "/" 'prefix)
  @result{} ""
(string-join '("") "/" 'prefix)
  @result{} "/"
@end example
@item suffix
Use @var{delim} after each string.
@example
(string-join '("a" "b" "c") "&" 'suffix)
  @result{} "a&b&c&"
(string-join '() "&" 'suffix)
  @result{} ""
(string-join '("") "&" 'suffix)
  @result{} "&"
@end example
@end table

@end defun

@defun string-scan string item &optional return
Scan @var{item} (either a string or a character) in @var{string}.
The @var{return} argument specifies what value should be returned
when @var{item} is found in @var{string}.  It must be one of the
following symbols.

@table @code
@item index
Returns the index in @var{string} if @var{item} is found, or @code{#f}.
This is the default behavior.
@example
(string-scan "abracadabra" "ada") @result{} 5
(string-scan "abracadabra" #\c) @result{} 4
(string-scan "abracadabra" "aba") @result{} #f
@end example
@item before
Returns a substring of @var{string} before @var{item}, or
@code{#f} if @var{item} is not found.
@example
(string-scan "abracadabra" "ada" 'before) @result{} "abrac"
(string-scan "abracadabra" #\c 'before) @result{} "abra"
@end example
@item after
Returns a substring of @var{string} after @var{item}, or
@code{#f} if @var{item} is not found.
@example
(string-scan "abracadabra" "ada" 'after) @result{} "bra"
(string-scan "abracadabra" #\c 'after) @result{} "adabra"
@end example
@item before*
Returns a substring of @var{string} before @var{item}, and
the substring after it.  If @var{item} is not found, returns
@code{(values #f #f)}.
@example
(string-scan "abracadabra" "ada" 'before*)
  @result{} "abrac" @r{and} "adabra"
(string-scan "abracadabra" #\c 'before*)
  @result{} "abra" @r{and} "cadabra"
@end example
@item after*
Returns a substring of @var{string} up to the end of @var{item},
and the rest.  If @var{item} is not found, returns
@code{(values #f #f)}.
@example
(string-scan "abracadabra" "ada" 'after*)
  @result{} "abracada" @r{and} "bra"
(string-scan "abracadabra" #\c 'after*)
  @result{} "abrac" @r{and} "adabra"
@end example
@item both
Returns a substring of @var{string} before @var{item} and
after @var{item}.  If @var{item} is not found, returns
@code{(values #f #f)}.
@example
(string-scan "abracadabra" "ada" 'both)
  @result{} "abrac" @r{and} "bra"
(string-scan "abracadabra" #\c 'both)
  @result{} "abra" @r{and} "adabra"
@end example
@end table
@end defun

@defun string-split string splitter
Splits @var{string} by @var{splitter} and returns a list of strings.
@var{splitter} can be a character, a character set, a string,
a regexp, or a procedure.

If @var{splitter} is a character, the character is used as a delimiter.

If @var{splitter} is a character set, any consecutive characters
that are member of the character set are used as a delimiter.

If a procedure is given to @var{splitter}, it is called for each
character in @var{string}, and the consecutive characters that caused
@var{splitter} to return a true value are used as a delimiter.
@c COMMON

@example
(string-split "/aa/bb//cc" #\/)    @result{} ("" "aa" "bb" "" "cc")
(string-split "/aa/bb//cc" "/")    @result{} ("" "aa" "bb" "" "cc")
(string-split "/aa/bb//cc" "//")   @result{} ("/aa/bb" "cc")
(string-split "/aa/bb//cc" #[/])   @result{} ("" "aa" "bb" "cc")
(string-split "/aa/bb//cc" #/\/+/) @result{} ("" "aa" "bb" "cc")
(string-split "/aa/bb//cc" #[\w])  @result{} ("/" "/" "//" "")
(string-split "/aa/bb//cc" char-alphabetic?) @result{} ("/" "/" "//" "")

;; some boundary cases
(string-split "abc" #\/) @result{} ("abc")
(string-split ""    #\/) @result{} ("")
@end example

Note: When @var{splitter} is a char-set, @code{string-split} is
equivalent to @code{string-tokenize} except the meaning of the
char-set is reversed
(@xref{SRFI-13 other string operations}).
@end defun

@node String Pointers, Incomplete strings, String utilities, Strings
@subsection String Pointers
@c NODE 文字列ポインタ

@deftp {Builtin Class} <string-pointer>
@clindex string-pointer
String pointer is an object to access string efficiently in sequential
order (either forward or backward).

Higher level string iterators and accessors are constructed on top of 
this primitive.  @xref{srfi-13 - String library}, for details.
It is highly recommended to use SRFI-13 functions instead of these
string pointer objects, for portability.
@end deftp

@defun make-string-pointer str &optional (index 0)
Creates a string pointer that points to the @var{index}-th character of
string @var{str}.
@end defun

@defun string-pointer-copy sp
Copies a string pointer.  The resulting string pointer
shares the same string as @var{sp}, but has distinct pointer.
@end defun

@defun string-pointer? obj
Returns @code{#t} iff @var{obj} is a string pointer.
@end defun

@defun string-pointer-next! sp
@defunx string-pointer-prev! sp
@end defun

@defun string-pointer-set! sp index
@end defun

@defun string-pointer-substring sp &keyword (after #f)
@end defun

@defun string-pointer-index sp
@defunx string-pointer-byte-index sp
@end defun



@node Incomplete strings,  , String Pointers, Strings
@subsection Incomplete strings

@defun string-complete->incomplete str
@end defun

@defun string-incomplete->complete str
@end defun

@c ----------------------------------------------------------------------
@node Regular expression, Vectors, Strings, Core library
@section Regular expression
@c NODE 正規表現

@deftp {Builtin Class} <regexp>
@clindex regexp
@c EN
Regular expression object.  You can construct a regexp object
from a string by @code{string->regexp} at run time.  Gauche also 
has a special syntax to denote regexp literals, which construct
regexp object at loading time.

Gauche's regexp engine is fully aware of multibyte characters.
@c JP
正規表現オブジェクトのクラスです。@code{string->regexp}を使って実行時に
作成できます。また、Gaucheはリテラルの正規表現を表す構文を持っており、
ロード時に作成することもできます。

Gaucheの正規表現エンジンはマルチバイト文字列に対応しています。
@c COMMON
@end deftp

@deftp {Builtin Class} <regmatch>
@clindex regmatch
@c EN
Regexp match object.  A regexp matcher @code{rxmatch} returns
this object if match.  This object contains all the information
about the match, including submatches.

The advantage of using match object, rather than substrings or
list of indices is efficiency.  The regmatch object keeps internal
state of match, and computes indices and/or substrings only when
requested.  This is particularly effective for mutibyte strings,
for index access is slow on them.
@c JP
正規表現マッチオブジェクトのクラスです。正規表現エンジン@code{rxmatch}は、
一致した場合にこのオブジェクトを返します。部分一致の情報を含めた
全てのマッチに関する情報がこのオブジェクトに含まれています。

一致した部分文字列やそのインデックスのリストではなく
マッチオブジェクトを返すことの利点は効率です。
regmatchオブジェクトはマッチの内部状態を保持しており、
要求された時にはじめて該当する部分文字列やインデックスを計算します。
これは特にマルチバイト文字列に有効です。マルチバイト文字列
へのインデックスアクセスは遅いからです。
@c COMMON
@end deftp

@deftp {Reader Syntax} @code{#/@i{regexp-spec}/}
@deftpx {Reader Syntax} @code{#/@i{regexp-spec}/i}
@c EN
Denotes literal regular expression object.  When read, it becomes
an instance of @code{<regexp>}.
@c JP
リテラルの正規表現オブジェクトを表記します。読まれた際に@code{<regexp>}の
インスタンスとなります。
@c COMMON

@c EN
If a letter '@code{i}' is given at the end, the created regexp
becomes @emph{case-folding regexp}, i.e. it matches in the case-insensitive
way.  (The current version only cares ASCII characters for case-folding---
beyond ASCII characters, the match is done in the same way as normal match.)
@c JP
末尾に文字@code{i}が与えられた場合は、マッチ時に大文字小文字を区別しない
正規表現オブジェクトとなります。(現在のバージョンでは、大文字小文字の
同一視はASCII文字のみに対して行われます。それ以外の文字は通常の方法でマッチします)。
@c COMMON

@c EN
The advantage of using this syntax over @code{string->regexp} is
that the regexp is compiled only once.  You can use literal regexp
inside loop without worring about regexp compilation overhead.
If you want to construct regexp on-the-fly, however, use @code{string->regexp}.
@c JP
@code{string->regexp}に対してこの構文を使う利点は、
正規表現のコンパイルが一度しか行われない点です。この構文は、
内部ループの中でも、正規表現のコンパイルのオーバヘッドを気にせずに
使うことができます。動的に正規表現を作成したい場合のみ@code{string->regexp}を
使って下さい。
@c COMMON

@c EN
The recognized syntax is a subset of POSIX extended regular expression,
with a bit of extension taken from Perl.  Specifically, Gauche supports:
@c JP
認識される構文はPOSIX拡張正規表現のサブセットに、Perlの拡張の一部を
採り入れたものです。具体的には以下の構文がサポートされます。
@c COMMON
@itemize @bullet
@item
@c EN
Repetition by @code{*}, @code{+} and @code{?}.
@c JP
@code{*}、@code{+}、@code{?}による繰り返しの指定。
@c COMMON
@item
@c EN
Grouping by @code{()}.  No backslash escape is needed.
@c JP
@code{()}によるグルーピング。括弧の前にバックスラッシュは不要です。
@c COMMON
@item
@c EN
Alternative by @code{|}.
@c JP
@code{|}による選択。
@c COMMON
@item 
@c EN
Character class by @code{[]}.  The syntax recognized by character set
literals (@xref{Character set}) are valid.
@c JP
@code{[]}による文字クラス。文字集合リテラル (@ref{Character set}参照) で認識される
表記が全て有効です。
@c COMMON
@item
@c EN
Beginning of the string @code{^} and end of the string @code{$} assertions.
@c JP
文字列の先頭@code{^}、および末尾@code{$}へのマッチ。
@c COMMON
@item
@c EN
Several special character class abbreviations;
@code{\d} for digits, @code{\D} for non-digits, @code{\w} for alfphanumeric
characters, @code{\W} for non-alphanumeric characters, @code{\s} for
whitespace characters, and @code{\S} for non-whitespace characters.
These can be used both inside and outside of @code{[]}.
@c JP
いくつかの特定の文字クラスの略記。
数字@code{\d}、数字の補集合@code{\D}、アルファベットと数字@code{\w}、
その補集合@code{\W}、空白文字@code{\s}、その補集合@code{\S}が使えます。
これらは通常のコンテクストでも、文字クラス@code{[]}の中でも使えます。
@c COMMON
@end itemize

@c EN
And Gauche does not supports:
@c JP
以下の機能はサポートされていません。
@c COMMON
@itemize @bullet
@item
@c EN
Collating elements, e.g. @code{[=e=]} and @code{[.ll.]}.
@c JP
@code{[=e=]}や@code{[.ll.]}のような、コレーティングエレメント。
@c COMMON
@item
@c EN
Beginning/end of word assertions.
@c JP
単語の先頭/終了へのマッチ。
@c COMMON
@item
@c EN
Fixed-number repetition, @code{@{m,n@}}.
@c JP
@code{@{m,n@}}のような、回数を指定した繰り返し。
@c COMMON
@item
@c EN
Back reference of submatches.
@c JP
部分一致へのバックリファレンス。
@c COMMON
@end itemize

@c EN
Among those unsupported features, the first three will eventually
be supported.  It is unlikely to support back reference, however.
If you use back reference, you're not dealing with regular grammer
any more.  And if you're dealing with higher class of grammer,
there should be appropriate tools rather than regular expressions.
@c JP
これらのサポートされていない機能のうち、最初の3つはいずれサポートする予定です。
但し、バックリファレンスに関してはおそらくサポートしないでしょう。
バックリファレンスを使わなければならないということは、
その対象は正規文法では表現できないということです。
それならばより複雑なクラスの文法を扱うのに適したツールを使うべきであって、
無理矢理正規表現を使おうとするのは良くありません。
@c COMMON
@end deftp

@defun string->regexp string &keyword case-fold
@c EN
Takes @var{string} as a regexp specification, and constructs
an instance of @code{<regexp>} object.
@c JP
文字列@var{string}を正規表現とみなして、@code{<regexp>}のインスタンスを
作成して返します。
@c COMMON

@c EN
If a true value is given to the keyword argument @var{case-fold},
the created regexp object becomes case-folding regexp.
(See the above explanation about case-folding regexp).
@c JP
キーワード引数@var{case-fold}に真の値が与えられた場合、作成される正規表現は
大文字小文字を区別しないものとなります。
(大文字小文字を区別しない正規表現に関しては上の説明を参照して下さい)。
@c COMMON
@end defun

@defun regexp? @var{obj}
@c EN
Returns true iff @var{obj} is a regexp object.
@c JP
@var{obj}が正規表現オブジェクトなら真の値を返します。
@c COMMON
@end defun

@defun regexp->string @var{regexp}
@c EN
Returns a source string describing the regexp @var{regexp}.
The returned string is immutable.
@c JP
正規表現@var{regexp}を記述する元になった文字列を返します。
返される文字列は変更不可な文字列です。
@c COMMON
@end defun

@defun rxmatch regexp string
@c EN
@var{Regexp} is a regular expression object.
A string @var{string} is matched by
@var{regexp}.  If it matches, the function returns a @code{<regmatch>}
object.  Otherwise it returns @code{#f}.
@c JP
正規表現オブジェクト@var{regexp}に一致するものを文字列@var{string}から
探します。一致が見付かった場合は@code{<regmatch>}オブジェクトを返し、
見付からなかった場合は@code{#f}を返します。
@c COMMON

@c EN
This is called @code{match}, @code{regexp-search} or @code{string-match}
in some other Scheme implementations.
@c JP
他のScheme処理系ではこれは
@code{match}、@code{regexp-search}、@code{string-match}など
様々な名で呼ばれています。
@c COMMON
@end defun

@deftp {Generic application} @var{regexp} @var{string}
@c EN
A regular expression object can be applied directly to the string.
This works the same as @code{(rxmatch @var{regexp} @var{string})},
but allows shorter notation.   @xref{Applicable objects}, for
generic mechanism used to implement this.
@c JP
正規表現オブジェクトは直接文字列に対して適用することもできます。
これは@code{(rxmatch @var{regexp} @var{string})}と同じ動作をしますが、
表記が短くて済みます。この機能は@ref{Applicable objects} で述べているメカニズムを
使って実装されています。
@c COMMON
@end deftp

@defun rxmatch-start match &optional (i 0)
@defunx rxmatch-end match &optional (i 0)
@defunx rxmatch-substring match &optional (i 0)
@c EN
@var{Match} is a match object returned by @code{rxmatch}.
If @var{i} equals to zero, the functions return
start, end or the substring of entire match, respectively.
With positive integer @var{I}, it returns those of @var{I}-th
submatches.  It is an error to pass other values to @var{I}.
@c JP
@code{rxmatch}が返すマッチオブジェクト@var{match}から情報を取り出します。
@var{i}が省略されるか0の場合、これらの手続きはそれぞれ一致した
文字列の開始インデックス、終了インデックス、および一致した部分文字列を
返します。@var{i}に正の整数が与えられた場合は、@var{i}番目のサブマッチ
に関する情報を返します。@var{i}にそれ以外の値を与えるのはエラーです。
@c COMMON

@c EN
It is allowed to pass @code{#f} to @var{match} for convenience.
The functions return @code{#f} in such case.
@c JP
簡便のために、@var{match}に@code{#f}を渡すことも許されています。
その場合、これらの手続きは@code{#f}を返します。
@c COMMON

@c EN
These functions correspond to scsh's @code{match:start}, @code{match:end}
and @code{match:substring}.
@c JP
これらの手続きはScshで@code{match:start}、@code{match:end}、
@code{match:substring}と呼ばれているものと等価です。
@c COMMON
@end defun

@defun rxmatch-after match &optional (i 0)
@defunx rxmatch-before match &optional (i 0)
@c EN
Returns substring of the input string after or before @var{match}.
If optional argument is given, the @var{i}-th submatch is used
(0-th submatch is the entire match).
@c JP
マッチオブジェクト@var{match}の前および後の文字列を返します。
正の整数が@var{i}に与えられた場合はi番目のサブマッチの前および後の
文字列を返します。
@c COMMON
@example
(define match (rxmatch #/(\d+)\.(\d+)/ "pi=3.14..."))

(rxmatch-after match) @result{} "..."
(rxmatch-after match 1) @result{} ".14..."

(rxmatch-before match) @result{} "pi="
(rxmatch-before match 2) @result{} "pi=3."
@end example
@end defun

@deftp {Generic application} @var{regmatch} &optional @var{index}
@deftpx {Generic application} @var{regmatch} @code{'before} &optional @var{index}
@deftpx {Generic application} @var{regmatch} @code{'after} &optional @var{index}
@c EN
A regmatch object can be applied directly to the integer index,
or a symbol @code{before} or @code{after}.
They works the same as @code{(rxmatch-substring @var{regmatch} @var{index})},
@code{(rxmatch-before @var{regmatch})}, and
@code{(rxmatch-after @var{regmatch})}, respectively.
This allows shorter notation.  @xref{Applicable objects}, for
generic mechanism used to implement this.
@c JP
マッチオブジェクトは直接整数のインデックスもしくはシンボル@code{before}または
@code{after}に対して適用することができます。
それぞれ@code{(rxmatch-substring @var{regmatch} @var{index})}、
@code{(rxmatch-before @var{regmatch})}、および
@code{(rxmatch-after @var{regmatch})}と同じ動作をしますが、
表記が短くて済みます。
この機能は@ref{Applicable objects} で述べているメカニズムを使って実装されています。
@c COMMON

@example
(define match (#/(\d+)\.(\d+)/ "pi=3.14..."))

(match)           @result{} "3.14"
(match 1)         @result{} "3"
(match 2)         @result{} "14"

(match 'after)    @result{} "..."
(match 'after 1)  @result{} ".14..."

(match 'before)   @result{} "pi="
(match 'before 2) @result{} "pi=3."
@end example
@end deftp


@c EN
Seel also @ref{gauche.regexp - Regular expression utilities}, which defines
useful macros and functions to deal with regular expression matching.
@c JP
また、@ref{gauche.regexp - Regular expression utilities}には、正規表現検索に便利な
マクロや手続きが定義されています。参照して下さい。
@c COMMON

@c ----------------------------------------------------------------------
@node Vectors, Hashtables, Regular expression, Core library
@section Vectors
@c NODE ベクター

@deftp {Builtin Class} <vector>
@clindex vector
@c EN
A vector is a simple 1-dimensional array of Scheme objects.
You can access its element by index in constant time.
Once created, a vector can't be resized.

Class @code{<vector>} inherits @code{<sequence>} and 
you can use various generic functions such as @code{map} and @code{fold}
on it.   @xref{gauche.collection - Collection framework}, and @xref{gauche.sequence - Sequence framework}.

If you keep only a homogeneous numeric type, you may be able
to use SRFI-4 homogenous vectors (@xref{srfi-4 - Homogeneous vectors}).
@c JP
ベクタはSchemeオブジェクトの単純な一次元配列です。
インデックスを用いて定数時間でその要素にアクセスできます。
一度作成されたベクタはその大きさを変えることはできません。

@code{<vector>}クラスはまた@code{<sequence>}クラスを継承し、
@code{map}や@code{fold}など様々な総称関数を使うことができます。
@ref{gauche.collection - Collection framework} と
@ref{gauche.sequence - Sequence framework} を参照して下さい。

数値しか要素に持たないベクタを使う場合、SRFI-4の
単一型ベクタも使えるかもしれません (@ref{srfi-4 - Homogeneous vectors}参照)。
@c COMMON
@end deftp

@defun vector? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a vector, @code{#f} otherwise.
@c JP
@var{obj}がベクタなら@code{#t}を、そうでなければ@var{#f}を返します。
@c COMMON
@end defun

@defun make-vector k &optional fill
[R5RS]
@c EN
Creates and returns a vector with length @var{k}.
If optional argument @var{fill} is given, each element of the vector
is initialized by it.  Otherwise, the initial value of each element
is undefined.
@c JP
長さ@var{k}のベクタを作成して返します。
省略可能な引数@var{fill}が与えられていれば、ベクタの各要素はその値で
初期化されます。そうでなければベクタの各要素の値は不定です。
@c COMMON
@end defun

@defun vector obj @dots{}
[R5RS]
@c EN
Creates a vector whose elements are @var{obj} @dots{}.
@c JP
要素が@var{obj} @dots{}であるようなベクタを作成して返します。
@c COMMON
@end defun

@defun vector-length vector
[R5RS]
@c EN
Returns the length of a vector @var{vector}.

With @code{gauche.collection} module,
you can also use a method @code{size-of}.
@c JP
ベクタ@var{vector}の長さを返します。

@code{gauche.collection}モジュールをロードしていれば、
メソッド@code{size-of}も同じ目的で使えます。
@c COMMON
@end defun

@defun vector-ref vector k &optional fallback
[R5RS+]
@c EN
Returns @var{k}-th element of vector @var{vector}.

By default, @code{vector-ref} signals an error if @var{k} is
negative, or greater than or equal to the length of @var{vector}.
However, if an optional argument @var{fallback} is given,
it is returned for such case.  This is an extension of Gauche.

With @code{gauche.sequence} module,
you can also use a method @code{ref}.
@c JP
ベクタ@var{vector}の@var{k}番目の要素を返します。

@code{vector-ref}は@var{k}が負の値であったりベクタの長さより
大きかったりした場合はエラーを通知します。但し、省略可能な引数@var{fallback}
が与えられている場合はその値が返されます。これはGaucheの拡張です。

@code{gauche.sequence}モジュールをロードしていれば、
メソッド@code{ref}も同じ目的で使えます。
@c COMMON
@end defun

@defun vector-set! vector k obj
[R5RS]
@c EN
Sets @var{k}-th element of the vector @var{vector} to @var{obj}.
It is an error if @var{k} is negative or greater than or equal to the
length of @var{vector}.

With @code{gauche.sequence} module, you can also use
a setter method of @code{ref}.
@c JP
ベクタ@var{vector}の@var{k}番目の要素を@var{obj}に変更します。
@var{k}が負数であったりベクタの長さより大きい場合はエラーとなります。

@code{gauche.sequence}モジュールをロードしていれば、
メソッド@code{ref}のsetterメソッドも使えます。
@c COMMON
@end defun

@defun vector->list vector &optional start end
@defunx list->vector list
[R5RS+]
@c EN
Converts a vector to a list, or vice versa.

The optional @var{start} and @var{end} argument of @code{vector->list}
limits the range of the @var{vector} to be retrieved.

@example
(vector->list '#(1 2 3 4 5))     @result{} (1 2 3 4 5)
(list->vector '(1 2 3 4 5))      @result{} #(1 2 3 4 5)
(vector->list '#(1 2 3 4 5) 2 4) @result{} (3 4)
@end example

With @var{gauche.collection} module, you can use
@code{(coerce-to <list> @var{vector})} and 
@code{(coerce-to <vector> @var{list})} as well.
@c JP
ベクタをリストに変換したり、その逆を行う手続きです。

@var{vector->list}に省略可能な引数@var{start}と@var{end}を与えることにより、
値を取り出す範囲を制限することができます。

@example
(vector->list '#(1 2 3 4 5))     @result{} (1 2 3 4 5)
(list->vector '(1 2 3 4 5))      @result{} #(1 2 3 4 5)
(vector->list '#(1 2 3 4 5) 2 4) @result{} (3 4)
@end example

@code{gauche.collection}モジュールをロードしていれば、
@code{(coerce-to <list> @var{vector})} と
@code{(coerce-to <vector> @var{list})} も同じ目的で使えます。
@c COMMON
@end defun

@defun vector-fill! vector fill &optional start end
[R5RS+]
@c EN
Sets all elements in a vector @var{vector} to @var{fill}.

Optional @var{start} and @var{end} limits the range
of effect between @var{start}-th index (inclusive) to
@var{end}-th index (exclusive).  @var{Start} defaults to
zero, and @var{end} defaults to the length of @var{vector}.
These optional arguments are Gauche's extension.
@c JP
ベクタ@var{vector}の全ての要素を@var{fill}に変更します。

省略可能な引数@var{start}と@var{end}が与えられた場合、
@var{start}番目の要素から@var{end}-1番目の要素までのみに
@var{fill}を格納します。@var{start}と@var{end}の既定値は
それぞれ0と@var{vector}の大きさです。
@var{start}, @var{end}引数はGaucheの拡張です。
@c COMMON
@end defun

@defun vector-copy vector &optional start end
@c EN
Copies a vector @var{vector}.  Optional @var{start} and @var{end}
arguments can be used to limit the range of @var{vector} to be copied.
@c JP
ベクタ@var{vector}をコピーします。引数@var{start}と@var{end}を与えることで
コピーされる範囲を制限することができます。
@c COMMON

@example
(vector-copy '#(1 2 3 4 5))     @result{} #(1 2 3 4 5)
(vector-copy '#(1 2 3 4 5) 2 4) @result{} #(3 4)
@end example
@end defun

@c ----------------------------------------------------------------------
@node Hashtables, Weak pointers, Vectors, Core library
@section Hashtables
@c NODE ハッシュテーブル

@deftp {Builtin Class} <hash-table>
@clindex hash-table
@c EN
Hash table class.
@c JP
ハッシュテーブルのクラスです。
@c COMMON
@end deftp

@defun make-hash-table &optional type
@c EN
Creates a hash table.   A symbol @var{type} specifies the type of the table.
The following types are currently supported.
@c JP
ハッシュテーブルを作成します。シンボル@var{type}はテーブルのタイプを指定します。
現在、以下のようなタイプがサポートされています。
@c COMMON
@table @code
@item eq?
@c EN
Keys are compared by @code{eq?}
@c JP
キーの比較に@code{eq?}を使います。
@c COMMON
@item eqv?
@c EN
Keys are compared by @code{eqv?}
@c JP
キーの比較に@code{eqv?}を使います。
@c COMMON
@item equal?
@c EN
Keys are compared by @code{equal?}
@c JP
キーの比較に@code{equal?}を使います。
@c COMMON
@item string=?
@c EN
Keys are compared by @code{string=?}.  Key must be a string.
@c JP
キーの比較に@code{string=?}を使います。キーは文字列でなければなりません。
@c COMMON
@end table

@c EN
If @var{type} is omitted, @code{eq?} is assumed.

@c JP
@var{type}が省略された場合は@code{eq?}とみなされます。
@c COMMON
@end defun

@defun hash-table? obj
@c EN
Returns @code{#t} if @var{obj} is a hash table.
@c JP
@var{obj}がハッシュテーブルであれば@code{#t}を返します。
@c COMMON
@end defun

@defun hash-table type key&value @dots{}
@c EN
Constructs and returns a hash table of type @var{type} from given
list of arguments.
@var{Type} is the same as of @code{make-hash-table}.
Each @var{key&value} must be a pair, and its car is used as a key
and its cdr is used as a value.
@c JP
与えられたキーと値の列からタイプが@var{type}であるハッシュテーブルを構築して
返します。@var{type}の意味は@code{make-hash-table}と同じです。
各@var{key&value}はペアでなければならず。そのcarがキー、cdrが値として使われます。
@c COMMON

@example
(hash-table 'eq? '(a . 1) '(b . 2))
  @equiv{}
  (let ((h (make-hash-table 'eq?)))
     (hash-table-put! h 'a 1)
     (hash-table-put! h 'b 2)
     h)
@end example
@end defun

@defun hash-table-get hash key &optional default
@c EN
Search @var{key} from a hash table @var{hash}, and returns its value
if found.  If the key is not found in the table and @var{default} is
given, it is returned.  Otherwise an error is signalled.
@c JP
キー@var{key}をハッシュテーブル@var{hash}から探します。見つかればキーに対応する
値を返します。キーが見つからなかった場合、@var{default}が与えられていればそれを
返し、そうでなければエラーを報告します。
@c COMMON
@end defun

@defun hash-table-put! hash key value
@c EN
Puts a key @var{key} with a value @var{value} to the hash table @var{hash}.
@c JP
キー@var{key}と対応する値@var{value}をハッシュテーブル@var{hash}に挿入します。
@c COMMON
@end defun

@defun hash-table-exists? hash key
@c EN
Returns @code{#t} if a hash table @var{hash} has a key @var{key}.
@c JP
ハッシュテーブル@var{hash}にキー@var{key}を持つエントリがあれば@code{#t}を返します。
@c COMMON
@end defun

@defun hash-table-delete! hash key
@c EN
Deletes an entry that has a key @var{key} from the hash table @var{hash}.
Returns @code{#t} if the entry has exist, or @code{#f} if the entry
hasn't exist.   The same function is called @code{hash-table-remove!} in STk
(except that it returns an undefined value); I use `delete' for consistency
to SRFI-1, SRFI-13 and other parts of the libraries.
@c JP
ハッシュテーブル@code{hash}からキー@var{key}を持つエントリを削除します。
@var{key}を持つエントリが実際に存在して削除された場合は@code{#t}を、
エントリが存在しなかった場合は@code{#f}を返します。
この手続きはSTkで@code{hash-table-remove!}と呼ばれているものです
(STkのは戻り値が定義されていませんが)。GaucheではSRFI-1, SRFI-13やその他の
ライブラリとの一貫性のために `delete' を採用しました。
@c COMMON
@end defun

@defun hash-table-push! hash key value
@c EN
Conses @var{value} to the existing value for the key @var{key} in the
hash table @var{hash} and makes it the new value for @var{key}.
If there's no entry for @var{key}, an entry
is created with the value @code{(list @var{value})}.

Works the same as the following code, except that this function
only looks up the @var{key} once, thus it's more efficient.
@c JP
ハッシュテーブル@var{hash}中の、キー@var{key}に対応する値に@var{value}をコンスし、
それを@var{key}に対する新たな値とします。もし@var{key}に対応する値がまだ無ければ、
新たなエントリが作成され、@code{(list @var{value})}がその値となります。

この手続きは次のコードと同じ動作をしますが、キーの探索が一度しか行われないためより高速です。
@c COMMON
@example
(hash-table-put! hash key
    (cons value (hash-table-get hash key '())))
@end example
@end defun

@defun hash-table-pop! hash key &optional default
@c EN
Looks for the value for the key @var{key} in the hash table @var{hash}.
If found and it is a pair, replaces the value for its cdr and returns
car of the original value.  If no entry for @var{key} is in the table,
or the value is not a pair, the table is not modified and
the procedure returns @var{default} if given, or signals an error otherwise.  

During the operation the key is looked for only once, thus runs
efficiently.
@c JP
ハッシュテーブル@var{hash}中のキー@var{key}に対応する値が存在し、かつペアで
あった場合に、そのエントリーを元の値のcdrで置き換え、元の値のcarを返します。
@var{key}に対応する値が存在しないかペアではなかった場合、テーブルは変更されず、
@var{default}が与えられていればそれが返され、与えられていなければエラーが報告されます。

値が置き換えれる場合でもキーの探索は一度しか行われないため効率が良いです。
@c COMMON
@end defun

@defun hash-table-for-each hash proc
@defunx hash-table-map hash proc
@c EN
A procedure @var{proc} is called with two arguments, a key and its associated
value, over all the entries in the hash table @var{hash}.
@c JP
ハッシュテーブル@var{hash}内の全てのエントリについて、各エントリのキーと値を
2つの引数として手続き@var{proc}を呼びます。
@c COMMON
@end defun

@defun hash-table-fold hash kons knil
@c EN
For all entries in the hash table @var{hash},
a procedure @var{kons} is called with three arguments;
a key, its associated value, and the previous return value of @var{proc}.
The first call of @var{proc} receives @var{knil} as the third argument.
The return value of the last call of @var{proc} is returned
from @code{hash-table-fold}.
@c JP
ハッシュテーブル@var{hash}内の全てのエントリについて@var{proc}を呼びます。
@var{proc}には3つの引数が渡されます。
各エントリのキーと値、および一つ前の@var{proc}の返り値です。
最初の@var{proc}の呼び出しの時には、第3引数に@var{knil}が渡されます。
最後の@var{proc}の返り値が@code{hash-table-fold}の返り値となります。
@c COMMON
@end defun

@defun hash-table-keys hash
@defunx hash-table-values hash
@c EN
Returns all the keys or values of hash table @var{hash} in a list,
 respectively.
@c JP
それぞれ、ハッシュテーブル@var{hash}内の全てのキーまたは値をリストにして返します。
@c COMMON
@end defun

@c @defun hash-table-stat hash
@c @end defun

@c ----------------------------------------------------------------------
@node Weak pointers, Control features, Hashtables, Core library
@section Weak pointers
@c NODE Weak pointer

@c EN
A weak pointer is a reference to an object that doesn't prevent
the object from being garbage-collected.
Gauche provides weak pointers as a @emph{weak vector} object.
A weak vector is like a vector of objects, except each object
can be garbage collected if it is not referenced from objects
other than weak vectors.   If the object is collected, the
entry of the weak vector is replaced for @code{#f.}
@c JP
Weak pointerとは、それが参照しているオブジェクトがガベージコレクトされることを
許すようなポインタです。
Gaucheは@emph{weak vector}オブジェクトによってweak pointerの機能を提供します。
Weak vectorは通常のベクタに似ていますが、要素のオブジェクトがweak vector以外から
参照されていない場合、オブジェクトはガベージコレクトされ、weak vectorの該当するエントリは
@code{#f}で置き換えられます。
@c COMMON
@example
gosh> (define v (make-weak-vector 1))
v
gosh> (weak-vector-ref v 0)
#f
gosh> (weak-vector-set! v 0 (cons 1 1))
#<undef>
gosh> (weak-vector-ref v 0)
(1 . 1)
gosh> (gc)
#<undef>
gosh> (gc)
#<undef>
gosh> (weak-vector-ref v 0)
#f
@end example

@deftp {Builtin Class} <weak-vector>
@clindex weak-vector
@c EN
The weak vector class.  Inherits @code{<sequence>} and @code{<collection>},
so you can use
@code{gauche.collection} (@xref{gauche.collection - Collection framework}) and
@code{gauche.sequence} (@xref{gauche.sequence - Sequence framework}).
@c JP
Weak vectorのクラスです。@code{<sequence>}と@code{<collection>}を継承しているので、
@code{gauche.collection} (@ref{gauche.collection - Collection framework}参照) と
@code{gauche.sequence} (@ref{gauche.sequence - Sequence framework}参照) も使えます。
@c COMMON
@example
(coerce-to <weak-vector> '(1 2 3 4))
  @result{} a weak vector with four elements
@end example
@end deftp

@defun make-weak-vector size
@c EN
Creates and returns a weak vector of size @var{size}.
@c JP
大きさ@var{size}のweak vectorを作成して返します。
@c COMMON
@end defun

@defun weak-vector-length wvec
@c EN
Returns the length of a weak vector @var{wvec}.
@c JP
Weak vector @var{wvec}の大きさを返します。
@c COMMON
@end defun

@defun weak-vector-ref wvec k &optioal fallback
@c EN
Returns @var{k}-th element of a weak vector @var{wvec}.

By default, @code{weak-vector-ref} signals an error if @var{k} is
negative, or greater than or equal to the size of @var{wvec}.
However, if an optional argument @var{fallback} is given,
it is returned for such case.

With @code{gauche.sequence} module,
you can also use a method @code{ref}.
@c JP
Weak vector @var{wvec}の@var{k}番目の要素を返します。

@code{weak-vector-ref}は@var{k}が負の値であったりベクタの長さより
大きかったりした場合はエラーを通知します。但し、省略可能な引数@var{fallback}
が与えられている場合はその値が返されます。

@code{gauche.sequence}モジュールをロードしていれば、
メソッド@code{ref}も同じ目的で使えます。
@c COMMON
@end defun

@defun weak-vector-set! wvec k obj
@c EN
Sets @var{k}-th element of the weak vector @var{wvec} to @var{obj}.
It is an error if @var{k} is negative or greater than or equal to the
size of @var{wec}.
@c JP
Weak vector @var{wvec}の@var{k}番目の要素を@var{obj}に変更します。
@var{k}が負数であったりベクタの長さより大きい場合はエラーとなります。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Control features, Exceptions, Weak pointers, Core library
@section Control features
@c NODE 制御

@menu
* Procedures::                  
* Applicable objects::          
* Continuation::                
* Multiple values::             
* Delayed Evaludation::         
@end menu

@node Procedures, Applicable objects, Control features, Control features
@subsection Procedures
@c NODE 手続き

@deftp {Builtin Class} <procedure>
@clindex procedure
@end deftp

@defun procedure? obj
[R5RS]
@c EN
Returns @code{#t} if @var{obj} is a procedure, @code{#f} otherwise.
@c JP
@var{obj}が手続きなら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun apply proc arg1 @dots{} args
[R5RS]
@c EN
Calls a procedure @var{proc} with a list of arguments,
@code{(@var{arg1} @dots{} . @var{args})}.
The last argument @var{args} must be a proper list.
Returns (a) value(s) @var{proc} returns.
@c JP
@code{(@var{arg1} @dots{} . @var{args})}を引数として手続き@var{proc}を呼びます。
最後の引数@var{args}は正規のリストでなければなりません。 @var{proc}が返す
値をそのまま返します。
@c COMMON
@example
(apply list 'a 'b '(c d e)) @result{} (a b c d e)

(apply + 1 2 '(3 4 5))      @result{} 15
@end example
@end defun


@menu
* Mapping::                     
* Combinators::                 
* Optional argument parsing::   
* Procedure arity::             
@end menu

@node Mapping, Combinators, Procedures, Procedures
@subsubsection Mapping
@c NODE マッピング

@defun map proc list1 list2 @dots{}
[R5RS+]
@c EN
Applies @var{proc} for each element(s) of given list(s),
and returns a list of the results.  R5RS doesn't specify
the application order of @code{map}, but Gauche guarantees
@var{proc} is always applied in order of the list(s).
Gauche's @code{map} also terminates as soon as one of
the list is exhausted.
@c JP
与えられたリストの各要素に対して@var{proc}を適用し、その結果をリストにして
返します。R5RSでは@var{proc}の適用順序が定められていませんが、Gaucheでは
常に@var{proc}はリスト内の順番で呼ばれます。
複数のリストが与えられた場合、最も短いリストが終了した時点で@var{proc}の適用を
打ち切ります。
@c COMMON

@example
(map car '((a b) (c d) (e f))) @result{} (a c e)

(map cons '(a b c) '(d e f))
  @result{} ((a . d) (b . e) (c . f))
@end example

@c EN
Note that the @code{gauche.collection} module (@xref{gauche.collection - Collection framework})
extends @code{map} to work on any type of collection.
@c JP
@code{gauche.collection}モジュール(@ref{gauche.collection - Collection framework}参照)
を使うと、@code{map}がリスト以外のコレクション型に対しても動作するようになります。
@c COMMON
@end defun

@defun for-each proc list1 list2 @dots{}
[R5RS]
@c EN
Applies @var{proc} for each element(s) of given list(s) in order.
The results of @var{proc} are discarded.  The return value of
@code{for-each} is undefined.  When more than one list is given,
@code{for-each} terminates as soon as one of the list is exhausted.
@c JP
手続き@var{proc}をリストの各エレメントに対して順に適用します。
@var{proc}の結果は捨てられます。@code{for-each}の戻り値は定義されていません。
複数のリストが与えられた場合、一番短いリストが終了した時点で@code{for-each}は終了します。
@c COMMON

@c EN
Note that the @code{gauche.collection} module (@xref{gauche.collection - Collection framework})
extends @code{for-each} to work on any type of collection.
@c JP
@code{gauche.collection}モジュール(@ref{gauche.collection - Collection framework}参照)
を使うと、@code{for-each}がリスト以外のコレクション型に対しても動作するようになります。
@c COMMON
@end defun


@node Combinators, Optional argument parsing, Mapping, Procedures
@subsubsection Combinators
@c NODE コンビネータ

@c EN
Gauche has some primitive procedures that allows combinatory programming.
@c JP
Gaucheには、combinatory programmingに使えるいくつかの基本手続きがあります。
@c COMMON

@defun pa$ proc arg @dots{}
@c EN
Partial application.  Returns a procedure, and when it is
called with arguments @var{m} @dots{}, it is equivalent to call
@code{(proc arg @dots{} m @dots{})}.
@c JP
部分適用。手続きを返します。その手続きが引数@var{m} @dots{}を伴って
呼ばれた場合、それは@code{(proc arg @dots{} m @dots{})}と等価になります。
@c COMMON

@example
(define add3 (pa$ + 3))
(add3 4) @result{} 7

(map (pa$ * 2) '(1 2 3)) @result{} (2 4 6)
@end example

@c EN
Macros @code{cut} and @code{cute} defined in SRFI-26 provide
a similar abstraction, with a bit more flexible but less compact
notation.  @xref{Making Procedures}.
@c JP
SRFI-26で定義されているマクロ@code{cut}と@code{cute}も似たような抽象化の
方法を提供しますが、@code{pa$}より多少柔軟性が高く、その分やや冗長です。
@ref{Making Procedures}を参照して下さい。
@c COMMON
@end defun

@defun apply$ proc
@defunx map$ proc
@defunx for-each$ proc
@c EN
Partial application version of @code{apply}, @code{map} and @code{for-each}.
@c JP
@code{apply}, @code{map}と@code{for-each}の部分適用版です。
@c COMMON

@example
(define map2* (map$ (pa$ * 2)))
(map2* '(1 2 3)) @result{} (2 4 6)
@end example

@end defun

@c EN
There are more 'partial-applied' version of procedures defined in
SRFI-1 (@xref{srfi-1 - List library}), such as @code{fold$},
@code{filter$}, @code{member$}, etc.
@c JP
他にも@code{fold$}、@code{filter$}、@code{member$}等
いくつかの部分適用版の手続きが定義されています。
@ref{srfi-1 - List library}を参照してください。
@c COMMON

@defun compose f g h @dots{}
@c EN
Combine two or more procedures.  Arguments must be procedures.
When two procedures are given, @code{(compose f g)} is equivalent to
@c JP
2つ以上の手続きを結合します。引数は全て手続きでなければなりません。
2つの引数が渡された時、@code{(compose f g)}は次の式と等価です。
@c COMMON
@example
(lambda args (call-with-values (lambda () (apply g args)) f))
@end example

@c EN
Some examples:
@c JP
いくつか例を示します。
@c COMMON

@example
(define not-zero? (compose not zero?))
(not-zero? 3) @result{} #t
(not-zero? 0) @result{} #f

(define dot-product (compose (apply$ +) (map$ *)))
(dot-product '(1 2 3) '(4 5 6)) @result{} 32
@end example
@end defun

@defun any-pred pred @dots{}
Returns a procedure which applies given argument(s) to
each predicate @var{pred}.  If any @var{pred} returns
a non-@code{#f} value, the value is returned.  If all the @var{pred}s
return @code{#f}, @code{#f} is returned.

@example
(define string-or-symbol? (any-pred string? symbol?))
(string-or-symbol? "abc") @result{} #t
(string-or-symbol? 'abc)  @result{} #t
(string-or-symbol? 3)     @result{} #f

(define <> (any-pred < >))
(<> 3 4) @result{} #t
(<> 3 3) @result{} #f

((any-pred (cut memq <> '(a b c))
           (cut memq <> '(1 2 3)))
 'b)  @result{} '(b c)
@end example
@end defun

@defun every-pred pred @dots{}
Returns a procedure which applies given argument(s) to
each predicate @var{pred}.  If every @var{pred} returns
a non-@code{#f} value, the value returned by the last @var{pred}
is returned.  If any @var{pred} returns @code{#f}, @code{every-pred}
returns @code{#f} without calling further @var{pred}s.

@example
((every-pred odd? positive?) 3)  @result{} #t
((every-pred odd? positive?) 4)  @result{} #f
((every-pred odd? positive?) -3) @result{} #f

(define safe-length (every-pred list? length))
(safe-length '(a b c))  @result{} 3
(safe-length "aaa")     @result{} #f
@end example
@end defun

@node Optional argument parsing, Procedure arity, Combinators, Procedures
@subsubsection Optional argument parsing
@c NODE 省略可能引数のパージング

To have optional arguments or keyword arguments in Scheme,
you have to take variable arguments as a list and decompose
them by yourself.   The following macros help it.

@defmac let-optionals* restargs (var-spec @dots{}) body @dots{}
@defmacx let-optionals* restargs (var-spec @dots{} . restvar) body @dots{}
Given a list of values @var{restargs}, binds variables accodring
to @var{var-spec}, then evaluates @var{body}.

@var{Var-spec} can be either a symbol, or a list of two elements
and its car is a symbol.  The symbol is the bound variable name.
The values in @var{restargs} are bound to the symbol in order.
If there are not as many values in @var{restargs} as @var{var-spec},
the rest of @var{symbol}s are bound to the default values, determined
as follows: If @var{var-spec} is just a symbol, the default value is
undefined.  If @var{var-spec} is a list, the default value is
the result of evaluation of the second element of the list.
In the latter case the second
element is only evaluated when there are not enough arguments.
The binding proceeds in the order of @var{var-spec}, so the second
element may refer to the bindings of previous @var{var-spec}.

In the second form, @var{restvar} must be a symbol and bound to
the list of values whatever left from @var{restargs} after binding
to @var{var-spec}.

It is not an error if @var{restarg} has more values than @var{var-spec}s.
The extra values are simply ignored in the first form.

@example
(define (proc x . args)
  (let-optionals* args ((a 'a)
                        (b 'b)
                        (c 'c))
    (list x a b c)))

(proc 0)         @result{} (0 a b c)
(proc 0 1)       @result{} (0 1 b c)
(proc 0 1 2)     @result{} (0 1 2 c)
(proc 0 1 2 3)   @result{} (0 1 2 3)

(define (proc2 . args)
  (let-optionals* args ((a 'a) . b)
    (list a b)))

(proc2)          @result{} (a ())
(proc2 0)        @result{} (0 ())
(proc2 0 1)      @result{} (0 (1))
(proc2 0 1 2)    @result{} (0 (1 2))

(define (proc3 . args)
  (let-optionals* args ((a 0)
                        (b (+ a 1))
                        (c (+ b 1)))
    (list a b c)))

(proc3)          @result{} (0 1 2)
(proc3 8)        @result{} (8 9 10)
(proc3 8 2)      @result{} (8 2 3)
(proc3 8 2 -1)   @result{} (8 2 -1)
@end example
@end defmac

@defmac get-optional restargs default
This is a short version of @var{let-optionals*} where you have only
one optional argument.  Given the optional argument list @var{restargs},
this macro returns the value of optional argument if one is given,
or the result of @var{default} otherwise.  @var{Default} is not
evaluated unless @var{restargs} is an empty list.

@example
(define (proc x . maybe-opt)
  (let ((option (get-optional maybe-opt #f)))
    (list x option)))

(proc 0)         @result{} (0 #f)
(proc 0 1)       @result{} (0 1)
@end example
@end defmac

@defmac let-keywords* restarg (var-spec @dots{}) body @dots{}
This macro is for keyword arguments.  @var{Var-spec} can be
one of the following forms:

@table @code
@item (@var{symbol} @var{expr})
If the @var{restrag} contains keyword which has the same name as @var{symbol},
binds @var{symbol} to the corresponding value.  If such a keyword doesn't
appear in @var{restarg}, binds @var{symbol} to the result of @var{expr}.
@item (@var{symbol} @var{keyword} @var{expr})
If the @var{restrag} contains keyword @var{keyword},
binds @var{symbol} to the corresponding value.  If such a keyword doesn't
appear in @var{restarg}, binds @var{symbol} to the result of @var{expr}.
@end table

The default value @var{expr} is only evaluated when the keyword is
not given to the @var{restarg}.  The binding is done in the order
of @var{var-spec}, so the @var{expr} can refer to the variables bound
by preceding @var{var-spec}.

If a keyword that doesn't listed in @var{var-spec} appears in @var{restarg},
it is simply ignored.

@example
(define (proc x . options)
  (let-keywords* options ((a 'a)
                          (b :beta 'b)
                          (c 'c))
    (list x a b c)))

(proc 0)         @result{} (0 a b c)
(proc 0 :a 1)    @result{} (0 1 b c)
(proc 0 :beta 1) @result{} (0 a 1 c)
(proc 0 :beta 1 :c 3) @result{} (0 a 1 3)
@end example
@end defmac


@node Procedure arity,  , Optional argument parsing, Procedures
@subsubsection Procedure arity
@c NODE 手続きのアリティ

Interface to query procedure's arity.
The API is taken from MzScheme (PLT Scheme).

@defun arity @var{proc}
Given procedure @var{proc,}
returns an integer, an @emph{arity-at-least} object, or
a list of integer(s) and @emph{arity-at-least} objects.

An integer result indicates @var{proc} takes exactly that number
of arguments.  An @emph{arity-at-least} indicats @var{proc} takes
at least @code{(arity-at-least-value @emph{arity-at-least})}
arguments.   The list indicates there are multiple procedures
with different arities.

Since one can add methods to an existing procedure or generic function
at any moment in Gauche, the value returned by @code{arity} only
indicates the current state of the procedure.  It will change
if new method is added to the procedure/generic-function.

@example
(arity cons) @result{} 2
(arity list) @result{} #<arity-at-least 0>
(arity make) @result{} (#<arity-at-least 1>)
@end example
@end defun

@defun arity-at-least? @var{obj}
Returns true if @var{obj} is an arity-at-least object.
@end defun

@defun arity-at-least-value @var{arity-at-least}
Returns the number of required arguments the arity-at-least object
indicates.
@end defun

@defun procedure-arity-includes? @var{proc} @var{k}
If a procedure @var{proc} can take @var{k} arguments, returns @code{#t}.
Otherwise returns @code{#f}.
@end defun


@node Applicable objects, Continuation, Procedures, Control features
@subsection Applicable objects
@c NODE 適用可能なオブジェクト

@c EN
Gauche has a special hook to make an arbitrary object @emph{applicable}.
@c JP
Gaucheでは、特別な組み込みの機構によって任意のオブジェクトを
「適用可能」にすることができます。
@c COMMON

@deffn {Generic Function} object-apply @var{object} @var{arg} @dots{}
@c EN
If an object that is neither a procedure nor a generic function
is applied to some arguments, 
the object and the arguments are passed to a generic function
@code{object-apply}.

This can be explained better by examples.
@c JP
手続きでもジェネリックファンクションでもないオブジェクトが何らかの引数に
適用されたとき、そのオブジェクトと引数がジェネリックファンクション@code{object-apply}
に渡されます。

この機能は、具体的な例を挙げた方が説明し易いでしょう。
@c COMMON
@end deffn

@c EN
For example, suppose you try to evaluate the
following expression:
@c JP
例えば、次のような式を評価しようとしたとします。
@c COMMON

@example
("abcde" 2)
@end example

@c EN
The operator evaluates to a string, which is neither a procedure
nor a generic fuction.  So Gauche interpretes the expression
as if it were like this:
@c JP
オペレータは文字列に評価されますから、手続きでもジェネリックファンクションでも
ありません。そこで、Gaucheはこの式を、あたかも次のような式が与えられた
かのように解釈します。
@c COMMON

@example
(object-apply "abcde" 2)
@end example

@c EN
Gauche doesn't define a method of @code{object-apply} that takes
@code{<string>} and @code{<integer>} by default, so this signals an error.
However, if you define such a method:
@c JP
デフォルトでは、@code{<string>}と@code{<integer>}を引数とする
@code{object-apply}のメソッドは定義されていないので、
この式はエラーになります。しかし、次のようなメソッドを定義すると：
@c COMMON

@example
(define-method object-apply ((s <string>) (i <integer>))
  (string-ref s i))
@end example

@c EN
Then the first expression works as if a string is @emph{applied} on
the integer:
@c JP
最初の式はまるで文字列が整数に適用されたかのように動作します。
@c COMMON

@example
("abcde" 2) @result{} #\c
@end example

@c EN
This mechanism works on almost all occasions where a procedure is allowed.
@c JP
このメカニズムは手続きが許されるほとんどの箇所で使うことができます。
@c COMMON

@example
(apply "abcde" '(1))   @result{} (#\b)
(map "abcde" '(3 2 1)) @result{} (#\d #\c #\b)
@end example

@c EN
Among Gauche built-in objects, @code{<regexp>} object and
@code{<regmatch>} object have @code{object-apply} defined.
@xref{Regular expression}.
@c JP
Gauche組み込みオブジェクトのうち、@code{<regexp>}オブジェクトと
@code{<regmatch>}オブジェクトに対しては@code{object-apply}メソッドが定義されて
います。@ref{Regular expression}を参照して下さい。
@c COMMON

@deffn {Generic Function} {(setter object-apply)} @var{object} @var{arg} @dots{} @var{value}
@c EN
If a form of applying an applicable object appears in the first position
of @code{set!} form, this method is called, that is:
@c JP
適用可能オブジェクトを適用するフォームが@code{set!}フォームの第一ポジションに
現れた場合、そのフォームは下に示すように展開され、このメソッドが呼ばれます。
@c COMMON
@example
(set! (@var{object} @var{arg} @dots{}) @var{value})
 @result{} ((setter object-apply) @var{object} @var{arg} @dots{} @var{value})
@end example
@end deffn




@node Continuation, Multiple values, Applicable objects, Control features
@subsection Continuation
@c NODE 継続


@defun call-with-current-continuation proc
@defunx call/cc proc
[R5RS]
@c EN
Encapsulates the current continuation to a procedure
(``continuation procedure''), and calls @var{proc} with it.
When @var{proc} returns, its value becomes @code{call/cc}'s value.
When the continuation procedure is invoked with zero or more arguments
somewhere, the further calculation is abandoned and @code{call/cc} returns
with the arguments given to the continuation procedure.

First class continuation is one of the most distinct feature of Scheme, but
this margin is too small to contain explanation.
Please consult to the appropriate documents.
@c JP
現在の継続を手続き (継続手続き) にパッケージ化して、それを引数として
@var{proc}を呼び出します。@var{proc}が戻ったら、その返り値が@code{call/cc}の
値となります。作成された継続手続きがどこかで0個または複数個の引数を伴って呼ばれたら、
あたかも@code{call/cc}から戻ったかのように実行が継続されます。その場合、
@code{call/cc}は、継続手続きに与えられた引数を複数の値として返します。

ファーストクラスの継続はSchemeの最も特徴的な機能のひとつですが、それを
十分に説明するにはこの本の余白は狭すぎます。適切なドキュメントを参照してください。
@c COMMON

@c EN
Gauche supports full continuation, with a few limitations in rare
cases.   Normally a continuation has an unlimited extent.  However,
if a continuation is created during ``callback'' from C code---
that is, you call some C-implemented function that calls Scheme
code again---the continuation's extent is limited until the Scheme
evaluation returns to the C code.   If you try to invoke the continuation
from out of its extent, Gauche detects it and signals an error.
This is a fundamental limitation and not likely to be addressed.
@c JP
Gaucheはわずかの例外を除いて、完全な継続をサポートしています。つまり継続は通常
無制限のエクステントを持ちます。しかし、継続がCコードからの「コールバック」
---SchemeがCで書かれたコードを呼び出し、それが再びSchemeコードを呼び出した場合---
で作られたら、その継続のエクステントはコールバックが呼び出したCコードに戻るまでと
なります。エクステントの切れた継続を呼ぼうとするとGaucheはエラーを報告します。
これは根本的な制限であり、おそらく解決されないでしょう。
@c COMMON

@c EN
Note that it is still allowed to invoke a continuation from
such callbacks.
Also, the typical higher-order functions such as @code{map}, @code{for-each}
or @code{apply} are not using callbacks, and not affected by this limitation
@c JP
なお、コールバックコードから有効な継続を呼ぶことは常に可能です。また、
高階関数を使う@code{map}や@code{for-each}、@code{apply}といった手続きは
Cからのコールバックを使っておらず、この制限の影響を受けません。
@c COMMON

@c EN
Fortunately, there are not much cases that you need to create an
unlimited extent continuation in such callbacks.
So far, the following code is executed in such callbacks.  Besides them,
typical callback functions from external C libraries, like GUI toolkit,
obeys the same limitation.
@itemize @bullet
@item
A @code{write-object} method that is invoked from @code{write},
@code{display} or @code{format} (@xref{Output}).
@item
A comparison function invoked from @code{sort} (@xref{Comparison and sorting}).
@item
A filler and a flusher callbacks of buffered ports
(@xref{Procedural ports}).
@end itemize
@c JP
おそらく、そのようなコールバック内で無制限のエクステントを持つ継続を作る必要というのは
あまり無いでしょう。Gauche組み込みの機能では、以下のようなコードがCからのコールバックで
呼び出されます。さらに、外部のCライブラリを使った場合、例えばGUIツールキットからの
コールバックなどはこの制限を受けるでしょう。
@itemize @bullet
@item
@code{write}、@code{display}、@code{format}から呼び出される
@code{write-object}メソッド (@ref{Output}参照)。
@item
@code{sort}から呼び出される比較クロージャ (@ref{Comparison and sorting}参照)。
@item
バッファードポートから呼び出されるfillerとflusher手続き。
(@ref{Procedural ports}参照)。
@end itemize
@c COMMON

@example
(define *oob-cont* #f)

(call/cc (lambda (valid-cont)
           (sort '(1 2 3 4 5 6)
                 (lambda (a b)
                   (call/cc (lambda (oob-cont)
                              (set! *oob-cont* oob-cont)))
                   (valid-cont 'ok)))))
 @result{} ok  ;@r{callback can call a continuation}

(*oob-cont* 'not-ok)
 @result{} ;@r{error -- *oob-cont* is out of its extent}.
@end example
@end defun

@defun dynamic-wind before thunk after
[R5RS]
@c EN
@var{Before}, @var{thunk} and @var{after} are all procedures with
no arguments.
In normal situation, @code{dynamic-wind} calls @var{before}, then @var{thunk},
then @var{after}, then returns whatever value(s) @var{thunk} returned.

If a control flow goes out from @var{thunk} by invoking a continuation
captured outside of the dynamic scope of @code{dynamic-wind}
(for example, an error is signalled in @var{thunk}),
@var{after} is called.  

If a control flow goes into @var{thunk} by invoking a continuation
captured inside @var{thunk} from outside of the dynamic
scope of @code{dynamic-wind}, @var{before} is called.
@c JP
@var{before}、@var{thunk}および@var{after} は引数を取らない手続きです。
@code{dynamic-wind}はまず@var{before}を呼び出し、続いて@var{thunk}を呼び出し、
続いて@var{after}を呼び出します。そして@var{thunk}が返した値を返します。

もし@code{dynamic-wind}のダイナミックスコープの外で捕捉された継続が
@var{thunk}の中で呼ばれることにより制御が@var{thunk}から飛び出した場合、
(@var{thunk}の中でエラーが起こった場合などが考えられます)、
@var{after}が呼ばれます。

もし、@var{thunk}の中で捕捉された継続が@var{dynamic-wind}のダイナミックスコープの
外で呼ばれることにより制御が@var{thunk}の中へ飛び込んだ場合、
@var{before}が呼ばれます。
@c COMMON
@example
(letrec ((paths '())
         (c #f)
         (add (lambda (s) (push! paths s))))
  (dynamic-wind
   (lambda () (add 'connect))
   (lambda ()
     (add (call/cc (lambda (c0) (set! c c0) 'talk1))))
   (lambda () (add 'disconnect)))
  (if (< (length paths) 4)
      (c 'talk2)
      (reverse paths)))
 @result{} (connect talk1 disconnect connect talk2 disconnect)
@end example
@end defun

@node Multiple values, Delayed Evaludation, Continuation, Control features
@subsection Multiple values
@c NODE 多値

@defun values obj @dots{}
[R5RS]
@c EN
Returns @var{obj} @dots{} as multiple values.
Caller can capture multiple values by a built-in syntax
@code{receive} (@ref{Binding constructs}), or the R5Rs procedure
@code{call-with-values} described below.
See also @ref{srfi-11 - Let-values}.
@c JP
@var{obj} @dots{} を多値として返します。
呼び出し側は、組み込み構文の @code{receive} (@ref{Binding constructs}参照)か、
下に説明するR5RSの手続き@code{call-with-values}を使って多値を受け取ることが
できます。
@ref{srfi-11 - Let-values}も参照してください。
@c COMMON
@example
(values 1 2) @result{} 1 @r{and} 2
@end example
@end defun

@defun call-with-values producer consumer
[R5RS]
@c EN
Call a procedure @var{producer} with no argument.
Then applies a procedure @var{consumer} on the
value(s) @var{producer} returned.  Returns the value(s) @var{consumer}
returns.
@c JP
手続き@var{producer}を引数無しで呼びます。そして、それが返した値
を引数として@var{consumer}を呼びます。@var{consumer}が返す値を
返します。
@c COMMON
@example
(call-with-values (lambda () (values 1 2)) cons)
  @result{} (1 . 2)
@end example
@end defun

@node Delayed Evaludation,  , Multiple values, Control features
@subsection  Delayed Evaludation
@c NODE 遅延評価

@defspec delay expression
[R5RS]
@end defspec

@defun force promise
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Exceptions, Eval and repl, Control features, Core library
@section Exceptions
@c NODE 例外

In Gauche, error singnaling mechanism is implemented in multiple
layers.   The lower layer provides very simple mechanism with which
the user can implement various semantics.  The higher layer provides
a way to handle common patterns like error handling in a simple way.

@menu
* Signalling errors::           
* Handling errors::             
* Exception object::            
* Low-level exception mechanism::  
@end menu

@node Signalling errors, Handling errors, Exceptions, Exceptions
@subsection Signalling errors
@c NODE エラーの通知

@defun error string arg @dots{}
[SRFI-23] Signals an error.   Internally the action is realized
by those two steps.
@enumerate
@item
An error exception is created, with the message prefixed
by @var{string} and followed by @var{arg}s.
@item
The error exception is thrown, which may be handled by the
current active error handler, if any.
@end enumerate

If no error handler is active, the default error handler is
used, which prints the error message to the current error port
and some debug information.   Then, if Gauche is running
interactively, the control moves to the toplevel; if Gauche
is running as a script, it exits with the exit status @code{EX_SOFTWARE}
(70).
@end defun

@defun errorf fmt-string arg @dots{}
Similar to an error, but the error message is formatted by
@code{format}, i.e. it is equivalent to:
@example
(define (errorf fmt . args)
  (error (apply format #f fmt args)))
@end example
@end defun

@node Handling errors, Exception object, Signalling errors, Exceptions
@subsection Handling errors
@c NODE エラーの処理

@defun with-error-handler handler thunk
Makes @var{handler} the active error handler and executes @var{thunk}.
If @var{thunk} returns normally, the result(s) will be returned.
If an error is signalled during execution of @var{thunk},
@var{handler} is called with one argument, an exception object
representing the error, with the continuation of @code{with-error-handler}.
That is, @code{with-error-handler} returns whatever value(s) @var{handler}
returns.

If @var{handler} signals an error, it will be handled by the
handler installed when @code{with-error-handler} called.

The dynamic environment where @var{handler} is executed is
the same as the error occurs.  If @code{dynamic-wind} is used
in @var{thunk}, its @var{after} method is called after @var{handler}
has returned, and before @code{with-error-handler} returns.

The behavior of @code{with-error-handler} can be
described in the form of Scheme code shown below,
using the low-level mechanism (@xref{Low-level exception mechanism}).
Note that the actual function is built in VM, using lighter
mechanisms (similar to "one-shot continuation", @ref{onecont, [1CC], 1CC}).

@example
;; @r{conceptual implementation of with-error-handler}
(define (with-error-handler handler thunk)
  (call/cc
    (lambda (cont)
      (let* ((prev-handler (current-exception-handler))
        (with-exception-handler
          (lambda (exn)
            (if (error? exn)
                (with-exception-handler
                  (lambda (err) (prev-handler err))
                  (lambda () (call-with-values (handler exn) cont)))
                (prev-handler exn)))
          thunk))))))
@end example
@end defun

@node Exception object, Low-level exception mechanism, Handling errors, Exceptions
@subsection Exception object
@c NODE 例外オブジェクト

@deftp {Class} <exception>
@clindex exception
Represents An exception.
The complete exception class hierarchy is under construction.
Right now, only the following information is available.

@defivar {<exception>} message
For an error exception, this is the error message.
@end defivar
@end deftp

@node Low-level exception mechanism,  , Exception object, Exceptions
@subsection Low-level exception mechanism

This layer provides SRFI-18 compatible simple exception mechanism.
You can override the behavior of higher-level constructs such as
@code{with-error-handler} by using @code{with-exception-handler}.

Note that it is a double-edged sword.  You'll get a freedom to
construct your own exception handling semantics, but the Gauche
system won't save if something goes wrong.   Use these primitives
when you want to customize the system's higher-level semantics
or you are porting from other SRFI-18 code.

@defun current-exception-handler
[SRFI-18]
Returns the current exception handler.
@end defun

@defun raise exception
[SRFI-18] 
Invokes the current exception handler with one argument, @var{exception}.
@var{exception} can be any Scheme object; it doesn't need to be
an instance of @code{<exception>} class.
Combined with @code{with-exception-handler} you can give your own
semantics to the @var{exception}.
@code{raise} returns whatever the handler returns.
@end defun

@defun with-exception-handler handler thunk
[SRFI-18]
A procedure @var{handler} must take one argument.  This procedure
sets @var{handler} to the current exception handler and calls
@var{thunk}.
@end defun

Generally, if you want to handle non-continuable exception such as
errors using this low-level mechanism,
you have to transfer the control from the handler explicitly
(See the explanation of @code{with-error-handler} above).
@code{raise} detects if the handler returns on the
non-continuable exceptions and reports an error using the
default error handler mechanism, but it is just a safety net.

Note also that @var{handler} is called in the same dynamic environment
of @code{raise}.  So if you raise an exception inside @var{handler},
it is captured by @var{handler} again.   It is the programmer's
responsibility to propagate the exception handling to the ``outer''
exception handlers.

The behavior of those procedures can be explained in
the following conceptual Scheme code.

@example
;; @r{Conceptual implementation of low-level exception mechanism.}
;; @r{Suppose %xh is a list of exception handlers}

(define (current-exception-handler) (car %xh))

(define (raise exn)
  (receive r ((car %xh) exn)
    (when (uncontinuable-exception? exn)
      (set! %xh (cdr %xh))
      (raise (@r{@i{make-error}} "returned from uncontinuable exception")))
    (apply values r)))

(define (with-exception-handler handler thunk)
  (let ((prev %xh))
    (dynamic-wind
      (lambda () (set! %xh (cons handler)))
      thunk
      (lambda () (set! %xh prev)))))
@end example

@c ----------------------------------------------------------------------
@node Eval and repl, Input and output, Exceptions, Core library
@section Eval and repl

@defun eval expr env
[R5RS]
Evaluate @var{expr}.   @var{env} must be a value returned by
the following procedures below.  Right now it is just a
@code{<module>} object, but it is possible that the Gauche
adopts a first-class environment object in future.
@end defun

@defun null-environment version
@defunx scheme-report-environment version
@defunx interaction-environment
[R5RS]
Returns an environment specifier which can be used as the second
argument of @code{eval}.   Right now an environment specifier
is just a module.  @code{(null-environment 5)} returns
a @code{null} module, which contains just the syntactic bindings
specified in R5RS, @code{(scheme-report-environment 5)}
returns a @code{scheme} module, which contains syntactic and procedure
bindings in R5RS, and @code{(interaction-environment)} returns
a @code{user} module that contains all the Gauche built-ins plus
whatever the user defined.
It is possible that the Gauche adopts a first-class environment object
in future, so do not rely on the fact that the environment specifier
is just a module.

An error is signaled if a value other than 5 is passed as @var{version}
argument.

There's one difference from R5RS in @code{null-environment} and
@code{scheme-report-environment}; they contain @code{with-module}
special form.   It is necessary to define R5RS procedure using
Gauche built-ins for now.  It'll be removed as soon as I find
a better way.
@end defun

@defun read-eval-print-loop &optional reader evaluator printer prompter
This exports @code{Gosh}'s default read-eval-print loop to applications.
Each argument can be @code{#f}, which indicates it to use Gauche's
default procedure(s), or a procedure that satisfies the
following conditions.

@table @emph
@item reader
A procedure that takes no arguments.  It is supposed to read an expression
and returns it.
@item evaluator
A procedure that takes two arguments, an expression and an environment
specifier.  It is supposed to evaluate the expression and returns zero or
more value(s).
@item printer
A procedure that takes zero or more arguments.   It is supposed to
print out these values.   The result of this procedure is discarded.
@item prompter
A procedure that takes no arguments.  It is supposed to print
out the prompt.   The result of this procedure is discarded.
@end table

Given those procedures, @code{read-eval-print-loop} runs as follows:

@enumerate
@item
Prints the prompt by calling @var{prompter}.
@item
Reads an expression by calling @var{reader}.  If it returns EOF,
exits the loop and returns from @code{read-eval-print-loop}.
@item
Evaluates an expression by calling @var{evaluator}
@item
Prints the result by calling @var{printer}, then repeats from 1.
@end enumerate

When an error is signaled from one of those procedures, it is
captured and reported by the default escape handler, then
the loop restarts from 1.

It is OK to capture a continuation within those procedures
and re-invoke them afterwards.
@end defun

@c ----------------------------------------------------------------------
@node Input and output, Loading Programs, Eval and repl, Core library
@section Input and Output
@c NODE 入出力

@menu
* Ports::                       
* Port and threads::            
* Common port operations::      
* File ports::                  
* String ports::                
* Procedural ports::            
* Input::                       
* Output::                      
@end menu

@node Ports, Port and threads, Input and output, Input and output
@subsection Ports
@c NODE ポート

@deftp {Builtin Class} <port>
@clindex port
@c EN
A port class.   A port is Scheme's way of abstraction of I/O channel.
Gauche extends a port in number of ways so that it can be used
in wide range of applications.
@c JP
Portは、Schemeにおいて抽象化された入出力のインタフェースを提供します。
Gaucheはportにいくつかの拡張を行い、いろいろなアプリケーションに対応できるようにしました。
@c COMMON

@c EN
Standard Scheme (R5RS) essentially defines a port as an entity that
you can fetch a character at a time and
look one character ahead from an input port, 
and put a character at a time to an output port.
Other R5RS I/O routines can be built on top of them.
@c JP
標準のSchemeでは、portはキャラクタを一文字づつ読み込む(一文字先読み可)、
もしくは書き出すだけのもので、他の入出力ルーチンはその上に構築されています。
@c COMMON

@c EN
Besides this basics, Gauche's port can handle the following
opertaions.
@c JP
Gaucheではさらに次のような操作がportに対して可能になっています。
@c COMMON

@table @asis
@c EN
@item Byte I/O
You can read/write one byte at a time, instead of a character.
(Remember, Gauche handles multibyte characters, so a character
may be consisted from more than one bytes).
Most ports allow you to mix byte I/O and character I/O, if needed.
@c JP
@item バイトI/O
キャラクタ毎でなく、バイト毎のI/Oが可能です(Gaucheではマルチバイト文字を
扱うので、この２つが異なることに注意して下さい)。大抵のポートでは
キャラクタI/OとバイトI/Oを混ぜて使うことができます。
@c COMMON

@c EN
@item Block I/O
You can read/write a specified number of byte sequences.
This can be an efficient way of moving block of data,
if the port's underlying implementation supports block I/O
operation (for example, if the underyling port is a unix buffered
stream, this operation uses @code{fread} or @code{fwrite}).
@c JP
@item ブロックI/O
ポートから指定した数のバイト列を読んだり、ポートへ書いたりできます。
ポートがブロックI/Oを行うデバイスに接続されている場合、ある程度大きなブロック毎に
読み書きすると効率の良いデータ転送ができます。
@c COMMON

@c EN
@item Conversion
Some ports can be used to convert a data stream from one format
to another; one of such applications is character code conversion
ports, provided by @code{gauche.charconv} module
(@xref{gauche.charconv - Character code conversion}, for details).
You can define a procedural ports, in both Scheme and C, 
to implement other functionality.
@c JP
@item 変換
ポートはまた、データストリームを変換するのにも使えます。例えば@code{gauche.charconv}
モジュールでは、文字コード間の変換を行うポートを提供しています
(詳しくは@ref{gauche.charconv - Character code conversion}を参照)。
プロシージャルなポートを定義することにより、様々な機能を実装できます。
@c COMMON
@end table

@end deftp

@node Port and threads, Common port operations, Ports, Input and output
@subsection Port and threads
@c NODE ポートとスレッド

@c EN
When Gauche is compiled with thread support, 
the builtin port operations locks the port, so that port access
from multiple threads will be serialized.   
(It is required by SRFI-18, BTW).
Here, "builtin port opertaions" are the port access functions
that takes a port and does some I/O or query on it,
such as @code{read}/@code{write}, @code{read-char}/@code{write-char}, 
@code{port->string}, etc.
Note that @code{call-with-*} and @code{with-*} procedures do not
lock the port during calling the given procedures, since the
procedure may pass the reference of the port to the other thread,
and Gauche wouldn't know if that's the case.
@c JP
GaucheがスレッドサポートをONにしてコンパイルされている場合、
組み込みのポート操作関数はポートをロックして、
複数のスレッドからの同一のポートへのアクセスがポートの内部状態を壊さないように
しています。
(SRFI-18によって要求されている動作です)。
ここで「組み込みのポート操作関数」はGaucheにより提供される、
ポートを引数に取り何らかのI/O動作や問い合わせを行う手続きで、
@code{read}/@code{write}、@code{read-char}/@code{write-char}、
@code{port->string}等を含みます。
但し、@code{call-with-*}や@code{with-*}系関数は、
与えられた手続きを呼ぶ際にはポートをロックしません。
その手続きが別のスレッドにポートを渡すかもしれず、Gaucheにはそれを知ることが
できないからです。
@c COMMON

@c EN
This means usually you don't need to worry about accessing the
ports under multithreaded environment, but also it costs some
overhead for each port access.  The overhead may be a problem
if your program is I/O intensive and does a lot of fine-grained
port access (character-wise or byte-wise).
If that is the case, you can explicitly lock the port during
the processing by the following procedure:
@c JP
このことはつまり、マルチスレッド環境でポートへのアクセス競合にそれほど
気を使わなくても良いということですが、同時にポートアクセスの度に
いくぶんかのオーバヘッドがあることを意味します。I/Oを多く行うプログラムで、
しかもその粒度が細かい場合(文字ごととかバイトごととか)、このオーバヘッドが
問題になるかもしれません。
その場合、次の手続きを使って処理中にポートを明示的にロックすることができます。
@c COMMON

@defun with-port-locking port thunk
@c EN
Executes @var{thunk}, while making the calling thread
hold the exclusive lock of @var{port} during the dynamic extent
of @var{thunk}.

Calls of the builtin port functions during the lock is held
would bypass mutex operations and yield better performance.

Note that the lock is held during the dynamic extent of @var{thunk};
so, if @var{thunk} invokes a continuation captured outside of
@code{with-port-locking}, the lock is released.  If the continuation
captured within @var{thunk} is invoked afterwards, the lock is re-acquired.

@code{With-port-locking} may be nested.  The lock is valid during
the outermost call of @code{with-port-locking}.
@c JP
@var{port}をロックし、@var{thunk}を実行します。
ロックは@var{thunk}のダイナミックエクステントの期間有効です。

@var{port}がロックされている期間での組み込みのポートアクセス関数の
呼び出しは排他制御をバイパスするため、性能向上が見込まれます。

ロックの有効期間は@var{thunk}のダイナミックエクステントなので、
@var{thunk}内から@code{with-port-locking}の外で捕捉された
継続を呼んだ場合、ロックは解放されます。その後、@var{thunk}内で
捕捉された継続が呼ばれた場合、再びロックが獲得されます。

@code{with-port-locking}はネスト可能です。ロックは最も外側の
@code{with-port-locking}の期間中有効となります。
@c COMMON
@end defun

@node Common port operations, File ports, Port and threads, Input and output
@subsection Common port operations
@c NODE ポート共通の操作

@defun port? obj
@defunx input-port? obj
@defunx output-port? obj
[R5RS]
@c EN
Returns true if @var{obj} is a port, an input port and an output port,
respectively.  @code{Port?} is not listed in the
R5RS standard procedures, but mentioned in the "Disjointness of Types"
section.
@c JP
@var{obj} がそれぞれポート、入力ポート、出力ポートなら真を返します。
@code{port?}はR5RSの"Standard Procedures"の項には
載っていませんが、"Disjointness of Types"の項に挙げられています。
@c COMMON
@end defun

@defun port-closed? port
@c EN
Returns true if @var{obj} is a port and it is already closed.
A closed port can't be reopened.
@c JP
@var{obj}がポートであり、既に閉じられていた場合に真を返します。
一度閉じたポートは再び開くことはできません。
@c COMMON
@end defun

@defun current-input-port
@defunx current-output-port
[R5RS]
@c EN
Returns the current input port and the current output port, respectively.
@c JP
現在の入力ポートと出力ポートをそれぞれ返します。
@c COMMON
@end defun

@defun current-error-port
@c EN
Returns the current output port.
@c JP
現在のエラーポートを返します。
@c COMMON
@end defun

@defun standard-input-port
@defunx standard-output-port
@defunx standard-error-port
@c EN
Returns ports that are bound initially to current input, output and
error port, respectively.
@c JP
プログラム開始時点の入力、出力、エラーポートをそれぞれ返します。
@c COMMON
@end defun

@defun with-input-from-port port thunk
@defunx with-output-to-port port thunk
@defunx with-error-to-port port thunk
@c EN
Calls @var{thunk}.  During evaluation of thunk, the current input port, current
output port and current error port are set to @var{port}, respectively.
@c JP
それぞれ入力、出力、エラーポートは@var{port}にセットした状態で@var{thunk}を呼び出します。
@c COMMON
@end defun

@defun close-input-port port
@defunx close-output-port port
[R5RS]
@c EN
Closes input and output @var{port}, respectively
@c JP
それぞれ、入力ポートと出力ポートを閉じます。
@c COMMON
@end defun

@defun port-type port
@c EN
Returns the type of @var{port} in one of the symbols @code{file}, 
@code{string} or @code{proc}.
@c JP
@var{port}のタイプを、シンボル@code{file}、@code{string}、@code{proc}の
いずれかで返します。
@c COMMON
@end defun

@defun port-name port
@c EN
Returns the name of @var{port}.  If the port is associated to a file,
it is the name of the file.   Otherwise, it is some description of the port.
@c JP
@var{port}の名前を返します。ポートがファイルに関連付けられている場合は、ポートの名前は
ファイル名です。そうでない場合、ポートを説明する文字列が返されます。
@c COMMON
@end defun

@defun port-buffering port
@defunx {(setter port-buffering)} port buffering-mode
@c EN
If @var{port} is type of file port (i.e. @code{(port-type @var{port})}
returns @code{file}), these procedures gets and sets the port's
buffering mode.  For input ports, the port buffering mode may be
either one of @code{:full}, @code{:modest} or @code{:none}.
For output ports, @code{port-buffering}, it may be
one of @code{:full}, @code{:line} or @code{:none}.
@xref{File ports}, for explanation of those modes.

If @code{port-buffering} is applied to ports other than file ports,
it returns @code{#f}.  If the setter of port-buffering is
applied to ports other than file ports, it signals an error.
@c JP
ファイルポート(@code{(port-type @var{port})}が@code{file}を返すもの)
に対して、そのバッファリングモードを読みだし、もしくは変更します。
入力ポートではバッファリングモードは
@code{:full}、 @code{:modest}、@code{:none}のいずれかです。
出力ポートでは
@code{:full}、 @code{:line}、@code{:none}のいずれかです。
バッファリングモードの詳細な説明は、@ref{File ports} を参照してください。

@code{port-buffering}がファイルポート以外のポートに対して呼ばれた場合は
@code{#f}を返します。@code{port-buffering}のsetterが
ファイルポート以外のポートに対して呼ばれた場合はエラーとなります。
@c COMMON
@end defun

@defun port-current-line port
@c EN
Returns the current line count of @var{port}.  This information is
only available on file-based port, and as long as you're doing
sequential character I/O on it.  Otherwise, this returns -1.
@c JP
@var{port}の現在の行番号を返します。行番号は、ファイルに関連付けられたポートで
かつシーケンシャルなキャラクタI/Oを行っている場合のみ有効です。それ以外の場合は
-1を返します。
@c COMMON
@end defun

@defun port-file-number port
@c EN
Returns an integer file descriptor, if the @var{port} is associated
to the system file I/O.  Returns @code{#f} otherwise.
@c JP
@var{port}がファイルに関連付けられている場合、そのファイルディスクリプタ番号を
返します。それ以外の場合は@code{#f}を返します。
@c COMMON
@end defun

@defun port-seek port offset &optional whence
@c EN
If the given @var{port} allows random access, this procedure sets
the read/write pointer of the @var{port} accodring to the given @var{offset}
and @var{whence}, then returns the updated offset (number of bytes
from the beginning of the data).  If @var{port} is not random-accessible,
@code{#f} is returned.  In the current version, file ports and
input string ports are fully random-accessible.  You can only query
the current byte offset of output string ports.
@c JP
@var{port}がランダムアクセス可能なポートの場合、
この手続きは@var{port}のread/writeポインタを@var{offset}と@var{whence}の値によって
設定し、新たなread/writeポインタの値(データの先頭からのバイトオフセット)を
返します。@var{port}がランダムアクセス可能でない場合は@code{#f}が返されます。
現在のバージョンでは、ファイルポートおよび入力文字列ポートがランダムアクセス可能です。
出力文字列ポートは現在のポインタの値を問い合わせる動作だけが可能です。
@c COMMON

@c EN
Note that port position is represented by byte count, not character count.
@c JP
ポートのポインタはバイト数で表現され、文字数とは異なることに注意して下さい。
@c COMMON

@c EN
It is allowed to seek after the data if @var{port} is an output
file port.  See POSIX lseek(2) document for details of the behavior.
For input file port and input string port, you can't seek after the data.
@c JP
@var{port}が出力ファイルポートの場合は、データの終端を超えた位置までseek
することが可能です。その場合の動作はPOSIXのlseek(2)に準じます。
入力ファイルポートや入力文字列ポートではデータの終端以降にseekすることはできません。
@c COMMON

@c EN
The @var{whence} argument must be a small integer that represents
from where @var{offset} should be counted.   The following constant
values are defined.
@c JP
@var{whence}引数は、@var{offset}の基準を指定する小さな整数です。
以下の定数が定義されています。
@c COMMON

@table @code
@item SEEK_SET
@c EN
@var{Offset} represents the byte count from the beginning of the data.
This is the default behavior when @var{whence} is omitted.
@c JP
@var{offset}はデータ先頭からのバイト数を指定します。
@var{whence}が省略された場合のデフォルトの動作です。
@c COMMON

@item SEEK_CUR
@c EN
@var{Offset} represents the byte count relative to the current read/write
pointer.  If you pass 0 to @var{offset}, you can get the current
port position without changing it.
@c JP
@var{offset}は現在のread/writeポインタからの相対バイト数を指定します。
@var{offset}が0であれば、ポインタを動かさずに現在のポート位置を知ることができます。
@c COMMON

@item SEEK_END
@c EN
@var{Offset} represents the byte count relative to the end of the data.
@c JP
@var{offset}はデータの終端からの相対バイト数を指定します。
@c COMMON
@end table
@end defun

@defun port-tell port
@c EN
Returns the current read/write pointer of @var{port} in byte count,
if @var{port} is random-accessible.   Returns @code{#f} otherwise.
This is equivalent to the following call:
@c JP
@var{port}の現在のread/writeポインタの値をバイト数で返します。
@var{port}がランダムアクセス可能でない場合は@code{#f}が返されます。
これは以下の呼び出しと等価です。
@c COMMON
@example
(port-seek @var{port} 0 SEEK_CUR)
@end example
@end defun

@c EN
@emph{Note on the names}:  @code{Port-seek} is called
@code{seek}, @code{file-position} or @code{input-port-position}/
@code{output-port-position} on some implementations.
@code{Port-tell} is called @code{tell}, @code{ftell} or
@code{set-file-position!}.   Some implementations have
@code{port-position} for different functionality.
CommonLisp has @code{file-position}, but it is not suitable
for us since @var{port} need not be a file port.  @code{Seek} and
@code{tell} reflects POSIX name, and with Gauche naming convention
we could use @code{sys-seek} and @code{sys-tell}; however, @var{port}
deals with higher level of abstraction than system calls, so I dropped
those names, and adopted new names.
@c JP
@emph{名前に関するメモ}: @code{port-seek}は他の処理系で
@code{seek}、@code{file-position}、@code{input-port-position}/
@code{output-port-position}等と呼ばれています。
@code{port-tell}は@code{tell}、@code{ftell}、@code{set-file-position!}等と
呼ばれています。いくつかの処理系は@code{port-position}という手続きを
持っていますが、@code{port-seek}とは別の機能を実現しています。
@code{file-position}はCommonLisp由来の名前ですが、
fileポート以外のものも扱うため採用しませんでした。
また、@code{seek}と@code{tell}はPOSIXの名前由来であり、
Gaucheの名前付け規則を使って@code{sys-seek}と@code{sys-tell}としても
よさそうですが、portの操作はシステムコールレベルよりも抽象度が高いため
これも採用しませんでした。結局、新しい名前を採用することにしました。
@c COMMON

@defun copy-port src dst &keyword (unit 0)
@c EN
Copies data from an input port @var{src} to an output port @var{dst},
until eof is read from @var{src}.
@c JP
@var{src}からEOFまでデータを読みだし、@var{dst}へ書き出します。
@c COMMON

@c EN
The keyword argument @var{unit} may be zero, a positive exact integer,
a symbol @code{byte} or a symbol @code{char}, to specify the unit
of copying.  If it is an integer, a buffer of the size
(in case of zero, a system default size) is used to copy,
using block I/O.  Generally it is the fastest if you copy
between normal files.   If @var{unit} is a symbol @code{byte},
the copying is done byte by byte, using C-verson of @code{read-byte}
and @code{write-byte}.  If @var{unit} is a symbol @code{char},
the copying is done character by character, using C-version of
@code{read-char} and @code{write-char}.
@c JP
キーワード引数@var{unit}は0以上の整数か、シンボル@code{byte}もしくは@code{char}
でなければなりません。これはデータをコピーする単位を指定します。
整数ならば、その大きさ(0の場合はシステム規定の大きさ)のバッファが確保され、
ブロックI/Oを使って転送が行われます。通常のファイルをコピーする場合などはこれが
速いでしょう。もし@var{unit}がシンボル@code{byte}であれば、バイト毎
に読みだし／書き込みが行われます。@var{unit}がシンボル@code{char}であれば、
キャラクタ毎に読みだし／書き込みが行われます。
@c COMMON
@end defun


@node File ports, String ports, Common port operations, Input and output
@subsection File ports
@c NODE ファイルポート

@defun open-input-file filename &keyword if-does-not-exist buffering element-type
@defunx open-output-file filename &keyword if-does-not-exist if-exists buffering element-type
[R5RS+]
@c EN
Opens a file @var{filename} for input or output, and
returns an input or output port associated with it, respectively.

The keyword arguments specify precise behavior on the exceptional case.
@c JP
ファイル@var{filename}を入力または出力用にオープンし、
入力ポートまたは出力ポートを作成して返します。

キーワード引数により、例外的な場合の動作を細かく指定できます。
@c COMMON

@table @code
@item :if-exists
@c EN
This keyword argument can be specified only for @code{open-output-file}, and
specifies the action when the @var{filename} already exists.
One of the following value can be given.
@c JP
このキーワード引数は@code{open-output-file}のみに指定でき、
@var{filename}が既に存在した場合の動作を指定します。次の値のいずれかを与えることができます。
@c COMMON
@table @code
@item :supersede
@c EN
The existing file is truncated.  This is the default behavior.
@c JP
既存のファイルが長さ0に縮められます。これが既定の動作です。
@c COMMON
@item :append
@c EN
The output data will be appended to the existing file.
@c JP
既存のファイルにこれから書き出す内容が追加されます。
@c COMMON
@item :overwrite
@c EN
The output data will overwrite the existing content.
If the output data is shorter than the existing file, the rest of
existing file remains.
@c JP
既存のファイルにこれから書き出す内容が上書きされます。
書き出されるデータが既存のファイルのデータよりも短い場合、
残りの部分はそのまま残されます。
@c COMMON
@item :error
@c EN
An error is signalled.
@c JP
エラーが報告されます。
@c COMMON
@item #f
@c EN
No action is taken, and the function returns @code{#f}.
@c JP
何もせず、@code{#f}を返します。
@c COMMON
@end table

@item :if-does-not-exist
@c EN
This keyword argument specifies the action when @var{filename} does not exist.
@c JP
このキーワード引数は@var{filename}が存在しない場合の動作を指定します。
@c COMMON
@table @code
@item :error
@c EN
An error is signalled.  This is the default behavior of
@code{open-input-file}.
@c JP
エラーを報告します。これが@code{open-input-file}の既定の動作です。
@c COMMON
@item :create
@c EN
A file is created.  This is the default behavior of @code{open-output-file}.
The check of file existence and creation is done atomically; you can
exclusively create the file by specifying @code{:error} or @code{#f} to
@var{if-exists}, along this option.
You can't specify this value for @code{open-input-file}.
@c JP
ファイルが作成されます。これが@code{open-output-file}の既定の動作です。
ファイルの存在のチェックと作成はアトミックに行われます。
このオプションに加え、@var{if-exists}オプションに@code{:error}か@code{#f}を
指定することで、排他的にファイルを作成することができます。
@code{open-input-file}に対してはこの値を指定することはできません。
@c COMMON
@item #f
@c EN
No action is taken, and the function returns @code{#f}.
@c JP
何もせず、@code{#f}を返します。
@c COMMON
@end table

@item :buffering
@c EN
This argument specifies the buffering mode.  The following values are
allowed.
The port's buffering mode can be get/set by @code{port-buffering}.
(@xref{Common port operations}).
@c JP
この引数はバッファリングモードを指定します。以下の値が設定できます。
ポートのバッファリングモードは手続き@code{port-buffering}
(@ref{Common port operations}参照)によって
読みだし/変更可能です。
@c COMMON
@table @code
@item :full
@c EN
Buffer the data as much as possible.  This is the default mode.
@c JP
出来る限りデータをバッファリングします。これがデフォルトのモードです。
@c COMMON
@item :none
@c EN
No buffering is done.  Every time the data is written (to an output port)
or read (from an input port), the underlying system call is used.
Process's standard error port is opened in this mode by default.
@c JP
バッファリングを行いません。出力ポートにデータが書き出されるか、
入力ポートからデータが読み込まれる度に、下位にあるシステムコールが呼ばれます。
プロセスの標準エラーポートはこのモードでオープンされています。
@c COMMON
@item :line
@c EN
This is valid only for output ports.  The written data is buffered, but
the buffer is flushed whenever a newline character is written.
This is suitable for interactive output port.  Process's standard
output port is opened in this mode by default.
(Note that this differs from the line buffering mode of C stdio, which
flushes the buffer as well when input is requested from the same file
descriptor.)
@c JP
このモードは出力ポートにのみ有効です。書き出されたデータはバッファに
貯められますが、改行文字が書かれたらフラッシュされます。
このモードは対話的な出力ポートなどに便利です。
プロセスの標準出力ポートはこのモードでオープンされています。
(これは、Cのstdioライブラリの「ラインバッファリング」とちょっと違うことに
注意してください。stdioでは同じファイルディスクリプタから入力が行われる時も
バッファはフラッシュされますが、Gaucheではそうはなりません)。
@c COMMON
@item :modest
@c EN
This is valid only for input ports.  This is almost the same as the mode
@code{:full}, except that @code{read-block} may return less data
than requested if the requested amount of data is not immediately available.
(In the @code{:full} mode, @code{read-block} waits the entire data to be
read).   This is suitable for the port connected to a pipe or network.
@c JP
このモードは入力ポートにのみ有効です。ほとんど@code{:full}バッファリングモードと
同じですが、@code{read-block}はポートに要求されたデータより少ないデータしか
無かった場合、要求された量がたまるまで待つのではなく、今あるデータだけを
返します。このモードはポートがパイプやネットワークに接続されている場合に
便利です。
@c COMMON
@end table

@item :element-type
@c EN
This argument specifies the type of the file.
@c JP
この引数はファイルのタイプを指定します。
@c COMMON
@table @code
@item :character
@c EN
The file is opened in "character" (or "text") mode.
@c JP
ファイルはキャラクタモード(テキストモード)でオープンされます。
@c COMMON
@item :binary
@c EN
The file is opened in "binary" mode.
@c JP
ファイルはバイナリモードでオープンされます。
@c COMMON
@end table
@c EN
@emph{In the current version, this argument is ignored and all files
are opened in binary mode.  It doesn't make difference in the Unix platforms.}
@c JP
@emph{現在のバージョンでは、この引数は無視され、全てのファイルはバイナリモードで
オープンされます。いずれにせよUnixプラットフォームでは違いはありません。}
@c COMMON
@end table

@c EN
By combination of @var{if-exists} and @var{if-does-not-exist} flags,
you can implement various actions:
@example
(open-output-file "foo" :if-exists :error)
 @result{} ;@r{opens "foo" exclusively, or error}

(open-output-file "foo" :if-exists #f)
 @result{} ;@r{opens "foo" exclusively, or returns} #f

(open-output-file "foo" :if-exists :append
                        :if-does-not-exist :error)
 @result{} ;@r{opens "foo" for append only if it already exists}
@end example
@c JP
@var{if-exists}と@var{if-does-not-exist}フラグの組合せにより、
色々な動作を実現できます。
@example
(open-output-file "foo" :if-exists :error)
 @result{} ;@r{"foo"を排他的にオープンするかエラーを報告する}

(open-output-file "foo" :if-exists #f)
 @result{} ;@r{"foo"を排他的にオープンするか}#f@r{を返す}

(open-output-file "foo" :if-exists :append
                        :if-does-not-exist :error)
 @result{} ;@r{"foo"が既に存在する場合に限り、それを追加モードでオープン}
@end example
@c COMMON

@c EN
To check the existence of a file without opening it,
use @code{sys-access} or @code{file-exists?} (@xref{File stats}).
@c JP
ファイルをオープンせずにその存在をチェックするには、
@code{sys-access}か@code{file-exists?}を使って下さい (@ref{File stats}参照)。
@c COMMON

@c EN
Note: @code{gauche.charconv} module extends these procedures to
take @var{encoding} keyword argument so that they can read or write
in different character encoding scheme.  @xref{gauche.charconv - Character code conversion}.
@c JP
註：@code{gauche.charconv}モジュールはこれらの手続きを、
@var{encoding}キーワード引数を取るように拡張して、
異なる文字エンコーディングでのファイルの読み書きを可能にします。
@ref{gauche.charconv - Character code conversion}参照。
@c COMMON

@c EN
Note for portability: Some Scheme implementations (e.g. STk) allows
you to specify a command to @var{filename} and reads from, or
writes to, the subprocess standard input/output.  Some other scripting
languages (e.g. Perl) have similar features.  In Gauche,
@code{open-input-file} and @code{open-output-file} strictly operates
on files (what the underlying OS thinks as files).
However, you can use ``process ports'' to invoke
other command in a subprocess and to communiate it.
@xref{Process ports}, for details.
@c JP
移植性に関する註：Schemeシステムによっては、@var{filename}のところに
シェルコマンドを指定して、サブプロセスの標準入出力と通信できるようにするものが
あります。他のスクリプティング言語(例：Perl)にも同様の機能があります。
Gaucheでは、@code{open-input-file}と@code{open-output-file}は
あくまでファイル (OSがファイルとして扱うもの) のみに対して使えます。
サブプロセスと通信するためには、「プロセスポート」という機能が提供されています。
@ref{Process ports}を参照して下さい。
@c COMMON
@end defun

@defun call-with-input-file string proc &keyword if-exists buffering element-type
@defunx call-with-output-file string proc &keyword if-does-not-exist if-exists buffering element-type
[R5RS]
@c EN
Opens a file specified by @var{string} for input/output,
and call @var{proc} with one argument, the file port.  When @var{proc}
returns, or an error is signalled from @var{proc} that is not captured
within @var{proc}, the file is closed.
@c JP
@var{string}で示されるファイルを入力または出力用にオープンし、
作成されたポートを引数として手続き@var{proc}を呼び出します。
@var{proc}が正常終了するか、@var{proc}内で捕捉されないエラーが起きた場合に
ファイルはクローズされます。
@c COMMON

@c EN
The keyword arguments @code{if-exists}, @code{element-type} and
@code{if-does-not-exist} have the same meanings of
@code{open-input-file} and @code{open-output-file}'s.  Note that
if you specify @code{#f} to @var{if-exists} and/or @var{if-does-not-exist},
@var{proc} may receive @code{#f} instead of a port object when
the file is not opened.
@c JP
キーワード引数は@code{if-exists}、@code{buffering}, @code{element-type}、
@code{if-does-not-exist}は
@code{open-input-file}及び@code{open-output-file}のものと同じ意味を持ちます。
@var{if-exists}や@var{if-does-not-exist}に@code{#f}を指定した場合、
ファイルがオープンされなかった場合は@var{proc}にポートではなく@code{#f}が渡される
ことに注意して下さい。
@c COMMON

@c EN
Returns the value(s) @code{proc} returned.
@c JP
@var{proc}が返す値を返します。
@c COMMON
@end defun

@defun with-input-from-file string thunk &keyword if-exists buffering element-type
@defunx with-output-to-file string thunk &keyword if-does-not-exist if-exists buffering element-type
[R5RS]
@c EN
Opens a file specified by @var{string} for input or output
and makes the opened port as the current input or output port,
then calls @var{thunk}.  The file is closed when @var{thunk}
returns or an error is signalled from @var{thunk} that is not
captured within @var{thunk}.

The keyword arguments have the same
meanings of @code{open-input-file} and @code{open-output-file}'s,
except that @code{#f} is not allowed to @var{if-exists} and
@var{if-does-not-exist}; i.e. an error is always signalled if the
file can't be opened.

Returns the value(s) @code{thunk} returned.
@c JP
@var{string}で示されるファイルを入力または出力用にオープンし、オープンされた
ポートを現在の入力または出力ポートに設定して、@var{thunk}を呼び出します。
@var{thunk}が戻るか、@var{thunk}内で捕捉されないエラーが生じた際にファイルは閉じられます。

キーワード引数は
@code{open-input-file}及び@code{open-output-file}のものと同じ意味を持ちます。
但し@var{if-exists}や@var{if-does-not-exist}に@code{#f}を指定することは
出来ません。ファイルがオープンできなかった場合は常にエラーとなります。

@var{thunk}が返す値を返します。
@c COMMON
@end defun

@c EN
@emph{Notes on semantics of closing file ports:}
R5RS states, in the description of @code{call-with-input-file} et al., 
that @emph{"If @emph{proc} does not return, then the port will
not be closed automatically unless it is possible
to prove that the port will never again be used for read or write
operation."}
@c JP
@emph{ポートを閉じるセマンティクスについて:} 
R5RSは@code{call-with-input-file}等の説明において、次のように述べています。
「@emph{procが戻って来なかった場合、今後ポートが読み書きに一切使われないことが
証明できない限りは、ポートは自動的には閉じられない}」。
@c COMMON

@c EN
Gauche's implementation slightly misses this criteria; the mere fact
that an uncaptured error is thrown in @var{proc} does not prove
the port will never be used.  Nevertheless, it is very diffcult
to think the situation that you can do meaningful operation on
the port after such an error is signalled; you'd have no idea
what kind of state the port is in.  In practical programs, you
should capture error explicitly inside @var{proc} if you still want
to do some meaningful operation with the port.
@c JP
Gaucheの実装は若干この条件には反しています。捕捉されないエラーが@var{proc}から
発せられたというだけでは、そのポートが今後一切使われないかどうかはわかりません。
しかし実際には、そのようなエラーが発せられた後でポートに対して意味のある操作をするのは
非現実的です。ポートがどのような状態にあるかわからないわけですから。
現実的なプログラムでは、ポートに対して意味のある操作をしつづけたいのなら、
@var{proc}の中で明示的にエラーをハンドルすべきでしょう。
@c COMMON

@c EN
Note that if a continuation captured outside @code{call-with-input-file}
et al. is invoked inside @var{proc}, the port is not closed.
It is possible that the control returns later into the @var{proc},
if a continuation is captured in it (e.g. coroutines).
The low-level exceptions 
(@xref{Low-level exception mechanism}) also doesn't ensure closing 
the port.
@c JP
@code{call-with-input-file}の外で捕捉された継続を@var{proc}内で呼んだ場合には
ポートは閉じられないことに注意して下さい。後で@var{proc}へと制御が戻ってくるかも
しれないからです (コルーチン等)。また、
低レベルの例外メカニズム(@ref{Low-level exception mechanism}
参照)を利用した場合、エラー時にポートを閉じるのはプログラマの責任になります。
@c COMMON


@defun open-input-fd-port fd &keyword buffering name owner?
@defunx open-output-fd-port fd &keyword buffering name owner?
@c EN
Creates and returns an input or output port on top of the given
file descriptor.  @var{Buffering} specifies the buffering mode
as described in @code{open-input-file} entry above; the default
is @code{:full}.  @var{Name} is used for the created port's name
and returned by @code{port-name}.  A boolean flag @code{owner?}
specfies whether @var{fd} should be closed when the port is closed.
@c JP
与えられたファイルディスクリプタにアクセスする入力または出力ポートを
作成して返します。@var{buffering} は@code{open-input-file} の項で
説明されたポートのバッファリングモードを指定します。デフォルトは@code{:full}です。
@var{name}は@code{port-name}によって返されるポートの名前を指定します。
@var{owner?} は、このポートを閉じた時に@var{fd}もクローズすべきかどうかを
指定するブーリアン値です。
@c COMMON
@end defun

@node String ports, Procedural ports, File ports, Input and output
@subsection String ports
@c NODE 文字列ポート

@c EN
String ports are the ports that you can read from or write to
memory.
@c JP
文字列ポートは、メモリ上のデータと関連付けられたポートです。
@c COMMON

@defun open-input-string string
[SRFI-6]
@c EN
Creates an input string port that has the content @var{string}.
This is a more efficient way to access a string in order
rather than using @code{string-ref} with incremental index.

@example
(define p (open-input-string "foo x"))
(read p) @result{} foo
(read-char p) @result{} #\space
(read-char p) @result{} #\x
(read-char p) @result{} #<eof>
(read-char p) @result{} #<eof>
@end example
@c JP
@var{string}を内容とする入力文字列ポートを作って返します。
文字列に逐次的にアクセスする場合、インデックスをインクリメントしながら
@code{string-ref}を呼び出すより効率の良い方法です。
@example
(define p (open-input-string "文字 列"))
(read p) @result{} 文字
(read-char p) @result{} #\space
(read-char p) @result{} #\列
(read-char p) @result{} #<eof>
(read-char p) @result{} #<eof>
@end example
@c COMMON
@end defun

@defun open-output-string
[SRFI-6]
@c EN
Creates an output string port.   Anything written to the
port is accumulated in the buffer, and can be obtained
as a string by @code{get-output-string}.
This is a far more efficient way to construct a string
sequentially than pre-allocate a string and fill it with
@code{string-set!}.
@c JP
出力文字列ポートを作成して返します。このポートに書き出された文字列は
内部のバッファにたくわえられ、@code{get-output-string} で取り出すことが
できます。
これは、順番に文字列を構成する方法として、あらかじめ文字列をアロケートして
@code{string-set!}で埋めて行くよりもずっと効率の良い方法です。
@c COMMON
@end defun

@defun get-output-string port
[SRFI-6]
@c EN
Takes an output string port @code{port} and returns a string
that has been accumulated to @code{port} so far.
If a byte data has been written to the port, this function
re-scans the buffer to see if it can consist a complete string;
if not, an incomplete string is returned.
@c JP
出力文字列ポート@code{port}を取り、それまでそのポートに蓄積された
文字列を返します。バイトデータがそのポートに書き出されていた場合、
この手続きはまず内部バッファをスキャンし、結果が完全な文字列で表現できるかどうかを
調べます。もし表現できなければ、不完全な文字列が返されます。
@c COMMON
@end defun

@defun call-with-input-string string proc
@defunx call-with-output-string proc
@defunx with-input-from-string string thunk
@defunx with-output-to-string thunk
@c EN
These utility functions are trivially defined as follows.
The interface is parallel to the file port version.
@c JP
これらのユーティリティ関数は次に定義されるような動作をします。
インタフェースはファイルポートを扱う類似の関数と揃えてあります。
@c COMMON
@example
(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (get-output-string out)))

(define (call-with-input-string str proc)
  (let ((in (open-input-string str)))
    (proc in)))

(define (with-output-to-string thunk)
  (let ((out (open-output-string)))
    (with-output-to-port out thunk)
    (get-output-string out)))

(define (with-input-from-string str thunk)
  (with-input-from-port (open-input-string str) thunk))
@end example
@end defun

@defun call-with-string-io str proc
@defunx with-string-io str thunk
@example
(define (call-with-string-io str proc)
  (let ((out (open-output-string))
        (in  (open-input-string str)))
    (proc in out)
    (get-output-string out)))

(define (with-string-io str thunk)
  (with-output-to-string
    (lambda ()
      (with-input-from-string str
        thunk))))
@end example
@end defun

@defun write-to-string obj &optional writer
@defunx read-from-string string &optional start end
@c EN
These convenience functions cover commin idioms using string ports.
@example
(write-to-string obj writer)
  @equiv{}
  (with-output-to-string (lambda () (writer obj)))

(read-from-string string)
  @equiv{}
  (with-input-from-string string read)
@end example
The default value of @var{writer} is the procedure @code{write}.
The default values of @var{start} and @var{end} is 0 and
the length of @var{string}.

Portability note: Common Lisp has these functions, with
different optional arguments.
STk has @code{read-from-string} without optional argument.
@c JP
文字列ポートを使う定型句をユーティリティ関数にしました。
@example
(write-to-string obj writer)
  @equiv{}
  (with-output-to-string (lambda () (writer obj)))

(read-from-string string)
  @equiv{}
  (with-input-from-string string read)
@end example
@var{writer}の既定値は@code{write}です。@var{start}, @var{end}は
省略されればそれぞれ0と文字列の長さになります。

移植性への註：Common Lispに同名の関数があります。必須引数の動作は同じですが、
省略可能な引数は異なります。
STkには@code{read-from-string}がありますが、省略可能な引数は取りません。
@c COMMON
@end defun

@node Procedural ports, Input, String ports, Input and output
@subsection Procedural ports
@c NODE 手続き的ポート

The underlying mechanism of procedural ports is very flexible,
but I don't have Scheme interface yet, except the following ones:

@defun open-input-buffered-port filler buffer-size
@defunx open-output-buffered-port flusher buffer-size
@b{These procedures are deprecated and will be replaced by more general procedural APIs.}

These are the Scheme interface to the ``buffered port''.

@code{open-input-buffered-port} creates and returns an input port,
with associated buffer of size @var{buffer-size}.
The data is read from the buffer.
When the port is read and the buffer is empty, a procedure @var{filler}
is called with one argument, the size of required data.
@var{filler} must return a string (either complete or incomplete)
of the specified size.  It is permitted for @var{filler}
to return a string shorter than the size, if not enough data is available.
The behavior is undefined if @var{filler} returns larger string than
specified.  Note that the @var{size} of string matters, not the @var{length}
of string.
If @var{filler} finds that it reached EOF of its data source, it can
return EOF.  Retuning zero size string has the same effect as EOF.
Initially, the buffer is empty, so @var{filler} is always called
at the first attempt of reading from the port.

@code{open-output-buffered-port} creates and returns an output port,
with associated buffer of size @var{buffer-size}.
The data output to the port is accumulated in the buffer.
When the buffer gets full, or @code{flush} is called on the port,
a procedure @var{flusher} is called with an @emph{incomplete} string
to be flushed.   @var{flusher} must return a number of bytes flushed,
which must be the same as the size of the passed string.
The string may shorter than @var{buffer-size}.
When the port is closed, @var{flusher} is called with any data
remaining in the buffer, then it is called again with @code{#f} to
indicate the port is closed.
@end defun

@node Input, Output, Procedural ports, Input and output
@subsection Input 
@c NODE 入力

@c EN
For the input-related procedures, the optional @var{iport} argument must be
an input port, and when omitted, the current input port is assumed.
@c JP
入力に関する手続きで、省略可能な引数@var{iport}は入力ポートでなければなりません。
省略された場合が現在の入力ポートが使われます。
@c COMMON

@menu
* Reading data::                
* Read-time constructor::       
* Input utility functions::     
@end menu

@node Reading data, Read-time constructor, Input, Input
@subsubsection Reading data
@c NODE データの読み込み

@defun read &optional iport
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun read-char &optional iport
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun peek-char &optional iport
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun read-byte &optional iport
@c EN
Reads one byte from an input port @var{iport}, and returns an integer
in the range between 0 and 255.
If @var{iport} has already reached EOF, an eof object is returned.
@c JP
入力ポート@var{iport}から1バイト読み込み、0から255までの整数値として返します。
@var{iport}が既にEOFに達していた場合はeofオブジェクトを返します。
@c COMMON
@end defun

@defun read-line &optional iport
@c EN
Reads one line (a sequence of characters terminated by newline or EOF)
and returns a string.  The terminating newline is not included.
This function recognizes popular line terminators (LF only, CRLF, and CR only).
If @var{iport} has already reached EOF, an eof object is returned.
@c JP
入力ポートから、行末もしくはEOFまで読み込んで文字列として返します。
よく使われる行末 (LF only, CRLF, and CR only) を認識します。
戻り値にはこれらの行末文字は含まれません。
@var{iport}が既にEOFに達していた場合はeofオブジェクトを返します。
@c COMMON
@end defun

@defun read-block nbytes &optional iport
@c EN
Reads @var{nbytes} bytes from @var{iport}, and returns an incomplete
string consisted by those bytes.  The size of returned string may
shorter than @var{nbytes} when @var{iport} doesn't have enough bytes
to fill.  If @var{iport} has already reached EOF, an eof object is returned.
@c JP
@var{nbytes}バイトのデータを@var{iport}から読み込み、
不完全な文字列として返します。@var{iport}に十分なデータが無い場合、
返される文字列は@var{nbytes}より短いかもしれません。
@var{iport}が既にEOFに達していた場合はEOFオブジェクトが返されます。
@c COMMON

@c EN
If @var{iport} is a file port, the behavior of @code{read-block}
differs by the buffering mode of the port (@xref{File ports}, for
the detail explanation of buffering modes).
@c JP
@var{iport}がファイルポートだった場合、@code{read-block}は
ポートのバッファリングモードによってふるまいが異なります
(バッファリングモードの詳細については@ref{File ports}を参照して下さい)。
@c COMMON
@itemize @bullet
@item
@c EN
If the buffering mode is @code{:full}, @code{read-block} waits 
until @var{nbytes} data is read, except it reads EOF.
@c JP
バッファリングモードが@code{:full}の場合、@code{read-block}は
EOFを読まない限り、@var{nbytes}のデータが読まれるまで待ちます。
@c COMMON
@item
@c EN
If the buffering mode is @code{:modest} or @code{:none}, @code{read-block}
returns shorter string than @var{nbytes} even if it doesn't reach EOF,
but the entire data is not available immediately.
@c JP
バッファリングモードが@code{:modest}か@code{:none}である場合、
@code{read-block}はEOFが読まれなくても、すぐに読めるデータが@var{nbytes}よりも
少ない場合はそのデータだけを返します。
@c COMMON
@end itemize

@c EN
@code{Read-block} returns newly allocated string every time.
If you want to avoid allocation and read the data into a pre-allocated
fixed-length buffer, you can use @code{read-block!}
in @code{gauche.uvector} module (@xref{Uvector block I/O}).
It uses a uniform vector as the buffer.
@c JP
@code{read-block}は呼ばれるたびに新たな文字列をアロケートします。
アロケーションを避け、あらかじめ用意された固定長のバッファにデータを読み込みたい
場合は、@code{gauche.uvector}モジュールの@code{read-block!}
を使って下さい (@ref{Uvector block I/O}参照)。
@code{Read-block!}はuniform vectorをバッファとして用います。
@c COMMON

@c EN
If you want to write a chunk of bytes to a port,
you can use either @code{display} if the data is in string,
or @code{write-block} in @code{gauche.uvector} (@xref{Uvector block I/O})
if the data is in uniform vector.
@c JP
データブロックをポートに書き出すには、データが文字列で表現されている
場合は単純に@code{display}が使えます。データがuniform vectorで表現されている
場合は@code{gauche.uvector}モジュールの@code{write-block}が
使えます (@ref{Uvector block I/O}参照)。
@c COMMON
@end defun

@defun eof-object? obj
[R5RS]
@c EN
Returns true if @var{obj} is an EOF object.
@c JP
@var{obj}がEOFオブジェクトなら@code{#t}を返します。
@c COMMON
@end defun

@defun char-ready? port
[R5RS]
@c EN
If a character is ready to be read from @var{port}, returns @code{#t}.

For now, this procedure actually checks only if next @emph{byte} is
immediately available from @var{port}.   If the next byte is a part of
a multibyte character, the attempt to read the whole character may block,
even if @code{char-ready?} returns @code{#t} on the port.
(It is unlikely to happen in usual situation, but theoretically it can.
If you concern, use @code{read-block} to read the input as a byte
sequence, then use input string port to read characters.)
@c JP
@var{port}から文字が読み出せる状態ならば@code{#t}を返します。

今のところ、この手続きは@var{port}から少なくとも1バイト読み出せる状態なら@code{#t}
を返します。そのバイトがマルチバイト文字を構成する場合、@code{char-ready?}を返した
ポートから文字全てを読み込もうとすると、ブロックする可能性があります。
(通常の使用状況ではそのようなことは起きないでしょうが、理論的には起こり得ます。
慎重を期したい場合は@code{read-block}でバイトシーケンスとして読み込んだ後、
入力文字列ポート等を使って文字毎に読むようにして下さい。)
@c COMMON
@end defun

@node Read-time constructor, Input utility functions, Reading data, Input
@subsubsection Read-time constructor
@c NODE 読み込み時コンストラクタ

Read-time constructor, defined in SRFI-10, provides an easy way
to create an external representation of user-defined structures.

@deftp {Reader Syntax} @code{#,(@var{tag} @var{arg} @dots{})}
[SRFI-10]
Gauche maintains a global table that associates a @var{tag} (symbol)
to @emph{a constructor procedure}.

When the reader encounters this syntax, it reads @var{arg} @dots{},
finds a reader constructor associated with @var{tag}, and
calls the constructor with @var{arg} @dots{} as arguments,
then inserts the value returned by the constructor as the result
of reading the syntax.

Note that this syntax is processed inside the reader---the
evaluator doesn't see any of @var{arg}s, but only sees the object
the reader returns.
@end deftp

@defun define-reader-ctor @var{tag} @var{procedure}
[SRFI-10]
Associates a reader constructor @var{procedure} with @var{tag}.

Examples:
@example
(define-reader-ctor 'pi (lambda () (* (atan 1) 4)))

#,(pi) @result{} 3.141592653589793

'(#,(pi)) @result{} (3.141592653589793)

(define-reader-ctor 'hash
  (lambda (type . pairs)
    (let ((tab (make-hash-table type)))
      (for-each (lambda (pair)
                  (hash-table-put! tab (car pair) (cdr pair)))
                pairs)
      tab)))

(define table
 #,(hash eq? (foo . bar) (duh . dah) (bum . bom)))

table @result{} #<hash-table eq? 0x80f9398>
(hash-table-get table 'duh) @result{} dah
@end example

Combined with @code{write-object} method (@xref{Output}),
it is easy to make a user-defined class written in the form
it can be read back:

@example
(define-class <point> ()
  ((x :init-value 0 :init-keyword :x)
   (y :init-value 0 :init-keyword :y)))

(define-method write-object ((p <point>) out)
  (format out "#,(<point> ~s ~s)" (ref p 'x) (ref p 'y)))

(define-reader-ctor '<point>
  (lambda (x y) (make <point> :x x :y y)))
@end example

@end defun

@emph{NOTE:} The extent of the effect of @code{define-reader-ctor}
is not specified in SRFI-10, and might pose a compatibility problem
among implementations that support SRFI-10.
(In fact, the very existence of @code{define-reader-ctor} is
up to an implementation choice.)

In Gauche, at least for the time being, @code{define-reader-ctor}
take effects as soon as the form is compiled and evaluated.  Since
Gauche compiles and evaluates each toplevel form in order, @var{tag}
specified in @code{define-reader-ctor} can be used immediately after that.
However, it doesn't work if the call of @code{define-reader-ctor} and
the use of @var{tag} is enclosed in a @code{begin} form, for the entire
@code{begin} form is compiled at once before being evaluated.

Other implementations may require to read the entire file before
making its @code{define-reader-ctor} call effective.  If so, it
effectively prevents one from using @code{define-reader-ctor} and
the defined @var{tag} in the same file.   It is desirable to separate
the call of @code{define-reader-ctor} and the use of @var{tag}
in the different files if possible.

Another issue about the current @code{define-reader-ctor} is that
it modifies the global table of Gauche system, hence not modular.
The code written by different people might use the same tags,
and yield an unexpected result.   In future versions, Gauche may
have some way to encapsulate the scope of @var{tag}, although
the author doesn't have clear idea yet.


@node Input utility functions,  , Read-time constructor, Input
@subsubsection Input utility functions
@c NODE 入力ユーティリティ手続き

@defun port->string port
@defunx port->list reader port
@defunx port->string-list port
@defunx port->sexp-list port
@c EN
Generally useful input procedures.  The API is taken from
scsh and STk.
@c JP
便利な入力手続きです。APIはScshとSTkから取りました。
@c COMMON

@c EN
@code{port->string} reads @var{port}
until EOF and returns the accumulated data as a string.
@c JP
@code{port->string}は@var{port}をEOFまで読み込み、
読んだものを文字列として返します。
@c COMMON

@c EN
@code{port->list} applies @var{reader} on @var{port} repeatedly, until
@var{reader} returns an EOF, then returns the list of objects
@var{reader} returned.
@c JP
@code{port->list}は手続き@var{reader}を@var{port}に繰り返し適用し、
結果をリストに蓄積します。@var{reader}がEOFを返したら
蓄積されたリストを返します。
@c COMMON

@code{(port->string-list port)} @equiv{}
@code{(port->list read-line port)}
@c EN
, and
@c JP
であり、
@c COMMON
@code{(port->sexp-list port)} @equiv{}
@code{(port->list read port)}
@c EN
.
@c JP
です。
@c COMMON
@end defun

@defun port-fold fn knil reader
@defunx port-fold-right fn knil reader
@defunx port-for-each fn reader
@defunx port-map fn reader
@c EN
Convenient iterators over the input read by @var{reader}.
Basically, @var{reader} is called repeatedly without arguments
and @var{fn} is called for each item it returns, until @var{reader}
returns EOF.   Actually @var{reader} can be any thunk; it doesn't
need to be related to input port.
@c JP
@var{reader}によって読まれる入力に対する便利な繰り返し手続きです。
基本的に、@var{reader}が引数無しでEOFを返すまで繰り返し呼ばれ、
それが返した値に対して@var{fn}が呼ばれます。
@var{reader}はいずれEOFを返す手続きなら、入力ポートと関係している必要はありません。
@c COMMON

@c EN
Suppose @var{reader} returns a series of items
@{X0, X1, @dots{}, Xn@}.
@code{port-fold} returns the following:
@c JP
@var{reader}が要素 @{X0, X1, @dots{}, Xn@} を返したとすると、
@code{port-fold} は次の値を返します。
@c COMMON
@example
(fn Xn (fn Xn-1 @dots{} (fn X0 knil)))
@end example
@c EN
while @var{port-fold-right} returns the following:
@c JP
一方、@var{port-fold-right}は次の値を返します。
@c COMMON
@example
(fn X0 (fn X1 @dots{} (fn Xn knil)))
@end example
@c EN
That is, @code{(port-fold cons '() read)} returns a reverse
list of all the inputs, while @code{(port-fold-right cons '() read)}
returns the same thing as @code{(port->list read port)}.
@c JP
すなわち、@code{(port-fold cons '() read)}は全ての入力の逆リストを
返し、@code{(port-fold-right cons '() read)}は
@code{(port->list read port)}と同じものを返します。
@c COMMON

@c EN
On the other hand, @code{port-for-each} and @code{port-map}
applies @var{fn} to each item.  The former discards the results
@var{fn} returns, while the latter returns a list of results.
@c JP
@code{port-for-each}と@code{port-map}は@var{fn}を読まれた要素に
次々と適用します。前者は@code{fn}の結果を捨てますが、後者は@code{fn}の
結果をリストにして返します。
@c COMMON
@end defun

@node Output,  , Input, Input and output
@subsection Output
@c NODE 出力

@c EN
For the following procedures, the optional @var{port} argument must be
an output port, and when omitted, the current output port is assumed.
@c JP
以下の手続きで、省略可能な引数@var{port}は出力ポートでなければなりません。
省略された場合が現在の出力ポートが使われます。
@c COMMON

@defun write obj &optional port
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun display obj &optional port
[R5RS]
@c EN
@c JP
@c COMMON
@end defun

@defun print expr @dots{}
@c EN
Displays @var{expr}s (using @code{display}) to the current output port,
then writes a newline.
@c JP
@var{expr} @dots{} を@code{display}を使って現在の出力ポートに表示し、
最後に改行を書き出します。
@c COMMON
@end defun

@deffn {Method} write-object (obj <object>) port
You can customize how the object is printed out by this method.
@end deffn

@defun newline &optional port
[R5RS]
@c EN
Writes a newline character to @var{port}
@c JP
@var{port}に改行文字を書き出します。
@c COMMON
@end defun

@defun flush &optional port
@defunx flush-all-ports
@c EN
Output the buffered data in @var{port}, or all ports, respectively.

The function "flush" is called in variety of ways on the various
Scheme implementations: @code{force-output} (Scsh, SCM),
@code{flush-output} (Gambit), or @code{flush-output-port} (Bigloo).
The name @code{flush} is taken from STk and STklos.
@c JP
それぞれ、@var{port}、および全てのポートにバッファされているデータを
全て書き出します。

手続き"flush"はScheme実装によって様々な名前で呼ばれています：
@code{force-output} (Scsh, SCM)、
@code{flush-output} (Gambit)、@code{flush-output-port} (Bigloo) 等。
@code{flush}の名前はSTkとSTklosから取りました。
@c COMMON
@end defun

@defun write-char char &optional port
[R5RS]
@c EN
Write a single character @var{char} to the output port @var{port}.
@c JP
文字@var{char}をポートに出力します。
@c COMMON
@end defun

@defun write-byte byte &optional port
@c EN
Write a byte @var{byte} to the port.
@var{byte} must be an exact integer in range between 0 and 255.
@c JP
出力ポートに1バイトのデータ@var{byte}を書き出します。
@var{byte}は0から255の間の正確な整数でなければなりません。
@c COMMON
@end defun

@defun write* obj &optional port
@end defun

@defun format port string arg @dots{}
@defunx format string arg @dots{}
[SRFI-28+]
@c EN
Format @var{arg} @dots{} according to @var{string}.
This function is a subset of CommonLisp's @code{format} function,
with a bit of extension.  It is also a superset of SRFi-28,
Basic format strings (@ref{srfi-28,[SRFI-28],SRFI-28}).
@c JP
@var{string} の指示に従い、@var{arg} @dots{}をフォーマットします。
この手続きはCommonLispの@code{format}のサブセットに、Gauche独自の拡張を
加えたものです。また、これはSRFI-28 "Basic format strings" のスーパーセットに
なっています (@ref{srfi-28,[SRFI-28],SRFI-28})。
@c COMMON

@c EN
@var{port} specifies the destination; if it is an output port, the
formatted result is written to it; if it is @code{#t},
the result is written to the current output port;
if it is @code{#f}, the formatted result is returned as a string.
@var{Port} can be omitted, as SRFI-28 @code{format};
it has the same effects as giving @code{#f} to the @var{port}.
@c JP
@var{port}は出力先を指定します。それが出力ポートであれば、フォーマットされた
結果はそのポートに書き出されます。@var{port}が@code{#t}であれば、結果は
現在の出力ポートに書き出されます。@var{port}が@code{#f}であれば、結果は
文字列として@code{format}から返されます。
@var{port}は省略することもできます。その場合は、@code{port}に@code{#f}
を指定したのと同じ動作をします(SRFI-28の@code{format})。
@c COMMON

@c EN
@var{string} is a string that contains format directives.
A format directive is a character sequence begins with tilda, `@code{~}',
and ends with some specific characters.  A format directive takes
the corresponding @var{arg} and formats it.  The rest of string is
copied to the output as is.
@c JP
@var{string}はフォーマット指示子を含んだ文字列です。
フォーマット指示子はチルダ`@code{~}'から始まり、特定の文字で終了する文字の並びで、
それぞれのフォーマット指示子が対応する@var{arg}を取りフォーマットします。
@var{string}内のフォーマット指示子以外の文字列はそのまま出力されます。
@c COMMON

@example
(format #f "the answer is ~s" 42)
  @result{} "the answer is 42"
@end example

@c EN
The format directive can take one or more @var{parameters}, separated
by comma characters.  A parameter may be an integer or a character;
if it is a character, it should be preceded by a quote character.
Parameter can be omitted, in such case the system default value is
used.  The interpretation of the parameters depends on the 
format directive.
@c JP
フォーマット指示子は一つ以上のコンマで区切られたパラメータを取ることもできます。
パラメータは整数か文字です。文字の場合、クオート文字に続けてその文字を置きます。
パラメータが省略された場合は既定値が使われます。パラメータの意味はフォーマット指示子毎に
異なります。
@c COMMON

@c EN
Furthermore, a format directive can take two
additional flags: atmark `@code{@@}' and colon `@code{:}'.  One or
both of them may modify the behavior of the format directive.
Those flags must be placed immediately before the directive
character.
@c JP
さらに、フォーマット指示子は2種類のフラグ、`@code{@@}' と `@code{:}' を
取ることができます。これらの組合せでフォーマットの動作が変わります。フラグは
(もしあれば)パラメータの後、指示子の文字の直前に置かれなければなりません。
@c COMMON

@c EN
If a character `@code{v}' or `@code{V}' is in the place of the
parameter, the value of the parameter is taken from the format's
argument.  The argument must be either an integer, a character, or
@code{#f} (indicating that the parameter is effectively omitted).
@c JP
パラメータの位置に文字 `@code{v}' か `@code{V}' を置くこともできます。
その場合、パラメータの値が引数リストから取られます。対応する引数は整数か
文字、または@code{#f}でなければなりません。@code{#f}の場合はそのパラメータが
省略されたのと同じになります。
@c COMMON

@c EN
Some examples:

@table @code
@item ~10,2s
A format directive @code{~s}, with two parameters, 10 and 2.
@item ~12,,,'*A
A format directive @code{~a}, with 12 for the first parameter and
a character `@code{*}' for the fourth parameter.  The second and
third parameters are omitted.
@item ~10@@d
A format directive @code{~d}, with 10 for the first parameter and
`@code{@@}' flag.
@item ~v,vx
A format directive @code{~x}, whose first and second parameter will
be taken from the arguments.
@end table
@c JP
いくつかの例です。

@table @code
@item ~10,2s
パラメータ10と2を伴う、フォーマット指示子@code{~s}。
@item ~12,,,'*A
第1パラメータに数値12、第4パラメータに文字`@code{*}'を取るフォーマット指示子@code{~a}。
第2と第3のパラメータは省略されています。
@item ~10@@d
フォーマット指示子@code{~d}。パラメータ10と`@code{@@}'フラグがついています。
@item ~v,vx
フォーマット指示子@code{~x}。第1パラメータと第2パラメータは引数リストから取られます。
@end table
@c COMMON

@c EN
The following is a complete list of the supported format directives.
Either upper case or lower case character can be used for the format
directive; usually they have no distinction, except noted.
@c JP
以下にサポートされているフォーマット指示子を示します。フォーマット指示子の文字自体は
大文字であっても小文字であっても構いません。特に断りのない限り両者は同じ動作をします。
@c COMMON

@table @asis
@item @b{~}@var{mincol},@var{colinc},@var{minpad},@var{padchar},@var{maxcol}@b{A}
@c EN
Ascii output.  The corresponding argument is printed by @code{display}.
If an integer @var{mincol} is given, it specifies the minimum number
of characters to be output; if the formatted result is shorter than
@var{mincol}, a whitespace is padded to the right (i.e. the result
is left justified).
@c JP
ASCII出力。対応する引数が@code{display}を使ってフォーマットされます。
整数が@var{mincol}に与えられた場合、それは出力される最小の文字数を指定します。
引数のフォーマット結果が@var{mincol}より短ければ、空白が右に追加されます(つまり、
左詰めになります)。
@c COMMON

@c EN
The @var{colinc}, @var{minpad} and @var{padchar} parameters
control, if given, further padding.  A character @var{padchar} replaces
the padding character for the whitespace.  If an integer @var{minpad}
is given and greater than 0, at least @var{minpad} padding character
is used, regardless of the resulting width.  If an integer @var{colinc}
is given, the padding character is added (after @var{minpad}) in chunk
of @var{colinc} characters, until the entire width exceeds @var{mincol}.
@c JP
@var{colinc}、@var{minpad}、そして@var{padchar}は更に細かいパディング方法を
指定します。@var{padchar}に文字が与えられた場合、それが空白文字の代わりにパディング文字と
して使われます。@var{minpad}に0以上の整数が与えられた場合、少なくともその数だけの
パディング文字が追加されます。@var{colinc}が指定された場合、
追加されるパディング文字の数が@var{colinc}の倍数に調整されます。
@c COMMON

@c EN
If atmark-flag is given, the format result is right justified, i.e.
padding is added to the left.
@c JP
アトマーク `@code{@@}' フラグが与えられた場合、結果は右詰めになります。
@c COMMON

@c EN
The @var{maxcol} parameter, if given, limits the maximum number of characters
to be written.  If the length of formatted string exceeds
@var{maxcol}, only @var{maxcol} characters are written.
If colon-flag is given as well and the length of formatted string
exceeds @var{maxcol}, @var{maxcol} - 4 characters are written and
a string ``@code{ ...}'' is attached after it.
@c JP
@var{maxcol}パラメータは与えられていれば書かれる文字数の上限を指定します。
フォーマット後の文字列の長さが@var{maxcol}を超えた場合、@var{maxcol}文字だけが
書かれます。コロン `@code{:}' フラグが同時に与えられていれば、
@var{maxcol} - 4 文字が書かれた後、文字列``@code{ ...}''が書かれます。
@c COMMON

@example
(format #f "|~a|" "oops")
  @result{} "|oops|"
(format #f "|~10a|" "oops")
  @result{} "|oops      |"
(format #f "|~10@@a|" "oops")
  @result{} "|      oops|"
(format #f "|~10,,,'*@@a|" "oops")
  @result{} "|******oops|"
@c JP
(format #f "|~10,,,'☆a|" "oops")
  @result{} "|oops☆☆☆☆☆☆|"
@c COMMON

(format #f "|~,,,,10a|" '(abc def ghi jkl)
  @result{} "|(abc def gh|" 
(format #f "|~,,,,10:a|" '(abc def ghi jkl)
  @result{} "|(abc de ...|" 
@end example

@item @b{~}@var{mincol},@var{colinc},@var{minpad},@var{padchar},@var{maxcol}@b{S}
@c EN
S-expression output.  The corresponding argument is printed
by @code{write}.  The semantics of parameters and flags are the same
as @code{~A} directive.
@c JP
S式出力。対応する引数が@code{write}を使ってフォーマットされます。
パラメータの意味は@code{~A}指示子と同じです。
@c COMMON

@example
(format #f "|~s|" "oops")
  @result{} "|\"oops\"|"
(format #f "|~10s|" "oops")
  @result{} "|\"oops\"    |"
(format #f "|~10@@s|" "oops")
  @result{} "|    \"oops\"|"
(format #f "|~10,,,'*@@s|" "oops")
  @result{} "|****\"oops\"|"
@c JP
(format #f "|~10,,,'★s|" "oops")
  @result{} "|\"oops\"★★★★|"
@c COMMON
@end example

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{D}
@c EN
Decimal output.  The argument is formatted as an decimal integer.
If the argument is not an integer, all parameters are ignored 
(after processing `@code{v}' parameters) and
it is formatted by @code{~A} directive.
@c JP
10進出力。対応する引数が10進数表記でフォーマットされます。もし引数が数値でなければ、
全てのパラメータは(`@code{v}'パラメータの処理後に)無視され、
引数は@code{~A}でフォーマットされます。
@c COMMON

@c EN
If an integer parameter @var{mincol} is given, it specifies minimum
width of the formatted result; if the result is shorter than it,
@var{padchar} is padded on the left (i.e. the result is right
justified).  The default of @var{padchar} is a whitespace.
@c JP
もし@var{mincol}に整数が与えられたら、それが最小の文字数を指定します。
結果の文字数がそれより少なければ、文字@var{padchar}が左に追加されます(右詰めになります)。
@var{padchar}が省略された場合は空白文字が使われます。
@c COMMON

@example
(format #f "|~d|" 12345)
  @result{} "|12345|"
(format #f "|~10d|" 12345)
  @result{} "|     12345|"
(format #f "|~10,'0d|" 12345)
  @result{} "|0000012345|"
@end example

@c EN
If atmark-flag is given, the sign `@code{+}' is printed for the
positive argument.
@c JP
アトマーク `@code{@@}' フラグが与えられた場合、正の引数に対して `@code{+}' が
先頭につけられます。
@c COMMON

@c EN
If colon-flag is given, every @var{interval}-th digit of
the result is grouped and @var{commachar} is inserted between them.
The default of @var{commachar} is `@code{,}', and the default of
@var{interval} is 3.
@c JP
コロンフラグ `@code{:}' が与えられた場合、結果の文字は@var{interval}文字毎に
まとめられ、間に文字@var{commachar}が挿入されます。デフォルトでは3文字毎にコンマが
挿入されます。
@c COMMON

@example
(format #f "|~:d|" 12345)
  @result{} "|12,345|"
(format #f "|~,,'_,4:d|" -12345678)
  @result{} "|-1234_5678|"
@end example

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{B}
@c EN
Binary output.  The argument is formatted as a binary integer.
The semantics of parameters and flags are the same as
the @code{~D} directive.
@c JP
2進出力。対応する引数が2進数の整数としてフォーマットされます。
パラメータの意味は@code{~D}と同じです。
@c COMMON

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{O}
@c EN
Octal output.  The argument is formatted as an octal integer.
The semantics of parameters and flags are the same as
the @code{~D} directive.
@c JP
8進出力。対応する引数が8進数の整数としてフォーマットされます。
パラメータの意味は@code{~D}と同じです。
@c COMMON

@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{X}
@item @b{~}@var{mincol},@var{padchar},@var{commachar},@var{interval}@b{x}
@c EN
Hexadecimal output.
The argument is formatted as a hexadecimal integer.
If `@code{X}' is used, upper case alphabets are used for
the digits larger than 10.  If `@code{x}' is used, lower case
alphabets are used.
The semantics of parameters and flags are the same as
the @code{~D} directive.
@c JP
16進出力。対応する引数が16進数の整数としてフォーマットされます。
フォーマット指示文字に `@code{X}' が与えられた場合は `@code{ABCDEF}' が桁文字として
使われ、 `@code{x}' が与えられた場合は `@code{abcdef}' が桁文字として使われます。
パラメータの意味は@code{~D}と同じです。
@c COMMON

@example
(format #f "~8,'0x" 259847592)
  @result{} "0f7cf5a8"
(format #f "~8,'0X" 259847592)
  @result{} "0F7CF5A8"
@end example

@item @b{~}@var{count}@b{*}
@c EN
Moves the argument counter @var{count} times forward, effectively skips
next @var{count} arguments.  The default value of @var{count} is 1,
hence skip the next argument.  If a colon-flag is given, moves the argument
counter backwards, e.g. @code{~:*} makes the next directive to process
last argument again.  If an atmark-flag is given, @var{count} specifies
absolute position of the arguments, starting from 0.
@c JP
引数のカウンタを@var{count}だけ後方にずらします。つまり、@var{count}個の引数が
無視されることになります。@var{count}のデフォルト値は1です。
コロンフラグが与えられた場合は引数カウンタを前方に動かします。
例えば@code{~:*}は次のディレクティブが直前に使った引数を再び使うようにします。
アトマークフラグが与えられた場合は、@var{count}が引数の絶対位置を示します。
0が最初の引数です。
@c COMMON
@end table

@end defun


@c ----------------------------------------------------------------------
@node Loading Programs, Comparison and sorting, Input and output, Core library
@section Loading Programs
@c NODE プログラムのロード

@menu
* Loading Scheme file::         
* Loading dynamic library::     
* Require and provide::         
* Autoload::                    
@end menu

@node Loading Scheme file, Loading dynamic library, Loading Programs, Loading Programs
@subsection Loading Scheme file
@c NODE Schemeファイルのロード

@defun load file &keyword paths (error-if-not-found #t) environment
[R5RS+]
@c EN
Loads @var{file}, that is, read Scheme expressions in @var{file} and
evaluates them.
An extension ``@code{.scm}'' may be omitted from @var{file}.

If @var{file} doesn't begin with ``/'' or ``./'' or ``../'',
it is searched from the system file search list,
stored in a variable @code{*load-path*}.
Or you can explicitly specify the search path by passing
a list of directory names to the keyword argument @var{paths}.

On success, @code{load} returns @code{#t}.
If the specified file is not found, an error is signalled unless
the keyword argument @var{error-if-not-found} is @code{#f}, in
which case @code{load} returns @code{#f}.

If a module is given to the keyword argument @var{environment},
@code{load} works as if the given module is selected at the beginning
of the loaded file.

The current module is preserved; even @code{select-module} is
called in @var{file}, the module in which @code{load} is called
is restored afterwards.

If you want to load a library file, it's better to use `@code{use}'
(@xref{Defining and selecting modules}), or `@code{require}' described below.
@xref{Compilation}, for difference between @code{load} and @code{require}.
@c JP
@var{file}をロードします。すなわち、@var{file}に書かれたScheme式を順次読み込んで
評価します。@var{file}の拡張子 (``@code{.scm}'') は省略できます。

@var{file}が ``/'', ``./'' または ``../'' で始まっていない場合は、
システムファイルサーチパス (変数@code{*load-path*} に格納されています)
の中から該当ファイルが探されます。あるいは、キーワード引数@var{paths}にディレクトリ名の
リストを渡すことによりサーチパスを指定することもできます。

ロードに成功した場合は@code{#t}が返されます。
指定ファイルがみつからない場合はエラーとなりますが、もしキーワード引数
@code{error-if-not-found}に@code{#f}が与えられていれば単に@code{load}から
@code{#f}が返されます。

キーワード引数@var{environment}にモジュールが渡された場合は、
あたかもそのモジュールがファイルの先頭でselectされたかのように
@code{load}されます。

カレントモジュールは保存されます。つまり、@var{file}中で@code{select-module}によって
カレントモジュールを変更しても、@code{load}が終わったら@code{load}を読んだ時点の
モジュールに戻ります。

ライブラリファイルをロードする場合は、`@code{use}' (@ref{Defining and selecting modules}参照) を
使うか、下に説明する`@code{require}' を使う方が良いでしょう。
@code{load}と@code{require}の違いについては@ref{Compilation}を参照してください。
@c COMMON
@end defun

@defvar *load-path*
@c EN
Keeps a list of directories that are searched by @code{load} and
@code{require}.

If you want to add other directories to the search path,
do not modify this variable directly; use @code{add-load-path},
described below, instead.
@c JP
@code{load}と@code{require}がファイルを探すディレクトリのリストを保持しています。

もしサーチパスにディレクトリを追加したい場合は、この変数を直接変更せずに、下に説明する
@code{add-load-path}を用いて下さい。
@c COMMON
@end defvar

@defspec add-load-path path &optional (afterp #f)
@c EN
Adds a path @var{path} to the library load path list.
If a true value is given to @var{afterp}, @var{path} is added
after the existing paths; otherwise, @var{path} is added before the
existing paths.

Use this form instead of changing @code{*load-path*} directly.
This form is a special form and recognized by the compiler;
if you change @code{*load-path*}, it is in effect at run time,
and that may be too late for ``use'' or ``require''.

Furthermore,
@code{add-load-path} looks for the architecture dependent directories
under the specified path and if it exists, sets up the internal
path list for dynamic loading correctly.   Suppose you have
your Scheme module in @code{/home/yours/lib}, and that requires 
a dyncamic loadable library.  You can put the library under
@code{/home/yours/lib/@var{ARCH}/}, where @var{ARCH} is
the value @code{(gauche-architecture)} returns (@xref{Environment Inquiry}).
Then you can have compiled libraries for multiple platforms and
Gauche can still find the right library.
@c JP
パス@var{path}をライブラリロードパスのリストに加えます。
@var{afterp}に真の値が与えられていれば@var{path}は既存のリストの末尾に
追加されます。そうでなければ@var{path}は既存のリストの先頭に追加されます。

ロードパスを変更したい場合、@code{*load-path*}を直接替えずにこのフォームを
使って下さい。このフォームはコンパイル時に解釈されるのに対し、@code{*load-path*}を
書き換えるコードは実行時に解釈されます。``@code{use}'' や ``@code{require}'' は
コンパイル時のロードパスを使うので、@code{*load-path*}への変更は反映されないかもしれません。

更に、@code{add-load-path}は@var{path}の下にアーキテクチャ依存のディレクトリが
ないかどうかを探し、あればそれを内部の共有ライブラリサーチパスに追加します。
例えばあなたが自分のSchemeモジュールを@code{/home/yours/lib}に入れていて、
それが共有ライブラリを必要としていたとします。手続き@code{gauche-architecture}
(@ref{Environment Inquiry}参照)が返す値を@var{ARCH}として、
共有ライブラリを@code{/home/yours/lib/@var{ARCH}/}に置いておくと、
共有ライブラリはそこからロードされます。この方法を取ると、複数のプラットフォーム用に
別々にコンパイルされた共有ライブラリを管理することができます。
@c COMMON
@end defspec

@defun load-from-port port
@c EN
Reads Scheme expressions from an input port @var{port} and evaluates
them, until EOF is read.
@c JP
入力ポート@var{port}から、EOFを読むまで繰り返しScheme式を読み込み評価します。
@c COMMON
@end defun

@defun current-load-port
@defunx current-load-history
@defunx current-load-next
@c EN
These procedures allows you to query the current context of loading.
They returns the following values when called inside a file being loaded:
@table @code
@item current-load-port
Returns the port object from which the file is being read.
@item current-load-history
Returns a list of pairs of a port and a line number (integer),
representing the nesting of loads.  Suppose you load
@file{foo.scm}, and from its line 7 it loads @file{bar.scm}, 
and from its line 18 it loads @file{baz.scm}.   If you call
@code{current-load-history} in the file @file{baz.scm}, you'll get
@example
((#<port "foo.scm"> . 7) (#<port "bar.scm"> . 18))
@end example
@item current-load-next
Returns a list of remaining directories to be searched
at the time this file is found.   Suppose the @code{*load-path*}
is @code{("." "../lib" "/home/gauche/lib" "/share/gauche/lib")}
and you load @file{foo.scm}, which happens to be in @file{../lib/}.
Then, inside @file{foo.scm}, @code{current-load-next} returns:
@example
("/home/gauche/lib" "/share/gauche/lib")
@end example
@end table

When called outside of @code{load}, these procedures returns
@code{#f}, @code{()} and @code{()}, respectively.
@c JP
これらの手続きによって、現在のロードのコンテクストを知ることができます。
ロードされているファイルの中でこれらの手続きを呼ぶと、次のような値が返されます。
@table @code
@item current-load-port
現在のファイルがロードされている入力ポート。
@item current-load-history
入力ポートと行番号のペアのリストで、ロードのネスティングを示したもの。
例えばあなたが@file{foo.scm}をロードし、そのファイルの7行目で
@file{bar.scm}がロードされ、そのファイルの18行目で@file{baz.scm}が
ロードされたとします。@code{current-load-history}を@file{baz.scm}中で
呼ぶと、それは次のような値を返します。
@example
((#<port "foo.scm"> . 7) (#<port "bar.scm"> . 18))
@end example
@item current-load-next
現在のファイルがロードされた時点での、ファイルサーチパスの残りを返します。
例えば @code{*load-path*} が
@code{("." "../lib" "/home/gauche/lib" "/share/gauche/lib")}で、
あなたが@file{foo.scm}をロードしたところ、それが@file{../lib/}中に見つかったと
しましょう。このとき、@file{foo.scm}中で@code{current-load-next}を呼べば
@example
("/home/gauche/lib" "/share/gauche/lib")
@end example
が返されます。
@end table

@code{load}されていない状態で呼ばれた時は、これらの手続きはそれぞれ@code{#f}、
@code{()}、@code{()}を返します。
@c COMMON
@end defun


@node Loading dynamic library, Require and provide, Loading Scheme file, Loading Programs
@subsection Load dynamic library
@c NODE ダイナミックライブラリのロード

@defun dynamic-load file &keyword init-function export-symbols
@c EN
Loads and links a dynamic loadable library (shared library) @var{file}.
@var{File} shouldn't contain the suffix (``.so'' on most systems);
@code{dynamic-load} adds it, for it may differ among platforms.

The keyword argument @var{init-function} specifies the initialization
function name of the library in a string.  By default, if the file
basename (without extension) is ``foo'', the initialization function
name is ``Scm_Init_foo''.

The keyword argument @var{export-symbols} tells whether the dynamic loader
that the external symbols in @var{file} should be appended to
the symbol table of the running process.  (Note: I'm talking about
C function and variable names, not Scheme symbols).
By default, the symbols
in @var{file} are not visible from other dynamically loaded libraries.
If you want to allow other dynamically loaded libraries to call
C function in your library, you should give @code{#t} to this 
argument.  It sets @code{RTLD_GLOBAL} flag for @code{dlopen()}.

Usually a dynamic loadable library is provided with wrapping Scheme
module, so the user doesn't have to call this function directly.

There's no way to unload the loaded libraries.
@c JP
ダイナミックローダブルライブラリ(共有ライブラリ)@var{file}をロードしてリンクします。
@var{file}にはサフィックス(``.so'' 等) を含めないで下さい。システムによって
サフィックスは異なるため、@code{dynamic-load}がそれを追加します。

キーワード引数@var{init-function}は共有ライブラリ中の初期化関数の名前を
指定します。デフォルトでは、サフィックスを除くファイル名が ``foo'' の場合、
初期化関数名は ``Scm_Init_foo'' となります。

キーワード引数@var{export-symbols}は、ロードされるライブラリ中の外部シンボルを
プロセスのシンボルテーブルに追加すべきかどうかを指定します。(註：ここでの「シンボル」
とはCの関数名や変数名のことで、Schemeのシンボルのことではありません)。
デフォルトでは共有ライブラリの外部シンボルはプロセスのシンボルテーブルに追加されず、
それぞれの共有ライブラリは他の共有ライブラリのシンボルを見ることができません。
@var{export-symbols}に真の値を渡すと、フラグ@code{RTLD_GLOBAL}が
@code{dlopen()}に渡されて、その共有ライブラリ中のシンボルがこれからロードされる
共有ライブラリからも見えるようになります。

通常、共有ライブラリはSchemeモジュール中でロードされるので、モジュールユーザが
直接この手続きを呼ぶ必要はほとんどないでしょう。

一度ロードされた共有ライブラリをアンロードすることはできません。
@c COMMON
@end defun


@node Require and provide, Autoload, Loading dynamic library, Loading Programs
@subsection Require and provide
@c NODE requireとprovide

@defspec require feature
@c EN
If @var{feature} is not loaded, load it.  @var{Feature} must be a string,
and it is taken as a file name (without suffix) to be loaded.
This loading takes place at compile time.   The loaded file must provide
@var{feature}; if not, a warning is issued.

If you load SLIB module, @code{require} is extended.  @xref{slib - SLIB} for
details.
@c JP
@var{feature}がまだロードされていなければロードします。@var{feature}は文字列で
なければなりません。それがそのまま(サフィックスを除く)ファイル名としてロードパスから
探されます。@code{require}の解釈はコンパイル時に行われます。
ロードされたファイルはその中で@var{feature}をprovideしなければなりません。
そうでないと警告が出されます。

SLIBモジュールをロードすると、@code{require}が拡張されます。詳しくは@ref{slib - SLIB}を
参照して下さい。
@c COMMON
@end defspec

@defun provide feature
@c EN
Adds @var{feature} to the system's provided feature list, so that
the subsequent @code{require} won't load the same file again.
Usually this procedure should be called at the end of the Scheme file
that is to be @code{require}d.   The reason that it should be at the end
of file is that if an error is raised during loading, you may want to
fix the error and @code{require} it again.
@c JP
@var{feature}をシステムのprovideされたフィーチャーリストに加えます。
以降、@var{feature}が@code{require}されてもファイルはふたたびロードされません。
通常この手続きは、requireされるファイルの末尾で呼ばれます。ファイルの末尾で呼ぶのが良いのは、
もしファイルのロード中にエラーが発生した場合、そのエラーを修正した上でふたたび@code{require}
でロードできるからです。
@c COMMON
@end defun

@defun provided? feature
@c EN
Returns @code{#t} if @var{feature} is already provided.
@c JP
@var{feature}が既にprovideされていれば@code{#t}を返します。
@c COMMON
@end defun

@node Autoload,  , Require and provide, Loading Programs
@subsection Autoload

@defmac autoload file/module item @dots{}
@c EN
Sets up @var{item} @dots{} to be autoloaded.
That is, when an @var{item} is referenced for the first time,
@var{file/module} is loaded before the @var{item} is evaluated.
This delays the loading of @var{file/module} until it is needed.
@c JP
@var{item} @dots{} がオートロードされるように設定します。すなわち、
次に@var{item}が参照された時、それが実際に評価される前に@var{file/module}がロード
されるようにします。これによって、必要とされる時まで@var{file/module}のロードを遅らせる
ことができます。
@c COMMON

@c EN
You can specify either a string file name or a symbol module name
to @var{file/module}.  If it is a string, the named file is
loaded.  If it is a symbol, the named module is loaded (using the
same rule as of @code{use}), then the binding of @var{item} in the
@var{file/module} is imported to the module used the autoload
(@xref{Defining and selecting modules}, for details of @code{use}).
@c JP
引数@var{file/module}には、文字列かシンボルを指定できます。文字列の場合は
そのファイルがロードされます。シンボルの場合、その名のモジュールが(@code{use}と
同じルールで)ロードされ、@var{item}が@var{file/module}から
オートロードを呼び出したモジュールへとインポートされます。
(モジュールの@code{use}の詳細については@ref{Defining and selecting modules}を参照して下さい)。
@c COMMON

@c EN
@var{Item} can be either a variable name (symbol), 
or a form @code{(:macro @var{symbol})}.  If it is a variable,
the named file/module is loaded when the variable is
about to be evaluated.  If it is the latter form,
the named file/module is loaded when a form
@code{(@var{symbol} arg @dots{})} is about to be @emph{compiled},
which enables autoloading macros.
@c JP
@var{item}は変数名(シンボル)か、@code{(:macro @var{symbol})}というフォーム
でなければなりません。変数名の場合は、その変数が評価されようとした時に
指定のファイル／モジュールがロードされます。後者のフォームの場合は、
@code{(@var{symbol} arg @dots{})} というフォームがコンパイルされようとした
時に指定のファイル／モジュールがロードされます。後者はマクロのオートロードになります。
@c COMMON

@c EN
@var{file/module} must define @var{symbol} in it, or an error is signalled
when @var{file/module} is autoloaded.
@c JP
@var{symbol}は@var{file/module}の中で定義されなければなりません。
そうでなければロード時にエラーが報告されます。
@c COMMON

@c EN
The following is an example of autoloading procedures.
@c JP
手続きのオートロードの例を示します。
@c COMMON
@example
(autoload "foo" foo0 foo1)
(autoload "bar" bar0 bar1)

(define (foobar x)
  (if (list? x)
      (map bar0 x)
      (foo0)))

@c EN
(foobar '(1 2)) ; @r{"bar" is loaded at this moment}

(foobar #f)     ; @r{"foo" is loaded at this moment}
@c JP
(foobar '(1 2)) ; @r{この時点で "bar" がロードされる}

(foobar #f)     ; @r{この時点で "foo" がロードされる}
@c COMMON
@end example

@c EN
Note that if you set to autoload macro, the file/module is loaded
immediately when such form that uses the macro is compiled,
regardless of the piece of
the code is executed or not.
@c JP
マクロのオートロードを設定した場合、指定のファイルまたはモジュールは、
そのマクロを使っているフォームが実行されるされないにかかわらず、
コンパイラがそのフォームを見た時点でロードされることに注意してください。
@c COMMON
@end defmac


@c ----------------------------------------------------------------------
@node Comparison and sorting, System interface, Loading Programs, Core library
@section Comparison and sorting
@c NODE 比較とソート

@defun compare obj1 obj2
@end defun

@deffn {Generic Function} object-compare obj1 obj2
@end deffn

@defun sort seq &optional cmfpn
@defunx sort! seq &optional cmfpn
Sorts elements in a sequence @var{seq} (a list or a vector) 
in ascending order and returns the sorted sequence.
@code{sort!} destructively reuses the original sequence.
The sorting order is specified by @code{cmpfn}, which is
a procedure takes two elements of @var{list}, and returns @code{#t}
if the first argument strictly precedes the second.

@example
(sort '(("Chopin" "Frederic") 
        ("Liszt" "Franz")
        ("Alkan" "Charles-Valentin"))
      (lambda (x y) (string<? (car x) (car y))))
  @result{} (("Alkan" "Charles-Valentin")
             ("Chopin" "Frederic")
             ("Liszt" "Franz"))
@end example

Some builtin objects have natural comparison order, and it is used
if @code{cmpfn} is omitted.

Built-in sort function uses quicksort and heapsort algorithm, 
so it is not a stable sort.
@end defun


@c ----------------------------------------------------------------------
@node System interface,  , Comparison and sorting, Core library
@section System interface
@c NODE システムインタフェース

@c EN
Gauche supports most of POSIX.1 functions and other system functions
popular among Unix variants as built-in procedures.
@c JP
GaucheはPOSIX.1の多くの関数と、さまざまなUnixで共通して使われているシステム関数へのインタフェースを
組込み手続きとして提供しています。
@c COMMON

@c EN
Lots of Scheme implementations provide some sort of system interface
under various APIs.  Some are just called by different names
(e.g, @code{delete-file} or @code{remove-file} or @code{unlink} to delete
a file), some do more abstraction introducing new Scheme objects.
Instead of just picking one of such interfaces, I decided to implement
Gauche's system interface API in two layers; the lower level layer,
described in this section, follows the operating system's API
as close as possible.  On top of that, the higher-level APIs are
provided, with considering compatibility to the existing systems.
@c JP
多くのScheme実装はいろいろな形で何らかのシステムインタフェースを提供
しています。名前だけが違うもの(例：@code{delete-file}、@code{remove-file}
、@code{unlink}) もあれば、新しいSchemeオブジェクトを導入して
抽象化を行っているものもあります。Gaucheでは、既存のAPIのどれかを
そのまま真似るのではなく、2つのレイヤを提供することにしました。
この章で述べられる低レベルレイヤは、OSのインタフェースに似せたものを実装します。
その上に、既存のシステムと互換性のある高レベルのインタフェースが実装されます。
@c COMMON

@c EN
The low level system interface has the name @code{sys-}@var{name}
and usually correspond to the system call @var{name}.
I tried to keep the interface similar whenever reasonable.
@c JP
@code{sys-}@var{name}という名前を持つ手続きは、多くの場合、
システムコール@var{name}に対応しています。
可能な限り、インタフェースが似るようにしました。
@c COMMON

@c EN
If you are familiar with system programming in C,
see also @ref{C to Scheme mapping}, which shows
correspondence between C standard library functions
and Gauche procedures.
@c JP
Cによるシステムプログラミングに慣れている方は、
@ref{C to Scheme mapping}も参考にして下さい。
Cの標準ライブラリとGaucheの手続きとの対応が示してあります。
@c COMMON

@menu
* Program termination::         
* Environment Inquiry::         
* Filesystems::                 
* Unix groups and users::       
* Locale::                      
* Signal::                      
* System Inquiry::              
* Time::                        
* Unix process management::     
* I/O multiplexing::            
* Miscellaneous system calls::  
@end menu

@node Program termination, Environment Inquiry, System interface, System interface
@subsection Program termination
@c NODE プログラムの終了

@defun exit &optional (code 0)
[POSIX]
@c EN
Terminates the current process with the exit code @var{code}.
@var{Code} must be zero or positive exact integer.
This procedure first invokes the @var{after} thunks of the current dynamic
handlers (@xref{Continuation}), then flushes opened file buffers,
finally calls @code{exit(2)}.
@c JP
現在のプロセスを終了し、@var{code}を終了コードにします。
@var{code}はゼロもしくは正の正確な整数でなければなりません。
この手続きはまずアクティブなダイナミックハンドラの@var{after}手続きを全て呼び出し
(@xref{Continuation})、続いてオープンされている出力ポートのバッファを
フラッシュし、最後に@code{exit(2)}を呼び出します。
@c COMMON
@end defun


@defun sys-exit &optional (code 0)
[POSIX]
@c EN
Terminates the current process with the exit code @var{code}.
@var{Code} must be zero or positive exact integer.
This procedure calls @code{_exit(2)} directly.
No cleanup is done.  Unflushed file output is discarded.
@c JP
現在のプロセスを終了し、@var{code}を終了コードにします。
@var{code}はゼロもしくは正の正確な整数でなければなりません。
この手続きは@code{_exit(2)}を直接コールします。
クリーンアップは一切行われません。
フラッシュされてないファイルバッファの内容は捨てられます。
@c COMMON
@end defun

@defun sys-abort
[POSIX]
@c EN
Calls POSIX abort().  This usually terminates the running process 
and dumps core.  No cleanup is done.
@c JP
POSIXのabort()を呼びます。通常、現在のプロセスは終了され、コアダンプされます。
クリーンアップは一切行われません。
@c COMMON
@end defun

@node Environment Inquiry, Filesystems, Program termination, System interface
@subsection Environment Inquiry
@c NODE 環境の問い合わせ

@defun sys-getenv name
[POSIX]
@c EN
Returns the value of the environment variable @var{name} as a string,
or @code{#f} if the environment variable is not defined.
@c JP
環境変数@var{name}の値を文字列で返します。もし@var{name}が定義されていなければ、
@code{#f}が返ります。
@c COMMON
@end defun

@defun sys-putenv name value
@c EN
Add environment variable @var{name} with @var{value} to the current
process's environment.  If the system doesn't support putenv(3),
this function signals an error.
@c JP
プロセスの環境変数@var{name}に値@var{value}をセットします。システムが
putenv()をサポートしていない場合はエラーが通知されます。
@c COMMON
@end defun

@defun gauche-version
@defunx gauche-architecture
@defunx gauche-library-directory
@defunx gauche-architecture-directory
@defunx gauche-site-library-directory
@defunx gauche-site-architecture-directory
@c EN
These functions returns a string that tells information about Gauche
interpreter itself.
@c JP
これらの手続きはGaucheインタプリタの情報を文字列で返します。
@c COMMON
@end defun

@node Filesystems, Unix groups and users, Environment Inquiry, System interface
@subsection Filesystems
@c NODE ファイルシステム

@c EN
System calls that deal with filesystems.
See also @ref{file.util - Filesystem utilities}, which defines high-level APIs
on top of the procedures described here.
@c JP
ファイルシステムに関するシステムコール群です。
ここで述べる手続きの上に、より高レベルなAPIがモジュール@code{file.util}として
実装されています。@ref{file.util - Filesystem utilities}を参照して下さい。
@c COMMON

@menu
* Directories::                 
* Directory manipulation::      
* Pathnames::                   
* File stats::                  
* Other file operations::       
@end menu

@node Directories, Directory manipulation, Filesystems, Filesystems
@subsubsection Directories
@c NODE ディレクトリ

@c EN
See also @ref{Directory utilities} for high-level API.
@c JP
高レベルAPIに関しては@ref{Directory utilities}も参照して下さい。
@c COMMON

@defun sys-readdir path
@c EN
@var{path} must be a string that denotes valid pathname of an existing
directory.  This function returns a list of strings of the directory
entries.  The returned list is not sorted.  An error is signalled
if @var{path} doesn't exists or is not a directory.
@c JP
@var{path}は存在するディレクトリを示すパス名でなければなりません。
この手続きはディレクトリの全エントリを文字列のリストとして返します。
リストはソートされません。@var{path}が存在しなかったり、ディレクトリでなかった場合は
エラーとなります。
@c COMMON
@end defun

@defun sys-glob pattern
@c EN
An interface to @code{glob(3)} function.  @var{pattern} is a file pattern
like sh(1): a character `@code{?}' matches any single character, 
`@code{*}' matches zero or more characters, `@code{[abc]}' matches
either `@code{a}', `@code{b}' or `@code{c}'.  If no pathname matches
@var{pattern}, an empty list is returned.

If the undelying platform doesn't have @code{glob()}, this function
signals an error of "feature not supported".

Note: it is known that on some systems glob() implementation has
a security issue.  Gauche will eventually implement glob() functionality
in itself.
@c JP
glob(3)関数へのインタフェースです。@var{pattern}はsh(1)で使われるパターンです:
`@code{?}'は任意の一文字にマッチし、`@code{*}'は0以上の任意の文字にマッチし、
`@code{[abc]}'は文字`@code{a}', `@code{b}', `@code{c}' のいずれにも
マッチします。マッチするパス名が無ければ空のリストが返されます。

glob()をサポートしていないシステムでは、エラーが通知されます。

註：glob()の実装にセキュリティ上の問題のあるシステムがあることが知られています。
Gaucheではいずれ、自前のglob()実装を持つ予定です。
@c COMMON
@end defun

@c EN
@xref{File stats}, to check if a path is actually a directory.
@c JP
パスがディレクトリかどうかチェックする方法は、@ref{File stats}を参照してください。
@c COMMON

@node Directory manipulation, Pathnames, Directories, Filesystems
@subsubsection Directory manipulation
@c NODE ディレクトリ操作

@defun sys-remove filenmae
[POSIX] 
@c EN
If @var{filename} is a file it is removed.
On some systems this may also work on an empty directory,
but portable scripts shouldn't depend on it.
@c JP
@var{filename}がファイルであればそれを消去します。
システムによっては@var{filename}が空のディレクトリであっても動作しますが、
移植性を気にする場合はその動作に依存しない方が良いでしょう。
@c COMMON
@end defun

@defun sys-rename old new
[POSIX]
@c EN
Renames a file @var{old} to @var{new}.  The new name
can be in different directory from the old name, but both paths
must be on the same device.
@c JP
ファイル@var{old}を@var{new}にリネームします。新しい名前は
古い名前と異なるディレクトリにあってもかまいませんが、両者は同じデバイス上に
なければなりません。
@c COMMON
@end defun

@defun sys-tmpnam
[POSIX]
@c EN
Creates a file name which is supposedly unique, and returns it.
This is in POSIX, but its use is discouraged because of potential
security risk.  Use @code{sys-mkstemp} below if possible.
@c JP
ユニークなファイル名を作成して返します。この関数はPOSIXに含まれていますが、
セキュリティ上の問題が指摘されており、使わない方が良いとされています。
可能なら下にあげる@code{sys-mkstemp}を使って下さい。
@c COMMON
@end defun

@defun sys-mkstemp template
@c EN
Creates and opens a file that has unique name, and returns two values;
opened port and the created filename.  The file is created exclusively,
avoiding race conditions.   @var{tmpname} is used as the prefix
of the file.  Unlinke Unix's mkstemp, you don't need padding characters.
The file is opened for writing, and its permission is set to 600.
@c JP
ユニークな名前を持つファイルを作成してオープンし、オープンされたポートとファイル名の
二つの値を返します。ファイルは排他的に作成されるため、レースコンディションは起こりません。
@var{tmpname}はファイル名のプレフィックスに使われます。Unixのmkstempと違って、
パディングキャラクタをつける必要はありません。ファイルは書き込み用としてオープンされ、
パーミッションは600にセットされます。
@c COMMON
@end defun

@defun sys-link existing new
[POSIX] 
@c EN
Creates a hard link named @var{new} to the existing file @var{existing}.
@c JP
既存のファイル@var{existing}に対し、@var{new}という名のハードリンクを作成します。
@c COMMON
@end defun

@defun sys-unlink pathname
[POSIX]
@c EN
Removes @var{pathname}.  It can't be a directory.
Returns @code{#t} if it is successfully removed, or
@var{#f} if @var{pathname} doesn't exist.
An error is signalled otherwise.
@c JP
@var{pathname}で示されるファイルを消去します。
@var{pathname}はディレクトリであってはなりません。
もし消去に成功したら@code{#t}が、@var{pathname}が存在しなければ@code{#f}が返されます。
他の場合はエラーが通知されます。
@c COMMON
@end defun

@defun sys-symlink existing new
@c EN
Creates a symbolic link named @var{new} to the pathname @var{existing}.
On systems that doesn't support symbolic links,
this function is unbound.
@c JP
@var{existing}を指す@var{new}という名のシンボリックを作成します。
シンボリックリンクをサポートしないシステムでは、この手続きは定義されません。
@c COMMON
@end defun

@defun sys-readlink path
@c EN
If a file specified by @var{path} is a symbolic link, its content is
returned.  If @var{path} doesn't exist or is not a symbolic link, an
error is signalled.
On systems that don't support symbolic links,
this function is unbound.
@c JP
@var{path}で示されるファイルがシンボリックリンクならば、それが指すパスを返します。
もし@var{path}が存在しなかったり、シンボリックリンクでなければ、エラーが通知されます。
シンボリックリンクをサポートしないシステムでは、この手続きは定義されません。
@c COMMON
@end defun

@defun sys-mkdir pathname mode
[POSIX] 
@c EN
Makes a directory @var{pathname} with mode @var{mode}.
(Note that @var{mode} is masked by the current umask;
see @code{sys-umask} below).
The parent directory of @var{pathname} must exist and be writable
by the process.  To create intermediate directories at once, use
@code{make-directory*} in @code{file.util} (@ref{Directory utilities}).
@c JP
ディレクトリ@var{pathname}をモード@var{mode}で作成します。
(@var{mode}はさらにumaskでマスクされることに注意して下さい；下の@code{sys-umask}
参照)。
@var{pathname}の親ディレクトリは存在して、プロセスが書き込めるようになっていなければ
なりません。中間のディレクトリも一度に作成するには、
@code{file.util}の@code{make-directory*}が使えます
(@ref{Directory utilities})。
@c COMMON
@end defun

@defun sys-rmdir pathname
[POSIX]
@c EN
Removes a directory @var{pathname}.  The directory must be empty.
To remove a directory with its contents, use @code{remove-directory*}
in @code{file.util} (@ref{Directory utilities}).
@c JP
ディレクトリ@var{pathname}を消去します。ディレクトリは空でなければなりません。
ディレクトリの内容も一緒に消去するには、@code{file.util}の@code{remove-directory*}
が使えます(@ref{Directory utilities})。
@c COMMON
@end defun

@defun sys-umask mode
[POSIX] 
@c EN
Sets umask setting to @var{mode}.  Returns previous umask setting.
See @code{man umask} for more details.
@c JP
umaskを@var{mode}にセットします。変更される前のumaskを返します。
umaskについては@code{man umask}を参照してください。
@c COMMON
@end defun

@node Pathnames, File stats, Directory manipulation, Filesystems
@subsubsection Pathnames
@c NODE パス名

@c EN
See also @ref{Pathname utilities}, for high-level APIs.
@c JP
高レベルのAPIに関しては@ref{Pathname utilities}も参照して下さい。
@c COMMON

@defun sys-normalize-pathname pathname &keyword absolute expand canonicalize
@c EN
Converts @var{pathname} according to the way specified by keyword arguments.
More than one keyword argument can be specified.
@c JP
与えられたキーワード引数によって@var{pathname}を以下のように変換します。
キーワード引数は同時に複数指定できます。
@c COMMON
@table @code
@item absolute
@c EN
  If this keyword arugment is given and true, and @var{pathname} is not
  an absolute pathname, it is converted to an absolute pathname by
  appending the current working directory in front of @var{pathname}.
@c JP
  このキーワード引数に真の値が与えられて、@var{pathname}が絶対パスでない場合、
  @var{pathname}の前にプロセスのワーキングディレクトリを足して絶対パスにします。
@c COMMON
@item expand
@c EN
  If this keyword argument is given and true, and @var{pathname} begins
  with `@code{~}', it is expanded as follows:
@c JP
  このキーワード引数に真の値が与えられて、@var{pathname}が`@code{~}' で始まっていた
  場合、以下のように展開されます。
@c COMMON
@itemize @bullet
@item
@c EN
    If @var{pathname} is consisted entirely by ``@code{~}'', or begins
    with ``@code{~/}'', then the character ``@code{~}'' is replaced
    for the pathname of the current user's home directory.
@c JP
    @var{pathname}が``@code{~}''のみであるか、または``@code{~/}''で始まっている
    場合、文字``@code{~}''が現在のプロセスのユーザのホームディレクトリに置き換えられます。
@c COMMON
@item
@c EN
    Otherwise, characters following `@code{~}' until either `@code{/}' or
    the end of @var{pathname} are taken as a user name, and the user's
    home directory is replaced in place of it.  If there's no such
    user, an error is signalled.
@c JP
    上記以外の場合、`@code{~}'以降、`@code{/}'か@var{pathname}の終端までの文字列
    がユーザ名とみなされ、そのユーザのホームディレクトリに置換されます。もし該当するユーザが
    いなければエラーとなります。
@c COMMON
@end itemize
@item canonicalize
@c EN
  Tries to remove pathname components ``@code{.}'' and ``@code{..}''.
  The pathname interpretation is done purely in textural level, i.e.
  it doesn't access filesystem to see the conversion reflects the
  real files.  It may be a problem if there's a symbolic links to
  other directory in the path.
@c JP
  パス名から ``@code{.}'' や ``@code{..}'' を除き、単純化します。
  この操作は実際のファイルシステムを参照せずに行われます。元のパス名がディレクトリへの
  シンボリックリンクを含んでいた場合、単純化されたパス名は正しくないかもしれません。
@c COMMON
@end table
@end defun

@defun sys-basename pathname
@defunx sys-dirname pathname
@c EN
@code{sys-basename} returns a basename, that is the last component of
@var{pathname}.  @code{sys-dirname} returns the components of @var{pathname}
but the last one.   If @var{pathname} has a trailing `@code{/}', 
it is simply ignored.
@c JP
@code{sys-basename}は与えられたパスのベース名、すなわち最後のコンポーネントを返します。
@code{sys-dirname}は与えられたパスのディレクトリ名、すなわち最後のコンポーネント以外の
コンポーネントを返します。@var{pathname}の末尾が`@code{/}'である場合、その文字は
無視されます。
@c COMMON
@example
(sys-basename "foo/bar/bar.z") @result{} "bar.z"
(sys-basename "coo.scm") @result{} "coo.scm"
(sys-basename "x/y/") @result{} "y"
(sys-dirname "foo/bar/bar.z") @result{} "foo/bar"
(sys-dirname "coo.scm") @result{} "."
(sys-dirname "x/y/") @result{} "x"
@end example
@c EN
These functions doesn't check if @var{pathname} really exists.
@c JP
この手続きは@var{pathname}が存在するかどうかはチェックしません。
@c COMMON

@c EN
Some boundary cases:
@c JP
特殊なケース：
@c COMMON
@example
(sys-basename "") @result{} ""
(sys-dirname "") @result{} "."

(sys-basename "/") @result{} ""
(sys-dirname "/") @result{} "/"
@end example
@c EN
Note: The above behavior is the same as Perl's @code{basename} and
@code{dirname}.   On some implementations, the command @code{basename}
may return @code{"/"} for the argument @code{"/"}, and
@code{"."} for the argument @code{"."}.
@c JP
註：このふるまいはPerlの@code{basename}および@code{dirname}と同様です。
システムによっては、コマンドの@code{basename}は@code{"/"}に対して@code{"/"}を、
@code{"."}に対して@code{"."}を返すものがあります。
@c COMMON
@end defun

@node File stats, Other file operations, Pathnames, Filesystems
@subsubsection File stats
@c NODE ファイルの状態

@c EN
See also @ref{File attribute utilities}, for high-level APIs.
@c JP
高レベルのAPIに関しては@ref{File attribute utilities}も参照して下さい。
@c COMMON

@defun file-exists? path
@defunx file-is-regular? path
@defunx file-is-directory? path
@c EN
Returns true if @var{path} exists, is a regular file, or is a directory,
respectively.   The latter two returns false if @var{path} doesn't
exist at all.

These functions are built on top of primitive
system interfaces described below; I provide these for convenience
and compatibility (STk has the same functions).
@c JP
それぞれ、@var{path}が存在するか、存在してそれがレギュラーファイルであるか、
存在してそれがディレクトリであれば@code{#t}を返します。

これらの手続きは便利であり、STkとの互換性もあるので定義されていますが、
実体は下に説明されている低レベル手続きの上に作成されています。
@c COMMON
@end defun

@deftp {Builtin Class} <sys-stat>
@clindex sys-stat
@c EN
An object that represents @code{struct stat}, attributes of an
entry in the filesystem.   It has the following read-only slots.
@c JP
ファイルシステム内のエントリの属性を表す、@code{struct stat}のラッパー
オブジェクトです。以下に示す読みだし専用のスロットを持ちます。
@c COMMON

@defivar <sys-stat> type
@c EN
A symbol represents the type of the file.
@c JP
ファイルのタイプを示すシンボルです。
@c COMMON
@multitable {aaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item @code{regular} @tab a regular file
@item @code{directory} @tab a directory
@item @code{character} @tab a character device
@item @code{block} @tab a block device
@item @code{fifo} @tab a fifo
@item @code{symlink} @tab a symbolic link
@item @code{socket} @tab a socket
@end multitable
@c EN
If the file type is none of the above, @code{#f} is returned.
@c JP
以上のどれにも当てはまらない場合は@code{#f}が返されます。
@c COMMON

@c EN
Note: Some operating systems don't have the @code{socket} file type
and returns @code{fifo} for socket files.   Portable programs should
check both possibilities to see if the given file is a socket.
@c JP
注：いくつかのオペレーティングシステムでは@code{socket}ファイルタイプを
@code{fifo}と区別せず、どちらに対しても@code{fifo}を返します。
ポータブルなプログラムを書くときは注意して下さい。
@c COMMON
@end defivar

@defivar <sys-stat> perm
@c EN
An exact integer for permission bits of @code{struct stat}.
It is the same as lower 9-bits of "mode" slot; provided for the convenience.
@c JP
パーミッションビットマスク。"mode"スロットの下位9ビットと同じですが、
便利なので独立したスロットとして提供されます。
@c COMMON
@end defivar

@defivar <sys-stat> mode
@defivarx <sys-stat> ino
@defivarx <sys-stat> dev
@defivarx <sys-stat> rdev
@defivarx <sys-stat> nlink
@defivarx <sys-stat> uid
@defivarx <sys-stat> gid
@defivarx <sys-stat> size
@c EN
An exact integer for those information of @code{struct stat}.
@c JP
@code{struct stat}の該当するフィールドの値。正確な整数です。
@c COMMON
@end defivar

@defivar <sys-stat> atime
@defivarx <sys-stat> mtime
@defivarx <sys-stat> ctime
@c EN
A number of seconds since Unix Epoch for those information of @code{struct stat}.
@c JP
@code{struct stat}の該当するフィールドの値を、Unix Epochからの秒数で。
@c COMMON
@end defivar
@end deftp

@defun sys-stat path
@defunx sys-fstat port-or-fd
[POSIX]
@c EN
Returns a @code{<sys-stat>} object of @var{path}, or
the underlying file of @var{port-or-fd}, which 
may be a port or a positive exact integer file descriptor, respectively.

If @var{path} is a symbolic link, a stat of the file the link points
to is returned from @code{sys-stat}.

If @var{port-or-fd} is not associated to a file, @code{sys-fstat} returns
@code{#f}.
@c JP
与えられたパス名@var{path}、またはポートかファイルディスクリプタ
@var{port-or-fd}で示されるファイルの情報を@code{<sys-stat>}オブジェクトで
返します。

@code{sys-stat}は、@var{path}がシンボリックリンクであった場合は
リンクの指す先のファイルに関する情報を返します。

@code{sys-fstat}は、@var{port-or-fd}がファイルに関係ないポートであった
場合は@code{#f}を返します。
@c COMMON
@end defun

@defun sys-lstat path
@c EN
Like @code{sys-stat}, but it returns a stat of a symbolic link
if @var{path} is a symbolic link.
@c JP
@code{sys-stat}と同じですが、@var{path}がシンボリックリンクであった
場合はリンクそのものの情報を返します。
@c COMMON
@end defun

@example
gosh> (describe (sys-stat "gauche.h"))
#<<sys-stat> 0x815af70> is an instance of class <sys-stat>
slots:
  type      : regular
  perm      : 420
  mode      : 33188
  ino       : 845140
  dev       : 774
  rdev      : 0
  nlink     : 1
  uid       : 400
  gid       : 100
  size      : 79549
  atime     : 1020155914
  mtime     : 1020152005
  ctime     : 1020152005
@end example

@defun sys-stat->mode stat
@defunx sys-stat->ino stat
@defunx sys-stat->dev stat
@defunx sys-stat->rdev stat
@defunx sys-stat->nlink stat
@defunx sys-stat->size stat
@defunx sys-stat->uid stat
@defunx sys-stat->gid stat
@defunx sys-stat->atime stat
@defunx sys-stat->mtime stat
@defunx sys-stat->ctime stat
@defunx sys-stat->file-type stat
@strong{Deprecated}.
@c EN
Use @code{slot-ref} to access information of @code{<sys-stat>} object.
@c JP
@code{<sys-stat>}オブジェクトの情報にアクセスするには@code{slot-ref}を
使って下さい。
@c COMMON
@end defun

@defun sys-access pathname amode
[POSIX]
@c EN
An interface to @code{access(2)}.
Returns a boolean value of indicating whether access of @var{pathname}
is allowed in @var{amode}.  @var{amode} can be a combinations (logical or) of
following predefined flags.
@c JP
@code{access(2)}へのインタフェースです。@var{pathname}へのアクセスが
@var{mode}に示されるモードで許可されているかどうかを示す真偽値を返します。
@var{mode}は以下に示す定数のコンビネーション(logical or)です。
@c COMMON
@table @code
@item R_OK
@vindex R_OK
@c EN
Checks whether @var{pathname} is readable by the current user.
@c JP
@var{pathname}をカレントユーザが読み出し可能かどうか
@c COMMON
@item W_OK
@vindex W_OK
@c EN
Checks whether @var{pathname} is writable by the current user.
@c JP
@var{pathname}へカレントユーザが書き込み可能かどうか
@c COMMON
@item X_OK
@vindex X_OK
@c EN
Checks whether @var{pathname} is executable (or searchable in case
@var{pathname} is a directory) by the current user.
@c JP
@var{pathname}をカレントユーザが実行可能かどうか(@var{pathname}が
ディレクトリの場合はサーチ可能かどうか)
@c COMMON
@item F_OK
@vindex F_OK
@c EN
Checks whether @var{pathname} exists or not, regardless of
the access permissions of @var{pathname}.  (But you need to have
access permissions of the directories containing @var{pathname}).
@c JP
@var{pathname}のパーミッションフラグにかかわらず、@var{pathname}が
存在するかどうか (但し@var{pathname}があるディレクトリの読みだし許可は必要)。
@c COMMON
@end table
@end defun

@defun sys-chmod path mode
@c EN
Change the mode of the file named @var{path} to @var{mode}.
@var{mode} must be a small positive integer whose lower 9 bits
specifies POSIX style permission.
@c JP
ファイル@var{path}のパーミッションビットを@var{mode}に変更します。
@var{mode}は小さな正の正確な整数で、POSIXスタイルのパーミッションビットマスク
でなければなりません。
@c COMMON
@end defun

@defun sys-chown path owner-id group-id
@c EN
Change the owner and/or group of the file named @var{path}
to @var{owner-id} and @var{group-id} respectively.
@var{owner-id} and @var{group-id} must be an exact integer.
If either of them is -1, the corresponding ownership is not changed.
@c JP
ファイル@var{path}のオーナーとグループを@var{owner-id}と@var{gruop-id}
で示されるものに変更します。@var{owner-id}と@var{gruop-id}は正確な整数で
なければなりません。どちらかに-1が渡された場合は、対応する情報は変更されません。
@c COMMON
@end defun

@defun sys-utime path &optional atime mtime
@c EN
Change the file's access time and modification time to @var{atime}
and @var{mtime}, respectively.   If @var{atime} and @var{mtime} is
omitted, they are set to the current time.
See also @code{touch-file} (@xref{File operations}).
@c JP
ファイルのアクセスタイムと変更タイムを@var{atime}と@var{mtime}が示す
値にセットします。@var{atime}と@var{mtime}が省略された場合は現在の時刻が
使われます。
@ref{File operations}の@code{touch-file}も参照して下さい。
@c COMMON
@end defun

@node Other file operations,  , File stats, Filesystems
@subsubsection Other file operations
@c NODE 他のファイル操作

@defun sys-chdir dir
[POSIX]
@c EN
An interface to @code{chdir(2)}. 
See also @code{current-directory} (@xref{Directory utilities}).
@c JP
@code{chdir(2)}へのインタフェースです。
@code{current-direoctry}(@ref{Directory utilities})も参照して下さい。
@c COMMON
@end defun

@defun sys-pipe &keyword (buffering :line)
[POSIX] Creates a pipe, and returns two ports.
The first returned port is an input port and the second is an output port.
The data put to the output port can be read from the input port.

@var{Buffering} can be @code{:full}, @code{:line} or @code{:none}, 
and specifies the buffering mode of the ports opened on the pipe.
@xref{File ports}, for details of the buffering mode.
The default mode is sufficient for typical cases.

@example
(receive (in out) (sys-pipe)
  (display "abc\n" out)
  (flush out)
  (read-line in)) @result{} "abc"
@end example

Note: the returned value is changed from version 0.3.15, in which
@code{sys-pipe} returned a list of two ports.
@end defun

@defun sys-mkfifo path mode
[POSIX] creates a fifo (named pipe) with a name @var{path} and mode
@var{mode}.  @var{Mode} must be a positive exact integer to represent
the file mode.
@end defun

@defun sys-isatty port-or-fd
[POSIX] @var{port-or-fd} may be a port or an integer file descriptor.
Returns @code{#t} if the port is connected to the console, @code{#f}
otherwise.
@end defun

@defun sys-ttyname port-or-fd
[POSIX] @var{port-or-fd} may be a port or an integer file descriptor.
Returns the name of the terminal connected to the port,
or @code{#f} if the port is not connected to a terminal.
@end defun

@node Unix groups and users, Locale, Filesystems, System interface
@subsection Unix groups and users
@c NODE Unixのグループとユーザ

@menu
* Unix group::                  
* Unix users::                  
* Password encryption::         
@end menu

@node Unix group, Unix users, Unix groups and users, Unix groups and users
@subsubsection Unix Group
@c NODE Unixのグループ

@deftp {Builtin Class} <sys-group>
@clindex sys-group
@c EN
Unix group information.  Has following slots.
@c JP
Unixのグループの情報です。以下のスロットを持ちます。
@c COMMON

@defivar <sys-group> name
@c EN
Group name.
@c JP
グループ名。
@c COMMON
@end defivar

@defivar <sys-group> gid
@c EN
Group id.
@c JP
グループID
@c COMMON
@end defivar

@defivar <sys-group> passwd
@c EN
Group password.
@c JP
グループパスワード。
@c COMMON
@end defivar

@defivar <sys-group> mem
@c EN
List of user names who are in this group.
@c JP
このグループに属するユーザ名のリスト。
@c COMMON
@end defivar

@end deftp

@defun sys-getgrgid gid
@defunx sys-getgrnam name
[POSIX]
@c EN
Returns @code{<sys-group>} object from an integer group id @var{gid}
or a group name @var{name}, respectively.
If the specified group doesn't exist, @code{#f} is returned.
@c JP
グループID@var{gid}もしくはグループ名@var{name}で示されるグループの情報を
@code{<sys-group>}で返します。該当するグループが存在しない場合は
@code{#f}が返されます。
@c COMMON
@end defun

@defun sys-gid->group->name gid
@defunx sys-group-name->gid name
@c EN
Convenience function to convert between group id and group name.
@c JP
グループIDとグループ名を相互変換する便利な手続きです。
@c COMMON
@end defun

@node Unix users, Password encryption, Unix group, Unix groups and users
@subsubsection Unix users
@c NODE Unixのユーザ

@deftp {Builtin Class} <sys-passwd>
@clindex sys-passwd
@c EN
Unix user information.  Has following slots.
@c JP
Unixのユーザの情報です。以下のスロットを持ちます。
@c COMMON

@defivar <sys-group> name
@c EN
User name.
@c JP
ユーザ名。
@c COMMON
@end defivar

@defivar <sys-group> uid
@c EN
User ID.
@c JP
ユーザID
@c COMMON
@end defivar

@defivar <sys-group> gid
@c EN
User's primary group id.
@c JP
ユーザのプライマリグループID。
@c COMMON
@end defivar

@defivar <sys-group> passwd
@c EN
User's (encrypted) password.  If the system uses the shadow password file,
you just get obscure string like "x".
@c JP
ユーザの(暗号化された)パスワード。システムがシャドウパスワードファイルを
使っている場合は、 "x" のような無意味な文字列が入っています。
@c COMMON
@end defivar

@defivar <sys-group> gecos
@c EN
Gecos field.
@c JP
Gecosフィールド。
@c COMMON
@end defivar

@defivar <sys-group> dir
@c EN
User's home directory.
@c JP
ユーザのホームディレクトリ。
@c COMMON
@end defivar

@defivar <sys-group> shell
@c EN
User's login shell.
@c JP
ユーザのログインシェル。
@c COMMON
@end defivar

@defivar <sys-group> class
@c EN
User's class (only available on some systems).
@c JP
ユーザのクラス。(特定のシステムでのみ有効)。
@c COMMON
@end defivar

@end deftp

@defun sys-getpwuid uid
@defunx sys-getpwnam name
[POSIX]
@c EN
Returns @code{<sys-passwd>} object from an integer user id @var{uid}
or a user name @var{name}, respectively.
If the specified user doesn't exist, @code{#f} is returned.
@c JP
ユーザID@var{uid}もしくはユーザ名@var{name}で示されるユーザの情報を
@code{<sys-passwd>}で返します。該当するユーザが存在しない場合は
@code{#f}が返されます。
@c COMMON
@end defun

@defun sys-uid->user-name uid
@defunx sys-user-name->uid
@c EN
Convenience functions to convert between user id and user name.
@c JP
ユーザIDとユーザ名を相互変換する便利な手続きです。
@c COMMON
@end defun


@node Password encryption,  , Unix users, Unix groups and users
@subsubsection Password encryption
@c NODE パスワードの暗号化

@defun sys-crypt key salt
This is the interface to @code{crypt(3)}.   @var{Key} and @var{salt}
must be a string, and an encrypted string is returned.
On systems where @code{crypt(3)} is not available, call to this
function signals an error.
@end defun

@node Locale, Signal, Unix groups and users, System interface
@subsection Locale
@c NODE ロケール

@defun sys-setlocate category locale
[POSIX]
@c EN
Sets the locale of the category @var{category} to the locale @var{locale}.
@var{category} must be an exact integer; the following pre-defined
variables are available.  @var{locale} must be a string locale name.
Returns the locale name on success, or @code{#f} if the system
couldn't change the locale.
@c JP
カテゴリー@var{category}のロケールを@var{locale}にセットします。
@var{category}は整数でなければなりません；以下の変数が@var{category}の
ために定義されています。@var{locale}はロケールを表す文字列です。
成功した場合は新しいロケール名を、ロケールが変更できなかった場合は@code{#f}を
返します。
@c COMMON
@end defun

@defvar  LC_ALL
@defvarx LC_COLLATE
@defvarx LC_CTYPE
@defvarx LC_MONETARY
@defvarx LC_NUMERIC
@defvarx LC_TIME
@c EN
Predefined variables for possible @var{category} value of
@code{sys-setlocale}.
@c JP
@code{sys-setlocale}の@var{category}に渡せる数値を定義しています。
@c COMMON
@end defvar

@defun sys-localeconv
[POSIX]
@c EN
Returns an assoc list of various information for formatting numbers
in the current locale.
@c JP
現在のロケールで数値をフォーマットする際に必要な様々な情報をassoc listに
して返します。
@c COMMON
@end defun

@c EN
An example session.  It may differ on your system settings.
@c JP
例を示します。あなたのシステム設定によっては異なる結果になるかもしれません。
@c COMMON
@example
(sys-localeconv)
 @result{}
   ((decimal_point . ".") (thousands_sep . "")
    (grouping . "") (int_curr_symbol . "")
    (currency_symbol . "") (mon_decimal_point . "")
    (mon_thousands_sep . "") (mon_grouping . "")
    (positive_sign . "") (negative_sign . "")
    (int_frac_digits . 127) (frac_digits . 127)
    (p_cs_precedes . #t) (p_sep_by_space . #t)
    (n_cs_precedes . #t) (n_sep_by_space . #t)
    (p_sign_posn . 127) (n_sign_posn . 127))

(sys-setlocale LC_ALL "fr_FR")
 @result{} "fr_FR"

(sys-localeconv)
 @result{}
  ((decimal_point . ",") (thousands_sep . "")
   (grouping . "") (int_curr_symbol . "FRF ")
   (currency_symbol . "F") (mon_decimal_point . ",")
   (mon_thousands_sep . " ") (mon_grouping . "\x03\x03")
   (positive_sign . "") (negative_sign . "-")
   (int_frac_digits . 2) (frac_digits . 2)
   (p_cs_precedes . #f) (p_sep_by_space . #t)
   (n_cs_precedes . #f) (n_sep_by_space . #t)
   (p_sign_posn . 1) (n_sign_posn . 1))
@end example

@node Signal, System Inquiry, Locale, System interface
@subsection Signal
@c NODE  シグナル

@c EN
Gauche can send out operating system's signals to the other processes
(including itself) and can handle the incoming signals.
@c JP
Gaucheでは、OSのシグナルを自分自身や他のプロセスに送ったり、
送られたシグナルを処理することができます。
@c COMMON

@c EN
In multithread environment, all threads share the signal
handlers, and each thread has its own signal mask.
See @ref{Signals and threads}, for details.
@c JP
マルチスレッド環境では、全てのスレッドがシグナルハンドラを共有し、
各スレッドが独自のシグナルマスクを持ちます。
詳しくは@ref{Signals and threads}を参照して下さい。
@c COMMON

@menu
* Signals and signal sets::     
* Sending signals::             
* Handling signals::            
* Masking and waiting signals::  
* Signals and threads::         
@end menu

@node Signals and signal sets, Sending signals, Signal, Signal
@subsubsection Signals and signal sets
@c NODE シグナルとシグナルセット

@c EN
Signals are referred by its signal number (a small integer)
defined on the underlying operating system.
Variables are pre-defined to the system's signal number.
System's signal numbers may be architecture dependent, so you should
use those variables rather than using literal integers.
@c JP
シグナルはオペレーティングシステムで定義された小さな整数値で表現されます。
システムのシグナル番号に束縛された変数が定義されています。
システムのシグナル番号はアーキテクチャによって異なるので、
なるべく変数を利用するようにして下さい。
@c COMMON

@defvar  SIGABRT
@defvarx SIGALRM
@defvarx SIGCHLD
@defvarx SIGCONT
@defvarx SIGFPE
@defvarx SIGHUP
@defvarx SIGILL
@defvarx SIGINT
@defvarx SIGKILL
@defvarx SIGPIPE
@defvarx SIGQUIT
@defvarx SIGSEGV
@defvarx SIGSTOP
@defvarx SIGTERM
@defvarx SIGTSTP
@defvarx SIGTTIN
@defvarx SIGTTOU
@defvarx SIGUSR1
@defvarx SIGUSR2
@c EN
These variables are bound to the signal numbers of POSIX signals.
@c JP
これらの変数はPOSIXで定義された対応するシグナルの番号に束縛されています。
@c COMMON
@end defvar

@defvar  SIGTRAP
@defvarx SIGIOT
@defvarx SIGBUS
@defvarx SIGSTKFLT
@defvarx SIGURG
@defvarx SIGXCPU
@defvarx SIGXFSZ
@defvarx SIGVTALRM
@defvarx SIGPROF
@defvarx SIGWINCH
@defvarx SIGPOLL
@defvarx SIGIO
@defvarx SIGPWR
@c EN
These variables are bound to the signal numbers of system-dependent
signals.  Not all of them may be defined on some systems.
@c JP
これらの変数はシステム依存のシグナル番号に束縛されています。
全てのシステムで全てのシグナルがサポートされているわけではありません。
@c COMMON
@end defvar

@c EN
Besides each signal numbers, you can refer to a set of signals
using a @code{<sys-sigset>} object.
It can be used to manipulate the signal mask, and to install a signal
handler to a set of signals at once.
@c JP
それぞれのシグナル番号の他に、@code{<sys-sigset>}オブジェクトを使って
シグナルの集合を扱うことができます。シグナルの集合はシグナルマスクを操作したり、
ひとつのシグナルハンドラを多数のシグナルに同時に設定したりする際に使えます。
@c COMMON

@deftp {Class} <sys-sigset>
@clindex sys-sigset
@c EN
A set of signals.   An empty sigset can be created by
@c JP
シグナルの集合を表します。空のシグナルの集合は次の式で作成できます：
@c COMMON
@example
(make <sys-sigset>)
@end example
@end deftp

@defun sys-sigset-add! sigset signal @dots{}
@defunx sys-sigset-delete! sigset signal @dots{}
@c EN
@var{Sigset} must be a @code{<sys-sigset>} object.
Those procedures adds and removes the specified signals from
@var{sigset} respectively, and returns the result.  @var{sigset} itself
is also modified.

@var{signal} may be either a signal number, another @code{<sys-sigset>}
object, or @code{#t} for all available signals.
@c JP
@var{sigset}は@code{<sys-sigset>}オブジェクトでなければなりません。
これらの手続きは@var{sigset}に指定されたシグナルを追加、
もしくは@var{sigset}から指定されたシグナルを削除します。
変更された@var{sigset}が返されます。
@c COMMON
@end defun

@defun sys-sigset-fill! sigset
@defunx sys-sigset-empty! sigset
@c EN
Fills @var{sigset} by all available signals, or empties @var{sigset}.
@c JP
システムで定義された全てのシグナルを@var{sigset}にセット、
もしくは@var{sigset}を空にします。
@c COMMON
@end defun

@defun sys-signal-name signal
@c EN
Returns the human-readable name of the signal.
@c JP
シグナルの名前を返します。
@c COMMON
@end defun

@node Sending signals, Handling signals, Signals and signal sets, Signal
@subsubsection Sending signals
@c NODE シグナルの送出

@c EN
To send a signal, you can use @code{sys-kill} which works like
@code{kill(2)}.
@c JP
シグナルを送るには、@code{sys-kill}を使うことができます。
これはシステムの@code{kill(2)}のように動作します。
@c COMMON

@defun sys-kill pid sig
[POSIX]
@c EN
Sends a signal @var{sig} to the specified process(es).  @var{Sig}
must be a positive exact integer.  @var{pid} is an exact integer and
specifies the target process(es):
@c JP
シグナル@var{sig}を指定されたプロセス(群)に送ります。
@var{sig}は正確な正整数でなければなりません。@var{pid}は正確な整数でなければ
ならず、次のルールで対象となるプロセスを指定します。
@c COMMON
@itemize @bullet
@item
@c EN
If @var{pid} is positive, it is the target process id.
@c JP
@var{pid}が正ならば、それがそのまま対象となるプロセスIDです。
@c COMMON
@item
@c EN
If @var{pid} is zero, the signal is sent to every process in the process
group of the current process.
@c JP
@var{pid}がゼロならば、シグナルは現在のプロセスのプロセスグループ内の全ての
プロセスに送られます。
@c COMMON
@item
@c EN
If @var{pid} is less than -1, the signal is sent to every process in
the process group @var{-pid}.
@c JP
@var{pid}が-1より小さければ、シグナルはプロセスグループIDが@var{-pid}である
全てのプロセスに送られます。
@c COMMON
@end itemize
@end defun

@c EN
There's no Scheme equivalence for @code{raise()}, but you can use
@code{(sys-kill (sys-getpid) @var{sig})}.
@c JP
POSIXの@var{raise()}に対応するScheme関数はありませんが、
@code{(sys-kill (sys-getpid) @var{sig})} で同じことができます。
@c COMMON

@node Handling signals, Masking and waiting signals, Sending signals, Signal
@subsubsection Handling signals
@c NODE シグナルの処理

@c EN
You can register signal handling procedures in Scheme.
(In multithread environment, signal handlers are shared by all
threads; see @ref{Signals and threads} for details).
@c JP
Schemeでシグナルを処理する手続きを登録できます。
(マルチスレッド環境では、シグナルハンドラの設定は全てのスレッドで共有されます。
@ref{Signals and threads}を参照して下さい)。
@c COMMON

@c EN
When a signal is delivered to the Scheme process, it is queued in VM,
and processed in a 'safe point' where the state of VM is consistent.
(Note that this makes handling of some signals such as @code{SIGILL}
useless, for the process can't continue sensible execution after
queuing the signal).
@c JP
シグナルがSchemeプロセスに送られると、それはVM中のキューに入れられます。
VMは「安全なポイント」に達した時にキューを検査し、シグナルが届いていれば
それを順に処理します。
(このメカニズムのため、@code{SIGILL}のようなシグナルはSchemeレベルでは
処理できません。そのシグナルをキューに入れた後でプロセスが処理を続行できない
からです)。
@c COMMON

@c EN
When you're using the @code{gosh} interpreter, the default
behavior for each signal is as in the following table.
@c JP
@code{gosh}インタプリタを使っている場合、デフォルトでのシグナルの処理は
次のように設定されています。
@c COMMON

@table @code
@item SIGABRT, SIGILL, SIGKILL, SIGCONT, SIGSTOP, SIGSEGV, SIGBUS
@c EN
Cannot be handled in Scheme.  @code{Gosh} follows the system's
default behavior.
@c JP
Schemeでは処理できません。@code{gosh}ではこれらのシグナルを受けると
システムのデフォルトの動作をします。
@c COMMON
@item SIGCHLD, SIGTSTP, SIGTTIN, SIGTTOU, SIGWINCH
@c EN
No signal handles are installed for these signals by @code{gosh},
       so the process follows the system's default behavior.
       Scheme programs can install its own signal handler if necessary.
@c JP
@code{gosh}は初期状態ではこれらのシグナルのハンドラを設定せず、
       システムのデフォルトの振るまいに任せます。Schemeプログラムは必要ならば
       これらのシグナルのハンドラを設定できます。
@c COMMON
@item SIGHUP, SIGQUIT, SIGTERM
@c EN
@code{Gosh} installs a signal handler for these signals
       that exits from the application with code 0.
@c JP
@code{gosh}はこれらのシグナルに対して、終了コード0でアプリケーションを
       終了するシグナルハンドラをセットします。
@c COMMON
@item SIGPWR, SIGXCPU, SIGUSR1, SIGUSR2
@c EN
On Linux platforms with thread support, these signals are used
       by the system and not available for Scheme.  On other systems,
       these signals behaves the same as described below.
@c JP
Linuxプラットフォームでスレッドを使用している場合は、
       これらのシグナルはシステムで使用されるため、Schemeからは使用できません。
       他のシステムではこれらのシグナルは下記の「他のシグナル」と同じ動作と
       なります。
@c COMMON
@c EN
@item other signals
@code{Gosh} installs the default signal handler, which signals
       an "unhandled signal" error.  Scheme programs can override it
       by its own signal handler.
@c JP
@item 他のシグナル
@code{gosh}はデフォルトのシグナルハンドラを設定します。
       デフォルトのシグナルハンドラは "unhandled signal" エラーを通知します。
       Schemeプログラムはシグナル毎に独自のハンドラを設定することが可能です。
@c COMMON
@end table

@c EN
If you're using Gauche embedded in some other application,
it may redefine the default behavior.
@c JP
@code{gosh}でなく、他のアプリケーションに埋め込まれたGaucheを使っている場合、
Schemeレベルでのシグナルの使用をアプリケーションが制限している場合があります。
@c COMMON

@c EN
Use the following procedures to get/set signal handlers from Scheme.
@c JP
Schemeからシグナルハンドラを設定するには以下の手続きを使って下さい。
@c COMMON

@defun set-signal-handler! signals handler
@c EN
@var{Signals} may be a single signal number or a @code{<sys-sigset>}
object, and @var{handler} should be either @code{#t}, @code{#f}
or a procedure that takes one argument.
If @var{handler} is a procedure, it will be called when the process
receives one of specified signal(s), with the received signal
number as an argument.
It is safe to do anything in @var{handler}, including throwing
an error or invoking continuation captured elsewhere.  (However,
continuations captured inside @var{handler} will be invalid
once you return from @var{handler}).
@c JP
@var{signals}はシグナル番号か@code{<sys-sigset>}オブジェクト、
@var{handler}は@code{#t}、@code{#f}、一つの引数を取る手続きのいずれか
でなければなりません。
@var{handler}が手続きの場合、プロセスが指定されたシグナル(のうちのいずれか)を
受けた時に、そのシグナル番号を引数として@var{handler}が呼ばれます。
@var{handler}の中でできる操作にはほとんど制限がありません。
@var{handler}からエラーを投げたり、他の場所で補足された継続を呼ぶことも
できます。但し、@var{handler}内で補足した継続は@var{handler}から
戻った時点で無効になります。
@c COMMON

@c EN
If @var{handler} is @code{#t}, the operating system's default 
behavior is set to the specified signal(s).  If @var{handler}
is @code{#f}, the specified signals(s) will be ignored.
@c JP
@var{handler}が@code{#t}の場合、指定されたシグナルにはオペレーティングシステムの
デフォルトの振るまいが設定されます。
@var{handler}が@code{#f}の場合、指定されたシグナルは無視されます。
@c COMMON

@c EN
Note that signal handler setting is shared among threads in
multithread enviornment.  The handler is called from the thread
which is received the signal.  See @ref{Signals and threads}
for details.
@c JP
マルチスレッドプログラムでは、
シグナルハンドラの設定はスレッド間で共有されることに注意して下さい。
ハンドラはシグナルを受けたスレッドで実行されます。
詳しくは@ref{Signals and threads}を参照して下さい。
@c COMMON
@end defun

@defun get-signal-handler signum
@c EN
Returns the handler setting of a signal @var{signum}.
@c JP
シグナル@var{signum}に設定されたハンドラを返します。
@c COMMON
@end defun

@defun get-signal-handlers
@c EN
Returns an associative list of all signal handler settings.
Car of each element of returned list is a @code{<sys-sigset>} object,
and cdr of it is the handler (a procedure or a boolean value)
of the signals in the set.
@c JP
現在の全てのシグナルハンドラの設定を連想リストにして返します。
返されるリストの各要素のcarには@code{<sys-sigset>}オブジェクトが、
cdrにはそれらのシグナルに対応するハンドラ(手続きもしくはブール値)がセットされて
います。
@c COMMON
@end defun

@defmac with-signal-handlers (handler-clause @dots{}) thunk
@c EN
A convenience macro to install signal handlers temporarily
during execution of @var{thunk}.
(Note: though this is convenient, this has certain dangerous
properties described below.  Use with caution.)
@c JP
@var{thunk}の実行中だけシグナルハンドラを一時的に設定する便利なマクロです
(このマクロは便利ですが下に述べるような多少危険な性質もあるので、
注意して使って下さい)。
@c COMMON

@c EN
Each @var{Handler-clause} may be one of the following forms.
@table @code
@item (@var{signals} @var{expr} @dots{})
@var{Signals} must be an expression that will yield either a signal,
a list of signals, or a @code{<sys-sigset>} object.
Installs a signal handler for @var{signals} that evaluates
@var{expr} @dots{} when one of the signals in @var{signals} is delivered.

@item (@var{signals} => @var{proc})
@var{Proc} must be a procedure that takes one argument.
This form installs @var{proc} as the signal handler for @var{signals}.
@end table
@c JP
@var{handler-clause}は以下のいずれかの形式です
@table @code
@item (@var{signals} @var{expr} @dots{})
@var{signals}は、評価された時に単独のシグナル番号、シグナル番号のリスト、
あるいは@code{<sys-sigset>}オブジェクトを生成する式でなければなりません。
@var{signals}に含まれるシグナルを受け取った時に、@var{expr} @dots{}を
評価するようなハンドラを設定します。

@item (@var{signals} => @var{proc})
@var{signals}は上と同じです。@var{signals}に含まれるシグナルに
対して、一つの引数を取る手続き@var{proc}をハンドラとして設定します。
@end table
@c COMMON

@c EN
When the control exits from @var{thunk}, the signal handler setting
before @code{with-signal-handlers} are recovered.
@c JP
@var{thunk}から制御が抜けた時に、@code{with-signal-handlers}が呼ばれた時点での
シグナルハンドラが再設定されます。
@c COMMON

@c EN
@emph{CAVEAT:} If you're setting more than one signal handlers,
they are installed in serial.  If a signal is delivered before
all the handlers are installed, the signal handler state may be
left inconsistent.  Also note that the handler setting is a global state;
you can't set "thread local" handler by @code{with-signal-handlers},
although the form may be misleading.
@c JP
@emph{注意：} このフォームで一つ以上のシグナルハンドラを設定する場合、
それらは順にシステムに設定されます。全てのハンドラの設定が終る前に
シグナルが届いた場合、シグナルハンドラの設定や再設定が不完全なままになる
かもしれません。また、シグナルハンドラはグローバルな設定であり、
「スレッドローカル」なハンドラを設定することはできませんが、
@code{with-signal-handlers}の形式はそれを誤解させるかもしれません。
@c COMMON
@end defmac

@node Masking and waiting signals, Signals and threads, Handling signals, Signal
@subsubsection Masking and waiting signals
@c NODE シグナルのマスクと待機

A Scheme program can set a signal mask, which is a set of signals
to be blocked from delivery.   If a signal is delivered
which is completely blocked in the process, the signal becomes
"pending".  The pending signal may be delivered once the signal
mask is changed not to block the specified signal.
(However, it depends on the operating system whether the pending
signals are queued or not.)

In multithread environment, each thread has its own signal mask.

@defun sys-sigmask how mask
Modifies the current thread's signal mask, and returns the previous
signal mask.   @var{Mask} should be a @code{<sys-sigset>} object.
@var{How} argument should be one of the following
integer constants:
@table @code
@item SIG_SETMASK
Sets @var{mask} as the thread's signal mask.
@item SIG_BLOCK
Adds signals in @var{mask} to the thread's signal mask.
@item SIG_UNBLOCK
Removes signals in @var{mask} from the thread's signal mask.
@end table
@end defun

@defun sys-sigsuspend mask
Atomically sets thread's signal mask to @var{mask} and
suspends the calling thread.  When a signal that is not blocked
and has a signal handler installed is delivered, the associated
handler is called, then @code{sys-sigsuspend} returns.
@end defun

@node Signals and threads,  , Masking and waiting signals, Signal
@subsubsection Signals and threads
@c NODE シグナルとスレッド

The semantics of signals looks a bit complicated in the multithread
environment.   Nevertheless, it is pretty comprehensible once
you remember a small number of rules.  Besides,
Gauche sets up the default behavior easy to use,
while allowing programmers to do tricky stuff.

If you don't want to be bothered by the details, just remember
one thing, with one sidenote.
@strong{By default}, signals are handled by the
primordial (main) thread.  However, if the main thread
is suspended on mutex or condition variable,
the signal may not be handled at all, so be careful.

Now, if you are curious about the details, here are the rules:
@itemize @bullet
@item
The signal handler setting is shared by all threads.
@item
The signal mask is thread-specific.
@item
If a process receives an asynchronous signal (think it as a signal
delivered from other processes), one thread is chosen, out of
threads which don't block that signal.
@item
The signal handler is run on the chosen thread.
However, if the chosen thread is waiting for acquiring a mutex lock
or a condition variable, the handling of signal will be delayed
until the thread is restarted.   Signal delivery itself doesn't
restart the thread.
@end itemize

Now, these rules have several implications.

If there are more than one thread that don't block a particular
signal, you can't know which thread receives the signal.
Such a situation is much less useful in Gauche than C programs
because of the fact that the signal handling can be delayed indefinitely
if the receiver thread is waiting on mutex or condition variable.
So, it is recommended to make sure, for each signal, there is only one
thread that can receive it.

In Gauche, all threads created by @code{make-thread}
(@xref{Thread procedures}) blocks all the signals by default
(except the reserved ones).   This lets all the signals
to be directed to the primordial (main) thread.

Another strategy is to create a thread dedicated for handling
signals.  To do so, you have to block the signals in the
primordial thread, then create the signal-handling thread,
and within that thread you unblock all the signals.
Such a thread can just loop on @code{sys-pause}.

@example
(thread-start!
  (make-thread
    (lambda ()
      (sys-sigmask SIG_SETMASK (make <sys-sigset>)) ;;empty mask
      (let loop () (sys-pause) (loop)))))
@end example

Complicated application may want to control per-thread signal
handling precisely.   You can do so, just make sure that
at any moment only the designated thread unblocks the desired
signal.

@node System Inquiry, Time, Signal, System interface
@subsection System Inquiry
@c NODE システムへの問い合わせ

@defun sys-uname
[POSIX] Returns a list of five elements,
@code{(@var{sysname} @var{nodename} @var{release} @var{version} @var{machine})}.
@end defun

@defun sys-gethostname
Returns the host name.  If the system doesn't have gethostname(),
the second element of the list returned by @code{sys-uname} is used.
@end defun

@defun sys-getdomainname
Returns the domain name.  If the system doesn't have getdomainname(),
@code{"localdomain"} is returned.
@end defun

@defun sys-getcwd
[POSIX] Returns the current working directory by a string.
If the current working directory couldn't be obtained from the system,
an error is signalled.   See also @code{sys-chdir}
 (@xref{Other file operations}), @code{current-directory}
(@xref{Directory utilities}).
@end defun

@defun sys-getgid
@defunx sys-getegid
[POSIX] Returns integer value of real and effective group id of the
current process, respectively.
@end defun

@defun sys-setgid gid
[POSIX] Sets the effective group id of the current process.
@end defun

@defun sys-getuid
@defunx sys-geteuid
[POSIX] Returns integer value of real and effective user id of the
current process, respectively.
@end defun

@defun sys-setuid uid
[POSIX] Sets the effective user id of the current process.
@end defun

@defun sys-getgroups
[POSIX] Returns a list of integer ids of supplementary groups.
@end defun

@defun sys-getlogin
[POSIX] Returns a string of the name of the user logged in on the
controlling terminal of the current process.
If the system can't determine the information, @code{#f} is returned.
@end defun

@defun sys-getpgrp
[POSIX] Returns a process group id of the current process.
@end defun

@c @defun sys-setpgrp
@c Sets the process group id of the current process to the current
@c process id.   Equivalent to @code{sys-setpgid(0, 0)}.
@c @end defun

@defun sys-getpgid pid
Returns a process group id of the process specified by @var{pid}.
If @var{pid} is zero, the current process is used.

Note that @code{getpgid()} call is not in POSIX.  If the system
doesn't have @var{getpgid()}, @var{sys-getpgid} still works if
@var{pid} is zero (it just calls @code{sys-getpgrp}), but signals
an error if @var{pid} is not zero.
@end defun

@defun sys-setpgid pid pgid
[POSIX] Sets the process group id of the process @var{pid} to @var{pgid}.
If @var{pid} is zero, the process ID of the
current process is used.  If @var{pgid} is zero, the process ID
of the process specified by @code{pid} is used.  (Hence
@code{sys-setpgid(0, 0)} sets the process group id of the
current process to the current process id).
@end defun

@defun sys-setsid
[POSIX] Creates a new session if the calling process is
not a process group leader.
@end defun

@defun sys-getpid
@defunx sys-getppid
[POSIX] Returns the current process id and the parent process id,
respectively.
@end defun

@defun sys-times
[POSIX]
@end defun

@defun sys-ctermid
[POSIX]  Returns the name of the controlling terminal of the process.
This may be just a @code{"/dev/tty"}.   See also @code{sys-ttyname}.
@end defun

@node Time, Unix process management, System Inquiry, System interface
@subsection Time
@c NODE 時間

@c EN
Gauche has two representations of time, one is compatible to POSIX API,
and the other is compatible to SRFI-18, SRFI-19 and SRFI-21.
Most procedures accept both representations; if not, the representation
the procedure accepts is indicated as either 'POSIX time' or 'SRFI time'.
@c JP
Gaucheでは時間は2種類の表現を持ちます。ひとつはPOSIX APIとコンパチブルな
表現で、もう一つはSRFI-18、SRFI-19、SRFI-21とコンパチブルな表現です。
多くの手続きはどちらの表現も理解しますが、そうでない場合は
適用可能な表現を'POSIX time'または'SRFI time'と表記します。
@c COMMON

@c EN
POSIX time is represented by a real number which is a number of seconds
since Unix Epoch (Jan 1, 1970, 0:00:00GMT).
Procedure @code{sys-time}, which corresponds to POSIX @code{time(2)},
returns this time representation.
@c JP
POSIX timeは実数で、Unix Epoch(Jan 1, 1970, 0:00:00GMT)からの秒数で
表現されます。POSIXの@code{time(2)}に対応する@code{sys-time}手続きは
この表現を返します。
@c COMMON

@c EN
SRFI-compatible time is represented by an object of @code{<time>} class,
which keeps seconds and nanoseconds, as well as the type of the time
(UTC, TAI, duration, process time, etc).
@code{Current-time} returns this representation.
@c JP
SRFI互換の時間は@code{<time>}クラスのインスタンスとして表現され、
秒、およびナノ秒のスロットを持ちます。
また、時間の種別(UTC、TAI、期間、プロセス時間、他)も保持しています。
@code{Current-time}はこの表現を返します。
@c COMMON

@menu
* POSIX time::                  
* SRFI time::                   
@end menu

@node POSIX time, SRFI time, Time, Time
@subsubsection POSIX time

@defun sys-time
@c EN
[POSIX] Returns the current time in POSIX time
(the time since Epoch (00:00:00 UTC, January 1, 1970),
measured in seconds).  It may be a non-integral number, depending on
the architecture.

Note that POSIX's definition of ``seconds since the Epoch'' doesn't
take leap seconds into acount.
@c JP
[POSIX] 現在の時間を POSIX 時間(エポック(00:00:00 UTC, January 1, 1970)
からの秒数)で返します。マシンのアーキテクチャによっては、不正確数で
あるかもしれません。
@c COMMON
@end defun

@defun sys-gettimeofday
@c EN
Returns two values.  The first value is a number of seconds,
and the second value is a fraction in a number of microseconds,
since 1970/1/1 0:00:00 UTC.   If the system doesn't have
@code{gettimeofday} call, this function calls @code{time()};
in that case, microseconds portion is always zero.
@c JP
2つの値を返します。1970/1/1 0:00:00 UTC を基準として、
1つ目の値は秒数、2つ目の値は端数をマイクロ秒で表したものです。
システムが @code{gettimeofday} 呼び出しをサポートしていない場合、
この手続きは @code{time()} を呼び出し、その場合はマイクロ秒の
部分はいつも 0 です。
@c COMMON
@end defun

@deftp {Builtin Class} <sys-tm>
@clindex sys-tm
@c EN
Represents @code{struct tm}, a calendar date.  It has the following slots.
@c JP
カレンダーである、@code{struct tm} を表します。以下のスロットを持ちます。
@c COMMON
@defivar <sys-tm> sec
@c EN
Seconds. 0-61.
@c JP
秒。0-61。
@c COMMON
@end defivar
@defivar <sys-tm> min
@c EN
Minutes. 0-59.
@c JP
分。0-59。
@c COMMON
@end defivar
@defivar <sys-tm> hour
@c EN
Hours.  0-23.
@c JP
時。0-23。
@c COMMON
@end defivar
@defivar <sys-tm> mday
@c EN
Day of the month, counting from 1.  1-31.
@c JP
月の日。1 から数える。1-31。
@c COMMON
@end defivar
@defivar <sys-tm> mon
@c EN
Month, counting from 0.  0-11.
@c JP
月。0 から数える。0-11。
@c COMMON
@end defivar
@defivar <sys-tm> year
@c EN
Years since 1900, e.g. 102 for the year 2002.
@c JP
1900年からの年数。例えば、102 なら 2002年。
@c COMMON
@end defivar
@defivar <sys-tm> wday
@c EN
Day of the week.  Sunday = 0 .. Saturday = 6.
@c JP
曜日。日曜は 0 .. 土曜は 6。
@c COMMON
@end defivar
@defivar <sys-tm> yday
@c EN
Day of the year.  January 1 = 0 .. December 31 = 364 or 365.
@c JP
1年の中での日数。1月1日は 0 .. 12月31日は 364 か 365。
@c COMMON
@end defivar
@defivar <sys-tm> isdst
@c EN
A flag that indicates if the daylight saving time is in effect.
Positive if DST is in effect, zero if not, or negative if unknown.
@c JP
夏時間が有効であるかどうかを指定するフラグ。有効なら正の数、無効なら 0、
分からなければ負の数。
@c COMMON
@end defivar
@end deftp

@defun sys-gmtime time
@defunx sys-localtime time
@c EN
[POSIX] Converts @var{time} to @code{<sys-tm>} object, represented in GMT
or local timezone, respectively.   @var{Time} can be either POSIX-time or
SRFI-time.
@c JP
[POSIX] @var{time} を @code{<sys-tm>} オブジェクトに変換します。
標準時での表現かローカルタイムゾーンでの表現かで使い分けます。
@var{Time} は POSIX 時間か SRFI 時間であす。
@c COMMON
@end defun

@defun sys-ctime time
@c EN
[POSIX] Converts @var{time} to it string representation, using POSIX ctime().
@var{Time} can be either POSIX-time or SRFI-time.
@c JP
[POSIX] @var{time} を POSIX の ctime() を使って文字列表現に変換します。
@var{Time} は POSIX 時間か SRFI 時間です。
@c COMMON
@end defun

@defun sys-difftime time1 time0
@c EN
[POSIX] Returns the difference of two times in the real number of seconds.
@var{Time0} and @var{time1} can be either POSIX-time or SRFI-time.
@c JP
[POSIX] 2つの時間の差を、秒の実数で返します。@var{Time0} と@var{time1} は
POSIX 時間か SRFI 時間です。
@c COMMON
@end defun

@defun sys-asctime tm
@c EN
[POSIX] Converts @code{<sys-tm>} object @var{tm} to a string representation.
@c JP
[POSIX] @code{<sys-tm>} オブジェクトである @var{tm} を文字列表現に変換します。
@c COMMON
@end defun

@defun sys-strftime format tm
@c EN
[POSIX] Converts @code{<sys-tm>} object @var{tm} to a string representation,
according to a format string @var{format}.
@c JP
[POSIX] @code{<sys-tm>} オブジェクトである @var{tm} を、フォーマット文字列
@var{format} に従って文字列表現に変換します。
@c COMMON
@end defun

@defun sys-mktime tm
@c EN
[POSIX] Converts @code{<sys-tm>} object @var{tm}, expressed as local time,
to the POSIX-time (number of seconds since Epoch).
@c JP
[POSIX] ローカルタイムとして表現された @code{<sys-tm>} オブジェクトである
@var{tm} を POSIX 時間(エポックからの秒数)に変換します。
@c COMMON
@end defun

@defun sys-tm->alist tm
(Deprecated function)
@end defun


@node SRFI time,  , POSIX time, Time
@subsubsection SRFI time

@deftp {Builtin Class} <time>
The @code{<time>} object also represents a point of time.

@clindex time
@defivar <time> type
Indicates time type.  @code{time-utc} is the default, and that
represents the number of seconds since Unix Epoch.
SRFI-19 (@xref{srfi-19 - Time data types and procedures}) adds more types.
@end defivar
@defivar <time> second
Second part of the time.
@end defivar
@defivar <time> nanosecond
Nanosecond part of the time.
@end defivar
@end deftp

@defun current-time
[SRFI-18][SRFI-21]
Returns the @code{<time>} object representing the current time in
@code{time-utc}.   @xref{srfi-19 - Time data types and procedures}, for
it redefines @code{current-time} to allow optional argument to
specify time type.
@end defun

@defun time? obj
[SRFI-18][SRFI-19][SRFI-21]
Returns @code{#t} if @var{obj} is a time object.
@end defun

@defun time->seconds time
@defunx seconds->time seconds
[SRFI-18][SRFI-21]
Converts between time object and the number of seconds (POSIX-time).
@var{Time} argument of @code{time->seconds} has to be a @code{<time>} object.
@end defun


@node Unix process management, I/O multiplexing, Time, System interface
@subsection Unix process management
@c NODE Unixのプロセス管理

@menu
* Fork and exec::               
* Wait::                        
@end menu

@node Fork and exec, Wait, Unix process management, Unix process management
@subsubsection Fork and exec
@c NODE forkとexec

@defun sys-system command
[POSIX]
Runs @var{command} in a subprocess.   @var{command} is usually passed
to @code{sh}, so the shell metacharacters are interpreted.

This function returns an integer value @code{system()} returned.
Since POSIX doesn't define what @code{system()} returns, you can't
interpret the returned value in a portable way.
@end defun

@defun sys-fork
[POSIX]
Fork the current process.  Returns 0 if you're in the child process,
and a child process' pid if you're in the parent process.
All the opened file descriptors are shared between the parent and
the child.  See @code{fork(2)} of your system for details.

If the forked process runs some Scheme code and exits instead of
calling @code{sys-exec}, the forked process should call @code{sys-exit} to
terminate itself.  Normal exit call tries to flush the file
buffers, and on some OS it messes up the parent's file buffers.
@end defun

@defun sys-exec command args &optional iomap
[POSIX+]
Execute @var{command} with @var{args}, a list of arguments.
The current process image is replaced by @var{command},
so this function never returns.

All elements of @var{args} must be strings.  The first element of
@var{args} is used as @code{argv[0]}, i.e. the program name.

The optional @var{iomap} argument, when provided, specifies how the
open file descriptors are treated.  It must be the following format:
@example
((@i{to-fd} . @i{from-port-or-fd}) @dots{})
@end example
@i{To-fd} must be an integer,
and @i{from-port-or-fd} must be an integer file descriptor or a port.
Each element of the list makes the file descriptor of @i{from-port-or-fd}
of the current process be mapped to the file descriptr @i{to-fd}
in the executed process.

If @var{iomap} is provided,
any file descriptors other than specified in the iomap list will be closed
before @code{exec()}.  Otherwise, all file descriptors in the current
process remain open.

@example
(sys-exec "ls" '("ls" "-l")) @result{} ;; ls is executed.

(sys-exec "ls" '("ls" "-l") '((1 . 2) (1 . 1)))
   @result{} ;; ls is executed, with its stderr and stdout are mapped to the
              current process's stdout.
@end example

When it encounters an error, most of the time it raises an error condition.
Once the file descriptors are permuted, however, it would be impractical
to handle errors in reasonable way (you don't even know stderr is still
available!), so Gauche simply exits on the error.
@end defun

See also @ref{gauche.process - High Level Process Interface}, which provides
more convenient process handling on top of above primitives.

@node Wait,  , Fork and exec, Unix process management
@subsubsection Wait
@c NODE Wait

@defun sys-wait
[POSIX] Calls system's @code{wait(2)}.  The process suspends its execution
until one of the child terminates.  Returns two exact integer values,
the first one is the child's process id, and the second is a status code.
The status code can be interpreted by the following functions.
@end defun

@defun sys-waitpid pid &keyword nohang untraced
[POSIX] This is an interface to @code{waitpid(3)}, an extended version of
wait.

@var{pid} is an exact integer specifying which child(ren) it's waiting.
If it is a positive integer,
it waits fot that specific child.  If it is zero, it waits for any
member of this process group.  If it is -1, it waits for any child process.
If it is less than -1, it waits for any child process whose process group
id is equal to the absolute value of @var{pid}.

The calling process suspends until one of those child process is terminated,
unless true is specified to the keyword argument @var{nohang}.

If true is specified to the keyword argument @var{untraced},
the status of stopped child process can be also returned.

The return values are two exact integers, the first one is the child
process id, and the second is a status code.  If @var{nohang} is true and
no child process status is available, the first value is zero.
@end defun

@defun sys-wait-exited? status
@defunx sys-wait-exit-status status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-wait} or @code{sys-waitpid}.
@code{sys-wait-exited?} returns @code{#t} if the child process is 
terminated normally.   @code{sys-wait-exit-status} returns the exit
code the child process passed to @code{exit(2)}, or the return value
of @code{main()}.
@end defun

@defun sys-wait-signaled? status
@defunx sys-wait-termsig status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-wait} or @code{sys-waitpid}.
@code{sys-wait-signaled?} returns @code{#t} if the child process
is termintaed by an uncaught signal.
@code{sys-wait-termsig} returns the signal number that terminted the child.
@end defun

@defun sys-wait-stopped? status
@defunx sys-wait-stopsig status
[POSIX]
The argument is an exit status returned as a second value
from @code{sys-waitpid}.
@code{sys-wait-stopped?} returns @code{#t} if the child process is
stopped.   This status can be caught only by @code{sys-waitpid} with
true @var{untraced} argument.  @code{sys-wait-stopsig} returns the
signum number that stopped the child.
@end defun

@node I/O multiplexing, Miscellaneous system calls, Unix process management, System interface
@subsection I/O multiplexing
@c NODE I/Oの多重化

The interface functions for @code{select(2)}.
The higher level interface is provided on top of these
primitives; see @ref{gauche.selector - Simple dispatcher}.

@deftp {Builtin Class} <sys-fdset>
@clindex sys-fdset
Represents @code{fd_set}, a set of file descriptors.  You can make
an empty file descriptor set by make method:
@example
(make <sys-fdset>)
@end example
@end deftp

@defun sys-fdset-ref fdset port-or-fd
@defunx sys-fdset-set! fdset port-or-fd flag
Gets and sets specific file descritor bit of @var{fdset}.
@var{port-or-fd} may be a port or an integer file descriptor.
If @var{port-or-fd} is a port that doesn't have associated file descriptor,
@code{sys-fdset-ref} returns @code{#f}, and @code{sys-fdset-set!} doesn't
modify @var{fdset}.  @var{flag} must be a boolean value.

You can use generic setter of @code{sys-fdset-ref} as this:
@example
(set! (sys-fdset-ref fdset port-or-fd) flag)
  @equiv{} (sys-fdset-set! fdset port-or-fd flag)
@end example
@end defun

@defun sys-fdset-max-fd fdset
Returns the maximum file descriptor number in @var{fdset}.
@end defun

@defun sys-select readfds writefds exceptfds &optional timeout
@defunx sys-select! readfds writefds exceptfds &optional timeout
Waits for a set of file descriptors to change status.
@var{readfds}, @var{writefds}, and @var{exceptfds} are @code{<fdset>}
objects to represent a set of file descriptors to watch.
File descriptors in @var{readfds} are watched to see if characters
are ready to be read.   File descriptors in @var{writefds} are
watched if writing to them is ok.  File descriptors in @var{exceptfds}
are watched for exceptions.  You can pass @code{#f} to one or more
of those arguments if you don't care about watching the condition.

@var{timeout} specifies maximum time @code{sys-select} waits for
the condition change.  It can be a real number, for number of microseconds,
or a list of two integers, the first is the number of seconds and
the second is the number of microseconds.  If you pass @code{#f},
@code{sys-select} waits indefinitely.

@code{sys-select} returns four values.  The first value is a number
of descriptors it detected status change.  It may be zero if 
timeout expired.  The second, third and fourth values are @code{<fdset>}
object that contains a set of descriptors that changed status
for reading, writing, and exception, respectively.
If you passed @code{#f} to one or more of @var{readfds},
@var{writefds} and @var{exceptfds}, the corresponding return value
is @code{#f}.

@code{sys-select!} variant works the same as @code{sys-select}, except
it modifies the passed @code{<fdset>} arguments.
@code{sys-select} creates new @code{<fdset>} objects and
doesn't modify its arguments.
@end defun


@node Miscellaneous system calls,  , I/O multiplexing, System interface
@subsection Miscellaneous system calls
@c NODE その他のシステムコール

@defun sys-pause
[POSIX]
Suspends the process until it receives a signal whose
action is to either execute a signal-catching function or to terminate
the process.  This function only returns when the signal-catching
function returns.  The returned value is undefined.

Note that just calling @code{pause()} doesn't suffice the above semantics
in Scheme-level.  Internally this procedure calls @code{sigsuspend()}
with the current signal mask.
@end defun

@defun sys-alarm seconds
[POSIX] Arranges a SIGALRM signal to be delivered after @var{seconds}.
The previous settings of the alarm clock is cancelled.  Passing zero
to @var{seconds} doesn't schedule new alarm.
Returns the number of seconds remaining until previously scheduled
alarm was due to be delivered (or zero if no alarm is active).
@end defun

@defun sys-sleep seconds
[POSIX] Suspends the process until the specified number of seconds elapses,
or the process receives a signal.  Returns zero if it sleeps well,
or the number of unslept seconds if it is woke up by a signal.

To be porable across POSIX implementation, keep @var{seconds} less than
65536.
@end defun

@defun sys-nanosleep nanoseconds
[POSIX] 
Suspends the process until the specified number of nanoseconds elapses,
or the process receives a signal.  The argument @var{nanoseconds} can be
a @code{<time>} object (@xref{SRFI time}), or a real number.
Returns @code{#f} if @var{nanoseconds} elapsed, or a @code{<time>}
object that indicates the remaining time if @code{sys-nanosleep}
is interrupted by a signal.

@example
;@r{wait for 0.5 sec}
(sys-nanosleep 500000000)

;@r{wait for 1.3 sec}
(sys-nanosleep (make <time> :second 1 :nanosecond 300000000)
@end example
@end defun

@defun sys-random
@defunx sys-srandom seed
A pseudo random number generator.
@code{sys-random} returns a random number between 0 and a positive
integer @var{rand_max}, inclusive.  This is a straightforward
interface to @code{random(3)}.  If the underlying system doesn't have
@code{random(3)}, @code{lrand48(3)} is used.

@code{sys-srandom} sets the seed of the random number generator.
It uses either @code{srandom(3)} or @code{srand48(3)}, depending on
the system.

The intension of these functions are to provide an off-the-stock handy
random number generator (RNG) for applications that doens't
sensitive to the quality and/or speed of RNG.  For serious statistics
analysis, use Mersenne Twister RNG in @code{math.mt-random}
module (@xref{math.mt-random - Mersenne-Twister random number generator}).
@end defun

@defvar RAND_MAX
Bound to a positive integer that @code{sys-random} may return.
@end defvar

@c ======================================================================
@node Object system, Library modules - Overview, Core library, Top
@chapter Object system
@c NODE オブジェクトシステム

Gauche's object system design is largely inspired by
STklos, whose design has come from TinyCLOS.
It supports multiple inheritance, multimethods,
and metaobject protocol.

The type system is integrated to the object system,
that is, a string is an instance of the class @code{<string>},
and so on.

@c ----------------------------------------------------------------------
@menu
* General Inquiry::             
* Defining class::              
* Defining methods::            
* Creating Instance::           
* Accessing Instance::          
* Metaobject protocol::         
@end menu

@node General Inquiry, Defining class, Object system, Object system
@section  General Inquiry
@c NODE 一般的な問い合わせ

@defun class-of obj
Returns a class metaobject of @var{obj}.

@example
(class-of 3)     @result{} #<class <integer>>
(class-of "foo") @result{} #<class <string>>
@end example
@end defun

@defun is-a? obj class
Returns true if @var{obj} is an instance of @var{class} or an instance
of descendants of @var{class}.

@example
(is-a? 3 <integer>)   @result{} #t
(is-a? 3 <real>)      @result{} #t
(is-a? 5+3i <real>)   @result{} #f
(is-a? :foo <symbol>) @result{} #f
@end example
@end defun

@c ----------------------------------------------------------------------
@node Defining class, Defining methods, General Inquiry, Object system
@section Defining class
@c NODE クラスの定義

@c EN
A class is a first-class object in Gauche and you can create it
on the fly at run-time using procedure calls.
However, for convenience, a macro is defined to create a class
and bind it globally.
@c JP
クラスは、Gaucheではファーストクラスのオブジェクトなので、
手続き呼び出しを使って実行時に動的に作成することができます。
簡便のため、グローバルに束縛されたクラスを生成するマクロが
定義されています。
@c COMMON

@defmac define-class name supers (slot-spec @dots{}) option @dots{}
@c EN
Creates a class object according to the arguments, and globally
bind it to a variable @var{name}.   This macro should be used at toplevel.

@var{Supers} is a list of direct superclasses from which this class
inherits.   You can use multiple inheritance.
See @ref{Multiple inheritance}  below, for the rule that determines
precedence of inheritance chain.

@var{Slot-spec} is a specification of a "slot", sometimes known as 
a "field" or an "instance variable" (but you can specify "class variable"
in @var{slot-spec} as well). 
The simplest form of @var{slot-spec} is just a symbol, which names
the slot.  Or you can give a list, whose first element is a symbol
and whose rest is an interleaved list of keywords and values.
The list form not only defines a name of the slot but specifies
behavior of the slot.  See @ref{Slot specification}, for details.

Finally, @var{option} @dots{} is an interleaved list of keywords
and values, specifies how class object should be created.
This macro recognizes one keyword, @code{:metaclass}, whose
corresponding value is used for metaclass (class that instantiates
another class).   Other options are passed to the @code{make}
method to create the class object.  @xref{Class instantiation},
for the usage of metaclass.
@c JP
引数によって指定されたクラスオブジェクトを作成し、それを @var{name} に
グローバルに束縛します。このマクロはトップレベルでのみ使うことができます。

@var{Supers} はそのクラスが継承する直接のスーパークラスのリストです。
多重継承も使えます。継承関係の優先についてのルールについては、
@ref{多重継承} を参照して下さい。

@var{Slot-spec} は「スロット」の仕様で、「フィールド」や「インスタンス
変数」と呼ばれるものです (@var{slot-spec} を使って「クラス変数」
を指定することもできます)。
@var{slot-spec} の最も単純なフォームはシンボルそのもので、その名前が
スロットであるものです。あるいは、最初の要素がシンボルで残りの要素が
キーワードと値が交互に来るリストを渡すこともできます。

このリストフォームは、スロットの名前を定義するだけでなく、そのスロットの
振る舞いも定義します。詳細は、@ref{Slot specification} を参照して下さい。

最後に、@var{option} @dots{} は、クラスオブジェクトがどのように
作られるかを指定する、キーワードと値が交互に来るリストです。

このマクロでは1つのキーワード引数、@code{:metaclass} により、
メタクラス(他のクラスをインスタンス化するクラス)を指定できます。
他のオプションはクラスオブジェクトを作成するために、@code{make}
メソッドに渡されます。メタクラスの使用方法については、
@ref{Class instantiation}を参照。

@c COMMON
@end defmac

@menu
* Multiple inheritance::        
* Slot specification::          
@end menu

@node Multiple inheritance, Slot specification, Defining class, Defining class
@subsection Multiple inheritance
@c NODE 多重継承

@node Slot specification,  , Multiple inheritance, Defining class
@subsection Slot specification
@c NODE スロットの記述


@c ----------------------------------------------------------------------
@node Defining methods, Creating Instance, Defining class, Object system
@section Defining methods
@c NODE メソッドの定義

@defmac define-generic name
@end defmac

@defmac define-method name specs body
@end defmac

@c ----------------------------------------------------------------------
@node Creating Instance, Accessing Instance, Defining methods, Object system
@section Creating Instance
@c NODE インスタンスの作成

@deffn {Generic Function} make class arg @dots{}
@end deffn

@deffn {Method} make (class <class>) arg @dots{}
@end deffn

@deffn {Method} make (class <method>)  arg @dots{}
@deffnx {Method} make (class <generic>)  arg @dots{}
@end deffn

@deffn {Method} initialize (class <class>) initargs
@end deffn

@c ----------------------------------------------------------------------
@node Accessing Instance, Metaobject protocol, Creating Instance, Object system
@section Accessing Instance
@c NODE インスタンスへのアクセス

@defun slot-ref obj slot
Returns a value of the slot @var{slot} of object @var{object}.

If the specified slot is not bound to any value, a generic function
@code{slot-unbound} is called with three arguments, @var{obj}'s class,
@var{obj}, and @var{slot}.  The default behavior of @code{slot-unbound}
is to signal an error.

If the object doesn't have the specified slot,
a generic function @code{slot-missing} is called with three
arguments, @var{obj}'s class,
@var{obj}, and @var{slot}.  The default behavior of @code{slot-missing}
is to signal an error.
@end defun

@defun slot-set! obj slot value
Alters the value of the slot @var{slot} of object @var{object} to
the value @var{value}.

If the object doesn't have the specified slot, a generic function
@code{slot-missing} is called with four arguments,
@var{obj}'s class, @var{obj}, @var{slot}, @var{value}.
@end defun

@defun slot-bound? obj slot
Returns true if object @var{obj}'s slot @var{slot} is bound, 
otherwise returns false.

If the object doesn't have the specified slot, a generic function
@code{slot-missing} is called with four arguments,
@var{obj}'s class, @var{obj}, @var{slot}.

@end defun

@defun slot-exists? obj slot
Returns true iff @var{obj} has the slot named @var{slot}.
@end defun

@defun slot-push! obj slot value
This function implements the common idiom.
It can be defined like the following code
(but it may be optimized in the future versions).
@example
(define (slot-push! obj slot value)
  (slot-set! obj slot (cons value (slot-ref obj slot))))
@end example
@end defun

@deffn {Method} slot-unbound (class <class>) obj slot
@end deffn

@deffn {Method} slot-missing (class <class>) obj slot &optional value
@end deffn


@defun class-slot-ref class slot-name
@defunx class-slot-set! class slot-name obj
@end defun

@c ----------------------------------------------------------------------
@node Metaobject protocol,  , Accessing Instance, Object system
@section Metaobject procotol
@c NODE メタオブジェクトプロトコル

@menu
* System metaclasses::          
* Class introspection::         
* Class instantiation::         
* Customizing slot access::     
* Method instantiation::        
* Customizing method application::  
@end menu

@node System metaclasses, Class introspection, Metaobject protocol, Metaobject protocol
@subsection System metaclasses
@c NODE システムメタクラス

@deftp {Class} <top>
@clindex top
@end deftp

@deftp {Class} <class>
@clindex class
@end deftp

@deftp {Class} <generic>
@clindex generic
@end deftp

@deftp {Class} <method>
@clindex method
@end deftp

@deftp {Class} <object>
@clindex object
@end deftp


@node Class introspection, Class instantiation, System metaclasses, Metaobject protocol
@subsection Class introspection
@c NODE クラスのイントロスペクション

@menu
* Class metaobject::            
* Slot definition::             
@end menu

@node Class metaobject, Slot definition, Class introspection, Class introspection
@subsubsection Class metaobject
@c NODE クラスメタオブジェクト

@defun class-name class
@end defun

@defun class-precedence-list class
@end defun

@defun class-direct-supers class
@end defun

@defun class-direct-slots class
@end defun

@defun class-slots
@end defun

@node Slot definition,  , Class metaobject, Class introspection
@subsubsection Slot definition
@c NODE スロット定義

@deftp {Class} <slot-accessor>
@clindex slot-accessor
@end deftp


@defun class-slot-definition class slot-name
@end defun

@defun class-slot-accessor class slot-name
@end defun

@defun slot-definition-name slot-def
@end defun
@defun slot-definition-allocation slot
@end defun

@defun slot-definition-getter slot
@defunx slot-defininion-setter slot
@defunx slot-definition-accessor slot
@end defun

@defun slot-definition-options slot-def
@defunx slot-definition-option slot-def key &optional default
@end defun

@node Class instantiation, Customizing slot access, Class introspection, Metaobject protocol
@subsection Class instantiation
@c NODE クラスのインスタンシエーション

@deffn {Method} make (class <class>) &rest initargs
@end deffn


@node Customizing slot access, Method instantiation, Class instantiation, Metaobject protocol
@subsection Customizing slot access
@c NODE スロットアクセスのカスタマイズ


@deffn {Generic Function} compute-slots
@end deffn

@deffn {Generic Function} compute-get-n-set
@end deffn

@defun slot-ref-using-accessor obj slot-accessor
@defunx slot-set-using-accessor obj slot-accessor value
@end defun

@node Method instantiation, Customizing method application, Customizing slot access, Metaobject protocol
@subsection Method instantiation
@c NODE メソッドのインスタンシエーション

@deffn {Method} make (class <method>) &rest initargs
@end deffn

@node Customizing method application,  , Method instantiation, Metaobject protocol
@subsection Customizing method application
@c NODE メソッド適用のカスタマイズ

@deffn {Generic Function} apply-generic gf args
@end deffn

@deffn {Generic Function} sort-applicable-methods gf methods args
@end deffn

@deffn {Generic Function} method-more-specific? method1 method2 classes
@end deffn

@deffn {Generic Function} apply-methods gf methods args
@end deffn

@deffn {Generic Function} apply-method gf method build-next args
@end deffn

@c ======================================================================
@node Library modules - Overview, Library modules - Gauche extensions, Object system, Top
@chapter Library modules - Overview
@c NODE ライブラリモジュール - 概要

@c EN
In the following chapters, the library modules bundled with the Gauche
distribution are explained.
Those modules should generally be loaded and imported (usually using @code{use}
- @xref{Using modules}, for details), unless otherwise noted.
@c JP
続くいくつかの章で、Gaucheのディストリビューションに含まれる
ライブラリモジュールを解説します。
これらのモジュールを使うにあたっては、特に断りのない限り、
モジュールをロードしてimportすることが必要です
(通常は@code{use}マクロが使えます。@ref{Using modules}参照)。
@c COMMON

@c EN
@ref{Library modules - Gauche extensions} describes
@code{gauche.*} modules, which are more or less considered
the core features of Gauche but separated since less frequently used.
(Some modules are rather ad-hoc, but here for historically reasons).
The modules in this category include system APIs
(e.g. @code{gauche.fcntl}, @code{gauche.termios}),
networking (@code{gauche.net}), thread APIs (@code{gauche.threads}),
and some high-level routines that are built on top of Gauche
low-level core APIs (e.g. @code{gauche.process}, @code{gauche.regexp}).
@c JP
@ref{Library modules - Gauche extensions}では、
@code{gauche.*}モジュールを解説します。
これらのモジュールはGaucheのコアの機能ですが、使用頻度が少ないために
モジュールとして分離されたものです。
(一部のモジュールはそれほど重要ではありませんが、
歴史的な理由からこのカテゴリに含まれています)。
このカテゴリに含まれるモジュールには、システムAPI (@code{gauche.fcntl}、
@code{gauche.termios}等)、ネットワーキング(@code{gauche.net})、
スレッドAPI (@code{gauche.threads})、
それからGaucheの低レベルのコアAPIの上に実装された高レベルなルーチン
(@code{gauche.process}、@code{gauche.regexp}等) があります。
@c COMMON

@c EN
@ref{Library modules - SRFIs} describes the modules that
provides SRFI functionalities.
Note that some of SRFI features are built in Gauche core and
not listed here.  @xref{Standard conformance}, for entire list
of supported SRFIs.
@c JP
@ref{Library modules - SRFIs}では、SRFIの機能を提供するモジュールを
解説します。一部のSRFIはGaucheのコアに組み込まれており、
この章には挙げられていないことに注意して下さい。
サポートされている全てのSRFIのリストは@ref{Standard conformance}にあります。
@c COMMON

@c EN
@ref{Library modules - Utilities} describes the modules
provides miscellaneous utility functions---including
dbm-style database interface, filesystem utilities,
network protocol utilities, and more.
@c JP
@ref{Library modules - Utilities} ではその他のさまざまなユーティリティ
関数を提供するモジュールを解説します。dbmスタイルのデータベース
インタフェース、ファイルシステムユーティリティ、ネットワークプロトコルユーティリティ
等があります。
@c COMMON

@c EN
The following table summarizes naming categories of the modules,
including external ones and planned ones.
@c JP
下の表は、モジュールの名前付けの分類を示します。
外部モジュール、及び将来予定されているモジュールも含みます。
@c COMMON

@table @code
@item data.*
@c EN
Generic data structures (planned).
@c JP
汎用的なデータ構造。(予定)
@c COMMON

@item dbm.*
@c EN
DBM interface
@c JP
DBMインタフェース
@c COMMON

@item gauche.*
@c EN
Stuffs more or less considered as Gauche core features.
@c JP
Gauche本体の一部として考えられている機能。
@c COMMON

@item gl.*
@c EN
OpenGL binding and related libraries (external package).
@c JP
OpenGLバインディングと関連するライブラリ (外部パッケージ)。
@c COMMON

@item gtk.*
@c EN
GTk+ binding and related libraries (external package).
@c JP
GTk+バインディングと関連するライブラリ (外部パッケージ)。
@c COMMON

@item file.*
@c EN
Manipulating files and directories.
@c JP
ファイルとディレクトリの操作。
@c COMMON

@item lang.*
@c EN
Language-related libraries, artificial and/or natural (planned).
@c JP
言語に関するライブラリ(人工的なものも自然言語関連も)。(予定)
@c COMMON

@item math.*
@c EN
Mathematics.
@c JP
数学。
@c COMMON

@item compat.*
@c EN
Compatibility libraries
@c JP
他の実装とのコンパチビリティに関するライブラリ。 (予定)
@c COMMON

@item rfc.*
@c EN
Implementations of net protocols defined in RFC's.
@c JP
RFCで定義されているデータフォーマットやネットワークプロトコルの実装。
@c COMMON

@item srfi-*
@c EN
SRFI implementations.
@c JP
SRFIの実装
@c COMMON

@item text.*
@c EN
Libraries dealing with text data.
@c JP
テキストデータを扱うライブラリ
@c COMMON

@item util.*
@c EN
Generic implementations of various algorithms.
@c JP
汎用的なアルゴリズムの実装。
@c COMMON

@item www.*
@c EN
Implementations of various protocols and formats mainly used in WWW.
@c JP
WWWで主として使われるプロトコルやデータフォーマットの実装。
@c COMMON
@end table

@c ======================================================================
@node Library modules - Gauche extensions, Library modules - SRFIs, Library modules - Overview, Top
@chapter Library modules - Gauche extensions
@c NODE ライブラリモジュール - Gauche拡張モジュール

@c ----------------------------------------------------------------------
@menu
* gauche.array - Arrays::       
* gauche.charconv - Character code conversion::  
* gauche.collection - Collection framework::  
* gauche.config - Configuration parameters::  
* gauche.fcntl - Low-level file operations::  
* gauche.hook - Hooks::         
* gauche.interactive - Interactive session::  
* gauche.listener - Listener::  
* gauche.logger - User-level logging::  
* gauche.mop.singleton - Singleton::  
* gauche.mop.validator - Slot with validator::  
* gauche.net - Networking::     
* gauche.parameter - Parameters::  
* gauche.parseopt - Parsing command-line options::  
* gauche.process - High Level Process Interface::  
* gauche.regexp - Regular expression utilities::  
* gauche.reload - Reloading modules::  
* gauche.selector - Simple dispatcher::  
* gauche.sequence - Sequence framework::  
* gauche.syslog - Syslog::      
* gauche.termios - Termios::    
* gauche.test - Unit testing::  
* gauche.threads - Threads::    
* gauche.time - Measure timings::  
* gauche.uvector - Uniform vectors::  
* gauche.version - Comparing version numbers::  
@end menu

@node gauche.array - Arrays, gauche.charconv - Character code conversion, Library modules - Gauche extensions, Library modules - Gauche extensions
@section @code{gauche.array} - Arrays
@c NODE gauche.array - 配列, @code{gauche.array} - 配列

@deftp {Module} gauche.array
@mdindex gauche.array
@c EN
This module provides multi-dimensional array data type and operations.
The primitive API follows SRFI-25.  This module also defines several
useful operations.   This module also implements an external
representation of arrays, using SRFI-10 mechanism.
@c JP
このモジュールは多次元配列のデータタイプとそれに関する操作を提供します。
プリミティブなAPIはSRFI-25で定義されているものに従います。
さらにいくつかの便利な操作も定義されています。
また、SRFI-10を使った配列の外部表現も実装されます。
@c COMMON

@c EN
Each element of an @var{N}-dimensional array can be accessed
by @var{N} integer indices,
@code{[ @var{i_0} @var{i_1} @dots{} @var{i_N-1} ]}.
An array has associated @var{shape} that knows lower-bound @var{s_k} and
upper-bound @var{e_k} of index of each dimension, where
@var{s_k} <= @var{e_k}, and the index @var{i_k} must satisfy
@var{s_k} <= @var{i_k} < @var{e_k}.
(Note: it is allowed to have @var{s_k} == @var{e_k}, but such array can't
store any data.  It is also allowed to have zero-dimensional array,
that can store a single data.).
The shape itself is a [ @var{D} x 2 ] array, where @var{D} is the
dimension of the array which the shape represents.
@c JP
@var{N}次元の配列の各エレメントは@code{N}個の整数のインデックス
@code{[ @var{i_0} @var{i_1} @dots{} @var{i_N-1} ]}でアクセスされます。
配列は、各次元のインデックスの下限@var{s_k}および上限@var{e_k}を決める
@var{shape}を持っています。ここで、@var{s_k} <= @var{e_k}であり、
@var{k}次元目のインデックス@var{i_k}は
@var{s_k} <= @var{i_k} < @var{e_k} を満たすものとします。
(@var{s_k} == @var{e_k} であるような配列も作れますが、
その配列にはデータをストアすることはできません。
また、0次元の配列は作れます。それは一つだけデータを保持できます)。
Shapeはそれ自体が [ @var{D} x 2 ] の配列です。
ここで@var{D}はそのshapeが表現する配列の次元数です。
@c COMMON

@c EN
You can pass index to array access primitives in a few ways;
each index can be passed as individual argument,
or can be 'packed' in a vector or one-dimensional array.
In the latter case, such a vector or an array is called an "index object".
Using vector is efficient in Gauche when you iterate over the elements
by changing the vector elements, for it won't involve memory allocation.
@c JP
配列のプリミティブに対しインデックスを渡すにはいくつか方法があります。
各インデックスをばらばらの引数として渡すこともできますし、
ベクタや1次元の配列にパックして渡すこともできます。
後者においてインデックスがパックされたベクタや配列を「インデックスオブジェクト」
と呼ぶことがあります。Gaucheでは、配列の要素に次々とアクセスするような処理では
ベクタをインデックスオブジェクトとして使うと若干効率が良いでしょう。
@c COMMON

@c EN
Arrays can be compared by the @code{equal?} procedure.
@code{Equal?} returns @code{#t} if two arrays have the same
shape and their corresponding elements are the same
in the sense of @code{equal?}.
@c JP
配列は@code{equal?}手続きで比較することが出来ます。
二つの配列のshapeが等しく、また対応する各要素が@code{equal?}の意味で
等しい場合に二つの配列は@code{equal?}であると見なされます。
@c COMMON

@c EN
Internally, an array consists of a backing storage and a mapping procedure.
A backing storage is an object of aggregate type that can be accessed
by an integer index.  A mapping procedure takes
multi-dimensional indices (or index object) and 
returns a scalar index into the backing storage.
@c JP
内部的には、配列は1次元のインデックスでアクセスされるバッキングストレージと、
多次元のインデックスをバッキングストレージへのインデックスにマップする手続きとから
構成されています。
@c COMMON
@end deftp

@deftp {Class} <array>
@clindex array

@end deftp

@deftp {Reader syntax} @code{#,(<array> @var{shape} @var{obj} @dots{})}
@c EN
An array is written out in this format.  @var{shape} is a list
of even number of integers, and each 2@var{n}-th integer
and 2@var{n}+1-th integer specifies the
inclusive lower-bound and exclusive upper-bound of @var{n}-th dimension,
respectively.  The following @var{obj} @dots{} are the values in the array
listed in row-major order.
@c JP
配列をこの形式で書き出されます。@var{shape}は偶数個の整数のリストで、
2@var{n}番目の整数が@var{n}次元目のインデックスの下限を、2@var{n}+1番目の
整数が@var{n}次元目のインデックスの上限(+1)を表します。
その後に、配列の要素がrow-majorの順で書き出されます。
@c COMMON

@c EN
When read back, this syntax is read as an array with the same shape
and content, so it is @code{equal?} to the original array.
@c JP
この構文が読み込まれると、もとの配列と@code{equal?}である配列が作成されます。
@c COMMON

@example
@c EN
; an array such that:
@c JP
; 次のような配列：
@c COMMON
;   8 3 4
;   1 5 9
;   6 7 2
#,(<array> (0 3 0 3) 8 3 4 1 5 9 6 7 2)

@c EN
; a 4x4 identity matrix
@c JP
; 4x4の単位行列
@c COMMON
#,(<array> (0 4 0 4) 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1)
@end example
@end deftp

@defun array? obj
[SRFI-25]
@c EN
Returns @code{#t} if @var{obj} is an array, @var{#f} otherwise.
@c JP
@var{obj}が配列であれば@var{#t}が、そうでなければ@var{#f}が返されます。
@c COMMON
@end defun

@defun make-array shape &optional init
[SRFI-25]
@c EN
Creates an array of shape @var{shape}.
@var{Shape} must be a [ @var{D} x 2 ] array, and for each @var{k}
(0 <= @var{k} < @var{D}), the [ @var{k} 0 ] element must be less than or
equal to the [ @var{k} 1] element.
If @var{init} is given, all the elements are initialized by it.
Otherwise, the initial value of the elements are undefined.
@c JP
Shapeが@var{shape}である配列を作成します。
@var{Shape}は [ @var{D} x 2 ] の配列で、
0 <= @var{k} < @var{D} なる各@var{k}に対して要素 [ @var{k} 0 ] は
要素[ @var{k} 1 ]以下でなければなりません。
@var{init}が与えられた場合は、配列の各要素が@var{init}で初期化されます。
@var{init}が与えられなかった場合の配列の要素の初期値は不定です。
@c COMMON

@example
(make-array (shape 0 2 0 2 0 2) 5)
 @result{} #,(<array> (0 2 0 2 0 2) 5 5 5 5 5 5 5 5)
@end example
@end defun

@defun shape bound @dots{}
[SRFI-25]
@c EN
Takes even number of exact integer arguments, and returns
a two-dimensional array that is suitable for representing the shape
of an array.
@c JP
偶数個の正確な整数を引数に取り、配列のshapeとして使える2次元の配列を返します。
@c COMMON

@example
(shape 0 2 1 3 3 5)
 @result{} #,(<array> (0 3 0 2) 0 1 3 2 3 5)

(shape)
 @result{} #,(<array> (0 0 0 2))
@end example
@end defun

@defun array shape init @dots{}
[SRFI-25]
@c EN
Creates an array of shape @var{shape}, initializing its elements by
@var{init} @dots{}.
@c JP
Shapeが@var{shape}であるような配列を作成し、
その要素を@var{init} @dots{}で初期化します。
@c COMMON

@example
(array (shape 0 2 1 3) 'a 'b 'c 'd)
 @result{} #,(<array> (0 2 1 3) a b c d)
@end example
@end defun

@defun array-rank array
[SRFI-25]
@c EN
Returns the number of dimensions of an array @var{array}.
@c JP
配列@var{array}の次元数を返します。
@c COMMON

@example
(array-rank (make-array (shape 0 2 0 2 0 2))) @result{} 3
(array-rank (make-array (shape))) @result{} 0
@end example
@end defun

@defun array-shape array
@c EN
Returns a shape array of @var{array}.
@c JP
配列@var{array}のshapeを表す配列を返します。
@c COMMON
@end defun

@defun array-start array dim
@defunx array-end array dim
@defunx array-length array dim
[SRFI-25+]
@c EN
@code{Array-start} returns the inclusive lower bound of index of
@var{dim}-th dimension of an array @var{array}.
@code{Array-end} returns the exclusive upper bound.
And @code{array-length} returns the difference between two.
@code{Array-start} and @code{array-end} are defined in SRFI-25.
@c JP
@code{array-start}は配列@var{array}の@var{dim}番目の次元の
インデックスの下限を返します。
@code{array-end}は上限+1を、そして@code{array-start}は両者の差を返します。
@code{array-start}と@code{array-end}はSRFI-25で定義されています。
@c COMMON

@example
(define a (make-array (shape 1 5 0 2)))

(array-start a 0)  @result{} 1
(array-end a 0)    @result{} 5
(array-length a 0) @result{} 4
(array-start a 1)  @result{} 0
(array-end a 1)    @result{} 2
(array-length a 1) @result{} 2
@end example
@end defun

@defun array-size array
@c EN
Returns the total number of elements in the array @var{array}.
@c JP
配列@var{array}の全要素数を返します。
@c COMMON

@example
(array-size (make-array (shape 5 9 1 3))) @result{} 8
(array-size (make-array (shape))) @result{} 1
(array-size (make-array (shape 0 0 0 2))) @result{} 0
@end example
@end defun

@defun array-ref array k @dots{}
@defunx array-ref array index
[SRFI-25]
@c EN
Gets the element of array @code{array}.  In the first form,
the element is specified by indices @var{k} @dots{}.
In the second form, the element is specified by an index object
@var{index}, which must be a vector or an one-dimensional array.
@c JP
配列@var{array}の要素を取り出します。最初の形式では、
要素は整数のインデックス@var{k} @dots{}で指定されます。
2番目の形式では、要素はベクタまたは1次元配列のインデックスオブジェクト@var{index}
で指定されます。
@c COMMON
@end defun

@defun array-set! array k @dots{} value
@defunx array-set! array index value
[SRFI-25]
@c EN
Sets the element of array @var{array} to @var{value}.  In the first form,
the element is specified by indices @var{k} @dots{}.
In the second form, the element is specified by an index object
@var{index}, which must be a vector or an one-dimensional array.
@c JP
配列@var{array}の要素に@var{value}をセットします。
最初の形式では、
要素は整数のインデックス@var{k} @dots{}で指定されます。
2番目の形式では、要素はベクタまたは1次元配列のインデックスオブジェクト@var{index}
で指定されます。
@c COMMON
@end defun

@defun share-array array shape proc
[SRFI-25]
@c EN
Creates and returns a new array of shape @var{shape}, that shares
the backing storage with the given array @var{array}.
The procedure @var{proc} maps the indices of the new array to
the indices to the original array, i.e. @var{proc} must be a @var{n}-ary
procedure that returns @var{m} values, where @var{n} is the dimension
of the new array and @var{m} is the one of the original array.
Furthermore, @var{proc} must be an affine function; each mapping
has to be a linear combination of input arguments plus optional constant.
(@code{Share-array} optimizes the mapping function based on the affinity
assumption, so @var{proc} won't be called every time the new array
is accessed).
@c JP
Shapeが@var{shape}であり、与えられた配列@var{array}とバッキングストレージを
共有する新しい配列を作成して返します。
@var{proc}は、新しい配列へのインデックスを古い配列へのインデックスへ
マップする手続きです。新しい配列の次元数を@var{n}、古い配列の次元数を@var{m}と
した時、@var{proc}は@var{n}個の引数を取り@var{m}個の値を返す手続きでなければ
なりません。さらに、各マッピングはaffineマッピング、すなわち、
出力は入力の線形合成(プラス定数)でなければなりません。
(@code{share-array}は@var{proc}がaffineマッピングであるという事実に基づいた
最適化を行います。新しい配列にアクセスする度に@var{proc}が呼ばれるというわけでは
ありません)。
@c COMMON
@end defun

@defun array-for-each-index array proc &optional index
@end defun

@defun shape-for-each shape proc &optional index
@end defun

@defun tabulate-array shape proc &optional index
@end defun

@defun array-retabulate! array shape proc &optional index
@defunx array-retabulate! array proc &optional index
@end defun

@defun array-map! array shape proc array0 array1 @dots{}
@defunx array-map! array proc array0 array1 @dots{}
@end defun

@defun array-map shape proc array0 array1 @dots{}
@defunx array-map proc array0 array1 @dots{}
@end defun

@defun array->vector array
@defunx array->list array
@end defun

@c ----------------------------------------------------------------------
@node gauche.charconv - Character code conversion, gauche.collection - Collection framework, gauche.array - Arrays, Library modules - Gauche extensions
@section @code{gauche.charconv} - Character Code Conversion
@c NODE gauche.charconv - 文字コード変換, @code{gauche.charconv} - 文字コード変換

@deftp {Module} gauche.charconv
@mdindex gauche.charconv
@c EN
This module defines a set of functions that converts character encoding
schemes (CES) of the given data stream.
This module also overloads Gauche's file stream creating functions
(such as @code{open-input-file} and @code{call-with-output-file})
so that they accept @code{:encoding} keyword argument.
@c JP
与えられたデータストリームの文字エンコーディングを変換するための手続き群を提供する
モジュールです。また、このモジュールは@code{open-input-file}や
@code{call-with-output-file}等のファイルストリームを作成する手続きを
置き換え、@code{:encoding} キーワード引数を認識するようにします。
@c COMMON

@c EN
As of release 0.5.6, Gauche natively supports conversions between
typical Japanese character encodings: ISO2022JP, ISO2022JP-3,
EUC-JP (EUC-JISX0213), Shift_JISX0213, UTF-8 (Unicode 3.2).
Conversions between other encodings are handled by @code{iconv(3)}.
@xref{Supported character encoding schemes}, for details.
@c JP
リリース0.5.6より、Gaucheは日本語の主要エンコーディング
(ISO2022JP, ISO2022JP-3, EUC-JP (EUC-JISX0213), Shift_JIS (Shift_JISX0213), 
UTF-8 (Unicode 3.2))間の変換を自前で持つようになりました。
上記以外のコードとの変換は@code{iconv(3)}を利用します。
サポートされるコーディングシステムに関する詳細は
@ref{Supported character encoding schemes}を参照して下さい。
@c COMMON
@end deftp

@menu
* Supported character encoding schemes::  
* Autodetecting the encoding scheme::  
* Conversion ports::            
* Extended port procedures::    
@end menu

@node Supported character encoding schemes, Autodetecting the encoding scheme, gauche.charconv - Character code conversion, gauche.charconv - Character code conversion
@subsection Supported character encoding schemes
@c NODE サポートされる文字エンコーディング

@c EN
A CES is represented by its name as a string.
Case is ignored.  There may be several aliases defined for a single encoding.
@c JP
CESの名前は文字列で指定します。大文字小文字の違いは無視されます。
同じCESにいくつかの別名がついていることがあります。
@c COMMON

@c EN
You can check whether the specific conversion is supported on
your system or not, by the following function.
@c JP
特定の変換がシステムでサポートされているかどうかは次の手続きで調べることができます。
@c COMMON

@defun ces-conversion-supported? from-ces to-ces
@c EN
Returns @code{#t} if conversion from the character encoding scheme
(CES) @var{from-ces} to @var{to-ces} is supported in this system.
@c JP
符号化方法@var{from-ces}から@var{to-ces}への変換がサポートされていれば@code{#t}を、
そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@c EN
Conversion between common japanese CESes (EUC_JP, Shift JIS, UTF-8
and ISO2022-JP) of the character set JIS X 0201 and JIS X 0213
is handled by Gauche's built-in algorithm (see below for details).
When other CES name is given, Gauche uses
@code{iconv(3)} if it is linked.
@c JP
日本語の文字セットJIS X 0201及びJIS X 0213のエンコーディング
(EUC_JP、Shift JIS、UTF-8及びISO2022-JP) 間の変換に関しては、
Gaucheが内部に変換アルゴリズムを持っています (詳細は下の注記を参照)。
それ以外のCESに関しては、リンクされていればGaucheは@code{iconv(3)}を用いて
変換を行います。
@c COMMON

@c EN
When Gauche's conversion routine encounters a character that can't
be mapped, it replaces the character for "geta mark" (U+3013)
if it's a multibyte character in the input encoding, or for '?' if it's
a singlebyte character in the input encoding.
If that happens in iconv, handling of such character depends
on iconv implementation (glibc implementation returns an error).
@c JP
出力CESへマップ不可能な入力文字に出会った場合、Gaucheの変換ルーチンは
その文字が入力CESでマルチバイトである場合はgeta mark '〓' (U+3013) に、
入力CESでシングルバイトである場合は '?' に置換します。
iconvによる変換でマップ不可能な文字に出会った場合の処理はiconvの実装に
依存します(例えばglibcではエラーとなります)。
@c COMMON

@c EN
If the conversion routine encounters an input sequence that
is illegal in the input CES, an error is signalled.
@c JP
変換ルーチンが、入力CESとして不正な入力文字列に出会った場合は
エラーが報告されます。
@c COMMON

@c EN
@strong{Details of Gauche's native conversion algorithm:}
Between EUC_JP, Shift JIS and ISO2022JP, Gauche uses arithmetic
conversion whenever possible.  This even maps the undefined codepoint
properly.  Between Unicode (UTF-8) and EUC_JP, Gauche uses lookup tables.
Between Unicode and Shift JIS or ISO2022JP, Gauche converts the
input CES to EUC_JP, then convert it to the output CES.
If the same CES is specified for input and output, Gauche's conversion
routine just copies input characters to output characters, without 
checking the validity of the encodings.
@c JP
@strong{Gaucheの内部変換アルゴリズムの詳細:}
EUC_JP、Shift JIS、及びISO2022JP間の変換は可能な限り計算で行います。
文字が未定義のコードポイントも計算式に従って変換されます。
Unicode(UTF-8)とEUC_JP間の変換はテーブルルックアップによって行われます。
UnicodeとShift JISまたはISO2022JP間の変換は、入力CESを一度EUC_JPに
変換し、それを出力CESに変換することによって行います。
入力と出力のCESがGaucheの内部アルゴリズムがサポートする範囲で等しかった場合、
Gaucheの変換ルーチンはエンコーディングの正当性はチェックせず、
単に入力を出力にコピーします。
@c COMMON

@table @code
@item EUC_JP, EUCJP, EUCJ, EUC_JISX0213
@c EN
Covers ASCII, JIS X 0201 kana, JIS X 0212 and JIS X 0213 character sets.
JIS X 0212 character set is supported merely because it uses
the code region JIS X 0213 doesn't use, and JIS X 0212 characters
are not converted properly to Shift JIS and UTF-8.
Use JIS X 0213.
@c JP
ASCII, JIS X 0201カナ、JIS X 0212、及びJIS X 0213文字セットをカバーします。
JIS X 0212は、単にJIS X 0213と重ならないコードを使っているためにサポート
されていますが、他のCESへの変換は行われないので注意して下さい。
なるべくJIS X 0213の使用をおすすめします。
@c COMMON

@item SJIFT_JIS, SHIFTJIS, SJIS
@c EN
Covers Shift_JISX0213, except that 0x5c and 0x7e is mapped to ASCII
character set (REVERSE SOLIDUS and TILDE),
instead of JIS X 0201 Roman (YEN SIGN and OVERLINE).
@c JP
Shift_JISX0213をカバーします。但し、0x5cと0x7eに関しては
JIS X 0201 Roman (YEN SIGNとOVERLINE) ではなく
ASCII (REVERSE SOLIDUSとTILDE) にマップされます。
@c COMMON

@item UTF-8, UTF8
@c EN
Unicode 3.2.  Note that some JIS X 0213 characters are mapped to Extension B
(U+20000 and up).
Some JIS X 0213 characters are mapped to two
unicode characters (one base character plus a combining character).
@c JP
Unicode 3.2です。JIS X 0213中の文字のいくつかはExtension B (U+20000〜)
にマップされます。JIS X 0213中の他の文字のいくつかは2つのUnicode文字
(base character + combining character)にマップされます。
@c COMMON

@item ISO2022JP, CSISO2022JP, ISO2022JP-1, ISO2022JP-2, ISO2022JP-3
@c EN
These encodings differ a bit
(except ISO2022JP and CSISO2022JP, which are synonyms), but
Gauche handles them same.  If one of these CES is specified as input,
Gauche recognizes escape sequences of any of CES.
ISO2022JP-2 defines several non-Japanese escape sequences, and
they are recognized by Gauche, but mapped to substitution character
('?' or geta mark).
@c JP
これらのエンコーディングは、CSISO2022JPがISO2022JPのエイリアスであることを除き
異なるエスケープシーケンスを使いますが、Gaucheの中では同じルーチンで処理されます。
これらのエンコーディングのいずれかが入力CESに指定された場合、
Gaucheは全てのバリエーションのエスケープシーケンスを認識します。
但し、ISO2022JP-2に定義された日本語以外の言語のエスケープシーケンスに関しては、
Gaucheはエスケープシーケンスの認識だけを行い、
文字は'?'あるいは'〓' に置換します。
@c COMMON

@c EN
For output, Gauche assumes ISO2022JP first, and uses ISO2022JP-1
escape sequence to put JIS X 0212 character, or uses ISO2022JP-3
escape sequence to put JIS X 0213 plane 2 character.
Thus, if the string contains only JIS X 0208 characters, 
the output is compatible to ISO2022JP.
Precisely speaking, JIS X 0213 specifies some characters in JIS X 0208
codepoint that shouldn't be mixed with JIS X 0208 characters;
Gauche output those characters as JIS X 0208 for compatibility.
(This is the same policy as Emacs-Mule's iso2022jp-3-compatible mode).
@c JP
出力に関してはGaucheは出来る限りISO2022JPでエンコードし、
JIS X 0212文字に出会ったらISO2022JP-1のエスケープシーケンスを、
JIS X 0213の第2面の文字に出会ったらISO2022JP-3のエスケープシーケンスを
用います。したがって、文字列がJIS X 0208の範囲だけで構成されていた場合は
出力はISO2022JP互換となります。
厳密には、JIS X 0213では包摂基準の変更により、
「JIS X 0208と同じコードポイントを用いるがJIS X 0208のエスケープシーケンスを
使ってはいけない文字」というのが定義されています。
Gaucheでは互換性のため、これらの文字もJIS X 0208のエスケープシーケンスを
用いてエンコードします (これは、Emacs-Muleにおけるiso2022jp-3-compatible
モードと同じ方針です)。
@c COMMON
@end table

@node Autodetecting the encoding scheme, Conversion ports, Supported character encoding schemes, gauche.charconv - Character code conversion
@subsection Autodetecting the encoding scheme
@c NODE 文字エンコーディングの自動判定

@c EN
There are cases that you don't know the CES of the input, but
you know it is one of several possible encodings.
The charconv module has a mechanism
to guess the input encoding.  There can be multiple algorithms,
and each algorithm has the name.  Right now, there's only one
algorithm implemented:
@c JP
しばしば、入力のCESが未知であり、可能性のあるいくつかの候補から入力のCESを
推測しなければならない場合があります。推測するアルゴリズムはいくつも考えられるので、
それぞれに名前がついています。今のところ、一つのアルゴリズムしか実装されていません。
@c COMMON
@table @code
@item "*JP"
@c EN
To guess the character encoding from japanese text, among either
ISO2022-JP(-1,2,3), EUCJP, SHIFT_JIS or UTF-8.
@c JP
日本語のテキストのCESを、ISO2022-JP(-1,2,3), EUCJP, SHIFT_JIS または UTF-8の
いずれかであるとして推測する。
@c COMMON
@end table

@c EN
This name can be used in place of CES name for some conversion functions.
@c JP
このアルゴリズム名は、いくつかの変換関数においてCES名の代わりに使うことができます。
@c COMMON


@defun ces-guess-from-string string scheme
@c EN
Guesses the CES of @var{string} by the character guessing scheme
@var{scheme} (e.g. "*JP").  Returns CES name that can be used
by other charconv functions.   It may return @code{#f} if the
guessing scheme finds no possible encoding in @var{string}.
Note that if there may be more than one possible encoding in
@var{string}, the guessing scheme returns one of them,
usually in favor of the native CES.
@c JP
文字列@var{string}のCESを、CES推測アルゴリズム@var{scheme} ("*JP"など)
を使って推測し、結果のCES名を返します。もしどのCESにも該当しないデータが
含まれていれば@code{#f}が返されます。複数のCESが可能である場合、
ネイティブエンコーディングが含まれていればそれを、
そうでなければ可能なCESからどれかひとつが選んで返されます。
@c COMMON
@end defun


@node Conversion ports, Extended port procedures, Autodetecting the encoding scheme, gauche.charconv - Character code conversion
@subsection Conversion ports
@c NODE 変換ポート

@defun open-input-conversion-port source from-code &keyword to-code buffer-size owner?
@c EN
Takes an input port @var{source}, which feeds characters
encoded in @var{from-code}, and returns another input port,
from which you can read characters encoded in @var{to-code}.
@c JP
文字が符号化方法@var{from-code}で符号化されているデータを読み出せる
入力ポート@var{source}を取り、符号化方法@var{to-code}で符号化されたデータを
読み出せるポートを作成して返します。
@c COMMON

@c EN
If @var{to-code} is omitted, the native CES is assumed.
@c JP
@var{to-code}が省略された場合はネイティブのCESと見なされます。
@c COMMON

@c EN
@var{buffer-size} is used to allocate internal buffer size for
conversion.  The default size is about 1 kilobytes and it's suitable
for typical cases.
@c JP
@var{buffer-size}は変換のための内部バッファのサイズを指定します。
省略時のサイズは1Kバイト程で、通常の使用には問題ないサイズです。
@c COMMON

@c EN
If you don't know the @var{source}'s CES, you can specify
CES guessing scheme, such as @code{"*JP"}, in place of @var{from-code}.
The conversion port tries to guess the encoding, by prefetching
the data from @var{source} up to the buffer size.  It signals an error
if the code guessing routine finds no appropriate CES.
If the guessing routine finds ambiguous input, however, it silently
assume one of possible CES's, in favor of the native CES.
Hence it is possible that the guessing is wrong if the buffer
size is too small.  The default size is usually enough for most
text documents, but it may fail if the large text contains mostly ASCII
characters and multibyte characters appear only at the very end of
the document.
To be sure for the worst case,
you have to specify the buffer size large enough to
hold entire text.
@c JP
入力のCESが不明な場合、@code{"*JP"}などのCES推測アルゴリズム名を@var{from-code}
として指定することができます。変換ポートは最高でバッファサイズまでのデータを先読みし、
CESを推測しようとします。そのアルゴリズムで推測されるどのCESにも該当しないデータが
検出された場合はエラーが報告されます。もし複数のCESが可能であるようなデータであった
場合は、Gaucheのネイティブエンコーディングが可能なCESに含まれていればそれが選ばれ、
そうでなければいずれかのCESが適当に選ばれます。従って、バッファサイズが小さすぎると
誤った判定をする可能性が高くなります。大抵のテキストドキュメントに対して、
既定のバッファサイズは十分ですが、大きなテキストのほとんどがASCII文字で最後だけ
マルチバイト文字が現われるようなテキストでは誤判定の可能性があります。
最悪の場合でも結果を保証するには、テキスト全体が格納できるバッファサイズを指定すると
良いでしょう。
@c COMMON

@c EN
By default, @code{open-input-conversion-port} leaves @var{source} open.
If you specify true value to @var{owner?}, the function closes
@var{source} after it reads EOF from the port.
@c JP
通常、@code{open-input-conversion-port}は変換が全て終了した後でも@var{source}
はオープンしたままにします。キーワード引数@var{owner?}に真の値を指定すると、
EOFが読まれた後で@var{source}はクローズされます。
@c COMMON

@c EN
For example, the following code copies a file @file{unknown.txt} to a file
@file{eucjp.txt}, converting unknown japanese CES to EUC-JP.
@c JP
例を示しましょう。以下のコードは未知のCES(但しEUC-JP, SJIS, ISO2022-JP, UTF8の
いずれかであることは分かっている)で書かれたテキストファイル@file{unknown.txt}を
読みだし、文字エンコーディングをEUC-JPに変換して@file{eucjp.txt}に書き出します。
@c COMMON
@example
(call-with-output-file "eucjp.txt"
  (lambda (out)
    (copy-port (open-input-conversion-port
                 (open-input-file "unknown.txt")
                 "*jp"             ;@r{guess code}
                 :to-code "eucjp"
                 :owner? #t)       ;@r{close unknown.txt afterwards}
               out)))
@end example
@end defun


@defun open-output-conversion-port sink to-code &keyword from-code buffer-size owner?
@c EN
Creates and returns an output port that converts
given characters from @var{from-code} to @var{to-code}
and feed to an output port @var{sink}.
If @var{from-code} is omitted, the native CES is assumed.
You can't specify a character guessing scheme (such as "*JP") to
neither @var{from-code} nor @var{to-code}.
@c JP
文字のエンコーディングを@var{from-code}から@code{to-code}に変換して
出力ポート@var{sink}に書き出すような出力変換ポートを作成して返します。
@var{to-code}が省略された場合はネイティブのCESと見なされます。
@var{from-code}にも@var{to-code}にも、CES推測アルゴリズム名を
使用することはできません。
@c COMMON

@c EN
@var{buffer-size} specifies the size of internal conversion buffer.
The characters put to the returned port may stay in the buffer,
until the port is explicity flushed (by @code{flush}) or
the port is closed.
@c JP
@var{buffer-size}は内部で変換に使われるバッファサイズを指定します。
出力変換ポートに書き出された文字は、@code{flush}を使って明示的に
フラッシュするか出力変換ポートが閉じられるまで、バッファ内に残っている可能性があります。
@c COMMON

@c EN
By default, the returned port doesn't closes @var{sink} when
itself is closed.  If a keyword argument @var{owner?} is provided
and true, however, it closes @var{sink} when it is closed.
@c JP
通常、出力変換ポートがクローズされても@var{sink}はクローズされません。
@var{owner?}に真の値を与えれば、出力変換ポートのクローズ時に@var{sink}を
クローズするようにできます。
@c COMMON
@end defun

@defun ces-convert string from-code &optional to-code
@c EN
Convert @var{string}'s character encoding from @var{from-code}
to @var{to-code}, and returns the converted string.
The returned string may be a byte-string if @var{to-code}
is different from the native CES.
@c JP
@var{from-code}でエンコーディングされた文字列@var{string}を
@var{to-code}でエンコーディングされた文字列に変換します。
@var{to-code}がネイティブエンコーディングで無い場合、返される文字列は
バイト文字列(不完全な文字列)であるかもしれません。
@c COMMON

@c EN
@var{from-code} can be a name of character guessing scheme
(e.g. "*JP").  when @var{to-code} is omitted, the native CES is
assumed.
@c JP
@var{from-code}にはCES推測アルゴリズム名("*JP"など)を与えることができます。
@var{to-code}が省略された場合はネイティブエンコーディングと見なされます。
@c COMMON
@end defun



@node Extended port procedures,  , Conversion ports, gauche.charconv - Character code conversion
@subsection Extended port procedures
@c NODE 拡張されたポート手続き


@defun open-input-file filename &keyword encoding conversion-buffer-size @dots{}
@defunx call-with-input-file filename proc &keyword encoding conversion-buffer-size @dots{}
@defunx with-input-from-file filename thunk &keyword encoding conversion-buffer-size @dots{}
@defunx open-output-file filename &keyword encoding conversion-buffer-size @dots{}
@defunx call-with-output-file filename proc &keyword encoding conversion-buffer-size @dots{}
@defunx with-output-to-file filename thunk &keyword encoding conversion-buffer-size @dots{}
@c EN
These Gauche built-in procedures are extended to accept two extra
keyword arguments, @var{encoding} and @var{conversion-buffer-size}.
(@xref{File ports}, for their default behavior).

You can give a CES of the file @var{filename} to @var{encoding},
and the port automatically converts the file CES to the Gauche's
native CES.  You can use a CES guessing algorithm name for
input file port.

The keyword argument @var{conversion-buffer-size} has the same
meaning as @var{buffer-size} of @code{open-input-conversion-port}.
@c JP
これらのGauche組み込みの手続きは、@var{encoding}と@var{conversion-buffer-size}
という二つの追加のキーワード引数を取るように拡張されます。
(これらの手続きの元の動作については@ref{File ports}を参照して下さい)。

@var{filename}の文字エンコーディング名を@var{encoding}に渡すと、
ファイルを読む際に@var{encoding}からGaucheの内部エンコーディングへの変換が
行われます。入力の場合は@var{encoding}にCES推測アルゴリズム名を渡すこともできます。

@var{conversion-buffer-size}は@code{open-input-conversion-port}
における@var{buffer-size}と同じ意味を持ちます。
@c COMMON
@end defun



@c ----------------------------------------------------------------------
@node gauche.collection - Collection framework, gauche.config - Configuration parameters, gauche.charconv - Character code conversion, Library modules - Gauche extensions
@section @code{gauche.collection} - Collection framework
@c NODE gauche.collection - コレクションフレームワーク, @code{gauche.collection} - コレクションフレームワーク

@deftp {Module} gauche.collection
@mdindex gauche.collection
@c EN
This module provides a set of generic functions (GFs) that iterate over
various collections.   The Scheme standard [R5RS] has some iterative
primitives such as @code{map} and @code{for-each},
and SRFI-1 (@xref{srfi-1 - List library} adds a rich set of such functions,
but they work only on lists.

Using the method dispatch of the object system, this module
efficiently extends those
functions for other collection classes such as vectors and hash tables.
It also provides a simple way for user-defined class to adapt
those opertaions.
So far, the following operations are defined.
@c JP
このモジュールは、様々なコレクションに対して繰り返し処理を行う総称関数を提供します。
Schemeの規格は@code{map}や@code{for-each}などの繰り返し手続きを定義しており、
またSRFI-1(@ref{srfi-1 - List library}参照)は更に数多くの繰り返し手続きを提供しますが、
それらはリストに対してしか動作しません。

このモジュールはオブジェクトシステムのメソッドディスパッチを利用して、
これらの手続きをベクタやハッシュテーブルのような一般のコレクションタイプに対しても
効率良く動作するように拡張します。また、ユーザ定義のクラスにこれらの操作を実装するための
簡単な方法も提供します。今のところ、次のような総称関数が提供されています。
@c COMMON

@table @asis
@c EN
@item Mapping
@c JP
@item マッピング
@c COMMON
@code{fold}, @code{map}, @code{map-to}, @code{for-each}
@c EN
@item Selection and searching
@c JP
@item 選択と探索
@c COMMON
@code{find}, @code{filter}, @code{filter-to},
@code{remove}, @code{remove-to}, @code{partition}, @code{partition-to}
@c EN
@item Conversion
@c JP
@item 変換
@c COMMON
@code{coerce-to}
@c EN
@item Miscellaneous
@c JP
@item その他
@c COMMON
@code{size-of}, @code{lazy-size-of}
@c EN
@item Fundamental iterator creator
@c JP
@item 基礎的なイテレータ構築メソッド
@c COMMON
@code{call-with-iterator}, @code{call-with-builder},
@code{with-iterator}, @code{with-builder}, @code{call-with-iterators}.
@end table

@c EN
Those operations work on @emph{collections} and its subclass,
@emph{sequences}.  A collection is a certain form of a set
of objects that you can traverse all the object in it in a certain way.
A sequence is a collection that all its elements are ordered, so that
you can retrieve its element by index.
@c JP
これらの操作は、@emph{コレクション}とそのサブクラスである
@emph{シーケンス}に対して動作します。コレクションは、その要素を全て
訪れる方法が用意されているようなオブジェクトの集合です。
シーケンスは、要素間に全順序関係が定義されておりインデックスで要素を取り出すことが
できるようなコレクションです。
@c COMMON

@c EN
The following Gauche built-in objects are treated as collections and/or
sequences.
@c JP
次にあげるGaucheの組み込みオブジェクトはシーケンスあるいはコレクションとして動作します。
@c COMMON
@table @code
@item <list>
@c EN
A sequence.
@c JP
シーケンス
@c COMMON
@item <vector>
@c EN
A sequence.
@c JP
シーケンス
@c COMMON
@item <string>
@c EN
A sequence (of characters)
@c JP
文字のシーケンス
@c COMMON
@item <hash-table>
@c EN
A collection.  Each element is a pair of a key and a value.
@c JP
コレクション。各要素はキーと値のペア。
@c COMMON
@item <s8vector>, <u8vector>, @dots{} <f64vector>
@c EN
A sequence (methods defined in @code{srfi-4} module,
@xref{srfi-4 - Homogeneous vectors}).
@c JP
シーケンス。メソッドは@code{srfi-4}モジュール内で定義されます。
@ref{srfi-4 - Homogeneous vectors}参照。
@c COMMON
@end table

@c EN
@xref{gauche.sequence - Sequence framework}, for it adds more sequence specific
methods.
@c JP
@ref{gauche.sequence - Sequence framework}も参照してください。シーケンス特有のメソッドが
追加されます。
@c COMMON

@c EN
The methods that needs to return a set of objects, i.e. 
@code{map}, @code{filter}, @code{remove} and @code{partition}.
returns a list (or lists).  The corresponding ``-to'' variant
(@code{map-to}, @code{filter-to}, @code{remove-to} and @code{partition-to}.
takes a collection class argument and returns the collection of the class.
@c JP
オブジェクトの集合を返すようなメソッド、すなわち
@code{map}、@code{filter}、@code{remove}および@code{partition}は、
リストを返します。対応する``-to''がつくメソッド
(@code{map-to}、@code{filter-to}、@code{remove-to}、@code{partition-to})
はコレクションクラスも引数に取り、そのクラスのコレクションを返します。
@c COMMON
@end deftp

@menu
* Mapping over collection::     
* Selection and searching in collection::  
* Miscellaneous operations on collection::  
* Fundamental iterator creators::  
* Implementing collections::    
@end menu

@node Mapping over collection, Selection and searching in collection, gauche.collection - Collection framework, gauche.collection - Collection framework
@subsection Mapping over collection
@c NODE コレクションに対するマッピング

@c EN
These generic functions extends the standard mapping procedures.
See also @ref{Mapping over sequences}, if you care the index
as well as elements.
@c JP
これらのジェネリックファンクションは標準のマッピング手続きを拡張します。
要素だけでなくそのインデックスも必要な場合は@ref{Mapping over sequences}を
参照して下さい。
@c COMMON

@deffn {Generic function} fold proc knil coll coll2 @dots{}
@c EN
This is a natural extension of @var{fold} in SRFI-1 (@xref{SRFI-1 Fold}).
@c JP
SRFI-1で定義される@var{fold} (@ref{SRFI-1 Fold}参照) の自然な拡張です。
@c COMMON

@c EN
For each element @var{Ei} in the collection @var{coll}, @var{proc} is
called as (@var{proc} @var{Ei} @var{Ri-1}), where @var{Ri-1} is the 
result of (@var{i}-1)-th invocation of @var{proc} for @var{i} > 0, 
and @var{R0} is @var{knil}.  Returns the last invocation of @var{proc}.
@c JP
コレクション@var{coll}の各要素@var{Ei}に対して、手続き@var{proc}が
(@var{proc} @var{Ei} @var{Ri-1}) のように呼ばれます。ここで、
@var{Ri-1} は @var{i} > 0 に対しては (@var{i}-1)番目の@var{proc}の呼び出しの
結果であり、@var{R0}は@var{knil}です。最後の@var{proc}の戻り値を返します。
@c COMMON
@example
(fold + 0 '#(1 2 3 4)) @result{} 10
(fold cons '() "abc")  @result{} (#\c #\b #\a)
@end example

@c EN
If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c COMMON

@c EN
You can fold more than one collection, although it doesn't make
much sense unless all of the collections are sequences.
Suppose @var{E(k, i)} for @var{i}-th element
of @var{k}-th collection.  @var{proc} is called as
@c JP
複数のコレクションを@code{fold}に渡すこともできます (但し、その全てがシーケンスで
なければあまり意味のある操作では無いでしょう)。
@var{k}番目のコレクションの@var{i}番目の要素を@var{E(k, i)}とするとき、
@var{proc}は以下のように呼ばれます。
@c COMMON
@example
(@var{proc} @var{E(0,i)} @var{E(1,i)} @dots{} @var{E(K-1,i)} @var{Ri-1})
@end example

@c EN
Different types of collections can be mixed together.
@c JP
異なる型のコレクションを混ぜて扱うことができます。
@c COMMON

@example
(fold acons '() "abc" '#(1 2 3))
  @result{} ((#\c 3) (#\b 2) (#\a 1))

@c EN
;; @r{calculates dot product of two vectors}
@c JP
;; @r{二つのベクタの内積を計算}
@c COMMON
(fold (lambda (a b r) (+ (* a b) r)) 0
      '#(3 5 7) '#(2 4 6))
  @result{} 68
@end example

@c EN
When more than one collection is given, @code{fold} terminates
as soon as at least one of the collections exhausted.
@c JP
複数のコレクションが与えられた場合、@code{fold}は少なくともひとつのコレクションが
終了した時点で終了します。
@c COMMON
@end deffn

@deffn {Generic function} map proc coll coll2 @dots{}
@c EN
This extends the built-in @code{map} (@xref{Procedures}).
Apply @var{proc} for each element in the collection @var{coll}, and
returns a list of the results.
@c JP
組み込み手続き@code{map} (@ref{Procedures}参照) を拡張します。
コレクション@var{coll}の各要素に手続き@var{proc}を適用し、その結果をリストにして
返します。
@c COMMON

@c EN
If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c COMMON

@c EN
If more than one collection is passed, @var{proc} is called with
elements for each collection.  In such case, @code{map} terminates
as soon as at least one of the collection is exhausted.  Note that passing
more than one collection doesn't make much sense unless
all the collections are sequences.
@c JP
複数のコレクションが与えられた場合、@var{proc}は各コレクションからの要素を引数として
呼び出されます。@code{map}はひとつでもコレクションの最後に到達したら終了します。
複数のコレクションを渡すのは、コレクションの全てがシーケンスでないとあまり意味がないでしょう。
@c COMMON

@example
(map (lambda (x) (* x 2)) '#(1 2 3))
  @result{} #(2 4 6)

(map char-upcase "abc")
  @result{} (#\A #\B #\C)

(map + '#(1 2 3) '#(4 5 6))
  @result{} (5 7 9)
@end example

@c EN
@code{map} @emph{always} returns a list.  If you want to get the result
in a different type of collection, use @code{map-to} described below.
If you wonder why @code{(map char-upcase "abc")} doesn't return
@code{"ABC"}, read the discussion in the bottom of this subsection.
@c JP
@code{map}は常にリストを返します。別のコレクション型で結果を得たい場合は、
次に示す@code{map-to}を使って下さい。何故@code{(map char-upcase "abc")}が
@code{"ABC"}を返さないのか疑問なら、この最後にあるディスカッションを参照してください。
@c COMMON
@end deffn

@deffn {Generic function} map-to class proc coll coll2 @dots{}
@c EN
This works the same as @code{map}, except the result is returned
in a collection of class @var{class}.   @code{Class} must be a
collection class and have a builder interface
(@xref{Fundamental iterator creators}).
@c JP
@code{map}と同じように動作しますが、結果はクラス@var{class}のインスタンスとして返されます。
@var{class}はコレクションクラスでなければなりません。
また、ビルダーインタフェースを持っている必要があります
(@ref{Fundamental iterator creators}参照).
@c COMMON

@example
(map-to <vector> + '#(1 2 3) '#(4 5 6))
  @result{} #(5 7 9)

(map-to <string> char-upcase "def")
  @result{} "DEF"

(map-to <vector> char=? "bed" "pet")
  @result{} #(#f #t #f)
@end example
@end deffn

@deffn {Generic function} for-each proc coll coll2 @dots{}
@c EN
Extension of built-in @code{for-each} (@xref{Procedures}).
Applies @var{proc} for each elements in the collection(s).
The result of @var{proc} is discarded.  The return value of
@code{for-each} is undefined.
@c JP
組み込み手続き@code{for-each} (@ref{Procedures}参照) を拡張します。
コレクション@var{coll}の各要素に手続き@var{proc}を適用します。
@var{proc}の結果は捨てられます。@code{for-each}の結果は未定義です。
@c COMMON

@c EN
If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c COMMON

@c EN
If more than one collection is passed, @var{proc} is called with
elements for each collection.  In such case, @code{for-each} terminates
as soon as one of the collection is exhausted.  Note that passing
more than one collection doesn't make much sense unless
all the collections are sequences.
@c JP
複数のコレクションが与えられた場合、@var{proc}は各コレクションからの要素を引数として
呼び出されます。@code{for-each}はひとつでもコレクションの最後に到達したら終了します。
複数のコレクションを渡すのは、コレクションの全てがシーケンスでないとあまり意味がないでしょう。
@c COMMON
@end deffn


@deffn {Generic Function} fold$ proc
@deffnx {Generic Function} fold$ proc knil
@deffnx {Generic Function} map$ proc
@deffnx {Generic Function} for-each$ proc
@c EN
Partial-application version of @code{fold}, @code{map} and @code{for-each}.
@c JP
@code{fold}、@code{map}、@code{for-each}の部分評価版です。
@c COMMON
@end deffn


@c EN
@emph{Discussion:}  It is debatable what type of collection @code{map}
should return when it operates on the collections other than lists.
It may seem more ``natural'' if @code{(map * '#(1 2) '#(3 4))}
returns a vector, and @code{(map char-upcase "abc")} returns a string.
@c JP
@emph{Discussion:}  @code{map}がリスト以外に対して適用されたとき、どういう
コレクション型を返すべきでしょう。
@code{(map * '#(1 2) '#(3 4))} がベクタを返し、
@code{(map char-upcase "abc")} が文字列を返すようにするほうが「自然」でしょうか。
@c COMMON

@c EN
Although such interface seems work for simple cases, it'll become
problematic for more general cases.  What type of collection should
be returned if a string and a vector are passed?  Furthermore,
some collection may only have iterator interface but no builder
interface, so that the result can't be coerced to the argument type
(suppose you're mapping over database records, for example).
And Scheme programmers are used to think @code{map} returns a list,
and the result of @code{map} are applied to the procedures that
takes list everywhere.
@c JP
そのようなインタフェースは単純な場合には動作するように思えますが、
一般的な拡張は困難です。文字列とベクタが同時に渡されたらどうします?
更に、コレクションクラスによっては繰り返しインタフェースは持っていても
ビルダーインタフェースを持っていない場合があり、結果をそのコレクションクラスとして
返せない場合もあります (データベースレコードのコレクションに対してマップする、
といった用法を考えてみて下さい)。また、Schemeプログラマは@code{map}が
リストを返すという事実に慣れ親しんでおり、既存のコードも@var{map}の戻り値を
リストを受け取る手続きに渡すことがよく行われています。
@c COMMON

@c EN
So I decided to add another method, @code{map-to}, to specify
the return type explicitly
The idea of passing the return type is taken from CommonLisp's @code{map}
function, but taking a class metaobject, @code{map-to} is much flexible
to extend using method dispatch.
This protocol (``-to'' variant takes a class metaobject
for the result collection) is used thoughout the collection framework.
@c JP
そこで、結果の型を明示的に指定する@code{map-to}という別のメソッドを定義しました。
結果の型を渡すのは、CommonLispの@code{map}関数にならっていますが、
Gaucheではクラスメタオブジェクトを渡すようにしたため、メソッドディスパッチを使って
拡張することが容易です。``-to'' のつくメソッドは結果のコレクションのクラスを
取るというインタフェースはコレクションフレームワーク中で統一的に使われています。
@c COMMON

@node Selection and searching in collection, Miscellaneous operations on collection, Mapping over collection, gauche.collection - Collection framework
@subsection Selection and searching in collection
@c NODE コレクションからの選択と探索

@deffn {Generic function} find pred coll
@c EN
Applies @var{pred} for each element of a collection @var{coll} until
@var{pred} returns a true value.  Returns the element on which @var{pred}
returned a true value, or @code{#f} if no element satisfies @var{pred}.
@c JP
@var{pred}をコレクション@var{coll}の要素に適用してゆきます。@var{pred}が
真の値を返したらそこで打ち切り、その要素を返します。@var{pred}が真の値を返す
要素が無かった場合は@code{#f}を返します。
@c COMMON

@c EN
If @var{coll} is a sequence, it is guaranteed that @var{pred} is
applied in order.  Otherwise the order of application is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c cOMMON

@example
(find char-upper-case? "abcDe") @result{} #\D
(find even? '#(1 3 4 6)) @result{} 4
(find even? '(1 3 5 7))  @result{} #F
@end example
@end deffn

@deffn {Generic function} filter pred coll
@c EN
Returns a list of elements of collection @var{coll} that satisfies
the predicate @var{pred}.   If the collection is a sequence,
the order is preserved in the result.
@c JP
コレクション@var{coll}中の要素のうち、述語手続き@var{pred}が真の値を返したものの
リストを返します。コレクションがシーケンスであれば、結果の要素の順序は元のシーケンスの
順序と同じになります。
@c COMMON

@example
(filter char-upper-case? "Hello, World")
  @result{} (#\H #\W)
(filter even? '#(1 2 3 4)) @result{} (2 4)
@end example
@end deffn

@deffn {Generic function} filter-to class pred coll
@c EN
Same as @code{filter}, but the result is returned 
as a collection of class @var{class}.
@c JP
@code{filter}と同じですが、結果のコレクションが@var{class}のインスタンスで
返されます。
@c COMMON

@example
(filter-to <vector> even? '#(1 2 3 4)) @result{} #(2 4)
(filter-to <string> char-upper-case? "Hello, World") 
  @result{} "HW"
@end example
@end deffn

@deffn {Generic function} remove pred coll
@c EN
Returns a list of elements of collection @var{coll} that does not
satisfy the predicate @var{pred}.   If the collection is a sequence,
the order is preserved in the result.
@c JP
コレクション@var{coll}中の要素のうち、述語手続き@var{pred}が偽の値を返したものの
リストを返します。コレクションがシーケンスであれば、結果の要素の順序は元のシーケンスの
順序と同じになります。
@c COMMON

@example
(remove char-upper-case? "Hello, World")
  @result{} (#\e #\l #\l #\o #\, #\space #\o #\r #\l #\d)
(remove even? '#(1 2 3 4)) @result{} (1 3)
@end example
@end deffn

@deffn {Generic function} remove-to class pred coll
@c EN
Same as @code{remove}, but the result is returned 
as a collection of class @var{class}.
@c JP
@code{remove}と同じですが、結果のコレクションが@var{class}のインスタンスで
返されます。
@c COMMON

@example
(remove-to <vector> even? '#(1 2 3 4)) @result{} #(1 3)
(remove-to <string> char-upper-case? "Hello, World") 
  @result{} "ello, orld"
@end example
@end deffn

@deffn {Generic function} partition pred coll
@c EN
Does @code{filter} and @code{remove} the same time.
Returns two lists, the first consists of elements of the collection
@var{coll} that satisfies the predicate @var{pred}, and the second
consists of elements that doesn't.
@c JP
@code{filter}と@code{remove}を同時に行います。
二つのリストを返します。最初のリストはコレクション@var{coll}の要素のうち
述語手続き@var{pred}が真の値を返したものから構成され、二つ目のリストは
そうでない要素から構成されます。
@c COMMON

@example
(partition char-upper-case? "PuPu")
  @result{} (#\P #\P) @r{and} (#\u #\u)
(partition even? '#(1 2 3 4))
  @result{} (2 4) @r{and} (1 3)
@end example
@end deffn

@deffn {Generic function} partition-to class pred coll
@c EN
Same as @code{partition}, except the results are returned
in the collections of class @var{class}.
@c JP
@code{partition}と同じですが、結果がクラス@var{class}のコレクションとして
返されます。
@c COMMON

@example
(partition-to <string> char-upper-case? "PuPu")
  @result{} "PP" @r{and} "uu"
(partition-to <vector> even? '#(1 2 3 4))
  @result{} #(2 4) @r{and} #(1 3)
@end example
@end deffn

@node Miscellaneous operations on collection, Fundamental iterator creators, Selection and searching in collection, gauche.collection - Collection framework
@subsection Miscellaneous operations on collection
@c NODE コレクションに対する様々な操作

@deffn {Generic function} size-of coll
@c EN
Returns the number of elements in the collection.  Default method iterates over
the collection to calculate the size, which is not very efficient
and may diverge if the collection is infinite.
Some collection classes overload the method for faster calculation.
@c JP
コレクションの要素数を返します。
デフォルトのメソッドは、コレクション中の要素をすべて数え上げるものですが、
あまり効率は良くないでしょう。また、無限個の要素を持つコレクションでは
帰ってきません。多くのコレクションクラスはより効率の良い方法でこのメソッドを定義しています。
@c COMMON
@end deffn

@deffn {Generic function} lazy-size-of coll
@c EN
Returns either the size of the collection, or a promise to
calculate it.  The intent of this method is to avoid
size calculation if it is expensive.  In some cases, the caller
wants to have size just for optimization, and it is not desirable
to spend time to calculate the size.  Such caller uses this method
and just discards the information if it is a promise.
@c JP
コレクションの要素数か、もしくはそれを計算するプロミスを返します。
このメソッドの目的は、要素数の計算が高価な場合にそれを避けることにあります。
しばしば、呼び出し側では最適化のための参考値として要素数が欲しい場合があり、
そういった場合は要素数を計算するために時間を費すのは望ましくありません。
このメソッドを代わりに呼び出して、結果がプロミスであればそれを使わない、
という選択ができます。
@c COMMON
@end deffn

@deffn {Generic function} coerce-to class coll
@c EN
Convert a collection @var{coll} to another collection
which is an instance of @var{class}.
If @var{coll} is a sequence and @var{class} is a sequence class,
the order is preserved.
@c JP
コレクション@var{coll}を、クラス@var{class}のインスタンスである
別のコレクションへと変換します。@var{coll}がシーケンスであり、
@var{class}がシーケンスクラスであれば、元のシーケンスの順序は保存されます。
@c COMMON

@example
(coerce-to <vector> '(1 2 3 4))
  @result{} #(1 2 3 4)

(coerce-to <string> '#(#\a #\b #\c))
  @result{} "abc"
@end example
@end deffn

@node Fundamental iterator creators, Implementing collections, Miscellaneous operations on collection, gauche.collection - Collection framework
@subsection Fundamental iterator creators
@c NODE 基礎的なイテレータ構築メソッド

@c EN
These are fundamental methods on which all the rest of
iterative method are built.  The method interface is not intended
to be called from general code, but suitable for building
other iterator construct.   The reason why I chose this interface
as fundamental methods are explained at the bottom of this subsection.
@c JP
ここに挙げるメソッドは、他のコレクションメソッドの基礎となるものです。
メソッドのインタフェースは一般のコードで使われることよりも、
効率良く他の繰り返しメソッドを記述するのに便利なように設計されています。
何故このインタフェースを基礎のメソッドとして選んだかについてはこの章の最後に説明します。
@c COMMON

@deffn {Generic function} call-with-iterator collection proc &keyword start
@c EN
A fundamental iterator creator.   This creates two procedures
from @var{collection}, both take no argument, and then call
@var{proc} with those two procedures.   The first procedure is
terminate predicate, which returns @code{#t} if the iteration
is exhausted, or @code{#f} if there are still elements to be visited.
The second procedure is an incrementer,
which returns one element from the collection and sets the
internal pointer to the next element.
The behavior is undefined if you call the incrementer after
the terminate predicate returns @code{#t}.
@c JP
基礎となるイテレータ構築メソッドです。このメソッドはコレクション@var{collection}
から繰り返しのための二つの手続きを作成し、それらを引数として手続き@var{proc}を
呼びます。作られる最初の手続きは終了判定手続きで、引数無しで呼び出され、繰り返しが
終了していれば@code{#t}を、まだ要素が残っていれば@code{#f}を返します。
作られる二番目の手続きはインクリメント手続きで、呼ばれる度に現在の要素を返し、
内部のポインタを次の要素へと進めます。終了判定手続きが@code{#t}を返した後に
インクリメント手続きを呼んだ場合の動作は未定義です。
@c COMMON

@c EN
If the collection is actually a sequence, the incrementer is guaranteed
to return elements in order, from 0-th element to the last element.
If a keyword argument @var{start} is given, however, the iteration
begins from @var{start}-th element and ends at the last element.
If the collection is not a sequence, the iteration order is
arbtrary, and @var{start} argument has no effect.
@c JP
コレクションがシーケンスでもある場合、インクリメント手続きはシーケンスの順番に要素を取り出します。
キーワード引数@var{start}が与えられていればイテレーションの範囲は
@var{start}番目の要素から最後の要素までとなります。シーケンスでないコレクションに
対しては@var{start}引数は意味を持ちません。
@c COMMON

@c EN
An implementation of @var{call-with-iterator} method may
limit the extent of the iterator inside the dynamic scope of the method.
For example, it allocates some resource (e.g. connect to a database)
before calling @var{proc}, and deallocates it (e.g. disconnect from a database)
after @var{proc} returns.
@c JP
@var{call-with-iterator}のメソッド実装は、イテレータのエクステントを
そのメソッドのダイナミックスコープ内に限ることを許されます。例えば、
メソッドは@var{proc}を呼ぶ前に何らかのリソースを確保し(データベースへのコネクションなど)、
@var{proc}から戻った後でそれを解放するということができます。
@c COMMON

@c EN
This method returns the value(s) @var{proc} returns.
@c JP
このメソッドは @var{proc} が返した値をそのまま返します。
@c COMMON

@example
(call-with-iterator '(1 2 3 4 5)
  (lambda (end? next)
    (do ((odd-nums 0))
        ((end?) odd-nums)
      (when (odd? (next)) (inc! odd-nums)))))
 @result{} 3
@end example

@c EN
See also @code{with-iterator} macro below, for it is easier to use.
@c JP
下に示す@code{with-iterator}マクロも参照してください。
@c COMMON
@end deffn

@deffn {Macro} with-iterator (collection end? next args @dots{}) body @dots{}
@c EN
A convenience macro to call @code{call-with-iterator}.
@c JP
@code{call-with-iterator}を簡潔に呼び出すマクロです。
@c COMMON
@example
(with-iterator (coll end? next args @dots{}) body @dots{})
 @equiv{}
(call-with-iterator coll
  (lambda (end? next) body @dots{})
   args @dots{})
@end example
@end deffn

@defun call-with-iterators collections proc
@c EN
A helper function to write n-ary iterator method.
This function applies @code{call-with-iterator} for each @var{collection}s,
and makes two lists, the first consists of terminate predicates
and the second of incrementers.  Then @var{proc} is called
with those two lists.  Returns whatever @var{proc} returns.
@c JP
N-aryのイテレータメソッドを書くのに便利な手続きです。
この手続きはコレクションのリスト@var{collections}の各コレクションに対して
@code{call-with-iterator}を呼び、二つのリストを作ります。最初のリストには
終了判定手続きが順に集められており、二つ目のリストにはインクリメント手続きが
順に集められています。そして、これらのリストを引数として@var{proc}を呼び出します。
@var{proc}が返した値を返します。
@c COMMON
@end defun

@deffn {Generic function} call-with-builder collection-class proc &keyword size
@c EN
A fundamental builder creator.  Builder is a way to construct
a collection incrementally.  Not all collection classes provide
this method.
@c JP
基礎的なビルダー構築メソッドです。ビルダーはコレクションをインクリメンタルに
作成する方法です。コレクションクラスによってはこの手続きを提供しないものもあります。
@c COMMON

@c EN
@var{Collection-class} is a class of the collection to be built.
This method creates two procedures, adder and getter, then calls
@var{proc} with those procedures.
Adder procedure takes one argument and adds it to the collection
being built.  Getter takes no argument and returns a built collection object.
The effect is undefined if adder is called after getter is called.
@c JP
@var{Collection-class}は作成されるコレクションのクラスです。
このメソッドは、追加手続きと結果手続きの二つの手続きを作成し、それらを
引数として@var{proc}を呼びます。追加手続きは一つ引数を取り、それを作成中の
コレクションに追加します。結果手続きは引数を取らず、作成されたコレクションを返します。
結果手続きが呼ばれた後で追加手続きを呼んだ場合の動作は未定義です。
@c COMMON

@c EN
A keyword argument @var{size} may be specified if the size of
the result collection is known.  Certain collections may be
built much more efficiently if the size is known; other collections
may just ignore it.   The behavior is undefined if more than
@var{size} elements are added, or the collection is retrieved before
@var{size} elements are accumulated.
@c JP
作られるコレクションのサイズが分かっている場合、キーワード引数@var{size}を与える
ことができます。コレクションクラスによってはその情報を使って効率的にコレクションを
作成することができます。その情報を単に無視するコレクションクラスもあります。
@var{size}個より多くの要素が追加されたり、@var{size}個の要素が追加される前に
結果手続きが呼ばれたりした場合の動作は未定義です。
@c COMMON

@c EN
If the collection class is actually a sequence class,
adder is guaranteed to add elements in order.  Otherwise,
the order of elements are insignificant.
@c JP
コレクションクラスがシーケンスクラスであった場合、追加手続きは要素を
シーケンスの順に追加してゆきます。
@c COMMON

@c EN
Some collection class may take more keyword arguments to
initialize the collection.
@c JP
コレクションクラスによっては、コレクションオブジェクトの初期化のために
他のキーワード引数を取るかもしれません。
@c COMMON

@c EN
This method returns the value(s) @var{proc} returned.
@c JP
このメソッドは@var{proc}が返す値を返します。
@c COMMON

@example
(call-with-builder <list>
  (lambda (add! get)
    (add! 'a) (add! 'b) (add! 'c) (get)))
 @result{} (a b c)

(call-with-builder <vector>
  (lambda (add! get)
    (add! 'a) (add! 'b) (add! 'c) (get)))
 @result{} #(a b c)
@end example

@c EN
See also @code{with-builder} macro below, for it is much easier to use.
@c JP
下に示す@code{with-builder}マクロも参照してください。
@c COMMON
@end deffn

@deffn {Macro} with-builder (collection add! get args @dots{}) body @dots{}
@c EN
A convenience macro to call @code{call-with-builder}.
@c JP
@code{call-with-builder}を簡潔に呼び出すマクロです。
@c COMMON
@example
(with-builder (coll add! get args @dots{}) body @dots{})
 @equiv{}
(call-with-builder coll
  (lambda (add! get) body @dots{})
  args @dots{})
@end example
@end deffn

@emph{Discussion}:
@c EN
Other iterator methods are built on top of call-with-iterator and
call-with-builder.
By implementing those methods, you can easily adapt your own collection
class to all of those iterative
operations.   Optionally you can overload some of higher-level
methods for efficiency.
@c JP
他のイテレータメソッドは全てこのcall-with-iteratorとcall-with-builderの上に構築可能です。
最低限これらのメソッドを定義すれば、そのクラスはコレクションとして振舞うことができます。
もちろん最適化のために他のイテレータメソッドを定義しても構いませんが。
@c COMMON

@c EN
It is debatable that which set of operations should be primitives.
I chose call-with-iterator style for efficiency of the applications
I see most.   The following is a discussion of other possible
primitive iterators.
@c JP
どの操作を基礎的なメソッドとするかには議論の余地があります。
Gaucheでは、作者がよく見るパターンで最も効率が良くなるように考えて現在のスタイルを
選びました。以下に、他の基礎的なメソッドの可能性を検討します。
@c COMMON

@table @asis
@item @code{fold}
@c EN
It is possible to make @code{fold} a primitive method, and
build other iterator method on top of it.
Collection-specific iterating states can be kept in the
stack of @code{fold}, thus it runs efficiently.  The method
to optimize a procedure that uses @code{fold} as a basic
iterator construct.
However, it is rather cumbersome to derive
generator-style interface from it.   It is also tricky
to iterate irregulary over more than one collections.
@c JP
@code{fold}を最も基礎的なメソッドとして、他のイテレータメソッドをその上に
構築することも可能です。繰り返しの状態はスタックに置かれるので効率良く走ります。
@code{fold}を基礎とした繰り返し関数を最適化する方法は良く知られています。
しかし、@code{fold}を元にしてジェネレータスタイルのインタフェースを
作成するのは複雑です。また、複数のコレクションに対しての繰り返しを書くのも
面倒です。
@c COMMON

@item CPS
@c EN
Passes iteratee the continuation procedure that continues
the iteration.   The iteratee just returns when it want
to terminate the iteration.
It has resource management problem described in
Oleg Kiselyov's article (@ref{oleg2,,OLEG2}).
@c JP
繰り返しの中身の手続きに対し、繰り返しを続けるための継続手続きを渡す方法です。
繰り返しを続けたくなければ、手続きは継続を呼ばすにそのまま戻ります。
Oleg Kiselyovの記事(@ref{oleg2,,OLEG2})に指摘されているような、
リソース管理の問題があります。
@c COMMON

@item Iterator object
@c EN
Like C++ iterator or Common Lisp generator.
Easy to write loop.   The problem is that every call of
checking termination or getting next element must be dispatched.
@c JP
C++のイテレータやCommon Lispのジェネレータのようなオブジェクトを使う方法です。
ループを書くのは容易ですが、終了判定や要素取り出しの度にメソッドディスパッチが
起こってしまいます。
@c COMMON

@item Series
@c EN
Common Lisp's series can be very efficient if the compiler can statically
analyze the usage of series.  Unfortunately it is not the case in
Gauche.  Even if it could, the extension mechanism doesn't blend well
with Gauche's object system.
@c JP
Common Lispのシリーズはコンパイラがシリーズの使われかたを追跡できれば
非常に効率の良いコードに変換できます。Gaucheのコンパイラはそこまでのデータフロー解析を
行っていません。また、それをやったとしても、コレクションクラスを拡張するための方法が
Gaucheのオブジェクトシステムとはうまく調和しません。
@c COMMON

@item Macros
@c EN
Iterator can be implemented as macros, and that will be very efficient;
e.g. Scheme48's iterator macro.  It uses macros to extend, however,
and that doesn't blend well with Gauche's object system.
@c JP
効率を気にするなら、イテレータをマクロで書いてしまう方法もあります
(例えばScheme48の@code{iterator}マクロなど)。
効率は良いのですが、拡張するにはマクロを書くことが必要となり、
Gaucheのオブジェクトシステムとうまく調和しません。
@c COMMON
@end table

@c EN
The current implementation is close to the iterator object approach,
but using closures instead of iterator objects so that avoiding
dispatching in the inner loop.  Also it allows the iterator
implementator to take care of the resource problem.
@c JP
現在の実装はイテレータオブジェクトアプローチに近いですが、イテレータオブジェクトを
作る代わりにクロージャを使うことで内部のループでのメソッドディスパッチを
避けています。また、現在のインタフェースはリソース管理の問題を解決しています。
@c COMMON

@node Implementing collections,  , Fundamental iterator creators, gauche.collection - Collection framework
@subsection Implementing collections
@c NODE コレクションの実装

The minimum requirements of the collection class implementation
is as follow:
@itemize @bullet
@item
The class inherits @code{<collection>} abstract class.
@item
A method @code{call-with-iterator} is implemented.
@end itemize

This makes iterator methods such as @code{map}, @code{for-each},
@code{find} and @code{filter} to work.

In order to make the constructive methods (e.g. @code{map-to} to
create your collection), you have to implement @code{call-with-builder}
method as well.  Note that @code{call-with-builder} method must work
a sort of class method, dispatched by class, rather than normal method
dispatched by instance.   In Gauche, you can implement it by using a
metaclass.   Then the minimal code will look like this:

@example
(define-class <your-collection-meta> (<class>) ())

(define-class <your-collection> (<collection>)
 (...) ;; @r{slots}
 :metaclass <your-collection-meta>)

(define-method call-with-iterator
    ((coll <your-collection>) proc . options)
  @dots{}
  )

(define-method call-with-builder
     ((coll <your-collection-meta>) proc . options)
  @dots{}
  )
@end example

Optionally, you can overload other generic functions to optimize
performance.

@c ----------------------------------------------------------------------
@node gauche.config - Configuration parameters, gauche.fcntl - Low-level file operations, gauche.collection - Collection framework, Library modules - Gauche extensions
@section @code{gauche.config} - Configuration parameters
@c NODE gauche.config - コンフィグレーション情報, @code{gauche.config} - コンフィグレーション情報

@deftp {Module} gauche.config
@mdindex gauche.config
@c EN
This module provides a simple wrapper to obtain configuration
parameters via @code{gauche-config} program.

The @code{gauche-config} program is a simple shell script
that records various parameters given at the configuration time
of Gauche.
@c JP
このモジュールは、@code{gauche-config} プログラム経由で設定パラメータを
取得するシンプルなラッパーを提供します。

@code{gauche-config} プログラムは、Gauche の設定時に与えられた
様々なパラメータを記録するためのシンプルなシェルスクリプトです。
@c COMMON
@end deftp

@defun gauche-config option
@c EN
Calls @code{gauche-config} with the option @var{option}, and
returns the string of the parameter value.  It is an error
to give the option gauche-config doesn't understand.

See the manpage of @code{gauche-config}, or run @code{gauche-config}
without any argument from the shell, to find out the valid options.
@c JP
@code{gauche-config} をオプション @var{option} とともに呼び出すと、
パラメータの値の文字列が返ります。gauche-config が理解できないオプションを
渡すとエラーになります。

有効なオプションについては、@code{gauche-config} のマニュアルページを
見るか、シェルで @code{gauche-config} を引数なしで実行して下さい。
@c COMMON
@example
(gauche-config "--cc")
  @result{} "gcc"
(gauche-config "-L")
  @result{} "-L/usr/lib/gauche/0.6.5/i686-pc-linux-gnu"
(gauche-config "-l")
  @result{} "-ldl -lcrypt -lm -lpthread"
@end example
@end defun

@c ----------------------------------------------------------------------
@node gauche.fcntl - Low-level file operations, gauche.hook - Hooks, gauche.config - Configuration parameters, Library modules - Gauche extensions
@section @code{gauche.fcntl} - Low-level file operations
@c NODE gauche.fcntl - 低レベルファイル操作, @code{gauche.fcntl} - 低レベルファイル操作

@deftp {Module} gauche.fcntl
@mdindex gauche.fcntl
Provides an interface to @code{fcntl(2)}, including
advisory file locking.
@end deftp

@defun sys-fcntl port-or-fd operation &optional arg
Performs certain operation on the file specfied by @var{port-or-fd},
which should be a port object or an integer
that specifies a system file descriptor.  If it is a port, it must
be associated to the opened file.

The operation is specified by an integer @var{operation}.
Several variables are defined for valid @var{operation}.

@table @code
@item F_GETFD
@vindex F_GETFD
@vindex FD_CLOEXEC
Returns flags associated to the file descriptor of @var{port-or-fd}.
The optional argument @var{arg} is not used.   The return value is 
an integer whose definition is system specific, except one flag,
@code{FD_CLOEXEC}, which indicates the file descriptor should be
closed on @code{exec}.

@item F_SETFD
@vindex F_SETFD
Sets the file descriptor flags given as @var{arg} to @var{port-or-fd}.
For example, the portable way of setting @code{FL_CLOEXEC} flag is
as follows:
@example
(sys-fcntl port F_SETFD
          (logior FD_CLOEXEC
                  (sys-fcntl port F_GETFD)))
@end example

@item F_GETFL
@vindex F_GETFL
Returns flags associated to the open files specified by @var{port-or-fd}.
The flags includes the following information:

@itemize @bullet
@item
@vindex O_ACCMODE
@vindex O_RDONLY
@vindex O_WRONLY
@vindex O_RDWR
File access mode.  When masked by @code{O_ACCMODE}, 
it's either one of @code{O_RDONLY}, @code{O_WRONLY} or @code{O_RDWR}.
@item
@vindex O_CREAT
@vindex O_EXCL
@vindex O_TRUNC
File creation options.  @code{O_CREAT}, @code{O_EXCL} and/or
@code{O_TRUNC}.
@item
@vindex O_APPEND
Whether appending is allowed or not, by @code{O_APPEND}
@item
@vindex O_NONBLOCK
Whether I/O is blocking or non-blocking, by @code{O_NONBLOCK}.
@item
@vindex O_NOCTTY
Whether it grabs terminal control, by @code{O_NOCTTY}.
@end itemize

The system may define system-specific flags.

@item F_SETFL
@vindex F_SETFL
Sets flags to the open files specified by @var{port-or-fd}.
Among the flags listed above, only @code{O_NONBLOCK} and @code{O_APPEND}
can be changed.

Note that @code{F_GETFD}/@code{F_SETFD} concern flags associated
to the file descriptor itself, while @code{F_GETFL}/@code{F_SETFL}
concern flags associated to the opened file itself.  This makes difference
when more than one file descriptor points to the same opened file.

@item F_DUPFD
@vindex F_DUPFD
Creates new file descriptor that points to the same file referred by
@var{port-or-fd}.
An integer must be provided as @var{arg}, and that specifies
the minimum value of file descriptor to be assigned.

@item F_GETLK
@vindex F_GETLK
The third argument must be provided and be an instance of @code{<sys-flock>}
object described below.  It searches the lock information specified by
@var{arg}, and modifies @var{arg} accordingly.

@item F_SETLK
@itemx F_SETLKW
@vindex F_SETLK
@vindex F_SETLKW
The third argument must be provided and be an instance of @code{<sys-flock>}
object described below.  Sets the advisory file lock according to 
@var{arg}.   If the lock is successfully obtained, @code{#t} is returned.
If the other process has the lock conflicting the request,
@code{F_SETLK} returns @code{#f}, while @code{F_SETLKW} waits until
the lock is available.
@end table

Other value for @var{operation} causes an error.
@end defun

@deftp {Builtin Class} <sys-flock>
@clindex sys-flock
A structure represents POSIX advisory record locking.
Advisory record locking means the system may not prevents the process
from operating on files that it doesn't have an appropriate lock.
All the processes are expected to use @code{fcntl} to check locks
before it operates on the files that may be shared.

The following slots are defined.

@defivar {<sys-flock>} type
An integer represents lock type.  Following variables are predefined
for the valid values:
@table @code
@item F_RDLCK
@vindex F_RDLCK
Read locking
@item F_WRLCK
@vindex F_WRLCK
Write locking
@item F_UNLCK
@vindex F_UNLCK
To remove a lock by @code{F_SETLK}, or to indicate the record is not
locked by @code{F_GETLK}.
@end table
@end defivar

@defivar {<sys-flock>} whence
Indicates from where @code{start} is measured.
@end defivar

@defivar {<sys-flock>} start
The offset of beginning of the locked region.
@end defivar

@defivar {<sys-flock>} len
The number of bytes to lock.  Zero means ``until EOF''.
@end defivar

@defivar {<sys-flock>} pid
An integer process id that holding the lock; used only by @code{F_GETLK}.
@end defivar
@end deftp

@c ----------------------------------------------------------------------
@node gauche.hook - Hooks, gauche.interactive - Interactive session, gauche.fcntl - Low-level file operations, Library modules - Gauche extensions
@section @code{gauche.hook} - Hooks

@deftp {Module} gauche.hook
@mdindex gauche.hook
Provides a hook object, which manages a list of closures to be
called at certain time.

This API of hooks are upper-compatible of Guile's, with the
following extensions.
@itemize @bullet
@item
Based on Gauche's object system.  Most APIs are methods
so you can extend the hook features.
@item
Hook object itself is applicable.  You don't need to use @code{run-hook}.
@item
The method to remove a procedure from a hook is called @code{delete-hook!},
for consistency with SRFI-1 and others.  @code{remove-hook!} is
defined as an alias of @code{delete-hook!} for compability with Guile.
@end itemize
@end deftp

@deftp {Class} <hook>
@clindex hook
A hook class, which keeps a list of procedures to be called at once.

The @code{object-apply} method is defined on @code{<hook>} class,
so you can "apply" a hook object as if it were a procedure---which
causes all the registered procedure to be invoked.
@end deftp

@defun make-hook &optional (arity 0)
Creates a new hook object with given arity, which should be a
non-negative integer.
@end defun

@defun hook? obj
Returns true if @var{obj} is a hook object.
@end defun

@defun hook-empty? hook
Returns true if @var{hook}'s procedure list is empty.
@end defun

@deffn {Method} add-hook! (hook <hook>) proc &optional (append? #f)
Adds a procedure @var{proc} to @var{hook}.  If @var{append?}
is given and true, @var{proc} is added at the end of the list.
Otherwise, @var{proc} is added at the front of the list.
The @var{proc} has to be called with the arity given 
at the @code{make-hook}.
@end deffn

@deffn {Method} delete-hook! (hook <hook>) proc
@deffnx {Method} remove-hook! (hook <hook>) proc
Removes @var{proc} from the procedure list of @var{hook}.
@code{Remove-hook!} is an alias of @code{delete-hook!} just for
compability with Guile.
@end deffn

@deffn {Method} reset-hook! (hook <hook>)
Empties @var{hook}'s procedure list.
@end deffn

@deffn {Method} hook->list (hook <hook>)
Returns a copy of @var{hook}'s procedure list.
@end deffn

@deffn {Method} run-hook (hook <hook>) arg @dots{}
Calls @var{hook}'s procedures in order, with arguments @var{arg} @dots{}.
The number of arguments must match the arity given at @code{make-hook}.
@end deffn

@c ----------------------------------------------------------------------
@node gauche.interactive - Interactive session, gauche.listener - Listener, gauche.hook - Hooks, Library modules - Gauche extensions
@section @code{gauche.interactive} - Utilities for interactive session
@c NODE gauche.interactive - インタラクティブセッション, @code{gauche.interactive} - インタラクティブセッション

@deftp {Module} gauche.interactive
@mdindex gauche.interactive
@c EN
Provides useful utilities for the interactive session.

This module is automatically loaded when you run @code{gosh}
interactively.
@c JP
インタラクティブセッションで便利なユーティリティ手続きを提供します。

@code{gosh}をインタラクティブモードで起動した場合、このモジュールは自動的にロードされます。
@c COMMON
@end deftp

@defmac apropos pattern &optional module
@c EN
Show a list of defined variables whose name matches @var{pattern}.
If you give a module or a module name @var{module}, only the variables
defined in that module are listed.  Without @var{module},
the variables "visible" from the current module are listed.
@c JP
名前が@var{pattern}にマッチするような定義された変数のリストを表示します。
@var{module}にモジュールオブジェクトまたはモジュール名を与えた場合は、
そのモジュール内で定義されている変数のみが表示されます。@var{module}が
省略された場合は、カレントモジュールから「見える」変数が全て表示されます。
@c COMMON

@c EN
@var{pattern} may be a symbol or a regexp object.
If it is a symbol, the variables whose name contains the
substring that matches the symbol's name are listed.
If it is a regexp object, the variables whose name matches
the regexp are listed.
@c JP
@var{pattern}はシンボルか正規表現オブジェクトでなければなりません。
シンボルの場合、そのシンボル名を部分文字列として名前に含むような変数が
リストされます。正規表現オブジェクトの場合は、その正規表現にマッチする
名前を持つ変数がリストされます。
@c COMMON

@c EN
Some examples:
@c JP
いくつか例を示します。
@c COMMON
@example
@c EN
;; @r{List variables that contains "string" in their name}
@c JP
;; @r{"string"を名前に含む変数を表示}
@c COMMON
(apropos 'string)

@c EN
;; @r{Search in srfi-14 module}
@c JP
;; @r{srfi-14モジュールの中のみを検索}
@c COMMON
(apropos 'char 'srfi-14)
@end example
@end defmac

@deffn {Generic Function} describe obj
@deffnx {Generic Function} d obj
@c EN
Prints the detail information about a Scheme object @var{obj}.
The default method shows @var{obj}'s class, and if it has
any slots, the list of slot names and their values.
You can specialize this method for customized display.
@c JP
Schemeオブジェクト@var{obj}の詳細情報を表示します。
既定メソッドは@var{obj}のクラスを表示し、さらに@var{obj}がスロットを
持っていればその名前と内容をリストします。
このメソッドをスペシャライズすることによりクラス毎に表示をカスタマイズできます。
@c COMMON
@end deffn

@defun info symbol
@c EN
Displays a page of Gauche's info file that contains definition of
the function or syntax specified by @var{symbol}.
If an environment variable @code{INFOPATH} is defined,
this function searches for the info file from the directories in it.
Otherwise, this function guesses info file location from the
@code{gosh}'s library directory.   If the info file can't be
found, an error is signalled.   If the info file is found,
but @var{symbol} is not in its index, an error is signalled as well.
So this function doesn't work if you haven't installed info file.
@c JP
Gaucheのinfoドキュメント中から、
@var{symbol}で指定される手続きか構文要素の定義を含んでいるページを表示します。
infoドキュメントは、もし環境変数@code{INFOPATH}が定義されていればそこに
示されるディレクトリ中から探され、そうでなければ@code{gosh}のライブラリディレクトリ
から推測されるディレクトリ中から探されます。infoドキュメントが見付からなかったり、
見付かっても@var{symbol}がIndexページ中に無かった場合はエラーとなります。
つまり、この手続きはinfoファイルがインストールされていないと動作しません。
@c COMMON

@c EN
If the current output port is a tty, the info page is displayed by
a paging software.  If an environment variable @code{PAGER} is defined,
it is used as a paging software.  Otherwise, this function looks for
@code{less} and @code{more} in this order from the directories in
@code{PATH}.  If none of them is found, or the output port is not
a tty, this function just displays the page.
@c JP
現在の出力ポートが端末である場合、infoドキュメントの該当ページは
ページングプログラムを用いて表示されます。環境変数@code{PAGER}が指定されていれば
それを用い、そうでなければコマンドサーチパスから@code{less}及び@code{more}を
この順で探します。いずれも見付からなかった場合や、出力ポートが端末では
ない場合には、単にページがそのまま出力されます。
@c COMMON

@c EN
The first invocation of this function in a session takes some time
to parse the info file.
@c JP
この手続きのセッション中での最初の呼び出しは、infoファイルをパーズするために
多少時間がかかります。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node gauche.listener - Listener, gauche.logger - User-level logging, gauche.interactive - Interactive session, Library modules - Gauche extensions
@section @code{gauche.listener} - Listener
@c NODE gauche.listener - リスナー, @code{gauche.listener} - リスナー

@deftp {Module} gauche.listener
@mdindex gauche.listener
@c EN
This module provides a convenient way to enable multiple
read-eval-print loop (repl) concurrently.
@c JP
このモジュールは、
複数のread-eval-printループ(repl)を並行して動作させるのに便利な機能を提供します。
@c COMMON

@c EN
An obvious way to run multiple repls is to use threads;
creating as many threads as sessions and calling
@code{read-eval-print-loop} (@xref{Eval and repl}) from each thread.
Nevertheless, sometimes single threaded implementation is preferred.
For instance, you're using a library which is not MT-safe,
or your application already uses select/poll-based dispatching mechanism.
@c JP
複数のreplを実現する自明な方法は、セッション毎にスレッドを生成して
各スレッド上で@code{read-eval-print-loop} (@ref{Eval and repl}参照)を
呼ぶことですが、シングルスレッドでの実装が好ましい場合もあります。
例えばアプリケーションがMT-safeでないライブラリに大きく依存していたり、
既にアプリケーションがselectやpollをベースにしたディスパッチメカニズムを
持っているような場合です。
@c COMMON

@c EN
To implement repl in the single-threaded selection-base application,
usually you register a handler that is called when data is available
in the listening port.  The handler reads the data and add them into
a buffer.  Then it examines if the data in the buffer consists a
complete expression, and if so, it reads the expression from the
buffer, evaluates it, then prints the result to the reporting port.
The @code{<listener>} class in this module provides this handler mechanism,
so all you need to do is to register the handler to your dispatching
mechanism.
@c JP
シングルスレッドのselectionベースのアプリケーションでreplを実装するには、
通常、listenしているポートにデータが到着した時に呼ばれるハンドラを登録します。
ハンドラはポートからデータを読み、内部バッファに追加します。
そして内部バッファをスキャンし、データが完全な式を構成した場合は
それをS式として読みだし、評価して結果をポートに流します。
このモジュールの@code{<listener>}クラスはこのハンドラのメカニズムを提供するので、
アプリケーション側はそれを自分のディスパッチメカニズムに登録するだけで済みます。
@c COMMON

@c EN
Note: it may also be desirable to buffer the output sometimes,
but the current version doesn't implement it.
@c JP
註：場合によっては、出力もバッファリングする必要があるかもしれませんが、
現在はそれは実装されていません。
@c COMMON
@end deftp

@deftp {Class} <listener>
@c EN
An object that maintains the state of a repl session.
It has many external slots to customize its behavior.
Those slot values can be set at construction time
by using the keyword of the same name as the slot,
or can be set by @code{slot-set!} afterwards.  However,
most of them should be set before calling 
@code{listener-read-hander}.
@c JP
Replセッションの状態を維持するオブジェクトです。
オブジェクトのふるまいをカスタマイズするためにいくつもの外部スロットがあります。
これらのスロットの値は、スロットの名前と同名のキーワード引数を用いて
オブジェクトの構築時に指定することもできますし、オブジェクト構築後に
@code{slot-set!}で設定することもできますが、@code{listener-read-handler}
を呼ぶ前に確定していなければなりません。
@c COMMON

@defivar <listener> input-port
Specifies the input port from which the listener get the input.
The default value is the current input port when the object is
constructed.
@end defivar

@defivar <listener> output-port
Specifies the output port to which the listener output will go.
The default value is the current output port when the object is
constructed.
@end defivar

@defivar <listener> error-port
Specifies the output port to which the listener's error messages will go.
The default value is the current error port when the object is
constructed.
@end defivar

@defivar <listener> reader
A procedure with no arguments.  It should read a Scheme expression
from the current input port when called.
The default value is system's @code{read} procedure.
@end defivar

@defivar <listener> evaluator
A procedure that takes two arguments, a Scheme expression and
an environment specifier.  It should evaluate the expression in
the given environment and returns zero or more value(s).
The default value is system's @code{eval} procedure.
@end defivar

@defivar <listener> printer
A procedure that takes zero or more argument(s) and prints them
out to the current output port.  The default value is a procedure
that prints each value by @code{write}, followed by a newline.
@end defivar

@defivar <listener> prompter
A procedure with no arguments.  It should prints a prompt
to the current output port.  The output is flushed by the listener
object so this procedure doesn't need to care about it.
The default procedure prints @code{"listener> "}.
@end defivar

@defivar <listener> environment
An environment specifier where the expressions will be
evaluated.  The default value is the value returned by
@code{(interaction-environment)}.
@end defivar

@defivar <listener> finalizer
A thunk that will be called when EOF is read from @code{input-port}.
It can be @code{#f} if no such procedure is needed.
The default value is @code{#f}.
@end defivar

@defivar <listener> error-handler
A procedure that takes one argument, an error exception.  It is
called when an error occurs during read-eval-print stage,
with the same dynamic environment as the error is signalled.
The default value is a procedure that simply prints the
error exception by @code{report-error}.
@end defivar
@end deftp


@deffn {Method} listener-read-handler (listener <listener>)
Returns a thunk that is to be called when a data is available
from @code{input-port} of the listener.

The returned thunk (read handler) does the following steps.
Note that the first prompt is @emph{not} printed by this
procedure.  See @code{listener-show-prompt} below.
@enumerate
@item
Reads available data from @code{input-port} and appends it to the
listener's internal buffer.
@item
Scans the buffer to see if it has a complete S-expression.
If not, returns.
@item
Reads the S-expression from the buffer.
The read data is removed from the buffer.
@item
Evaluates the S-expression, then prints the result to
@code{output-port}.
@item
Prints the prompt by prompter procedure to @code{output-port},
then flush @code{output-port}.
@item
Repeats from 2.
@end enumerate
@end deffn

@deffn {Method} listener-show-prompt (listener <listener>)
Shows a prompt to the listener's output port, by using
listener's prompter procedure.  Usually you want to use
this procedure to print the first prompt, for instance,
when the client is connected to the listener socket.
@end deffn

@defun complete-sexp? str
Returns @code{#t} if @var{str} contains a complete S-expression.
This utility procedure is exported as well, since it might be useful
for other purposes.

Note that this procedure only checks syntax of the expressions,
and doesn't rule out erroneous expressions (such as containing
invalid character name, unregistered SRFI-10 tag, etc.).
This procedure may raise an error if the input contains
'@code{#<}' character sequence.
@end defun

The following code snippet opens a server socket, and opens
a Scheme interactive session when a client is connected.
(Note: this code is just for demonstration.  Do not run
this program on the machine accessible from outside network!)

@example
(use gauche.net)
(use gauche.selector)
(use gauche.listener)

(define (scheme-server port)
  (let ((selector (make <selector>))
        (server   (make-server-socket 'inet port :reuse-addr? #t))
        (cid      0))

    (define (accept-handler sock flag)
      (let* ((client (socket-accept server))
             (id     cid)
             (input  (socket-input-port client :buffering :none))
             (output (socket-output-port client))
             (finalize (lambda ()
                         (selector-delete! selector input #f #f)
                         (socket-close client)
                         (format #t "client #~a disconnected\n" id)))
             (listener (make <listener>
                         :input-port input
                         :output-port output
                         :error-port output
                         :prompter (lambda () (format #t "client[~a]> " id))
                         :finalizer finalize))
             (handler (listener-read-handler listener))
             )
        (format #t "client #~a from ~a\n" cid (socket-address client))
        (inc! cid)
        (listener-show-prompt listener)
        (selector-add! selector input (lambda _ (handler)) '(r))))

    (selector-add! selector
                   (socket-fd server)
                   accept-handler
                   '(r))
    (format #t "scheme server started on port ~s\n" port)
    (do () (#f) (selector-select selector))))
@end example

@c ----------------------------------------------------------------------
@node gauche.logger - User-level logging, gauche.mop.singleton - Singleton, gauche.listener - Listener, Library modules - Gauche extensions
@section @code{gauche.logger} - User-level logging
@c NODE gauche.logger - ユーザレベルのロギング, @code{gauche.logger} - ユーザレベルのロギング

@deftp {Module} gauche.logger
@mdindex gauche.logger
@c EN
Provides a simple interface to log the program's activity.
The information can be written to the specified file,
or to the system logger using @code{syslog(3)}.
When a file is used, syslog-like prefix string is added
to each message, which is configurable.  It can also takes care of
locking of the file (see the description of @code{lock-policy} below).
@c JP
プログラムからログを書き出す簡単なインタフェースを提供します。
情報は指定されたファイルへ書き出されるか、もしくは@code{syslog(3)}を
使ってシステムログへと送られます。
ファイルに書き出される場合は、
syslogに似たプレフィクスが各メッセージの前に追加されます。
プレフィクスはカスタマイズすることもできます。
また、ログファイルの排他制御も行われます (下の@code{lock-policy}の説明を
参照して下さい)。
@c COMMON
@end deftp

@deftp {Class} <log-drain>
@clindex log-drain
@c EN
Represents the destination of log messages.
There's one implicit global @code{<log-drain>} instance, which is
used by default.  However, you can create as many instances
by @code{make} method as you want, in case if you want to log
to more than one destination.
@c JP
ログメッセージの行き先を表現するオブジェクトです。
デフォルトのログの行き先として、グローバルな@code{<log-drain>}のインスタンスが
ひとつ作られます。
ログをいくつかにわけて出力する場合などは@code{make}メソッドを使って
いくつでも@code{<log-drain>}のインスタンスを作ることができます。
@c COMMON

@defivar {<log-drain>} path
@c EN
Path of the log file.  It can be also @code{#t}, which means 
the current error port, or @code{#f}, which makes @code{log-format}
to return the formatted message but not write to any log files,
or a symbol @code{syslog}, which means the messages are sent to
the system logger.

By default, this slot is @code{#f}.
@c JP
ログファイルのパス名か、@code{#t}、@code{#f}、あるいはシンボル@code{syslog}
の値を取ります。このスロットが@code{#t}の場合、ログメッセージは現在のエラーポートに
書き出されます。@code{#f}の場合は@code{log-format}は
ログを書き出すかわりにフォーマットされたログメッセージを文字列として返します。
シンボル@code{syslog}の場合はメッセージがシステムログへと送られます。

このスロットの初期値は@code{#f}です。
@c COMMON
@end defivar

@defivar {<log-drain>} prefix
@c EN
Specifies the prefix string that is attached to the beginning of every
message.  If the message spans to several lines, the prefix is
attached to each line.   The value of this slot can also be a procedure
that takes @code{<log-drain>} object and returns a string to be used as
the prefix.  The procedure is called every time prefix is needed.
@c JP
各メッセージの前に追加されるプレフィクス文字列を指定します。
メッセージが複数行に渡る場合、プレフィクスは各行の頭に追加されます。
またこのスロットには手続きをセットすることもできます。
その場合、プレフィクス文字列が必要とされる度にその手続きが@code{<log-drain>}
を引数として呼び出され、戻り値の文字列がプレフィクスとして使われます。
@c COMMON

@c EN
When the @code{path} slot is a symbol @code{syslog}, the value of this slot
is ignored.  System logger will attach an appropriate prefix.
@c JP
@code{path}スロットの値がシンボル@code{syslog}の場合は、
このスロットの値は無視されます。システムのログ機構が適切なプレフィクスを付けるからです。
@c COMMON

@c EN
When the value of the prefix slot is a string, the following character sequences
have special meanings and replaced by @code{log-format} for appropriate
information when written out.
@c JP
prefixスロットの値が文字列の場合、以下に挙げる文字シーケンスは特別な意味を持ち、
@code{log-format}によって置換されます。
@c COMMON

@table @code
@item ~T
@c EN
Current time, in the format of "Mmm DD hh:mm:ss" where "Mmm" is
an abbreviated month, "DD" is the day of month, "hh", "mm" and
"ss" are hours (in 24 hour basis), minutes and seconds, respectively.
This format is compatible with system logs.
@c JP
現在の時刻を"Mmm DD hh:mm:ss"という形式で表したもの。
ここで"Mmm" は英語の月名の省略形、"DD" は日、"hh"、"mm"、
"ss" は時間(24時間制)、分、秒です。
このフォーマットはシステムログと同じです。
@c COMMON

@item ~Y
@c EN
Current 4-digit year.
@c JP
4桁で表した現在の西暦。
@c COMMON

@item ~P
@c EN
The program name.  The default value is the basename of
@code{*program-name*} (@xref{Writing Scheme scripts}), 
but you can change it by the @code{program-name}
slot described below.
@c JP
プログラム名。初期値は@code{*program-name*}の値のbasenameが使われます
(@ref{Writing Scheme scripts}参照)。
下に述べる@code{program-name}スロットの値を変えれば
ここに現れる文字列を変えることができます。
@c COMMON

@item ~$
@c EN
The process id of this program.
@c JP
このプログラムのプロセスID。
@c COMMON

@item ~U
@c EN
The name of the effective user of the process.
@c JP
このプロセスの実行ユーザ名。
@c COMMON

@item ~H
@c EN
The hostname the process is running.
@c JP
このプロセスが走っているホスト名。
@c COMMON
@end table

@c EN
The default value of this slot is "@code{~T ~P[~$]: }".  For example,
if a string "this is a log message.\nline 2\nline 3" is given as the
message, it produces something like the following log entry.
@c JP
このスロットの初期値は"@code{~T ~P[~$]: }"です。例えば
"this is a log message.\nline 2\nline 3"というメッセージが
与えられると、次のようなログが書き出されます。
@c COMMON

@example
Sep  1 17:30:23 myprogram[441]: this is a log message
Sep  1 17:30:23 myprogram[441]: line 2
Sep  1 17:30:23 myprogram[441]: line 3
@end example

@end defivar

@defivar {<log-drain>} program-name
@c EN
Specifies the program name written by @code{~P} directive of
the prefix slot.
@c JP
プレフィクス文字列の@code{~P}が置換されるプログラム名を指定します。
@c COMMON
@end defivar

@defivar {<log-drain>} lock-policy
@c EN
Specifies the way the log file should be locked.
If the value of this slot is a symbol @code{fcntl},
the log file is locked using
fcntl() (@xref{gauche.fcntl - Low-level file operations}).
If the value is a symbol @code{file}, the log file is locked by
creating auxiliary lock file, whose name is generated by appending ".lock"
after the log file path.  The logging
process needs a write permission to the log file directory.
Note that if the process is killed forcibly during writing the
log file, a stale lock file may remain.  @code{Log-format}
silently removes the lock file if it is unusually old (currently 10 minutes).
If the value is @code{#f}, no locking is performed.

The default value is @code{fcntl}, except MacOSX which doesn't
support fcntl()-style locking and thus @code{file} is default.

The locking isn't performed if the destination is not a file.
@c JP
ログファイルのロックの方法を指定します。
このスロットの値がシンボル@code{fcntl}だった場合は、
fcntl()によるファイルロックが使われます
(@ref{gauche.fcntl - Low-level file operations}参照)。
このスロットの値がシンボル@code{file}だった場合は、
ログファイルのパス名に ".lock" を追加したロックファイルを作成することによる
排他制御が行われます。この場合、ログを行うプロセスはログファイルの
置かれるディレクトリに書き込み権限が必要です。
また、プロセスがログファイル書き込み中に強制的に終了させられた場合、
ロックファイルが残ってしまう恐れがあります。
@code{Log-format}はロックファイルが十分に古い場合(現在は10分をリミットとしています)
ロックファイルを自動的に削除します。
このスロットの値が@code{#f}だった場合は、排他制御は行われません。

デフォルトの値は@code{fcntl}です。但しMacOSXではfcntlスタイルのロックが
サポートされていないため、@code{file}がデフォルト値となります。

ログの行き先がファイルでない場合は排他制御は行われません。
@c COMMON
@end defivar

@defivar {<log-drain>} syslog-option
@defivarx {<log-drain>} syslog-facility
@defivarx {<log-drain>} syslog-priority
@c EN
The value of these slots are used when the destination of the drain
is the system logger.   @xref{gauche.syslog - Syslog}, for the detailed information
about these values.  The default values of these slots
are @code{LOG_PID}, @code{LOG_USER} and @code{LOG_INFO}, respectively.
@c JP
これらのスロットの値は、ログの行き先がシステムログの場合にのみ使われます。
これらの値に関する説明は@ref{gauche.syslog - Syslog}を参照して下さい。
デフォルトの値はそれぞれ@code{LOG_PID}、@code{LOG_USER}、@code{LOG_INFO}です。
@c COMMON
@end defivar
@end deftp


@defun log-open path &keyword prefix program-name
@c EN
Sets the destination of the default log message to the path @var{path}.
It can be a string or a boolean, as described above.
You can also set prefix and program name by corresponding keyword 
arguments.
@c JP
デフォルトのログの行き先を@var{path}に指定します。
@var{path}は文字列かboolean値あるいはシンボル@code{syslog}で、
上の@code{path}スロットで述べたものと
おなじ意味を持ちます。またプレフィクスとプログラム名をキーワード引数で
指定することもできます。
@c COMMON

@c EN
Despite its name, this function doesn't open the specified file
immediately.  The file is opened and closed every time @code{log-format}
is called.
@c JP
名前に"open"とありますが、この手続きは指定されたファイルをオープンしません。
ファイルは@code{log-format}が呼ばれるたびにオープンされクローズされます。
@c COMMON
@end defun

@deffn {Method} log-format (format <string>) arg @dots{}
@deffnx {Method} log-format (drain <log-drain>) (format <string>) arg @dots{}
@c EN
Formats a log message by @var{format} and @var{arg @dots{}}, by using
@code{format} (@xref{Output}).    In the first form, the output goes
to the default destination.  In the second form, the output goes to
the specfied drain.
@c JP
ログメッセージを@code{format}手続きでフォーマットし(@ref{Output}参照)、
指定された行き先に書き出します。最初の形式ではデフォルトの行き先が使われます。
@c COMMON

@c EN
The file is opened and closed every time.  You can safely move
the log file while your program that touches the log file is running.
Also @code{log-format} acquires a write lock of the log file by
@code{sys-fcntl} (@xref{gauche.fcntl - Low-level file operations}).
@c JP
ファイルはこの手続きが呼ばれるたびにオープンされクローズされます。
したがって、ログファイルに書き出すプログラムが走っている最中でも
ログファイルをmoveすることができます。
また、@code{log-format}は@code{sys-fcntl} (@ref{gauche.fcntl - Low-level file operations}参照)
を使ってファイルロックを獲得します。
@c COMMON

@c EN
If the first form of @code{log-format} is called before @code{log-open}
is called, @code{log-format} does nothing.
It is useful to embed debug stubs in your code; once your code is
past the debugging stage, you just comment out @code{log-open} and
the code runs without logging.
@c JP
@code{log-open}が呼ばれる前に@code{log-format}が最初の形式で呼ばれた場合、
@code{log-format}は何もしません。したがって、@code{log-format}をデバッグに
活用し、必要なくなったら@code{log-open}だけをコメントアウトする、というような
使用法も可能です。
@c COMMON
@end deffn

@c ----------------------------------------------------------------------
@node gauche.mop.singleton - Singleton, gauche.mop.validator - Slot with validator, gauche.logger - User-level logging, Library modules - Gauche extensions
@section @code{gauche.mop.singleton} - Singleton

@deftp {Module} gauche.mop.singleton
@mdindex gauche.mop.singleton
Provides a metaclass to define a singleton class.
@end deftp

@deftp {Class} <singleton-meta>
@clindex singleton-meta
Creates a singleton class.  A singleton class is a class that is
guaranteed to create only one instance.
The first invocation of @code{make} creates the single instance,
and further attempt of creation returns the same instance.

@example
(define-class single () () :metaclass <singleton-meta>)

(define a (make single))
(define b (make single))

(eq? a b) @result{} #t
@end example

The slots of the instance are initialized at the first invocation
of @code{make}.  Initargs of @code{make} are effective only in the
fist invocation, and ignored in the subsequent invocation.
@end deftp

@deffn {Method} instance-of (class <singleton-meta>) &rest initargs
This method just calls @code{make} with the passed arguments.
It is more obvious in the program that you're dealing with singleton.
@end deffn

@deftp {Class} <singleton-mixin>
@clindex singleton-mixin
An instance of @code{<singleton-meta>}.  Instead of specifying
@code{<singleton-meta>} as the @code{:metaclass} argument of
@code{define-class}, you can inherit this class to give your
class the property of singleton.
@end deftp

@c ----------------------------------------------------------------------
@node gauche.mop.validator - Slot with validator, gauche.net - Networking, gauche.mop.singleton - Singleton, Library modules - Gauche extensions
@section @code{gauche.mop.validator} - Slot with validator
@c NODE gauche.mop.validator - Validator付きスロット, @code{gauche.mop.validator} - Validator付きスロット

@deftp {Module} gauche.mop.validator
@mdindex gauche.mop.validator
@c EN
Provides a metaclass that adds @code{:validator} slot option.
@c JP
@code{:validator}スロットオプションを追加するメタクラスを提供するモジュールです。
@c COMMON
@end deftp

@deftp {Class} <validator-meta>
@clindex validator-meta
@c EN
This metaclass adds a feature that the class can validate a value
before being set to the slot.   For example, if you want to guarantee
that a certain slot always holds a string value, you can make a procedure
be called before the slot is modified, either by @code{slot-ref} or
by a setter method.  In the procedure you can either rejects a
value except string, or coerce the value to a string.

The validator procedure can be set per each slot by using @code{:validator}
slot option.  The procedure takes two values, the instance and
the value to be set.  Whatever the procedure returns is set to
the actual slot value.
See the following example:
@c JP
このメタクラスは、スロットに対して値がセットされようとする時にその値の正当性を
検査する手続きを指定する機能を提供します。例えば、あるスロットに常に文字列のみが
セットされているようにしたい場合、そのスロットに、@code{slot-ref}経由であれ
アクセサメソッド経由であれ値がセットされようとした時に指定の手続きが呼ばれるように
し、その手続きの中で、値が文字列でなかったらエラーとするか、強制的に値を
文字列に変換してしまうことができます。その手続きが返した値が実際にスロットに
セットされます。

検査手続きは@code{:validator}スロットオプションによってスロット毎に指定できます。
手続きは、インスタンスとセットされようとしている値の二つを引数に取ります。
その手続きが返した値が実際にスロットにセットされる値となります。
下の例を参照して下さい。
@c COMMON

@example
(define-class <v> ()
  ((a :accessor a-of
      :validator (lambda (obj value) (x->string value)))
   (b :accessor b-of
      :validator (lambda (obj value)
                   (if (integer? value)
                       value
                       (error "integer required for slot b")))))
  :metaclass <validator-meta>)

(define v (make <v>))
(slot-set! v 'a 'foo)
(slot-ref v 'a) @result{} "foo"

(set! (a-of v) 1234)
(a-of v) @result{} "1234"

(slot-set! v 'b 55)
(slot-ref v 'b) @result{} 55

(slot-set! v 'b 3.4) @result{} @r{error}
(set! (b-of v) 3.4)  @result{} @r{error}
@end example

@c EN
You can specify default slot value (@code{:init-value} etc.) with
@code{:validator}.  In that case, the initialization method of the
instance calls the validator with the specified default value,
if :init-keyword is not given.
@c JP
@code{:validator} が指定されたスロットにも、@code{:init-value}等を
使って既定の初期値を指定しておくことができます。その場合、インスタンスの初期化ルーチンは、
init-keywordによる初期値指定が無ければ既定の初期値を引数としてvalidator手続きを
呼び出します。
@c COMMON

@example
(define-class <v> ()
  ((a :initform 'foo :init-keyword :a
      :validator (lambda (obj value) (x->string value)))))

(slot-ref (make <v>) 'a)        @result{} "foo"
(slot-ref (make <v> :a 555) 'a) @result{} "555"
@end example

@c EN
It looks similar to the virtual slot, but note that a slot with
validator has an actual storage in the instance, while a virtual
slot doesn't.

It is also a good example of customizing how the slots are accessed
using the metaobject protocol.  This feature is implemented by
only couple of dozen lines of code.
@c JP
仮想スロットに似ていますが、validatorを持つスロットはインスタンス内に実際に
値を格納している点が異なります。

このモジュールはまた、スロットのアクセスをメタオブジェクトプロトコルを使って
カスタマイズする例でもあります。この機能は20行ほどのコードで実現されています。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node gauche.net - Networking, gauche.parameter - Parameters, gauche.mop.validator - Slot with validator, Library modules - Gauche extensions
@section @code{gauche.net} - Networking
@c NODE gauche.net - ネットワーキング, @code{gauche.net} - ネットワーキング

@deftp {Module} gauche.net
@mdindex gauche.net
@c EN
Provides a set of functions necessary for network communications
based on BSD socket interface.

The API is provided in two different levels.  Lower level routines
reflect traditional BSD socket interface, such as @code{bind(2)}.
Higher level routines provides more convenient way to create
typical connection-oriented server/client sockets.

This module also provides APIs to obtain various information
about hostnames, service ports, and protocols.
@c JP
BSDソケットに基づいたネットワーキングに必要な手続きを提供するモジュールです。

2つのレベルのAPIが定義されています。低レベルの手続きは@code{bind(2)}のような
BSDソケットインタフェースに近いインタフェースを提供し、高レベルの手続きは
典型的なコネクション指向のクライアントサーバアプリケーションに便利な
インタフェースを提供します。

また、ホストネームやプロトコルに関する情報にアクセスするAPIも定義されます。
@c COMMON
@end deftp


@menu
* Socket address::              
* High-level network functions::  
* Low-level socket interface::  
* Netdb interface::             
@end menu

@node Socket address, High-level network functions, gauche.net - Networking, gauche.net - Networking
@subsection Socket address
@c NODE ソケットアドレス

@deftp {Builtin Class} <sockaddr>
@clindex sockaddr
@c EN
An abstract base class of socket addresses.  Each socket address family
is implemented as a subclass of this class.

Although socket addresses are built-in classes, you can use
@code{make} method to create an instance of a
specific socket address family.
@c JP
ソケットアドレスの抽象ベースクラスです。
ソケットアドレスファミリはこのクラスのサブクラスとして実装されます。

ソケットアドレスはビルトインクラスですが、@code{make}メソッドで
特定のソケットアドレスファミリのインスタンスを作成することができます。
@c COMMON
@end deftp

@deffn {Generic Function} sockaddr-family addr
@c EN
Returns a symbol that indicates the family of the socket address
@var{addr}.
@c JP
ソケットアドレス@var{addr}のファミリを表すシンボルを返します。
@c COMMON
@end deffn

@deffn {Generic Function} sockaddr-name addr
@c EN
Returns a string which represents the content of the socket address
@var{addr}.
@c JP
ソケットアドレス@var{addr}の名前を表す文字列を返します。
@c COMMON
@end deffn

@deftp {Builtin Class} <sockaddr-in>
@clindex sockaddr-in
@c EN
AF_INET family socket address.  To create an instance of this class,
use @code{make} method as follows:
@c JP
AF_INETファミリのソケットアドレスです。このクラスのインスタンスを
作成するには、次のようにして@code{make}メソッドを呼びます。
@c COMMON
@example
(make <sockaddr-in> :host @var{host} :port @var{port})
@end example
@c EN
@var{host} can be a string, or one of the keywords
@code{:any}, @code{:broadcast}, @code{:none} or @code{:loopback}.
If it is a string, it is either a host name or a dotted IP notation.
Gauche uses @code{gethostbyname(3)} to obtain the actual IP address from
@var{host} parameter.  If it is a keyword @code{:any}, 
or @code{:broadcast}, the address
uses @code{INADDR_ANY}, or @code{INADDR_BROADCAST}
respectively.  The keyword @code{:loopback} is a synonym to the
IPv4 loopback address "127.0.0.1".
@c JP
@var{host}は文字列か、
@code{:any}、@code{:broadcast}、@code{:none}、@code{:loopback}の
いずれかのキーワードでなければなりません。
文字列の場合、それはホスト名かIPアドレスのドット表記です。
Gaucheは@code{gethostbyname(3)}を使って実際のIPアドレスを得ます。
この値がキーワード@code{:any}か@code{:broadcast}なら、それぞれ
@code{INADDR_ANY}か@code{INADDR_BROADCAST}がアドレスとして使われます。
キーワード@code{:loopback}はIPv4のループバックアドレス"127.0.0.1"を表します。
@c COMMON

@c EN
@var{port} must be a positive integer indicating the port number.
@c JP
@var{port}はポート番号を示す正の整数です。
@c COMMON
@end deftp

@deffn {Method} sockaddr-family (addr <sockaddr-in>)
@c EN
Returns a symbol @code{inet}.
@c JP
シンボル@code{inet}を返します。
@c COMMON
@end deffn

@deffn {Method} sockaddr-name (addr <sockaddr-in>)
@c EN
Returns a string in the form "@var{a}.@var{b}.@var{c}.@var{d}:@var{port}",
 where "@var{a}.@var{b}.@var{c}.@var{d}" is dotted decimal notion of
the IP address and @var{port} is the port number.
@c JP
文字列"@var{a}.@var{b}.@var{c}.@var{d}:@var{port}"を返します。
コロンの前はIPアドレスのドット表記で、@var{port}はポート番号です。
@c COMMON
@end deffn

@deftp {Builtin Class} <sockaddr-un>
@clindex sockaddr-un
@c EN
AF_UNIX family socket address.  To create an instance of this class,
use @code{make} method as follows:
@c JP
AF_UNIXファミリのソケットアドレスです。このクラスのインスタンスを作成するには、
@code{make}メソッドを次のように呼んで下さい。
@c COMMON
@example
(make <sockaddr-un> :path @var{path})
@end example
@c EN
@var{path} must be a string specifying pathname of the socket.
@c JP
@var{path}はソケットのパス名を表す文字列です。
@c COMMON
@end deftp

@deffn {Method} sockaddr-family (addr <sockaddr-un>)
@c EN
Returns a symbol @code{unix}.
@c JP
シンボル@code{unix}を返します。
@c COMMON
@end deffn

@deffn {Method} sockaddr-name (addr <sockaddr-un>)
@c EN
Returns a pathname of the socket address.
@c JP
ソケットアドレスのパス名を返します。
@c COMMON
@end deffn


@node High-level network functions, Low-level socket interface, Socket address, gauche.net - Networking
@subsection High-level network functions
@c EN 高レベルネットワーク手続き

@deftp {Builtin Class} <socket>
@clindex socket
@c EN
Abstracts a socket, a communication endpoint.

For a connection-oriented socket, you can access the communication
channel by two ports associated to the socket, one for input and
another for output.  @code{socket-input-port} and @code{socket-output-port}
returns those ports, respectively.
@c JP
コミュニケーション終端であるソケットを表すクラスです。

コネクション型のソケットに対しては、2つのポート(入力用と出力用)を使って
コミュニケーションチャネルにアクセスすることができます。
@code{socket-input-port}と@code{socket-output-port}がこれらのポートを
それぞれ返します。
@c COMMON
@end deftp

@c EN
The following two functions are convenient ways to create
a connection-oriented socket.  Those functions
are to provide an easy methods for typical cases,
but have less control.  If you need more than these functions
provide, use low-level interface.
@c JP
以下の2つの手続きはコネクション型のソケットを作成する
便利な手続きです。これらは典型的な場合に対する簡単な方法を提供しますが、
細かい制御はできません。動作のより細かい制御が必要な場合は低レベルAPIを
見て下さい。
@c COMMON

@defun make-client-socket &optional address-spec @dots{}
@c EN
Creates and returns a client socket, connected to the address
specified by @var{address-spec} @dots{}.
@c JP
引数@var{address-spec} @dots{} によって指定されるアドレスと通信する
クライアントソケットを作成して返します。
@c COMMON

@table @code
@item (make-client-socket 'unix @var{path})
@c EN
The client socket is connected to the unix domain server socket
of addreess @var{path}.
@c JP
@var{path}で待っているUnixドメインのサーバーソケットに接続します。
@c COMMON
@item (make-client-socket 'inet @var{host} @var{port})
@c EN
The client socket is connected to the inet domain server socket
with hostname @var{host} and port @var{port}.   TCP protocol is
assumed.   @var{host} can be either a dotted decimal notation of
IPv4 address, or a hostname.  @var{port} must be an exact integer.
@c JP
ホスト@var{host}のポート@var{port}で待っているInetドメインのサーバーソケットに
TCPを使って接続します。@var{host}はIPアドレスのドット表記でもホスト名でも
構いません。@var{port}は正確な整数でなければなりません。
@c COMMON
@item (make-client-socket @var{host} @var{port})
@c EN
This works the same as above.  This form is for compatibility with STk.
@c JP
上と同じです。この形式はSTkとの互換性のために提供されています。
@c COMMON
@end table

@c EN
This function raises an error if it cannot create a socket,
or cannot connect to the specified address.
@c JP
ソケットを作成できなかったり、指定されたアドレスに接続できなかった場合は
エラーが報告されます。
@c COMMON

@example
(make-client-socket 'inet "www.w3.com" 80)
  @result{} ;@r{a socket connected to www.w3.com, port 80}
(make-client-socket "127.0.0.1" 23)
  @result{} ;@r{a socket connected to localhost, port 23}
(make-client-socket 'unix "/tmp/.sock"
  @result{} ;@r{a socket connected to a unix domain socket "/tmp/.sock"}
@end example
@end defun

@defun make-server-socket &optional address-spec @dots{}
@c EN
Creates and returns a server socket, listening the address
specified by @var{address-spec}.
@c JP
@var{address-spec}にて接続を待つサーバソケットを作成して返します。
@c COMMON

@table @code
@item (make-server-socket 'unix @var{path})
@c EN
The socket is bound to a unix domain socket with a name @var{path}.
@c JP
パス名@var{path}を持つUnixドメインソケットが作成されます。
@c COMMON
@item (make-server-socket 'inet @var{port} [:reuse-addr? @var{flag}])
@c EN
The socket is bound to an inet domain TCP socket, listening
port @var{port}, which must be a non-negative exact integer.
If @var{port} is zero, the system assigns one of available port numbers.
If a keyword argument @var{reuse-addr?} is given and true,
@code{SO_REUSEADDR} option is set to the socket before bound to
the port.  This allows the process to bind the server socket
immediately after other process releases the port.
@c JP
ポート@var{port}にて接続を待つInetドメインのTCPソケットが作成されます。
@var{port}が0の場合はシステムが適当なポート番号を割り当てます。
キーワード引数@var{reuse-addr?}に真の値が与えられた場合は、
ソケットに@code{SO_REUSEADDR}オプションがセットされます。
このオプションをセットすると、他のプロセスがそのポートを使わなくなったら直ちに
このプロセスがそのポートを使うことができます。
@c COMMON
@item (make-server-socket @var{port} [:reuse-addr? @var{flag}])
@c EN
This is a synonym to the above form.  This form is backward-compatible
with STk's @code{make-server-socket}.
@c JP
これは上の形式と同じ動作をします。STkの@code{make-server-socket}との
互換性のために提供されています。
@c COMMON
@end table

@example
(make-server-socket 'inet 8080)
  @result{} #<socket (listen "0.0.0.0:8080")>
(make-server-socket 8080)
  @result{} #<socket (listen "0.0.0.0:8080")>
(make-server-socket 'inet 0)
  @result{} #<socket (listen "0.0.0.0:35628")>
(make-server-socket 'unix "/tmp/.sock")
  @result{} #<socket (listen "/tmp/.sock")>
@end example
@end defun

@c EN
Several accessors are available on the returned socket object.
@c JP
返されたソケットオブジェクトに対して、以下のようなアクセサを適用することができます。
@c COMMON

@defun socket-address socket
@c EN
Returns a socket address associated with @var{socket}.
If no address has been associated to the socket, @code{#f} is returned.
@c JP
ソケット@var{socket}のアドレスを返します。
ソケットにアドレスがまだバインドされていない場合は@code{#f}が返ります。
@c COMMON
@end defun

@defun socket-input-port socket &keyword (buffering @code{:modest})
@defunx socket-output-port socket &keyword (buffering @code{:line})
@c EN
Returns an input and output port associated with @var{socket},
respectively.
@c JP
@var{socket}からデータを読みだす入力ポート、または
@var{socket}にデータを書き出す出力ポートを返します。
@c COMMON

@c EN
The keyword argument @var{buffering} specifies the buffering mode
of the port.  @xref{File ports}, for explanation of the
buffering mode.
@c JP
キーワード引数@var{buffering}はポートのバッファリングモードを
指定します。バッファリングモードの説明は@ref{File ports}を見て下さい。
@c COMMON
@end defun

@defun socket-close socket
@c EN
Closes @var{socket}.  All the ports associated to
@var{socket} are closed as well.   If the socket is connected,
it is shut down before closing.
@c JP
ソケット@var{socket}をクローズします。@var{socket}の入出力ポートも
クローズされます。ソケットが接続されていた場合は、クローズの前に接続が
シャットダウンされます。
@c COMMON
@end defun

@defun call-with-client-socket socket proc
@c EN
@var{socket} must be a connected client socket.  @var{proc} is called
with two arguments, an input port that reads from the socket
and an output port that writes to the socket.
The socket is closed after @var{proc} returns or @var{proc}
raises an error.
@c JP
@var{socket}は接続されたクライアントソケットでなければなりません。
@var{proc}がソケットから読み出す入力ポートと、
ソケットに書き出す出力ポートを引数として呼ばれます。
@var{proc}が正常終了するか、エラーを投げた場合にソケットは閉じられます。
@c COMMON
@end defun

@c EN
This is an example of usage of high-level socket functions,
a very simple http client.
@c JP
これは高レベルソケット手続きを使った、非常に単純なhttpクライアントです。
@c COMMON

@example
#!/usr/bin/env gosh
(use gauche.regexp)
(use gauche.net)

(define (usage)
  (display "Usage: swget url\n" (current-error-port))
  (exit 1))

;; Returns three values: host, port, and path.
(define (parse-url url)
  (rxmatch-let (rxmatch #/^http:\/\/([-A-Za-z\d.]+)(:(\d+))?(\/.*)?/ url)
      (#f host #f port path)
    (values host port path)))

(define (get url)
  (receive (host port path) (parse-url url)
    (call-with-client-socket
        (make-client-socket 'inet host (string->number (or port "80")))
      (lambda (in out)
        (format out "GET ~a HTTP/1.0\r\n" path)
        (format out "host: ~a\r\n\r\n" host)
        (flush out)
        (copy-port in (current-output-port))))))

(define (main args)
  (if (= (length args) 2)
      (get (cadr args))
      (usage))
  0)
@end example


@node Low-level socket interface, Netdb interface, High-level network functions, gauche.net - Networking
@subsection Low-level socket interface
@c NODE 低レベルソケットインタフェース

These functions provide APIs similar to the system calls.
Those who are familiar to programming with socket APIs will
find these functions useful since you can have more detailed control over
the sockets.

@defun make-socket domain type &optional protocol
Returns a socket with specified parameters.
@end defun

@defvar PF_UNIX
@defvarx PF_INET
These variables are bound to @code{PF_UNIX} and @code{PF_INET}.
@end defvar

@defvar AF_UNIX
@defvarx AF_INET
These variables are bound to @code{AF_UNIX} and @code{AF_INET}.
@end defvar

@defvar SOCK_STREAM
@defvarx SOCK_DGRAM
@defvarx SOCK_RAW
These variables are bound to @code{SOCK_STREAM}, @code{SOCK_DGRAM}
and @code{SOCK_RAW}.
@end defvar

@defun socket-fd socket
Returns an integer system file descriptor of the underlying socket.
@end defun


@defun socket-status socket
Returns a internal status of @var{socket}, by one of the following
symbols.
@multitable {aaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item none
@tab The socket is just created.
@item bound
@tab The socket is bound to an address by @code{socket-bind}
@item listening
@tab The socket is listening a connection by @code{socket-listen}
@item connected 
@tab The socket is connected by @code{socket-connect} or @code{socket-accept}.
@item shutdown
@tab The socket is shutdown by @code{socket-shutdown}
@item closed
@tab The socket is closed by @code{socket-close}.
@end multitable
@end defun

@defun socket-bind socket address
Binds @var{socket} to the local network address @var{address}.
It is usually used to associate specific address to the server port.
If binding failed, an error is signalled (most likely the address is
already in use).

For the inet domain address, you can pass @var{address} with port=0;
the system assigns the port number and sets the actual address to
the @code{address} slot of @var{socket}.
@end defun

@defun socket-listen socket backlog
Listens @var{socket}.  The socket must be already bound to some
address.  @var{backlog} specifies maximum number of connection
requests to be queued.
@end defun

@defun socket-accept socket
Accepts a connection request coming to @var{socket}.
Returns a new socket that is connected to the remote entity.
The original @var{socket} keeps waiting for further connections.
If there's no connection requests, this call waits for one to come.

You can use @code{sys-select} to check if there's a pending connection
request.
@end defun

@defun socket-connect socket address
Connects @var{socket} to the remote address @var{address}.
This is the way for a client socket to connect to the remote entity.
@end defun

@defun socket-shutdown socket how
Shuts down connection of @var{socket}.  If @var{how} is 0, the receive
channel of @var{socket} is disallowed.  If @var{how} is 1, the send
channel of @var{socket} is disallowed.  If @var{how} is 2, both
receive and send channels are disallowed.
It is an error to call this function on a non-connected socket.

If you shut down the send channel of the socket, the remote peer
sees EOF from its receive channel.  This is useful if the remote peer
expects EOF before sending something back to you.

Other than this kind of special cases, you don't usually need to
call @code{socket-shutdown} explicitly; @code{socket-close} calls it anyway.
@end defun

Further control over sockets and protocol layers is possible
by getsockopt/setsockopt interface, as described below.

@defun socket-setsockopt socket level option value
@defunx socket-getsockopt socket level option rsize
These are the interface to setsockopt() and getsockopt() calls.
The interface is a bit clumsy, in order to allow full access to
those low-level calls.

@var{socket} must be a non-closed socket object.
@var{level} and @var{option} is an exact integer to specify
the level of protocol stack and the option you want to deal with.
There are several variables pre-bound to system constants listed below.

To set the socket option, you can pass either an exact integer or
a string to @var{value}.  If it is an integer, the value is passed
to setsockopt(2) as C @code{int} value.  If it is a string, the
byte sequence is passed as is.  The required type of value depends on
the option, and Gauche can't know if the value you passed is expected
by setsockopt(2); it is your responsibility to pass the correct values.

To get the socket option, you need to tell the maximum length of expected
result by @var{rsize} parameter, for Gauche doesn't know the amount
of data each option returns.
@code{socket-getsockopt} returns the option value as a byte string.
If you know the option value is an integer, you can pass 0 to @var{rsize};
in that case @code{socket-getsockopt} returns the value as an exact integer.

Note about the name: I tempted to name these function socket-@{set|get@}opt
or socket-@{set|get@}-option,
but I rather took the naming consistency.  Hence duplicated "sock"s.

@end defun

The following predefined variables are provided.
Note that some of them are not available on all platforms.
See manpages @code{socket(7)}, @code{tcp(7)} or @code{ip(7)} of
your system to find out exact specification of those values.

For ``level'' argument:
@defvar SOL_SOCKET
@defvarx SOL_TCP
@defvarx SOL_IP
These variables are bound to @code{SOL_SOCKET}, @code{SOL_TCP} and
@code{SOL_IP}, respectively.
@end defvar

For ``option'' argument:
@defvar SO_KEEPALIVE
Expects integer value.  If it is not zero, enables sending  of
keep-alive messages on connection-oriented sockets.
@end defvar

@defvar SO_OOBINLINE
Expects integer value.  If it is not zero, out-of-band data is
directly placed into the receive data stream.  Otherwise
out-of-band  data  is  only passed when the
MSG_OOB flag is set during receiving.
@end defvar

@defvar SO_REUSEADDR
Expects integer value.  If it is not zero, @code{socket-bind}
allows to reuse local addresses, unless an active listening
socket bound to the address.
@end defvar

@defvar SO_TYPE
Gets the socket type as an integer (like @code{sock_stream}).
Can be only used with @code{socket-getsockopt}.
@end defvar

@defvar SO_BROADCAST
Expects integer value.  If it is not zero, datagram sockets
are allowed to send/receive broadcast packets.
@end defvar

@defvar SO_PRIORITY
Expects integer value, specifying the protocol-defined priority
for all packets to be sent on this socket.
@end defvar

@defvar SO_ERROR
Gets and clears the pending socket error as an integer.
Can be only used with @code{socket-getsockopt}.
@end defvar

@node Netdb interface,  , Low-level socket interface, gauche.net - Networking
@subsection  Netdb interface
@c NODE Netdbインタフェース

@deftp {Builtin Class} <sys-hostent>
@clindex sys-hostent
A class of objects for network hosts.  Corresponding to
@code{struct hostent}.  The following slots are available read-only.

@defivar {<sys-hostent>} name
The formal name of the host (string).
@end defivar
@defivar {<sys-hostent>} aliases
A list of alias names of the host (list of strings).
@end defivar
@defivar {<sys-hostent>} addresses
A list of addresses (list of strings).  Only ipv4 address is 
supported currently.  Each address is represented by dotted decimal
notation.
@end defivar
@end deftp

@defun sys-gethostbyname name
Looks up a host named @var{name}.
If found, returns a @code{<sys-hostent>} object.
Otherwise, returns @code{#f}.
@example
(let ((host (sys-gethostbyname "www.w3c.org")))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'addresses)))
  @result{} ("www.w3.org" ("www.w3c.org") ("18.29.1.34" "18.29.1.35"))
@end example
@end defun

@defun sys-gethostbyaddr addr proto
Looks up a host that has an address @var{addr} of protocol @var{proto}.
@var{addr} is a natural string representation of the address;
for ipv4, it is a dotted decimal notation.  @var{proto} is a
protocol number; only @code{AF_INET} is supported currently.
If the host is found, returns a @code{<sys-hostent>} object.
Otherwise, returns @code{#f}.
@example
(let ((host (sys-gethostbyaddr "127.0.0.1" AF_INET)))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'addresses))
  @result{} ("localhost" ("localhost.localdomain") ("127.0.0.1"))
@end example
@end defun

@deftp {Builtin Class} <sys-servent>
@clindex sys-servent
An entry of the network service database.  Corresponding to
@code{struct servent}.  The following slots are available read-only.

@defivar {<sys-servent>} name
The formal name of the service (string).
@end defivar
@defivar {<sys-servent>} aliases
A list of alias names of the service (list of strings).
@end defivar
@defivar {<sys-servent>} port
A port number registered for this service (exact integer).
@end defivar
@defivar {<sys-servent>} proto
A protocol name for this service (string).
@end defivar
@end deftp

@defun sys-getservbyname name proto
Looks up the network service database with a service name @var{name} and
a protocol @var{proto}.  Both @var{name} and @var{proto} must be a string.
If a service is found, an instance of @code{<sys-servent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((serv (sys-getservbyname "http" "tcp")))
  (list (slot-ref serv 'name)
        (slot-ref serv 'aliases)
        (slot-ref serv 'port)
        (slot-ref serv 'proto)))
  @result{} ("http" () 80 "tcp")
@end example
@end defun

@defun sys-getservbyport port proto
Looks up the network service database with a service port @var{port} and
a protocol @var{proto}.  @var{port} must be an exact integer, and
@var{proto} must be a string.
If a service is found, an instance of @code{<sys-servent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((serv (sys-getservbyport 6000 "tcp")))
  (list (slot-ref serv 'name)
        (slot-ref serv 'aliases)
        (slot-ref serv 'port)
        (slot-ref serv 'proto)))
  @result{} ("x-server" () 6000 "tcp")
@end example
@end defun

@deftp {Builtin Class} <sys-protoent>
@clindex sys-protoent
An entry of the protocol database.   Corresponds to @code{struct protoent}
in C.   The following slots are available read-only.

@defivar {<sys-servent>} name
The formal name of the protocol (string).
@end defivar
@defivar {<sys-servent>} aliases
A list of alias names of the protocol (list of strings).
@end defivar
@defivar {<sys-servent>} proto
A protocol number (exact integer).
@end defivar
@end deftp

@defun sys-getprotobyname name
Looks up the network protocol database with a name @var{name},
which must be a string.
If a protocol is found, an instance of @code{<sys-protoent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((proto (sys-getprotobyname "icmp")))
  (list (slot-ref proto 'name)
        (slot-ref proto 'aliases)
        (slot-ref proto 'proto)))
  @result{} ("icmp" ("ICMP") 1)
@end example
@end defun

@defun sys-getprotobynumber number
Looks up the network protoice database with a protocol number @var{number},
which must be an exact integer.
If a protocol is found, an instance of @code{<sys-protoent>} is returned.
Otherwise, @code{#f} is returned.
@example
(let ((proto (sys-getprotobynumber 17)))
  (list (slot-ref proto 'name)
        (slot-ref proto 'aliases)
        (slot-ref proto 'proto)))
  @result{} ("udp" ("UDP") 17)
@end example
@end defun

@c ----------------------------------------------------------------------
@node gauche.parameter - Parameters, gauche.parseopt - Parsing command-line options, gauche.net - Networking, Library modules - Gauche extensions
@section @code{gauche.parameter} - Parameters
@c NODE gauche.parameter - パラメータ, @code{gauche.parameter} - パラメータ

@deftp {Module} gauche.parameter
@mdindex gauche.parameter
@c EN
A @emph{parameter} is somethink like a stateful procedure that takes zero or
one argument.
If no argument is given, the parameter returns the current value it is keeping.
If single argument is given, it will be the current value of the parameter.
A parameter has several advantages over global variables to store
states.
@c JP
「パラメータ」は基本的にゼロもしくは一個の引数を取る状態を持つ手続きとみなせます。
引数が与えられなかった場合、それは内部に保持した値を返します。
一つの引数が与えられた場合、その値が新たなパラメータ内部の値となり、
変更前の値が返されます。
パラメータは状態を保持する手段として、
単なるグローバル変数に比べていくつかの利点を持っています。
@c COMMON

@c EN
Value of parameters are kept for each thread, so you can use
a parameter as a thread-local storage.  When a new thread is
created, it inherits a copy of parameters from its creator thread.
@c JP
パラメータの値はスレッド毎に保持されるので、
パラメータをスレッドローカルな格納領域として利用することができます。
新たに作られたスレッドは、その作成元のスレッドのパラメータのコピーを
受け取ります。
@c COMMON

@c EN
You can give a "filter procedure" that checks the new
value before setting it as the parameter value,
so that you can guarantee the value of the parameter is always sane.
@c JP
パラメータに値がセットされるときに、指定の「フィルタ手続き」を呼んで
値を検査することができます。これにより、パラメータの値が常に正当なもので
あることを保証できます。
@c COMMON

@c EN
With the macro @code{parameterize}, you can change the parameter's
value within certain dynamic scope.   It can effectively
replace dynamically scoped variables.
@c JP
マクロ@code{parameterize}により、特定のダイナミックスコープの中だけ
パラメータの値を変えることができます。これは、実質的にダイナミックスコープを
持つ変数を置き換えることができます。
@c COMMON

@c EN
You can also register callback procedures to be called whenever
the value of the parameter is changed.   It can effectively
replace so-called "traced variables"
@c JP
また、パラメータの値が変更されたときに呼ばれるコールバック手続きを
登録しておくこともできます。これによって実質的に、いわゆる
「traceされた変数」を置き換えることができます。
@c COMMON

@c EN
@var{Parameters} can be found in other Scheme implementations,
including ChezScheme, Chicken and MzScheme.
Guile and Scheme48 call them @var{fluids}, with different APIs.
@c JP
この機能はChezScheme、Chicken、MzSchemeなどいくつかのScheme処理系に
見られます。また、これはGuileやScheme48では@var{fluid}と呼ばれています。
@c COMMON
@end deftp

@deftp {Class} <parameter>
@clindex parameter
@c EN
A parameter class.  A @code{object-apply} method is defined
so that a parameter can be used as if it were a procedure.
@c JP
パラメータのクラスです。@code{object-apply}メソッドが定義されているので、
パラメータオブジェクトは普通の手続きと同様に使うことが出来ます。
@c COMMON
@end deftp

@defun make-parameter value &optional filter
@c EN
Creates a parameter whose initial value is @var{value}.
If an optional argument @var{filter} is given, it must be
a procedure that takes one argument and returns one value;
whenever the parameter's value is about to change, the procedure
is called with the given value, and the value the procedure
returns will be the parameter's value.  The filter procedure
can raise an error or reject to change the parameter's value.
@c JP
初期値が@var{value}であるパラメータを作成します。
もし省略可能な引数@var{filter}が与えられた場合、
それは一つの引数を取る手続きでなければなりません。
パラメータの値が変更されようとした時、@var{filter}は与えられた値を
引数として呼ばれ、@var{filter}が返した値がパラメータの新しい値と
なります。@var{filter}はエラーを報告したりパラメータの値を変えずに置くことも
可能です。
@c COMMON
@end defun

@defmac parameterize ((param value) @dots{}) body @dots{}
@c EN
Evaluages @var{body} @dots{}, with
change parameter @var{param}'s value to the given @var{value} within
the dynamic scope of @var{body} @dots{}.
Returns the value(s) of the result of the last @var{body}.
@c JP
@var{body} @dots{}を評価します。
但し、@var{body} @dots{} の実行中のみ、パラメータ@var{param}の値を
@var{value}に変更します。最後@var{body}の返した値を返します。
@c COMMON
@end defmac

@c EN
Some examples:
@c JP
例：
@c COMMON
@example
(define a (make-parameter 1))
(a) @result{} 1
(a 2)
(a) @result{} 2
(parameterize ((a 3))
  (a)) @result{} 3
(a) @result{} 2
@end example

@deffn {Method} parameter-observer-add! (p <parameter>) proc &optional when where
Adds @var{proc} to "observer" procedures of a parameter @var{p}.
Observer procedures are called either (1) just before
a new value is set to the parameter, or (2) just after the new value
is set to the parameter.   In case of (1), a filter procedure is
already applied before a callback is called.
In either case, observer procedures are called with two arguments,
the old value and the new value.  The return value(s) of observer
procedures are discarded.

The optional @var{when} argument must be either a symbol @code{before}
or @code{after}, to specify whether @var{proc} should be called
before or after the value is changed.   If omitted, @code{after} is
assumed.

The optional @var{where} argument must be either a symbol
@code{append} or @code{prepend}, to specify whether @var{proc} should
be prepended or appended to the existing observer procedure list.
If omitted, @code{append} is assumed.

@emph{Note}: Although the parameter value itself is thread-local,
the observer list is shared by all threads.
@end deffn

@deffn {Method} parameter-observer-delete! (p <parameter>) proc &optional when
Deletes @var{proc} from observer procedure list of a parameter @var{p}.
If @var{proc} is not in the list, nothing happens.
You can give either a symbol @code{before} or @code{after} to
@var{when} argument to specify from which list @var{proc} should be
deleted.  If @var{when} argument is omitted, @var{proc} is deleted
from both lists. 
@end deffn

@deffn {Method} parameter-pre-observers (p <parameter>)
@deffnx {Method} parameter-post-observers (p <parameter>)
Returns a hook object (@xref{gauche.hook - Hooks}) that keeps
"before" or "after" observers, respectively.

@emph{Note}: Although the parameter value itself is thread-local,
these hook objects are shared by all threads.
@end deffn

@c ----------------------------------------------------------------------
@node gauche.parseopt - Parsing command-line options, gauche.process - High Level Process Interface, gauche.parameter - Parameters, Library modules - Gauche extensions
@section @code{gauche.parseopt} - Parsing command-line options
@c NODE gauche.parseopt - コマンドライン引数の解析, @code{gauche.parseopt} - コマンドライン引数の解析

@deftp {Module} gauche.parseopt
@mdindex gauche.parseopt
This module defines a convenient way to parse command-line options.
The interface is hinted by Perl, and conveniently handles long-format
options with mutiple option arguments.

Actually, you have a few choices to parse command-line
options in Gauche.
SRFI-37 (@xref{srfi-37 - a program argument processor}) provides
functional interface to parse POSIX/GNU compatible argument syntax.
SLIB has @code{getopt}-compatible utility.
Required features may differ from application to application,
so choose whichever fits your requirement.
@end deftp

@defmac parse-options args (option-clause @dots{})
@var{args} is an expression that contains a list of command-line arguments.
This macro scans the command-line options (an argument that begins with
`@code{-}') and processes it as specified in @var{option-clause}s, then
returns the remaining arguments.

Unlike typical @code{getopt} or @code{getopt_long} implementation in C,
@code{parse-options} does not permute the given command-line arguments.
It stops parsing when it encounters a non-option argument (argument without
starting with a minus sign).

If the parser encounters an argument with only two minus signs `@code{--}',
it stops argument parsing and returns a list of arguments after `@code{--}'.

Each @var{option-clause} is consisted by a pair of @var{option-spec}
and its action.

@var{option-spec} is a string that specifies the name of the option and
how the option takes the arguments.  An alphanumeric characters, underscore,
plus and minus sign is allowed for option's names, except that
minus sign can't be the first character, i.e. the valid option name
matches a regexp @code{#/[\w_+][-\w_+]*/}.
If the option takes argument(s), it can be specified by attaching 
equal character and the type of the argument after the name.  The option
can take more than one arguments.

@table @code
@item "@var{name}"
Specifies option @var{name}, that doesn't take any argument.

@item "@var{name}=s"
Option @var{name} takes one argument, and it is passed as a string.

@item "@var{name}=i"
Option @var{name} takes one argument, and it is passed as an exact integer.
If the given argument is not valid string for an exact integer,
an error is signalled.

@item "@var{name}=f"
Option @var{name} takes one argument, and it is passed as a real number.
If the given argument is not valid string for a real number,
an error is signalled.

@item "@var{name}=ss"
Option @var{name} takes two arguments, both string.

@item "@var{name}=iii"
Option @var{name} takes three integer arguments.

@item "@var{name}=sf"
Option @var{name} takes two arguments, the first is a string and the
second is a number.
@end table

In the command line, the option may appear with preceding
single or double minus signs.  The option's argument may be comibined
by the option itself with an equal sign.  For example, all the following
command line arguments match an option spec @code{"prefix=s"}.
@example
-prefix /home/shiro
-prefix=/home/shiro
--prefix /home/shiro
--prefix=/home/shiro
@end example

If a given command-line option matches one of @var{option-spec}, then
the associated action is evaluated.  An action can be one of the
following forms.

@table @code
@item @var{bind-spec} @var{body} @dots{}
@var{bind-spec} is a proper or dotted list of variables like lambda-list.
The option's arguments are bound to @var{bind-spec}, then
then @var{body} @dots{} is evaluated. 

@item => @var{proc}
If a command-line option matches @var{option-spec}, calls a procedure
@var{proc} with a list of the option's arguments.
@end table

Examples:
@example
(parse-options '("-file" "foo")
  (("file=s" (file)
     (format #t "file is ~s\n" file))))
 @result{} ;@r{``@code{file is "foo"}'' is printed}

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" (xscale yscale)
     (format #t "scale is ~sx~s\n" xscale yscale))))
 @result{} ;@r{``@code{scale is 1.5x2.2}'' is printed}

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" scales
     (format #t "scale is ~s\n" scales))))
 @result{} ;@r{``@code{scale is (1.5 2.2)}'' is printed}

(define (scales x y)
  (format #t "scale is ~sx~s\n" x y))

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" => scales)))
 @result{} ;@r{``@code{scale is 1.5x2.2}'' is printed}
@end example

If a symbol @code{else} is at the position of @var{option-spec},
the clause is selected when no other option clause matches a given
command-line option.  Three ``arguments'' are associated to
the clause; the unmatched option, the rest of arguments, and
a procedure that represents the option parser.

@example
(parse-options args
  (("file=s" => process-file)
   (else (option . _)  (error "unrecognized option:" option))))
@end example

Unlike other clause, the else clause returns to the caller of
@code{parse-options}, without looping further.  In order to
continue looping, you have to call the third argument of the else
clause with the remaining arguments.  This can be used
to implement your own sub-parser.  The following example
just skips unrecognized option, with printing a warning,
and continues parsing:

@example
(parse-options args
  (("file=s" => process-file)
   (else (option args continue)
     (format #t "warning: ignoring unrecognized option: ~a" option)
     (continue args))))
@end example

@end defmac

@defmac make-option-parser (option-clause @dots{})
This is a lower-level interface.  @var{option-clause}s are the
same as @code{parse-options}.  This macro returns a procedure
that can be used later to parse the command line options.

The returned procedure takes one required argument and one
optional argument.  The required argument is a list of strings,
for given command-line arguments.  The optional argument may
be a procedure that takes more than three arguments, and if given,
the procedure is used as if it is the body of @code{else} option clause.
@end defmac

@c ----------------------------------------------------------------------
@node gauche.process - High Level Process Interface, gauche.regexp - Regular expression utilities, gauche.parseopt - Parsing command-line options, Library modules - Gauche extensions
@section @code{gauche.process} - High Level Process Interface
@c NODE gauche.process - 高レベルプロセスインタフェース, @code{gauche.process} - 高レベルプロセスインタフェース

@deftp {Module} gauche.process
@mdindex gauche.process
@c EN
This module provides a higher-level API of Unix process control,
implemented on top of low-level system calls such as @code{sys-fork}
and @code{sys-exec}.  The interface is mostly compatible with
STk's process library.  This module also provides ``process ports'', 
a convenient way to send/receive information to/from subprocesses.

To use this module, say @code{(use gauche.process)}.
@c JP
このモジュールは、@code{sys-fork} や @code{sys-exec} などの低レベルな
システムコールの上に実装された、Unix プロセス制御の高レベル API を提供します。
インターフェースは、STk のプロセスライブラリとほとんどの点で互換性があります。
また、このモジュールは、サブプロセスに情報を送ったり、サブプロセスから
情報を受け取ったりするのに便利な「プロセスポート」を提供します。

このモジュールを使うためには、@code{(use gauche.process)} として下さい。
@c COMMON
@end deftp

@menu
* Process object::              
* Process ports::               
@end menu

@node Process object, Process ports, gauche.process - High Level Process Interface, gauche.process - High Level Process Interface
@subsection Process object

@deftp {Class} <process>
@clindex process
@c EN
An object to keep the status of a child process.  You can create
the process object by @code{run-process} procedure described below.
@c JP
子プロセスの状態を保持するためのオブジェクト。以下で説明される
@code{run-process} 手続きにより、プロセスを作ることができます。
@c COMMON
@end deftp

@defun run-process command arg @dots{}
@c EN
Run @var{command} with @var{arg} in a subprocess, and returns a
@code{<process>} object.   @var{command} is searched from the
command search path.

Command line arguments @var{arg}s can include the following keyword
arguments which specify special handling of the child process:
@c JP
サブプロセスで、@var{arg} を引数として @var{command} を実行し、
@code{<process>} オブジェクトを返します。@var{command} は、
コマンドサーチパスから探されます。

コマンドライン引数 @var{arg}s は、子プロセスを特別に扱うための
キーワード引数を含むことができます。
@c COMMON
@table @code
@item :input @var{file}
@itemx :output @var{file}
@itemx :error @var{file}
@c EN
These arguments controls the subprocess' standard i/o.
@var{file} may be either a string or a keyword @code{:pipe}.
If it is a string, the process' standard input, output, or error goes
to the named file.   If it is @code{:pipe}, the process'
corresponding standard i/o is connected to a pipe, 
and the other side of the pipe is available for the calling process.
@c JP
これらの引数は、サブプロセスの標準入出力を制御します。
@var{file} は文字列かキーワード @code{:pipe} です。
文字列の場合は、プロセスの標準入力、標準出力、標準エラーはそのファイルに
なります。@code{:pipe} の場合は、プロセスの対応する標準入出力はパイプに
結び付けられ、そのパイプのもう一方はプロセスの呼び出し側で利用できます。
@c COMMON

@item :wait @var{flag}
@c EN
If @var{flag} is true, @code{run-process} waits until the
subprocess terminates.  Othewise the subprocess runs asynchronously
and @code{run-process} returns immediately, which is the default behavior.
Note that if the subprocess is running asynchronously, it is the
caller's responsibility to call @code{process-wait} at certain
timing to collect its exit status.
@c JP
@var{flag} が真の場合、@code{run-process} はサブプロセスが終了するまで待ちます。
そうでなければ、サブプロセスは非同期に実行され、@code{run-process} は
すぐに返ります。これがデフォルトの振る舞いになります。
サブプロセスが非同期に実行している場合、その終了ステータスを回収するために
適切なタイミングで @code{process-wait} を呼ぶことは、呼び出し側の責任であることに
注意してください。
@c COMMON

@item :fork @var{flag}
@c EN
If @var{flag} is true, @code{run-process} forks to run
the subprocess, which is the default behavior.  If @var{flag} is
false, @code{run-process} directly calls @code{sys-exec}, so
it never returns.
@c JP
@var{flag} が真の場合、@code{run-process} はサブプロセスをじっこうするために
フォークします。これはデフォルトの振る舞いです。@var{flag} が偽の場合、
@code{run-process} は直接 @code{sys-exec} を呼ぶので、それは返りません。
@c COMMON
@end table

@end defun

@defun process? obj
@equiv{} @code{(is-a? @var{obj} <process>)}
@end defun

@deffn {Method} process-pid (process <process>)
@c EN
Returns the process ID of the subprocess @var{process}.
@c JP
サブプロセス @var{process} のプロセスIDを返します。
@c COMMON
@end deffn

@deffn {Method} process-command (process <process>)
@c EN
Returns the command invoked in the subprocess @var{process}.
@c JP
サブプロセス @var{process} 内で起動されたコマンドを返します。
@c COMMON
@end deffn

@deffn {Method} process-input (process <process>)
@deffnx {Method} process-output (process <process>)
@deffnx {Method} process-error (process <process>)
@c EN
If the process' standard input, output or error is connected to
a pipe, returns another end of the pipe, i.e. @code{process-input}
returns an output port that can feed data to @var{process}' stdin,
@code{process-output} returns an input port that can read data from
@var{process}' stdout, and @code{process-error} returns an input port that
can read data from @code{process}' stderr.
If the corresponding i/o is not connected to the pipe,
the function returns @code{#f}.
@c JP
プロセスの標準入力、標準出力、標準エラーがパイプに接続されている場合は、
パイプのもう一方の終端を返します。例えば、@code{process-input} は、
@var{process} の標準入力へデータを送ることができる出力ポートを返します。
@code{process-output} は @var{process} の標準出力からデータを読み込むことの
できる入力ポートを返します。そして、@code{process-error} は、@code{process}
の標準エラーからデータを読み込むことのできる入力ポートを返します。
対応する入出力がパイプに接続されていない場合、手続きは @code{#f} を返します。
@c COMMON

@example
(let* ((process (run-process "date" :output :pipe))
       (line (read-line (process-output process))))
  (process-wait process)
  line)
 @result{} "Fri Jun 22 22:22:22 HST 2001"
@end example
@end deffn

@defun process-alive? process
@c EN
Returns true if @var{process} is alive.  Note that Gauche can't
know the subprocess' status until it is explicitly checked by
@code{process-wait}.
@c JP
@var{process} が生きている場合は真を返します。@code{process-wait} によって
明示的にチェックされない限り、Gauche はサブプロセスのステータスを知ることが
できないことに注意してください。
@c COMMON
@end defun

@defun process-list
@c EN
Returns a list of active processes.  The process remains active
until its exit status is explicitly collected by @code{process-wait}.
@c JP
アクティブなプロセスのリストを返します。プロセスは、その終了ステータスが
@code{process-wait} によって明示的に回収されない場合は、アクティブなまま
残ります。
@c COMMON
@end defun

@defun process-wait process
@c EN
Obtains exit status of the subprocess @var{process}.
This suspends execution until @var{process} exits.
@c JP
サブプロセス @var{process} の終了ステータスを取得します。
これは、@var{process} が終了するまで実行を一時停止します。
@c COMMON
@end defun

@defun process-send-signal process signal
@c EN
Sends a signal @var{signal} to the subprocess @var{process}.
@var{signal} must be an exact integer for signal number.
@xref{Signal}, for predefined variables of signals.
@c JP
サブプロセス @var{process} にシグナル @var{signal} を送ります。
@var{signal} は正確整数のシグナルナンバーでなければなりません。
シグナルの定義済み変数については、@ref{Signal}を参照して下さい。
@c COMMON
@end defun

@defun process-kill process
@defunx process-stop process
@defunx process-continue process
@c EN
Sends SIGKILL, SIGSTOP and SIGCONT to @var{process}, respectively.
@c JP
それぞれ、@var{process} に、SIGKILL、SIGSTOP、SIGCONT を送ります。
@c COMMON
@end defun

@node Process ports,  , Process object, gauche.process - High Level Process Interface
@subsection Process ports

@defun open-input-process-port command
@c EN
Runs @var{command} via @code{/bin/sh} asynchronously.
An input port is returned, which is connected to the
stdout of @var{command}.   The stdin and stderr of @var{command}
is redirected from/to @code{/dev/null}.  If you need to get
an error output, you can use shell's redirection.
@c JP
@var{command} を @code{/bin/sh} 経由で非同期に実行します。
@var{command} の標準出力に接続された入力ポートが返されます。
@var{command} の標準入力と標準出力はそれぞれ @code{/dev/null} に
リダイレクトされます。エラー出力が必要な場合は、シェルのリダイレクションを
使うことができます。
@c COMMON
@example
(define port (open-input-process-port "ls -l Makefile"))
(read-line port)
 @result{} "-rw-r--r--   1 shiro    users        1013 Jun 22 21:09 Makefile"

(open-input-process-port "command 2>&1")
 @result{} ;@r{the port reads both stdout and stderr}

(open-input-process-port "command 2>&1 1>/dev/null")
 @result{} ;@r{the port reads stderr}
@end example
@c EN
Metacharacters are interpreted by shell.
You have to be careful if you pass the string provided from
the outside world, for it may make a security flaw.

The exit status of subprocess is not automatically collected.
It is the caller's responsibility to issue @code{process-wait},
or the subprocess remains in a zombie state.  If it bothers you,
you can use one of the following functions.
@c JP
メタキャラクタはシェルによって展開されます。外部から与えられた文字列を
渡す場合には、セキュリティ上の問題が起こるので気を付けて下さい。

サブプロセスの終了ステータスは自動的に回収されません。
@code{process-wait} を呼ぶことは呼び出し側の責任であり、これを怠ると
サブプロセスはゾンビプロセスになります。それが面倒であれば、以下の
手続きを使うことができます。
@c COMMON
@end defun

@defun call-with-input-process command proc
@c EN
Runs @var{command} via @code{/bin/sh} and pipes its stdout
to an input port, then call @var{proc} with the port as an argument.
When @var{proc} returns, it collects its exit status,
then returns the result @var{proc} returned.
The cleanup is done even if @var{proc} raises an error.
@c JP
@code{/bin/sh} 経由で @var{command} を実行し、その標準出力と入力ポートを
パイプで繋ぎ、そのポートを引数として @var{proc} を呼び出します。
@var{proc} が返るとその終了ステータスを回収し、@var{proc} が返した
結果を返します。@var{proc} がエラーを通知しても、クリーンアップは
行われます。
@c COMMON
@example
(call-with-input-process "ls -l *"
  (lambda (p) (read-line p)))
@end example
@end defun

@defun with-input-from-process command thunk
@c EN
Runs @var{command} via @code{/bin/sh}, and calls @var{thunk}
with its current input port connected to the command's stdout.
The command is terminated and its exit status is collected
when @var{thunk} returns, or it raises an error.
@c JP
@code{/bin/sh} 経由で @var{command} を実行し、コマンドの標準出力に
接続された現在の入力ポートとともに @var{think} を呼び出します。
コマンドが終了すると、@var{think} が返った時点で終了ステータスが
回収されますが、そうでない場合はエラーを通知します。
@c COMMON
@example
(with-input-from-process "ls -l *" read-line)
@end example
@end defun

@defun open-output-process-port command
@c EN
Runs @code{command} via @code{/bin/sh}, and returns an output
port which is connected to the stdin of the command.
The stdout and stderr of the command is redirected to @var{/dev/null}.

The exit status of the subprocess is not automatically collected.
The caller should call @code{process-wait} on the subprocess
at appropriate time.
@c JP
@code{/bin/sh} 経由で @code{command} を実行し、コマンドの標準入力に
接続された出力ポートを返します。
コマンドの標準出力と標準エラーは @var{/dev/null} へリダイレクトされます。

サブプロセスの終了ステータスは自動的には回収されません。
適切なタイミングで、サブプロセスに対して @code{process-wait} を呼ぶ
必要があります。
@c COMMON
@end defun

@defun call-with-output-process command proc
@c EN
Runs @code{command} via @code{/bin/sh}, and calls @var{proc} 
with an output port which is connected to the stdin of the command.
The exit status of the command is collected after @var{proc}
returns, or it raises an error.
@c JP
@code{/bin/sh} 経由で @code{command} を実行し、コマンドの標準入力に
接続された出力ポートとともに @var{proc} を呼び出します。
コマンドの終了ステータスは、@var{proc} が返ると回収されますが、
そうでない場合はエラーが通知されます。
@c COMMON
@example
(call-with-output-process "/usr/sbin/sendmail"
  (lambda (out) (display mail-body out)))
@end example
@end defun

@defun with-output-to-process command thunk
@c EN
Same as @code{call-with-output-process}, except that the
output port which is connected to the stdin of the command
is set to the current output port while executing @var{thunk}.
@c JP
コマンドの標準入力に接続された出力ポートが、@var{think} の実行中は
現在の出力ポートにセットされることを除いて、@code{call-with-output-process}
と同じです。
@c COMMON
@end defun

@defun call-with-process-io command proc
@c EN
Runs @var{command} via @code{/bin/sh}, and calls @var{proc}
with two arguments; the first argument is an input port which
is connected to the command's stdout, and the second is an output
port connected to the command's stdin.  The error output from
the command is redirected to @code{/dev/null}.

The exit status of the command is collected when @var{proc}
returns or raises an error.
@c JP
@code{/bin/sh} 経由で @var{command} を実行し、@var{proc} を2つの引数と
ともに呼び出します。最初の引数は入力ポートで、コマンドの標準出力に
接続されたものです。2番目の引数は出力ポートでコマンドの標準入力に
接続されたものです。コマンドからのエラー出力は、@code{/dev/null} へ
リダイレクトされます。
@c COMMON
@end defun

@defun process-output->string command
@defunx process-output->string-list command
@c EN
Runs @var{command} and collects its output (to stdout) to return them.
@code{process-output->string} concatenates all the output from @var{command}
to one string, replacing any sequence of whitespace characters to
single space.   The action is similar to ``command substitution''
in shell scripts.
@code{process-output->string-list} collects the output from
@var{command} line-by-line and returns the list of them.  Newline
characters are stripped.

Internally, @var{command} is run by @code{call-with-input-process}.
@c JP
@var{command} を実行し、その(標準出力への)出力を返すために回収します。
@code{process-output->string} は @var{command} からの全ての出力を連結し
1つの文字列とします。その際、空白文字からなるシーケンスは1つの空白に
置換されます。このアクションは、シェルスクリプトにおける「コマンド置換」
に似たものです。
@code{process-output->string-list} は @var{command} からの出力を行ごとに
回収し、それらをリストにしたものを返します。改行文字は削除されます。

内部的には、@var{command} は @code{call-with-input-process} により
実行されます。
@c COMMON
@example
(process-output->string "uname -smp")
  @result{} "Linux i686 unknown"

(process-output->string "ls")
  @result{} "a.out foo.c foo.c~ foo.o"

(process-output->string-list "ls")
  @result{} ("a.out" "foo.c" "foo.c~" "foo.o")
@end example

@end defun

@c ----------------------------------------------------------------------
@node gauche.regexp - Regular expression utilities, gauche.reload - Reloading modules, gauche.process - High Level Process Interface, Library modules - Gauche extensions
@section @code{gauche.regexp} - Regular expression utilities
@c NODE gauche.regexp - 正規表現ユーティリティ, @code{gauche.regexp} - 正規表現ユーティリティ

@deftp {Module} gauche.regexp
@mdindex gauche.regexp
@c EN
This module defines some macros and utilities useful in regexp match.
See @ref{Regular expression} for builtin regexp features.
As of release 0.4.11, this module is set to be autoloaded in @code{gosh},
so you don't usually need to say @code{(use gauche.regexp)}.

The interface of some of the macros is borrowed from scsh
(@code{if-match}, @code{let-match} and @code{match-cond}),
but I changed the name of
macros since scsh's @code{match-cond} can be confusing
(e.g. Bigloo has @code{match-lambda} and @code{match-case} in
pattern match library, that sounds too similar).
@c JP
このモジュールは正規表現のマッチに関連する便利なマクロとユーティリティ関数を
定義します。組み込みの正規表現機能については@ref{Regular expression}を
参照して下さい。また、リリース0.4.11以降、このモジュールは@code{gosh}を
使う場合はオートロードされるようになっているので、
@code{(use gauche.regexp)}とする必要はありません。

いくつかのマクロのインタフェースはscshの
@code{if-match}、@code{let-match}、@code{match-cond} 
を参考にしました。但し名前に関してはscshのものは正規表現以外の
マッチライブラリと混乱しやすいため (例：Biglooのパターンマッチライブラリ
には@code{match-case}があります)、正規表現であることを明示する
名前に変えてあります。
@c COMMON
@end deftp

@c EN
In the following macros, @var{match-expr} is an expression
which produces a match object or @code{#f}. Typically
it is a call of @code{rxmatch}, but it can be any expression.
@c JP
以下のマクロにおいて、@var{match-expr}はマッチオブジェクトか
@code{#f}を生成する式でなければなりません。通常それは
@code{rxmatch}を呼ぶ式になりますが、それだけに限られるわけではありません。
@c COMMON

@defmac rxmatch-let match-expr (var @dots{}) form @dots{}

@c EN
Evaluates @var{match-expr}, and if matched, binds @var{var @dots{}}
to the matched strings, then evaluates @var{form}s.
The first @var{var} receives the entire match, and subsequent
variables receive submatches.  If the number of submatches are
smaller than the number of variables to receive them, the rest
of variables will get @code{#f}.
@c JP
@var{match-expr}を評価し、それがマッチオブジェクトを返したら、
マッチした文字列を@var{var @dots{}}に束縛し、@var{form}を評価します。
最初の@var{var}はマッチした文字列全体に束縛され、
以降の変数はサブマッチ文字列に束縛されます。実際のサブマッチ文字列が
与えられた変数より少なかった場合は、余った変数は@code{#f}に束縛されます。
@c COMMON

@c EN
It is possible to put @code{#f} in variable position, which says
you don't care that match.
@c JP
特定のマッチ文字列を受け取る必要が無いときは、その場所の
変数の変わりに@code{#f}を置いておくこともできます。
@c COMMON

@example
(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (time hh mm ss)
  (list time hh mm ss))
 @result{} ("23:59:58" "23" "59" "58")

(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (#f hh mm)
  (list hh mm))
 @result{} ("23" "59")
@end example

@c EN
This macro corresponds to scsh's @code{let-match}.
@c JP
このマクロはscshの@code{let-match}に相当します。
@c COMMON
@end defmac

@defmac rxmatch-if match-expr (var @dots{}) then-form else-form
@c EN
Evaluates @var{match-expr}, and if matched, binds @var{var} @dots{}
to the matched strings and evaluate @var{then-form}.
Otherwise evaluates @var{else-form}.
The rule of binding @var{var}s is the same as @code{rxmatch-let}.
@c JP
@var{match-expr}を評価し、それがマッチオブジェクトを返したら
マッチした文字列を変数@var{var} @dots{}に束縛して@var{then-form}を
評価します。マッチオブジェクトが返されなければ束縛は行われず、
@var{else-form}が評価されます。変数@var{var}をマッチ文字列に
束縛するルールは@code{rxmatch-let}と同じです。
@c COMMON

@example
(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11:22:33")
    (time)
  (format #f "time is ~a" time)
  "unknown time")
 @result{} "time is 11:22"

(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11-22-33")
    (time)
  (format #f "time is ~a" time)
  "unknown time")
 @result{} "unknown time"
@end example

@c EN
This macro corresponds to scsh's @code{if-match}.
@c JP
このマクロはscshの@code{if-match}に相当します。
@c COMMON
@end defmac

@defmac rxmatch-cond clause @dots{}
@c EN
Evaluate condition in @var{clause}s one by one.
If a condition of a clause satisfies, rest portion of the clause
is evaluated and becomes the result of @code{rxmatch-cond}.
@var{Clause} may be one of the following pattern.
@c JP
@var{clause}の条件を順に評価してゆき、条件を満たすものが現れたら
その@var{clause}の残りのフォームを評価し、最後のフォームの値を
@code{rxmatch-cond}の値とします。@var{clause}は以下のいずれかの
形式でなければなりません。
@c COMMON

@table @code
@item (@var{match-expr} (@var{var} @dots{}) @var{form} @dots{})
@c EN
Evaluate @var{match-expr}, which may return a regexp match
object or @code{#f}.  If it returns a match object, the matches
are bound to @var{var}s, like @var{rxmatch-let}, and @var{form}s
are evaluated.
@c JP
@var{match-expr}を評価し、それがマッチオブジェクトを返した場合は
マッチ文字列を変数@var{var} @dots{}に束縛した上で
@var{form} @dots{}を評価します。
@c COMMON

@item (test @var{expr} @var{form} @dots{})
@c EN
Evaluates @var{expr}.  If it yields true, evaluates @var{form}s.
@c JP
@var{expr}を評価し、それが真の値を返した場合は@var{form} @dots{}を評価します。
@c COMMON

@item (test @var{expr} => @var{proc})
@c EN
Evaluates @var{expr} and if it is true,
calls @var{proc} with the result of @var{expr} as the only argument.
@c JP
@var{expr}を評価し、それが真の値を返した場合は
それを唯一の引数として手続き@var{proc}を呼びます。
@c COMMON

@item (else @var{form} @dots{})
@c EN
If this clause exists, it must be the last clause.
If other clauses fail, @var{form}s are evaluated.
@c JP
この@var{clause}は、もし与えられたとすれば最後の@var{clause}でなければ
なりません。全ての@var{clause}が失敗した場合に、@var{form} @dots{}が
評価されます。
@c COMMON
@end table

@c EN
If no @code{else} clause exists, and all the other clause fail,
an undefined value is returned.
@c JP
@code{else} @var{clause}が与えられず、かつ全ての@var{clause}が
失敗した場合の戻り値は未定義です。
@c COMMON

@example
@c EN
;; @r{parses several possible date format}
@c JP
;; @r{何通りかの日付のフォーマットをパーズする}
@c COMMON
(define (parse-date str)
  (rxmatch-cond
    ((rxmatch #/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ str)
        (#f mm dd yyyy)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ str)
        (#f yyyy mm dd)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^\d+\/\d+\/\d+$/ str)
        (#f)
     (error "ambiguous: ~s" str))
    (else (error "bogus: ~s" str))))

(parse-date "2001/2/3") @result{} (2001 2 3)
(parse-date "12/25/1999") @result{} (1999 12 25)
@end example

@c EN
This macro corresponds to scsh's @code{match-cond}.
@c JP
@c JP
このマクロはscshの@code{match-cond}に相当します。
@end defmac

@defmac rxmatch-case string-expr clause @dots{}
@c EN
@var{String-expr} is evaluated, and @var{clause}s are interpreted
one by one.  A @var{clause} may be one of the following pattern.
@c JP
@var{string-expr}がまず評価され、続いて@var{clause}が順に検査されます。
@var{clause}は以下のいずれかの形式でなければなりません。
@c COMMON

@table @code
@item (@var{re} (@var{var} @dots{}) @var{form} @dots{})
@c EN
@var{Re} must be a literal regexp object (@xref{Regular expression}).
If the result of @var{string-expr} matches @var{re},
the match result is bound to @var{var}s
and @var{form}s are evaluated, and @code{rxmatch-case} returns
the result of the last @var{form}.
@c JP
@var{re}はリテラル正規表現オブジェクトでなければなりません
(@ref{Regular expression}参照)。@var{string-expr}の結果が文字列であり
@var{re}にマッチした場合は、マッチ文字列が変数@var{var} @dots{}に
束縛され、@var{form}が評価されます。最後の@var{form}の値が@code{rxmatch-case}
の値となります。
@c COMMON

@c EN
If @var{re} doesn't match the result of @var{string-expr},
@var{string-expr} yields non-string value, the interpretation proceeds
to the next clause.
@c JP
@var{string-expr}の結果の文字列が@var{re}にマッチしないか、
@var{string-expr}の結果が文字列以外であった場合は次の@var{clause}へと
処理が進みます。
@c COMMON

@item (test @var{proc} @var{form} @dots{})
@c EN
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{form}s are evaluated, and
@code{rxmatch-case} returns the result of the last @var{form}.
@c JP
手続き@var{proc}が@var{string-expr}の結果を引数として呼ばれます。
それが真の値を返した場合は@var{form}が順に評価され、最後の@var{form}の
値が@code{rxmatch-case}の値として返されます。
@c COMMON

@c EN
If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.
@c JP
@var{proc}が@code{#f}を返した場合は次の@var{clause}へと
処理が進みます。
@c COMMON

@item (test @var{proc} => @var{proc2})
@c EN
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{proc2} is applied on the result,
and its result is returned as the result of @code{rxmatch-case}.
@c JP
手続き@var{proc}が@var{string-expr}の結果を引数として呼ばれます。
それが真の値を返した場合は、その値を引数として@var{proc2}が呼ばれ、
その返り値が@code{rxmatch-case}の値として返されます。
@c COMMON

@c EN
If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.
@c JP
@var{proc}が@code{#f}を返した場合は次の@var{clause}へと
処理が進みます。
@c COMMON

@item (else @var{form} @dots{})
@c EN
This form must appear at the end of @var{clause}s, if any.
If other clauses fail, @var{form}s are evaluated,
and the result of the last @var{form} becomes the result of
@code{rxmatch-case}.
@c JP
このフォームは、与えられる場合は最後の@var{clause}でなければなりません。
他の全ての@var{clause}が失敗した場合に、@var{form}が順に評価され、最後の@var{form}の
値が@code{rxmatch-case}の値として返されます。
@c COMMON
@end table

@c EN
If no @code{else} clause exists, and all other clause fail,
an undefined value is returned.
@c JP
@code{else} @var{clause}が与えられず、かつ全ての@var{clause}が
失敗した場合の戻り値は未定義です。
@c COMMON

@c EN
The @code{parse-date} example above becomes simpler if you use
@code{rxmatch-case}
@c JP
上の@code{parse-date}の例は@code{rxmatch-case}を使うとより単純になります。
@c COMMON
@example
(define (parse-date2 str)
  (rxmatch-case str
    (test (lambda (s) (not (string? s))) #f)
    (#/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ (#f mm dd yyyy)
     (map string->number (list yyyy mm dd)))
    (#/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ (#f yyyy mm dd)
     (map string->number (list yyyy mm dd)))
    (#/^\d+\/\d+\/\d+$/                (#f)
     (error "ambiguous: ~s" str))
    (else (error "bogus: ~s" str))))
@end example
@end defmac


@defun regexp-replace regexp string substitution
@defunx regexp-replace-all regexp string substitution
@c EN
Replaces the part of @var{string} that matched to @var{regexp}
for @var{substitution}.  @code{regexp-replace} just replaces
the first match of @var{regexp}, while @code{regexp-replace-all}
repeats the replacing throughout entire @var{string}.
@c JP
@var{string}中で@code{regexp}にマッチした部分を@var{substitution}で
置き換えます。@code{regexp-replace}は最初にマッチした部分のみを置き換え、
@code{regexp-replace-all}は全てのマッチを置き換えます。
@c COMMON

@c EN
@var{substitution} may be a string or a procedure.  If it is a string,
it can contain a digit sequence preceded by a backslash
(e.g. @code{\2}) that refers the submatch.  @code{\0} refers to the
entire match.  Note that you need two backslashes to include
backslash character in the literal string; if you want to include a backslash
character itself in the @var{substitution}, you need four backslashes.
@c JP
@var{substitution}は文字列か手続きです。
文字列の場合、バックスラッシュに続く数値を使ってサブマッチ文字列を参照できます。
@code{\0}はマッチ文字列全体を参照します。文字列リテラルにバックスラッシュを
埋め込む場合は二つのバックスラッシュが必要であることに注意して下さい。
バックスラッシュそのものを@var{substitution}中で使いたい場合は
二つのバックスラッシュを重ねます; 文字列リテラルの場合は4つのバックスラッシュが
必要になります。
@c COMMON

@example
(regexp-replace #/def|DEF/ "abcdefghi" "...")
  @result{} "abc...ghi"
(regexp-replace #/def|DEF/ "abcdefghi" "|\\0|")
  @result{} "abc|def|ghi"
(regexp-replace #/def|DEF/ "abcdefghi" "|\\\\0|")
  @result{} "abc|\\0|ghi"
(regexp-replace #/c(.*)g/ "abcdefghi" "|\\1|")
  @result{} "ab|def|hi"
@end example

@c EN
If @var{substitution} is a procedure, for every match in @var{string}
it is called with one argument, regexp-match object.  The returned
value from the procedure is inserted to the output string using
@code{display}.
@c JP
@var{substitution}が手続きである場合、@var{string}中の各マッチについて、
マッチオブジェクトを引数としてその手続きが呼ばれます。その手続きが返す
値を@code{display}で表現したものが置換文字列として使われます。
@c COMMON

@example
(regexp-replace #/c(.*)g/ "abcdefghi" 
                (lambda (m)
                  (list->string
                   (reverse
                    (string->list (rxmatch-substring m 1))))))
 @result{} "abfedhi"
@end example
@end defun

@defun regexp-quote string
@c EN
Returns a string with the characters that are special to regexp escaped.
@c JP
@var{string}中で、正規表現において特別な意味を持つ文字を全てエスケープした
文字列を返します。
@c COMMON
@example
(regexp-quote "[2002/10/12] touched foo.h and *.c")
 @result{} "\\[2002/10/12\\] touched foo\\.h and \\*\\.c"
@end example
@end defun

@c ----------------------------------------------------------------------
@node gauche.reload - Reloading modules, gauche.selector - Simple dispatcher, gauche.regexp - Regular expression utilities, Library modules - Gauche extensions
@section @code{gauche.reload} - Reloading modules

@deftp {Module} gauche.reload
@mdindex gauche.reload
In the development cycle, you often have to reload modules frequently.
This module supports it.

Note that some part of semantics of the program depends on
the order of loading modules, so reloading arbitrary modules
may change the program behavior unexpectedly.  This module
is for developers who knows what they are doing.

@strong{Redefinition rules}: Reloading a module resets all
the binding in the module by default.
Sometimes it is not desirable, however.  For example,
you might have  a large list of objects that takes time to rebuild.
You can specify rules for the reloading procedure to determine
which binding to keep.

The rule is described in the following syntax.
@example
  <module-rules> : (<module-rule> @dots{})
  <module-rule>  : (<module-pattern> <rule> @dots{})
  <module-pattern> : @r{a symbol module name, or a symbol containing glob pattern}
  <rule>         : @r{procedure} | @r{symbol} | @r{regexp}
                 | (and <rule> @dots{})
                 | (or  <rule> @dots{})
                 | (not <rule>)
@end example

@code{<module-rules>} is the global rule to determine per-module
rules.  @code{<module-pattern>} is either a symbol module name
or a symbol that contains glob pattern (e.g. @code{mylib.*}).
If @code{<rule>} is a procedure, it is used as a predicate
and the bindings whose value satisfies the predicate are kept from
redefinition.   If @code{<rule>} is a symbol, the binding of
the variable whose name is the symbol is kept.  If @code{<rule>}
is a regexp, the bindings of the variable whose name matches the
regexp are kept.

Note that the mechanism to prevent redefinition is kind of ad-hoc
hack and semantically unclean.  It's just for your convenience.
Take a look at the code if you want to know the exact behavior.
@end deftp

@defun reload module-name &optional rule @dots{}
Reloads the specified module.   You can optionally specify
redefinition rules by @var{rule} @dots{},
where each @var{rule} is the term @code{<rule>} defined above.
@end defun

@defun reload-modified-modules &optional module-rules
Reloads module(s) that have been modified since they are loaded
last time.  If optional @var{module-rules} is given, it is
used to determine the redefinition rules for reloaded modules.
If @var{module-rules} is omitted, the current rules are used.
The default of current rules is empty.   You can set the current
rules by @code{module-reload-rules}.
@end defun

@defun module-reload-rules &optional module-rules
This is a parameter (@xref{gauche.parameter - Parameters}) that keeps
the default module rules for @code{reload-modified-modules}.
If called without arguments, returns the current module rules.
If called with @var{module-rules}, sets the argument to the
current module rules.
@end defun

@defun reload-verbose &optional flag
This is a parameter to control verbosity of the reloading procedures.
If called without arguments, returns the current verbosity flag.
If called with @var{flag}, it is set to the current verbosity flag.
@end defun

@c ----------------------------------------------------------------------
@node gauche.selector - Simple dispatcher, gauche.sequence - Sequence framework, gauche.reload - Reloading modules, Library modules - Gauche extensions
@section @code{gauche.selector} - Simple dispatcher
@c NODE gauche.selector - 簡単なディスパッチャ, @code{gauche.selector} - 簡単なディスパッチャ

@deftp {Module} gauche.selector
@mdindex gauche.selector
This module provides a simple interface to dispatch I/O events to
registered handlers, based on @code{sys-select} (@xref{I/O multiplexing}).
@end deftp

@deftp {Class} <selector>
@clindex selector
A dispatcher instance that keeps watching I/O ports with associated
handlers.  A new instance can be created by @code{make} method.
@end deftp


@deffn {Method} selector-add! (self <selector>) port-or-fd proc flags
Add a handler @var{proc} to the selector.  @var{proc} is called
when @var{port-or-fd}, which should be a port object or an integer
that specifies a system file descriptor,  meets a certain condition
specified by @var{flags}.
@var{flags} must be a list of one or more of the following symbols.
@table @code
@item r
Calls @var{proc} when data is available at @var{port-or-fd} to read.
@item w
Calls @var{proc} when @var{port-or-fd} is ready to be written.
@item x
Calls @var{proc} when an exceptional condition occurs on @var{port-or-fd}.
@end table

@var{proc} is called with two arguments.  The first one is @var{port-or-fd}
itself, and the second one is a symbol @code{r}, @code{w} or @code{x},
indicating the condition.

If a handler is already associated with @var{port-or-fd} under the
same condition, the previous handler is replaced by @var{proc}.
@end deffn

@deffn {Method} selector-delete! (self <selector>) port-or-fd proc flags
Deletes the handler entries that matches @var{port-or-fd}, @var{proc}
and @var{flags}.   One or more of the arguments may be @code{#f},
meaning ``don't care''.  For example,
@example
(selector-delete! selector the-port #f #f)
@end example
deletes all the handlers associated to @var{the-port}, and
@example
(selector-delete! selector #f #f '(w))
@end example
delets all the handlers waiting for writable condition.
@end deffn


@deffn {Method} selector-select (self <selector>) &optional (timeout #f)
Dispatcher body.  Waits for the conditions registered in @var{self},
and when it occurs, calls the associated handler.

If the @var{timeout} argument is omitted or false, this method waits
indefinitely.  Alternatively you can give a timeout value, that can
be a real number in microseconds, or a list of two integers that
represents seconds and microseconds.

Returns the number of handlers called.  Zero means the selector has been
timed out.

It is safe to modify @var{self} inside handler.  The change will be
effective from the next call of @code{selector-select}
@end deffn

This is a simple example of "echo" server:

@example
(use gauche.net)
(use gauche.selector)

(define (echo-server port)
  (let ((selector (make <selector>))
        (server   (make-server-socket 'inet port :reuse-addr? #t)))

    (define (accept-handler sock flag)
      (let* ((client (socket-accept server))
             (output (socket-output-port client)))
        (selector-add! selector
                       (socket-input-port client :buffered? #f)
                       (lambda (input flag)
                         (echo client input output))
                       '(r))))

    (define (echo client input output)
      (let ((str (read-block 4096 input)))
        (if (eof-object? str)
            (begin (selector-delete! selector input #f #f)
                   (socket-close client))
            (begin (display str output)
                   (flush output)))))

    (selector-add! selector
                   (socket-fd server)
                   accept-handler
                   '(r))
    (do () (#f) (selector-select selector))))
@end example

@c ----------------------------------------------------------------------
@node gauche.sequence - Sequence framework, gauche.syslog - Syslog, gauche.selector - Simple dispatcher, Library modules - Gauche extensions
@section @code{gauche.sequence} - Sequence framework
@c NODE gauche.sequence - シーケンスフレームワーク, @code{gauche.sequence} - シーケンスフレームワーク

@deftp {Module} gauche.sequence
@mdindex gauche.sequence
@c EN
Provides a generic opertaions on @emph{sequences}.  A sequence is
a collection in which elements can be accessed by integer index,
starting with zero.
@c JP
@emph{シーケンス}に関するジェネリックな操作を提供するモジュールです。
シーケンスとは、コレクションのうち0から始まる整数インデックスで
アクセスできるものです。
@c COMMON

@c EN
This module inherits @code{gauche.collection} (@xref{gauche.collection - Collection framework}),
All the collection generic operations can be applied to a sequence as well.
@c JP
このモジュールは@code{gauche.collection}を継承しています
(@ref{gauche.collection - Collection framework}参照)。
コレクションに使えるジェネリックな操作は全てシーケンスに対しても適用可能です。
@c COMMON

@c EN
Among Gauche builtin class, lists, vectors and strings are sequences
and the specialized methods are defined for them.   Other extension
types, such as SRFI-4 uniform vector, have the methods as well.
@c JP
Gauche組み込みクラスのうち、リスト、ベクター、そして文字列は
シーケンスであり、このモジュールでメソッドが定義されます。
また@code{gauche.uvector}のユニフォームベクタ等、
いくつかの拡張データタイプはシーケンスとなっています。
@c COMMON
@end deftp

@menu
* Fundamental sequence accessors::  
* Slicing sequence::            
* Mapping over sequences::      
* Implementing sequence::       
@end menu

@node Fundamental sequence accessors, Slicing sequence, gauche.sequence - Sequence framework, gauche.sequence - Sequence framework
@subsection Fundamental sequence accessors
@c NODE 基本的なシーケンスのアクセサ

@deffn {Generic function} ref (seq <sequence>) index &optional fallback
@c EN
Returns @var{index}-th element of the sequence @var{seq}.
This method enables uniform access for any sequence types.

When @var{index} is less than zero, or greater than or equal to the
size of the sequence, @var{fallback} is returned if provided, or
an error is signalled if not.
@c JP
シーケンス@var{seq}の@var{index}番目の要素を返します。
このメソッドによって、全てのシーケンスが統一的にアクセスできます。

@var{index}が負値だったりシーケンスのサイズ以上だった場合は、
@var{fallback}が与えられていればそれが返され、
そうでなければエラーとなります。
@c COMMON

@example
(ref '(a b c) 1)  @result{} b
(ref '#(a b c) 1) @result{} b
(ref "abc" 1)     @result{} #\b
@end example
@end deffn

@deffn {Generic function} {(setter ref)} (seq <sequence>) index value
@c EN
Sets @var{value} to the @var{index}-th element of the sequence @var{seq}.
This is the uniform sequence modifier.
@c JP
統一的なシーケンスの変更メソッドです。
シーケンス@var{seq}の@var{index}番目の要素に@var{value}をセットします。
@c COMMON

@example
(let ((x (list 'a 'b 'c)))
  (set! (ref x 1) 'z)
  x) @result{} (a z c)

(let ((x (vector 'a 'b 'c)))
  (set! (ref x 1) 'z)
  x) @result{} #(a z c)

(let ((x (string #\a #\b #\c)))
  (set! (ref x 1) #\z)
  x) @result{} "azc"
@end example
@end deffn

@deffn {Generic function} referencer (seq <sequence>)
@end deffn

@deffn {Generic function} modifier (seq <sequence>)
@end deffn

@node Slicing sequence, Mapping over sequences, Fundamental sequence accessors, gauche.sequence - Sequence framework
@subsection Slicing sequence
@c NODE シーケンスのスライス

@deffn {Generic function} subseq (seq <sequence>) &optional start end
@c EN
Retrieve a subsequence of the sequence @var{seq}, from
@var{start}-th element (inclusive) to @var{end}-th element (exclusive).
If @var{end} is omitted, up to the end of sequence is taken.
The type of the returned sequence is the same as @var{seq}.
@c JP
シーケンス@var{seq}の、@var{start}番目の要素から@var{end}番目の要素の直前
までの部分シーケンスを返します。@var{end}が省略された場合はシーケンスの
最後までが取られます。返されるシーケンスの型は@var{seq}と同じになります。
@c COMMON

@example
(subseq '(a b c d e) 1 4)   @result{} (b c d)
(subseq '#(a b c d e) 1 4)  @result{} #(b c d)
(subseq "abcde" 1 4)        @result{} "bcd"

(subseq '(a b c d e) 3)     @result{} (d e)
@end example
@end deffn

@deffn {Generic function} {(setter subseq)} (seq <sequence>) start end value-seq
@deffnx {Generic function} {(setter subseq)} (seq <sequence>) start value-seq
@c EN
Sets the elements of @var{value-seq} from the @var{start}-th element
(inclusive) to the @var{end}-th element (exclusive) of the sequence @var{seq}.
@var{Value-seq} can be any sequence, but its size
must be larger than (@var{end} - @var{start}).

In the second form, @var{end} is figured out by the length of @var{value-seq}.
@c JP
@var{value-seq}の各要素を、シーケンス@var{seq}の@var{start}番目から
@var{end}番目の直前まで順にセットします。
@var{value-seq}はどんなシーケンスでも構いませんが、
(@var{end} - @var{start}) よりは長くなくてはなりません。

2番目の形式では、@var{end}が@var{value-seq}の長さから算出されます。
@c COMMON

@example
(define s '#(a b c d e))
(set! (subseq s 1 4) '(4 5 6))
s @result{} #(a 4 5 6 e)
(set! (subseq s 0)   "ab")
s @result{} #(#\a #\b 5 6 e)
@end example
@end deffn

@node Mapping over sequences, Implementing sequence, Slicing sequence, gauche.sequence - Sequence framework
@subsection Mapping over sequences
@c NODE シーケンス上のマップ

You can use extended @code{fold}, @code{map}, @code{for-each} and other
generic functions on sequences, since a sequence is also a collection.
However, sometimes you want to have index as well as the element itself
during iteration.   There are several generic functions for it.

@deffn {Generic function} fold-with-index kons knil (seq <sequence>) @dots{}
Like generic @code{fold}, except @var{kons} is given
the index within @var{seq}, as the first argument,
as well as each element from @var{seq}s and the accrued value.

@example
(fold-with-index acons '() '(a b c))
  @result{} ((2 . c) (1 . b) (0 . a))
@end example
@end deffn

@deffn {Generic function} map-with-index proc (seq <sequence>) @dots{}
@deffnx {Generic function} map-to-with-index class proc (seq <sequence>) @dots{}
@deffnx {Generic function} for-each-with-index proc (seq <sequence>) @dots{}
Like @code{map}, @code{map-to} and @code{for-each}, except @var{proc}
receives the index as the first argument.

@example
(map-with-index list '(a b c d) '(e f g h))
  @result{} ((0 a e) (1 b f) (2 c g) (3 d h))

(map-to-with-index <vector> cons '(a b c d))
  @result{} #((0 . a) (1 . b) (2 . c) (3 . d))
@end example
@end deffn

@deffn {Generic function} find-with-index pred (seq <sequence>)
Finds the first element in @var{seq} that satisfies @var{pred}
like @code{find}, but returns two values, the index of the element
and the element itself.   If no element satisfies @var{pred},
two @code{#f}'s are returned.

@example
(find-with-index char-upper-case? "abraCadabra")
  @result{} 4 and #\C

(find-with-index char-numeric? "abraCadabra")
  @result{} #f and #f
@end example
@end deffn

@deffn {Generic function} find-index pred (seq <sequence>)
Like @code{find}, but returns the index of the first element
that satisfies @var{pred} in @var{seq}, instead of the element itself.
If no element in @var{seq} satisfies @var{pred}, @code{#f} is returned.

@example
(find-index char-upper-case? "abraCadabra")
  @result{} 4 

(find-index char-numeric? "abraCadabra")
  @result{} #f
@end example
@end deffn

@node Implementing sequence,  , Mapping over sequences, gauche.sequence - Sequence framework
@subsection Implementing sequence



@c ----------------------------------------------------------------------
@c @node Serializer, Termios, Simple dispatcher, Library modules
@c @section @code{gauche.serializer} - Serializer

@c @deftp {Module} gauche.serializer
@c @mdindex gauche.serializer
@c @end deftp

@c ----------------------------------------------------------------------
@node gauche.syslog - Syslog, gauche.termios - Termios, gauche.sequence - Sequence framework, Library modules - Gauche extensions
@section @code{gauche.syslog} - Syslog
@c NODE gauche.syslog - Syslog, @code{gauche.syslog} - Syslog

@deftp {Module} gauche.syslog
@mdindex gauche.syslog
This module provides syslog(3) system logger interface.

For the common applications, you might find @code{gauche.logger} module
easier to use (@xref{gauche.logger - User-level logging}).  This module is for those
who need direct access to the syslog API.

The procedures are only defined if the undelying system supports them.
@end deftp

@defun sys-openlog ident option facility
[POSIX]
Opens a connection to the system logger.  A string argument
@var{ident} is used for the prefix of the log, and usually is
the program name.  @var{Option} is an integer flag to control
the behavior of logging, and @var{facility} is an integer
that specify the type of the program.

The flag for @var{option} can be composed by @code{logior}-ing
one or more of the following integer constants:
@code{LOG_CONS}, @code{LOG_NDELAY}, @code{LOG_NOWAIT},
@code{LOG_ODELAY}, @code{LOG_PERROR} and @code{LOG_PID}.
(Some of the constants may not be defined if the underlying system
doesn't support them).

The @var{facility} argument can be one of the following integer
constants: @code{LOG_AUTH}, @code{LOG_AUTHPRIV}, @code{LOG_CRON},
@code{LOG_DAEMON}, @code{LOG_FTP}, @code{LOG_KERN}, @code{LOG_LOCAL0}
through @code{LOG_LOCAL7}, @code{LOG_LPR}, @code{LOG_MAIL}, @code{LOG_NEWS},
@code{LOG_SYSLOG}, @code{LOG_USER} and @code{LOG_UUCP}.
(Some of the constants may not be defined if the underlying system
doesn't support them).

See your system's manpage of openlog(3) for detail description about
these constants.
@end defun

@defun sys-syslog priority message
[POSIX]
Log the string @var{message}.  Unlike syslog(3), this procedure doesn't
do formatting---you can use @code{format} (@xref{Output}) to create
a formatted message, or use higher-level routine @code{log-format}
(@xref{gauche.logger - User-level logging}).

An integer argument @var{priority} can be composed by @code{logior}-ing
one of the @var{facility} constants described above and
the @var{level} constants: @code{LOG_EMERG}, @code{LOG_ALERT},
@code{LOG_CRIT}, @code{LOG_ERR}, @code{LOG_WARNING}, @code{LOG_NOTICE},
@code{LOG_INFO}, @code{LOG_DEBUG}.
@end defun

@defun sys-closelog
[POSIX]
Closes the connection to the logging system.
@end defun

@defun sys-setlogmask mask
[POSIX]
Sets the process's log priority mask that determines which calls to
@code{sys-syslog} may be logged.
An priority @var{mask} can be composed by @code{logior}-ing
bitmasks corresponding to the @var{level} argument of @code{sys-syslog}.
You can use @code{sys-logmask} below to obtain a bitmask
from the level.
@end defun

@defun sys-logmask level
[POSIX]
Returns an integer bitmask for @code{sys-setlogmask} from 
the log level @var{level}.
@end defun

@c ----------------------------------------------------------------------
@node gauche.termios - Termios, gauche.test - Unit testing, gauche.syslog - Syslog, Library modules - Gauche extensions
@section @code{gauche.termios} - Termios

@deftp {Module} gauche.termios
@mdindex gauche.termios
This module defines POSIX termios interface, which
controls terminal attributes.  This module also provides
pseudo tty interface, if the system provides it.
@end deftp

@deftp {Builtin Class} <sys-termios>
@clindex sys-termios
POSIX termios(7) structure.

@defivar {<sys-termios>}  iflag
@end defivar
@defivar {<sys-termios>}  oflag
@end defivar
@defivar {<sys-termios>}  cflag
@end defivar
@defivar {<sys-termios>}  lflag
@end defivar

@end deftp

Throughout this section, argument @var{port-or-fd} refers to
either a port object or a small integer representing system's file 
descriptor.  If @var{port} is not associated
to the system terminal, an error is signalled.  (You can check if @var{port}
has an associated terminal by @code{sys-isatty?}.
@xref{Other file operations}).

@defun sys-tcgetattr port-or-fd
Returns terminal parameters in a @code{<sys-termios>} object,
associated to @var{port-or-fd}.
@end defun

@defun sys-tcsetattr port-or-fd when termios
Sets terminal parameters associated to @var{port-or-fd} by @var{termios},
which must be an instance of @code{<sys-termios>}.

An integer argument @var{when} specifies when the changes take effect.
Three variables are pre-defined for the argument:
@table @code
@item TCSANOW
@vindex TCSANOW 
The change is reflected immediately.
@item TCSADRAIN
@vindex TCSADRAIN
The change is reflected after all pending output is flushed.
@item TCSAFLUSH
@vindex TCSAFLUSH
The change is reflected after all pending output is flushed,
and all pending input is discarded.
@end table
@end defun

@defun sys-tcsendbreak port-or-fd duration
Transmits a zero stream for the specified duration
to the terminal associated to @var{port-or-fd}.
The unit of duration depends on the system; see man tcsendbreak(3) of
your system for details.
@end defun

@defun sys-tcdrain port-or-fd
Waits until all output written to @var{port-or-fd} is transmitted.
@end defun

@defun sys-tcflush port-or-fd queue
Discards data in the buffer of @var{port-or-fd}, specified by 
@var{queue}, which may be one of the following values.
@table @code
@item TCIFLUSH
@vindex TCIFLUSH
Discards data received but not read.
@item TCOFLUSH
@vindex TCOFLUSH
Discards data written but not transmitted.
@item TCIOFLUSH
@vindex TCIOFLUSH
Do both @code{TCIFLUSH} and @code{TCOFLUSH} action.
@end table
@end defun

@defun sys-tcflow port-or-fd action
Controls data flow of @var{port-or-fd} by @var{action}, which may be
one of the following values:
@table @code
@item TCOOFF
@vindex TCOOFF
Suspends output transmission.
@item TCOON
@vindex TCOON
Restarts output transmission.
@item TCIOFF
@vindex TCIOFF
Transmits a STOP character to make the terminal device stop transmitting
data to the system.
@item TCION
@vindex TCION
Transmits a START character to make the terminal device resume transmitting
data to the system.
@end table
@end defun

@defun sys-tcgetpgrp port-or-fd
Returns process group ID of the terminal associated to @var{port-or-fd}.
@end defun

@defun sys-tcsetpgrp port-or-fd pgrp
Sets process group ID of the terminal associated to @var{port-or-fd}
to @var{pgrp}.
@end defun

@defun sys-cfgetispeed termios
@defunx sys-cfsetispeed termios speed
@defunx sys-cfgetospeed termios
@defunx sys-cfsetospeed termios speed
Gets/sets input/output speed (baud rate) parameter stored in @var{termios}
object.   Speed is represented by the following predefined numbers:
@code{B0}, @code{B50}, @code{B75}, @code{B110}, @code{B134}, 
@code{B150}, @code{B200}, @code{B300}, @code{B600}, @code{B1200}, 
@code{B1800}, @code{B2400}, @code{B4800}, @code{B9600},
@code{B19200}, @code{B38400}.
Some system may support higher baud rate, such as @code{B57600},
@code{B115200} or @code{B230400}.  You can use @code{symbol-bound?}
to check these options are defined.  @code{B0} is used to
terminate the connection.
@end defun

@defun sys-openpty &optional term
Openes a pair of pseudo ttys, one for master and the other for slave,
then returns two integers which are their file descriptors.
An optional argument @var{term} must be, if passed, a @code{<sys-termios>}
object; it sets the slave pty's parameters.

You can use @code{open-input-fd-port} and/or @code{open-output-fd-port}
to create a port around the returned file descriptor (@xref{File ports}).
To obtain pseudo tty's name, use @code{sys-ttyname}
(@xref{Other file operations}).

This function is available only if the system supports @code{openpty(3)}.
@end defun

@defun sys-forkpty &optional term
Openes a pair of pseudo ttys, one for master and the other for slave,
sets the slave pty suitable for login terminal, then fork(2).

Returns two integers; the first value is a child pid for the parent process,
and 0 for the child process.  The second value is a file descriptor
of the master pty.

An optional argument @var{term} must be, if passed, a @code{<sys-termios>}
object; it sets the slave pty's parameters.

This function is available only if the system supports @code{forkpty(3)}.
@end defun


The following example shows how to get a password from the user
without echoing:

@example
(use gauche.termios)

(define (get-password prompt)
  (let* ((port (current-input-port))
         (attr (sys-tcgetattr port))
         (lflag (slot-ref attr 'lflag)))
    ;; Show prompt
    (display prompt)
    (flush)
    ;; Turn off echo during reading.
    (dynamic-wind
     (lambda ()
       (slot-set! attr 'lflag (logand lflag (lognot ECHO)))
       (sys-tcsetattr port TCSAFLUSH attr))
     (lambda ()
       (read-line port))
     (lambda ()
       (slot-set! attr 'lflag lflag)
       (sys-tcsetattr port TCSANOW attr)))))
@end example

@c ----------------------------------------------------------------------
@node gauche.test - Unit testing, gauche.threads - Threads, gauche.termios - Termios, Library modules - Gauche extensions
@section @code{gauche.test} - Unit Testing
@c NODE gauche.test - 単体テスト, @code{gauche.test} - 単体テスト

@deftp {Module} gauche.test
@mdindex gauche.test
@c EN
Defines a set of functions to write test scripts.
A test script will look like this:
@lisp
(use gauche.test)
(test-start "my feature")
(load "my-feature")  ; @r{load your program}
(import my-feature)  ; @r{if your program defines a module.}

(test-module 'my-feature) ; @r{tests consistency in your module.}

(test-section "feature group 1")
(test "feature 1-1" EXPECT (lambda () TEST-BODY))
(test "feature 1-2" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-section "feature group 2")
(define test-data ...)
(test "feature 2-1" EXPECT (lambda () TEST-BODY))
(test "feature 2-2" *test-error* (lambda () TEST-THAT-SIGNALS-ERROR))
 @dots{}

(test-end)
@end lisp
@c JP
テストスクリプトを書くための手続きを提供します。
テストスクリプトは次のような形になります。
@lisp
(use gauche.test)
(test-start "my feature")
(load "my-feature")  ; @r{テストすべきプログラムをロード}
(import my-feature)  ; @r{モジュールを定義している場合はインポート}

(test-module 'my-feature) ; @r{モジュールの一貫性チェック}

(test-section "feature group 1")
(test "feature 1-1" EXPECT (lambda () TEST-BODY))
(test "feature 1-2" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-section "feature group 2")
(define test-data ...)
(test "feature 2-1" EXPECT (lambda () TEST-BODY))
(test "feature 2-2" *test-error* (lambda () TEST-THAT-SIGNALS-ERROR))
 @dots{}

(test-end)
@end lisp
@c COMMON

@c EN
With this convention, you can run test both interactively or
in batch.   To run a test interactively, just load the file
and it reports a result of each test, as well as the summary
of failed test at the end.  To run a test in batch, it is
convenient to redirect the stdout to some file
If stdout is redirected to other than tty, all the verbose logs will go
there, and only a small amount of messages go to stderr.
@c JP
このテストスクリプトは、バッチ処理でもインタラクティブセッションからでも
実行できます。インタラクティブセッションの場合はこのテストスクリプトを
ただロードすれば、各テストの結果とサマリーが報告されます。
バッチテストの場合は、標準出力を別のファイルにリダイレクトしておくと良いでしょう。
標準出力が端末でない場合、テスト手続きは詳しい結果をstdoutに出力し、簡単な
メッセージを標準エラー出力に書き出します。
@c COMMON

@c EN
It is recommended to have a "test" target always in Makefile
of your module/program, so that the user of your program can run a
test easily.  The rule may look like this:
@c JP
モジュールやプログラムを書いたら、Makefileに"test"ターゲットを作ることを
お薦めします。ルールはこんな感じになるでしょう：
@c COMMON

@example
test :
        gosh my-feature-test.scm > test.log
@end example

@end deftp

@defun test name expected thunk &optional compare
@c EN
Calls @var{thunk}, and compares its result with @var{expected}.
The comparison predicate is @code{equal?} by default, but you can
specify your own predicate by the argument @var{compare}.
@var{Name} is a name of the test, for logging purpose.

If @var{thunk} signals an uncaptured error, it is catched and
yields a special error object.  A global variable @code{*test-error*}
is bound to the error object, so that you can test an expected error.
@c JP
@var{thunk}を呼び、その結果を@var{expected}と比較します。
比較手続きには、引数@var{compare}が与えられていればそれを用い、
そうでなければ@code{equal?}
を用います。@var{name}はログに残すためのテストの名前です。

@var{thunk}内で捕捉されないエラーが発生した場合、それは捕捉され、
特別なエラーオブジェクトに置き換えられます。グローバル変数@code{*test-error*}
がエラーオブジェクトに束縛されており、エラーが期待される状況もテストすることが
できます。
@c COMMON
@end defun

@defvar *test-error*
@c EN
Bound to a special error object, which can be used as an expected
value if the test thunk is supposed to signal an error.
@c JP
特別なエラーオブジェクトに束縛されています。
テストのthunkがエラーを起こすことが期待されている状況で、
エラーオブジェクトを@var{expected}引数に渡すことができます。
@c COMMON

@example
(test "test if car signals an error" *test-error*
      (lambda () (car 5)))
@end example
@end defvar

@defmac test* name expected expr &optional compare
@c EN
A convenience macro that wraps @var{expr} by lambda.
@c JP
@var{expr}をlambdaでくるんでくれる便利なマクロです。
@c COMMON

@example
(test* name expected expr)
  @equiv{} (test name expected (lambda () expr))
@end example
@end defmac

@defun test-module module
@c EN
@var{Module} must be a symbol module name or a module.
This procedure performs some heuristic consistency check of
the given module: (1) whether symbols set as autoload
in @var{module} can actually be loaded, and (2) whether
the symbols declared in export list is actually defined
in the module.   Although not perfect, this test can catch
some careless typo in symbol names.
@c JP
@var{Module}はモジュール名のシンボルかモジュールでなければなりません。
この手続きはモジュール@var{module}に関していくつかの経験的な一貫性チェックを
行います：(1) autoloadに設定されたシンボルがちゃんとロードできるか、
(2) exportにリストされたシンボルがモジュール内で定義されているか。
この手続きは完璧ではないものの、
ケアレスミスによる名前の綴り間違いを発見することができます。
@c COMMON
@end defun

@defun test-start module-name
@c EN
Initializes internal state and prints a log header.
This should be called before any tests.
@var{Module-name} is used only for logging purpose.
@c JP
テストの状態を初期化して、ヘッダをログに書き出します。テストを呼ぶ前に呼んで下さい。
@var{module-name}はログのために使われる文字列です。
@c COMMON
@end defun

@defun test-section section-name
@c EN
Marks beginning of the group of tests.  This is just for logging.
@c JP
一群のテストの開始をマークします。単にログに使われるだけです。
@c COMMON
@end defun

@defun test-end
@c EN
Prints out list of failed tests.
@c JP
失敗したテストのリストを報告します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node gauche.threads - Threads, gauche.time - Measure timings, gauche.test - Unit testing, Library modules - Gauche extensions
@section @code{gauche.threads} - Threads
@c NODE gauche.threads - スレッド, @code{gauche.threads} - スレッド

If enabled at compilation time, Gauche can use threads
built on top of POSIX threads (pthreads). 

@deftp {Module} gauche.threads
@mdindex gauche.threads
Provides thread API.   You can 'use' this module regardless
whether the thread support is compiled in or not; if threads are not
supported, many thread-related procedures simply signals a 
"not supported" error.
@end deftp

To check if threads are available in the running Gauche program,
use the following procedure.

@defun gauche-thread-type
Returns a symbol that indicates the supported thread type.
In the current version, the return value may be @code{pthread}
when threads on top of POSIX threads are available, or
@code{none} when threads are not available.
@end defun

Scheme-level thread API conforms SRFI-18, "Multithreading support"
(@ref{srfi-18,,[SRFI-18]}), wrapped around Gauche's object interface.

@menu
* Thread programming tips::     
* Thread procedures::           
* Synchronization primitives::  
* Thread exceptions::           
@end menu

@node Thread programming tips, Thread procedures, gauche.threads - Threads, gauche.threads - Threads
@subsection Thread programming tips

Although the surface API of threads looks simple and portable,
you need know how the threads are implemented in order to utilize
the feature's potential.   Some languages support threads as
language's built-in construct and encourage programmers
to express the calculation in terms of threads.
However, it should be noted that in many cases there are
alternative ways than threads to implement the desired
algorithm, and you need to compare advantages and
disadvantages of using threads depending on how the threads
are realized in the underlying system.

In Gauche, the primary purpose of threads is to write programs
that @emph{require} preemptive scheduling, therefore are
difficult to express in other ways.  Preemptive threads may
be required, for example, when you have to call a module that 
does blocking I/O which you can't intercept, or may spend
nondeterministic amount of calculation time that you want
to interrupt.

For each Gauche's thread, an individual VM is allocated
and it is run by the dedicated POSIX thread.  Thus there
is not much overhead in context switch than the native
thread, but the creation of threads costs much higher than,
say, lightweight threads built on top of call/cc.
So Gauche's preemptive threads are @emph{not} designed for
applications that want to create thousands of threads
for fine-grained calculation. 

The recommended usage is the technique so called "thread pool",
that you create a set of threads and keep them around for
long time and dispatch jobs to them as needed.

Preemptive threads have other difficulties
(e.g. see @ref{fairthreads,[FairThreads],FairThreads}),
and sometimes the alternatives may be a better fit
than the native preemptive threads.

@itemize @bullet
@item
If what you need is just a concurrent calculation, you
might be able to use cooperative thread technique built
on top of @code{call/cc}.   Creating call/cc-based threads
is much faster than creating native threads. 

@item
If what you need is to deal with blocking I/O, and you have
all your code at hand, it is sometimes easier to use good old
@code{select}-based dispatching (@xref{gauche.selector - Simple dispatcher},
for example).

@item
If what you need is to control the resouce consumption in the
subsystem, and the subsystem works fairly independently from
the main system, you may be able to use Unix processes instead of threads.
It may sound to go backward, but Unix process does provide
higher "shield" between the subsystem and the main system
(e.g. the main system can keep running even if subsystem segfaults).

@end itemize

Of course, these technique are not mutually exclusive with
native threads.  You can use dispatcher with "thread pool" technique,
for example.   Just keep it in your mind that the native threads
are not only but one of the ways to realize those features.


@node Thread procedures, Synchronization primitives, Thread programming tips, gauche.threads - Threads
@subsection Thread procedures

@deftp {Builtin Class} <thread>
@clindex thread
A thread.  Each thread has an associated thunk which is evaluated by
a POSIX thread.  When thunk returns normally, the result is stored
in the internal 'result' slot, and can be retrieved by @code{thread-join!}.
When thunk terminates abnormally, either by raising an exception or
terminated by @code{thread-terminate!}, the exception condition is
stored in ther internal 'result exception' slot, and will be passed
to the thread calling @code{thread-join!} on the terminated thread.

Each thread has its own dynamic environment and dynamic handler stack.
When a thread is created, its dynamic environment is initialized by
the creator's dynamic environment.  The thread's dynamic handler
stack is initially empty.

Access to the resouces shared by multiple threads must be protected
explicitly by synchronization primitives.
@xref{Synchronization primitives}.

Access to ports are serialized by Gauche. If multiple threads attempt
to write to a port, their output may be interleaved but no output
will be lost, and the state of the port is kept consistent.
If multiple threads attempt to read from a port, a single read
primitive (e.g. @code{read}, @code{read-char} or @code{read-line})
works atomically.

Signal handlers are shared by all threads, but each thread has
its own signal mask.  @xref{Signals and threads}, for details.

A thread object has the following external slots.

@defivar <thread> name
A name can be associated to a thread.
This is just for the convenience of the application.
The primordial thread has the name "@code{root}".
@end defivar

@defivar <thread> specific
A thread-local slot for use of the application.
@end defivar
@end deftp

@defun current-thread
[SRFI-18], [SRFI-21]
Returns the current thread.
@end defun

@defun thread? obj
[SRFI-18], [SRFI-21]
Returns @code{#t} if @var{obj} is a thread, @code{#f} otherwise.
@end defun

@defun make-thread thunk &optional name
[SRFI-18], [SRFI-21]
Creates and returns a new thread.  To run the thread, you need to
call @code{thread-start!}.

You can provide the name of the thread by the optional argument @var{name}.

Internally, this procedure just allocates and initializes a Scheme
thread object; the POSIX thread is not created until @code{thread-start!}
is called.
@end defun

@defun thread-name thread
[SRFI-18], [SRFI-21]
Returns the value of @var{name} slot of @var{thread}.
@end defun

@defun thread-specific thread
@defunx thread-specific-set! thread value
[SRFI-18], [SRFI-21]
Gets/sets the value of the @var{thread}'s specific slot.
@end defun

@defun thread-start! thread
[SRFI-18], [SRFI-21]
Starts the @var{thread}.  It is an error if @var{thread} is already started.
Returns @var{thread}.
@end defun

@defun thread-yield!
[SRFI-18], [SRFI-21]
Suspends the execution of the calling thread and yields CPU to other
waiting runnable threads, if any.
@end defun

@defun thread-sleep! timeout
[SRFI-18], [SRFI-21]
Suspends the calling thread for the period specified by @var{timeout},
which must be either a @code{<time>} object (@xref{SRFI time}) that
specifies absolute point of time, or a real number that specifies
relative point of time from the time this procedure is called
in number of seconds.

After the specified time passes, @code{thread-sleep!} returns with
unspecified value.

If @var{timeout} points a past time, @code{thread-sleep!} returns
immediately.
@end defun

@defun thread-terminate! thread
[SRFI-18], [SRFI-21]
Terminates the specified thread @var{thread}.
The @var{thread} is terminated and an instance of 
@code{<terminated-thread-exception>} is stored in the result exception
field of @var{thread}.

If @var{thread} is the same as the calling thread, this procedure
won't return.  Otherwise, this procedure returns unspecified value.

This procedure should be used with care, since
@var{thread} won't have a chance to call cleanup
procedures (such as 'after' thunks of @code{dynamic-wind})
If @var{thread} is in the critical section, it leaves some state
inconsistent.  However, once a thread is terminated, any mutex
that the thread has kept becomes 'abandoned' state, and an attempt
to lock such a mutex by other thread raises an 'abandoned mutex exception',
so that you will know the situation.  @xref{Synchronization primitives}.
@end defun


@defun thread-join! thread &optional timeout timeout-val
[SRFI-18], [SRFI-21]
Waits termination of @var{thread}, or until the timeout is reached
if @var{timeout} is given.

@var{Timeout} must be either a @code{<time>} object (@xref{SRFI time})
that specifies absolute point of time, or a real number that specifies
relative point of time from the time this procedure is called
in number of seconds, or @code{#f} that indicates no timeout (default).

If @var{thread} terminates normally, @code{thread-join!} returns
a value which is stored in the result field of @var{thread}.
If @var{thread} terminates abnormally, @code{thread-join!} raises
an exception which is stored in the result exception field of @var{thread}.

If the timeout is reached, @var{thread-join!} returns @var{timeout-val}
if given, or raises @code{<join-timeout-exception>}.
@end defun

@node Synchronization primitives, Thread exceptions, Thread procedures, gauche.threads - Threads
@subsection Synchronization primitives

@deftp {Builtin Class} <mutex>
@clindex mutex
A primitive synchronization device.  It can take one of four states:
locked/owned, locked/not-owned, unlocked/abandoned and unlocked/not-abandoned.
A mutex can be locked (by @code{mutex-lock!}) only if it is in unlocked state.
An 'owned' mutex keeps a thread that owns it.
Typically an owner thread is the one that locked the mutex,
but you can make a thread other than the locking thread own a mutex.
A mutex becomes unlocked either by @code{mutex-unlock!} or the owner
thread terminates.  In the former case, a mutex becomes unlocked/not-abandoned
state.  In the latter case, a mutex becomes unlocked/abandoned state.

A mutex has the following external slots.

@defivar <mutex> name
The name of the mutex.
@end defivar

@defivar <mutex> state
The state of the mutex.  This is a read-only slot.
See the descrption of @code{mutex-state} below.
@end defivar

@defivar <mutex> specific
A slot an application can keep arbitrary data.  For example, an application
can implement a 'recursive' mutex using the specific field.
@end defivar
@end deftp

@defun mutex? obj
[SRFI-18], [SRFI-21]
Returns @code{#t} if @var{obj} is a mutex, @code{#f} otherwise.
@end defun

@defun make-mutex &optional name
[SRFI-18], [SRFI-21]
Creates and returns a new mutex object.
When created, the mutex is in unlocked/not-abandoned state.
Optionally, you can give a name to the mutex.
@end defun

@defun mutex-name mutex
[SRFI-18], [SRFI-21]
Returns the name of the mutex.
@end defun

@defun mutex-specific mutex
@defunx mutex-specific-set! mutex value
[SRFI-18], [SRFI-21]
Gets/sets the specific value of the mutex.
@end defun

@defun mutex-state mutex
[SRFI-18], [SRFI-21]
Returns the state of @var{mutex}, which may be one of the followings:

@table @asis
@item a thread
The mutex is locked/owned, and the owner is the returned thread.
@item symbol @code{not-owned}
The mutex is locked/not-owned.
@item symbol @code{abandoned}
The mutex is unlocked/abandoned.
@item symbol @code{not-abandoned}
The mutex is unlocked/not-abandoned.
@end table
@end defun

@defun mutex-lock! mutex &optional timeout thread
[SRFI-18], [SRFI-21]
Locks @var{mutex}.  If @var{mutex} is in unlocked/not-abandoned
state, this procedure changes its state to locked state exclusively.
By default, @var{mutex} becomes locked/owned state, owned by the
calling thread.  You can give other owner thread as @var{thread} argument.
If @var{thread} argument is given and @code{#f}, the mutex becomes
locked/not-owned state.

If @var{mutex} is in unlocked/abandoned state, that is, some other
thread has been terminated without unlocking it, this procedure
signals 'abandoned mutex exception' (@xref{Thread exceptions})
after changing the state of @var{mutex}.

If @var{mutex} is in locked state and
@var{timeout} is omitted or @code{#f}, this procedure blocks until
@var{mutex} becomes unlocked.   If @var{timeout} is specified,
@code{mutex-lock!} returns when the specified time reaches in
case it couldn't obtain a lock.  You can give @var{timeout}
an absolute point of time (by @code{<time>} object, @xref{SRFI time}),
or a relative time (by a real number).

@code{Mutex-lock!} returns @code{#t} if @var{mutex} is successfully
locked, or @code{#f} if timeout reached.

Note that @var{mutex} itself doesn't implements a 'recursive lock'
feature; that is, if a thread that has locked @var{mutex} tries to lock
@var{mutex} again, the thread blocks.  It is not difficult, however,
to implement a recursive lock semantics on top of this mutex.
The following example is taken from SRFI-18 document:

@example
(define (mutex-lock-recursively! mutex)
  (if (eq? (mutex-state mutex) (current-thread))
      (let ((n (mutex-specific mutex)))
        (mutex-specific-set! mutex (+ n 1)))
      (begin
        (mutex-lock! mutex)
        (mutex-specific-set! mutex 0))))

(define (mutex-unlock-recursively! mutex)
  (let ((n (mutex-specific mutex)))
    (if (= n 0)
        (mutex-unlock! mutex)
        (mutex-specific-set! mutex (- n 1)))))
@end example
@end defun

@defun mutex-unlock! mutex &optional condition-variable timeout
[SRFI-18], [SRFI-21]
Unlocks @var{mutex}.  The state of @var{mutex} becomes unlocked/not-abandoned.
It is allowed to unlock a mutex that is not owned by the calling thread.

If optional @var{condition-variable} is given, @code{mutex-unlock!}
serves the "condition variable wait" operation (e.g. @code{pthread_cond_wait}
in POSIX threads).   The current thread atomically wait on
@var{condition-variable} and unlocks @var{mutex}.
The thread will be unblocked when other thread signals on
@var{condition-variable} (see @code{condition-variable-signal!}
and @code{condition-variable-broadcast!} below), or @var{timeout}
reaches if it is supplied.  The @var{timeout} argument can be either
a @code{<time>} object to represent an absolute time point (@xref{SRFI time}),
a real number to represent a relative time in seconds, or @code{#f} which
means never.  The calling thread may be unblocked prematurely,
so it should reacquire the lock of @var{mutex} and checks the
condition, as in the follwing example (it is taken from SRFI-18 document):

@example
(let loop ()
  (mutex-lock! m)
  (if (condition-is-true?)
      (begin
        (do-something-when-condition-is-true)
        (mutex-unlock! m))
      (begin
        (mutex-unlock! m cv)
        (loop))))
@end example
@end defun

@deftp {Builtin Class} <condition-variable>
@clindex condition-variable
A condition variable keeps a set of threads that are waiting for
a certain condition to be true.  When a thread modifies the state 
of the concerned condition, it can call @code{condition-variable-signal!}
or @code{condition-variable-broadcast!}, which unblock one or more
waiting threads so that they can check if the condition is satisfied.

A condition variable object has the following slots.

@defivar <mutex> name
The name of the condition variable.
@end defivar

@defivar <mutex> specific
A slot an application can keep arbitrary data. 
@end defivar
@end deftp

@defun condition-variable? obj
[SRFI-18], [SRFI-21]
Returns @code{#t} if @var{obj} is a condition variable,
@code{#f} otherwise.
@end defun

@defun make-condition-variable &optional name
[SRFI-18], [SRFI-21]
Returns a new condition variable.  You can give its name by
optional @var{name} argument.
@end defun

@defun condition-variable-name cv
[SRFI-18], [SRFI-21]
Returns the name of the condition variable.
@end defun

@defun condition-variable-specific cv
@defunx condition-variable-specific-set! cv value
[SRFI-18], [SRFI-21]
Gets/sets the specific value of the condition variable.
@end defun

@defun condition-variable-signal! cv 
[SRFI-18], [SRFI-21]
If there are threads waiting on @var{cv}, causes the scheduler to select
one of them and to make it runnable.
@end defun

@defun condition-variable-broadcast! cv
[SRFI-18], [SRFI-21]
Unblocks all the threads waiting on @var{cv}.
@end defun

@node Thread exceptions,  , Synchronization primitives, gauche.threads - Threads
@subsection Thread exceptions

Some types of exceptions may be thrown from thread-related procedures.
These exceptions can be handled by Gauche's exception mechanism
(@xref{Exceptions}).   



@deftp {Builtin Class} <thread-exception>
@clindex thread-exception
A base class of thread-related exceptions.  Inherits @code{<exception>} class.
It has one slot.

@defivar <thread-exception> thread
A thread that threw this exception.
@end defivar
@end deftp

@deftp {Builtin Class} <join-timeout-exception>
@clindex join-timeout-exception
An exception thrown by @code{thread-join!} when a timeout reaches
before the waited thread returns.  Inherits @code{<thread-exception>}.
@end deftp

@deftp {Builtin Class} <abandoned-mutex-exception>
@clindex abandoned-mutex-exception
An exception thrown by @code{mutex-lock!} when a @var{mutex} to be
locked is in unlocked/abandoned state.  Inherits @code{<thread-exception>}.
It has one additional slot.

@defivar <abandoned-mutex-exception> mutex
A mutex that caused this exception.
@end defivar
@end deftp

@deftp {Builtin Class} <terminated-thread-exception>
@clindex terminated-thread-exception
An exception thrown by @code{thread-join!} when the waited thread
is terminated abnormally (by @code{thread-terminate!}).
Inherits @code{<thread-exception>}.  It has one additional slot.

@defivar <terminated-thread-exception> terminator
A thread that terminated the thread that causes this exception.
@end defivar
@end deftp

@deftp {Builtin Class} <uncaught-exception>
@clindex uncaught-exception
An exception thrown by @code{thread-join!} when the waited thread
is terminated by an uncaught exception.
Inherits @code{<thread-exception>}.  It has one additional slot.

@defivar <uncaught-exception> reason
An exception that caused the termination of the thread.
@end defivar
@end deftp

@defun join-timeout-exception? obj
@defunx abandoned-mutex-exception? obj
@defunx terminated-thread-exception? obj
@defunx uncaught-exception? obj
[SRFI-18], [SRFI-21]
These procedures checks if @var{obj} is a certain type of exception.
Provided for the compatibility to SRFI-18.
@end defun

@defun uncaught-exception-reason exc
[SRFI-18], [SRFI-21]
Returns the value of @code{reason} slot of @code{<uncaught-exception>}
object.
Provided for the compatibility to SRFI-18.
@end defun


@c ----------------------------------------------------------------------
@node gauche.time - Measure timings, gauche.uvector - Uniform vectors, gauche.threads - Threads, Library modules - Gauche extensions
@section @code{gauche.time} - Measure timings
@c NODE gauche.time - 時間の計測, @code{gauche.time} - 時間の計測

@deftp {Module} gauche.time
@mdindex gauche.time
@c EN
Provides two simple ways to measure execution time of Scheme code.
A macro @code{time}, which is convenient for interactive use,
and @code{<time-counter>} objects which are useful to be embedded
in the program.
@c JP
Schemeコードの実行時間を測る2つの単純な方法を提供します。
インタラクティブな使用に便利な@code{time}マクロ及び、
プログラム中に埋め込んで使える@code{<time-counter>}オブジェクトです。
@c COMMON
@end deftp

@defmac time expr expr2 @dots{}
@c EN
Evaluates @var{expr} @var{expr2} @dots{} sequentially, as @code{begin},
and returns the result(s) of the last expression.
Before returning the value(s), the macro reports the elapsed (real) time
and CPU times in the user space and the kernel space to the current
error port, much like the bourne shell's time command.
@c JP
式@var{expr} @var{expr2} @dots{} を順に評価し、最後の式の結果を返します。
結果が返される前に、全ての式の評価にかかった実(経過)時間および
ユーザースペース、カーネルスペースで費されたCPU時間がカレントエラーポートに
報告されます。
@c COMMON

@c EN
The current version uses @code{sys-gettimeofday} (@xref{POSIX time}) to
calculate the elapsed time, and @code{sys-times} (@xref{System Inquiry})
to calculate user and system CPU times.  So the resolution of these numbers
depends on these underlying system calls.  Usually the CPU
time has 10ms resolution, while the elapsed time might have higher
resolution.  On the systems that doesn't have gettimeofday(2) support,
however, the elapsed time resolution can be as bad as a second.
@c JP
現在の実装は、経過時間に対しては@code{sys-gettimeofday}
(@ref{POSIX time}参照)を、CPU時間に対しては@code{sys-times}
(@ref{System Inquiry}参照)を用いています。従って、
それぞれの数値の分解能はこれらの手続きが用いているシステムコールに依存します。
CPU時間は10ms単位で、経過時間はそれより細かいことが多いです。
但しgettimeofday(2)コールをサポートしていないOSでは経過時間が最悪の場合
秒単位になります。
@c COMMON

@example
gosh> (time (length (sort (call-with-input-file "/usr/share/dict/words" port->string-list))))
;(time (length (sort (call-with-input-file "/usr/share/dict/words" port- ...
; real   0.357
; user   0.350
; sys    0.000
45427
@end example
@end defmac

@deftp {Class} <time-counter>
@clindex time-counter
@c EN
An abstract class of time counters.  Time counter is a kind of timer
whose value is incremented as the time passes.  The counting
can be started and stopped any number of times.
The value of the counter can be read
when the timer is stopping.
You can have multiple time counters.  It is useful, for example,
to measure the time in two parts inside a loop independently.
@c JP
時間カウンタの抽象クラスです。時間カウンタは
時間の経過と共にその値が増加してゆく一種のタイマーです。
何度でもカウントを止めたり開始したりできます。
カウンタの値はカウントが止まっている時に読み出すことができます。
複数の時間カウンタを使えば、
例えばループ中の二つの部分について費される時間を別々に計測することもできます。
@c COMMON

@c EN
The concrete subclass determines which time it is counting.
You have to instantiate one of those subclasses described below
to use the time counter.
@c JP
具体的なサブクラスが、どの時間をカウントするかを決定します。
時間カウンタを使うには、下に挙げるサブクラスのいずれかを
インスタンシエイトしなければなりません。
@c COMMON
@end deftp

@deftp {Class} <real-time-counter>
@deftpx {Class} <user-time-counter>
@deftpx {Class} <system-time-counter>
@deftpx {Class} <process-time-counter>
@clindex real-time-counter
@clindex user-time-counter
@clindex system-time-counter
@clindex process-time-counter
@c EN
Classes for time counters that count real (elapsed) time, user-space CPU time,
kernel-space CPU time, and total CPU time (user + system), respectively.
@c JP
それぞれ、実経過時間、ユーザースペースCPU時間、カーネルスペースCPU時間、
総CPU時間 (ユーザー+カーネル)を計測する時間カウンタのクラスです。
@c COMMON
@end deftp

@deffn {Method} time-counter-start! (counter <time-counter>)
@deffnx {Method} time-counter-stop! (counter <time-counter>)
@c EN
Starts and stops the @var{counter}.  The time during the counter is
running is accumulated to the counter value when the counter is stopped.
@c JP
時間カウンタ@var{counter}を開始/停止します。カウンタが走っている間の時間が、
カウンタが停止した時点でカウンタの値に加算されます。
@c COMMON

@c EN
Start/stop pairs can be nested,
but only the outermost pair takes the effect.  That is, if you call
@code{time-counter-start!} on the counter that is already started,
it doesn't have any effect except that to stop such a counter
you have to call @code{time-counter-stop!} one more time.  It is useful
when you want to measure the time spent in the larger block that
may already contain timer start/stop pairs.
@c JP
開始/停止の対はネストすることができます。その場合は、一番外側の対のみが
有効です。
つまり、既に走っているカウンタに対し@code{time-counter-start!}を呼んでも
何も起こりませんが、一度余分に@code{time-counter-stop!}を呼ばないと
カウンタは止まりません。
これは、内部に既に開始/停止の対を含んでいるかもしれない大きなコードブロックの
全体の時間を計測したいというような場合に便利です。
@c COMMON

@c EN
Calling @code{time-counter-stop!} on the already stopped counter
has no effect.
@c JP
既に停止しているカウンタに対して@code{time-counter-stop!}を呼んでも
何も起こりません。
@c COMMON
@end deffn

@deffn {Method} time-counter-reset! (counter <time-counter>)
@c EN
Resets the value of @var{counter}.  If @var{counter} is already
running, it is forced to stop before being reset.
@c JP
カウンタ@var{counter}の値をリセットします。既に@var{counter}が走っている
場合は、リセットの前にカウンタは停止させられます。
@c COMMON
@end deffn

@deffn {Method} time-counter-value (counter <time-counter>)
@c EN
Returns the current value of the counter as the number of seconds,
in a real number.  The resolution depends on the source of the counter.
@c JP
カウンタ@var{counter}の現在の値(秒数)を実数で返します。
分解能はそれぞれのカウンタが用いているシステムコールに依存します。
@c COMMON
@end deffn

@defmac with-time-counter counter expr @dots{}
@c EN
A convenience macro to run the @var{counter} while @var{expr} @dots{}
are evaluated.  Returns the result(s) of the last expression.
It is defined as follows.
@c JP
式@var{expr} @dots{}が評価される間だけ@var{counter}を走らせる、
便利なマクロです。最後の式の結果を返します。このマクロは次のように
定義されます。
@c COMMON
@example
(define-syntax with-time-counter
  (syntax-rules ()
    ((_ counter . exprs)
     (dynamic-wind
      (lambda () (time-counter-start! counter))
      (lambda () . exprs)
      (lambda () (time-counter-stop! counter))))
    ))
@end example
@end defmac

@c EN
The following example measures approximate times
spend in process-A and process-B inside a loop.
@c JP
下の例では、ループ内でのprocess-Aとprocess-Bにて費された
概略の時間をそれぞれ計測します。
@c COMMON

@example
(let ((ta (make <real-time-counter>))
      (tb (make <real-time-counter>)))
  (dotimes (i 100000)
    (with-time-counter ta
      (process-A))
    (with-time-counter tb
      (process-B)))
  (format #t "Time spent in process-A: ~s\n" (time-counter-value ta))
  (format #t "Time spent in process-B: ~s\n" (time-counter-value tb))
  )
@end example


@c ----------------------------------------------------------------------
@node gauche.uvector - Uniform vectors, gauche.version - Comparing version numbers, gauche.time - Measure timings, Library modules - Gauche extensions
@section @code{gauche.uvector} - Uniform vectors
@c NODE gauche.uvector - ユニフォームベクタ, @code{gauche.uvector} - ユニフォームベクタ

@deftp {Module} gauche.uvector
@mdindex gauche.uvector
@c EN
Provides vectors whose elements are of the same numeric type,
as defined in SRFI-4 (@ref{srfi-4,,SRFI-4}).

Gauche's implementation is a superset of SRFI-4 in a few ways:
@itemize @bullet
@item
Some routines takes optional parameters: @code{@var{TAG}vector->list}
takes optional start and end indices, and @code{@var{TAG}vector-ref}
takes optional fallback value.
@item
Additional functions: copy procedures (@code{@var{TAG}vector-copy} and
@code{@var{TAG}vector-copy!}), conversion procedures
(@code{@var{TAG}vector->vector} and @code{vector->@var{TAG}vector}),
and some arithmetic functions (@code{@var{TAG}vector-add}, etc.)
@item
Implements the collection framework (@xref{gauche.collection - Collection framework})
and the sequence framework (@xref{gauche.sequence - Sequence framework}).  So the
methods like @code{map}, @code{for-each}, @code{ref} or @code{subseq}
can be used on the SRFI-4 vector types.
@end itemize
@c JP
SRFI-4(@ref{srfi-4,,SRFI-4})に定義されている、
要素が同一の数値型であるようなベクタを提供します。

Gaucheの実装は、SRFI-4の仕様を次のように拡張しています。
@itemize @bullet
@item
いくつかの手続きはSRFI-4に無い省略可能な引数を取ります。
@code{@var{TAG}vector->list}は省略可能なstartとendのインデックスを取り、
@code{@var{TAG}vector-ref}は省略可能なデフォルト値を取ります。
@item
追加の手続き： コピー(@code{@var{TAG}vector-copy},
@code{@var{TAG}vector-copy!})、
変換 (@code{@var{TAG}vector->vector}, @code{vector->@var{TAG}vector})、
及び各種算術演算(@code{@var{TAG}vector-add}等)。
@item
コレクションフレームワーク (@ref{gauche.collection - Collection framework}参照)と
シーケンスフレームワーク (@ref{gauche.sequence - Sequence framework}参照)の実装。
例えば @code{map}, @code{for-each}, @code{ref}, @code{subseq}等の
メソッドがSRFI-4ベクタに対して使えます。
@end itemize
@c COMMON

@c EN
There are some advantages of using SRFI-4 vectors over normal
(heterogeneous) vectors.  It may be more compact than the normal
vectors.  Some operations (especially Gauche's extension of vector
arithmetic operations) can bypass type check and conversion of
individual elements, thus be more efficient.  And it is much easier
and efficient to communicate with external libraries that require
homogeneous array of numbers; for example, OpenGL binding of Gauche
uses SRFI-4 vectors extensively.
@c JP
通常のベクタではなくSRFI-4ベクタを使うことにより得られる利点がいくつかあります。
まず、SRFI-4ベクタは通常のベクタよりもコンパクトです。
いくつかのオペレーション(特に、Gaucheの拡張仕様であるベクタ上の数値演算)では、
型検査と型変換を個々の要素に対して行わなくても良いため、
極めて効率の良い演算が可能です。さらに、
数値の配列を扱う外部のライブラリとのインタフェースが容易です。
例えば、GaucheのOpenGLバインディングではSRFI-4ベクタを多用しています。
@c COMMON
@end deftp
@c EN
The following ten types of vectors are defined.
@table @emph
@item s8vector
Elements are exact integers in the range between -2^7 and 2^7-1
@item u8vector
Elements are exact integers in the range between 0 and 2^8-1
@item s16vector
Elements are exact integers in the range between -2^15 and 2^15-1
@item u16vector
Elements are exact integers in the range between 0 and 2^16-1
@item s32vector
Elements are exact integers in the range between -2^31 and 2^31-1
@item u32vector
Elements are exact integers in the range between 0 and 2^32-1
@item s64vector
Elements are exact integers in the range between -2^63 and 2^63-1
@item u64vector
Elements are exact integers in the range between 0 and 2^64-1
@item f32vector
Elements are inexact real numbers representable in the @code{float} of
C compiler that compiles Gauche.  Usually it is a single precision
IEEE floating point number.
@item f64vector
Elements are inexact real numbers representable in the @code{double} of
C compiler that compiles Gauche.  Usually it is a double precision
IEEE floating point number.
@end table
@c JP
以下の10タイプのベクタが定義されます。
@table @emph
@item s8vector
要素が -2^7 から 2^7-1 の間の正確な整数であるベクタ
@item u8vector
要素が 0 から 2^8-1 の間の正確な整数であるベクタ
@item s16vector
要素が -2^15 から 2^15-1 の間の正確な整数であるベクタ
@item u16vector
要素が 0 から 2^16-1 の間の正確な整数であるベクタ
@item s32vector
要素が -2^31 から 2^31-1 の間の正確な整数であるベクタ
@item u32vector
要素が 0 から 2^32-1 の間の正確な整数であるベクタ
@item s64vector
要素が -2^63 から 2^63-1 の間の正確な整数であるベクタ
@item u64vector
要素が 0 から 2^64-1 の間の正確な整数であるベクタ
@item f32vector
要素が、GaucheをコンパイルしたCコンパイラの@code{float}で表現し得るような
不正確な実数(通常IEEE単精度浮動少数点数)であるベクタ
@item f64vector
要素が、GaucheをコンパイルしたCコンパイラの@code{double}で表現し得るような
不正確な実数(通常IEEE倍精度浮動少数点数)であるベクタ
@end table
@c COMMON

@c EN
When you try to store a number out of the range of the vector type,
an error is signalled by default.  However, some procedures take
an optional argument @var{clamp} that specifies alternative behavior
in such a case.  @var{Clamp} argument may take one of the following values.
@c JP
ベクタの型が許す範囲外の値を格納しようとした場合、通常はエラーとなります。
いくつかの手続きは省略可能な引数@var{clamp}によって、
そのような場合に別のふるまいを指定することができます。
@var{clamp}には以下のいずれかの値を与えることが出来ます。
@c COMMON
@table @code
@item #f
@c EN
Default behavior (signals an error).
@c JP
デフォルト (エラーを通知)
@c COMMON
@item high
@c EN
Clamps high bound; i.e. if the value to be stored is beyond the higher bound
of the range, the maximum value is stored instead.
@c JP
高い方の値をクランプ、すなわち、格納しようとする値が許される値の最大値より大きかった
場合は、可能な最大値を代わりに格納します。
@c COMMON
@item low
@c EN
Clamps low bound; i.e. if the value to be stored is below the lower bound
of the range, the minimum value is stored instead.
@c JP
低い方の値をクランプ、すなわち、格納しようとする値が許される値の最小値より大きかった
場合は、可能な最小値を代わりに格納します。
@c COMMON
@item both
@c EN
Clamps both sides; does both @code{high} and @code{low}.
@c JP
高いほうと低いほうの両方の値をクランプします。
@c COMMON
@end table

@example
(list->u8vector '(-1))         @result{} @r{error}
(list->u8vector '(-1) 'low)    @result{} #u8(0)
(list->u8vector '(-1) 'high)   @result{} @r{error}
(list->u8vector '(3000) 'high) @result{} #u8(255)
(list->u8vector '(-100 20 300) 'both) @result{} #u8(0 20 255)
@end example

@c EN
In the following description, @code{@var{TAG}} can be replaced
for any of @code{s8}, @code{u8}, @code{s16}, @code{u16}, 
@code{s32}, @code{u32}, @code{s64}, @code{u64}, @code{f32}, @code{f64}.
@c JP
以下の記述では、@code{@var{TAG}}は
@code{s8}, @code{u8}, @code{s16}, @code{u16}, 
@code{s32}, @code{u32}, @code{s64}, @code{u64}, @code{f32}, @code{f64}
のいずれにも置き換えて読むことができるものとします。
@c COMMON

@menu
* Uvector basic operations::    
* Uvector conversion operations::  
* Uvector numeric operations::  
* Uvector block I/O::           
@end menu

@node Uvector basic operations, Uvector conversion operations, gauche.uvector - Uniform vectors, gauche.uvector - Uniform vectors
@subsection Uvector basic operations
@c NODE ユニフォームベクタの基本操作

@deftp {Builtin Class} <@var{TAG}vector>
@clindex s8vector
@clindex u8vector
@clindex s16vector
@clindex u16vector
@clindex s32vector
@clindex u32vector
@clindex s64vector
@clindex u64vector
@clindex f32vector
@clindex f64vector
@c EN
A class for @var{TAG}vector.  It inherits @code{<sequence>}.
@c JP
@var{TAG}vectorのクラス。@code{<sequence>}を継承します。
@c COMMON
@end deftp

@deftp {Reader Syntax} @code{#@var{TAG}(@var{n} @dots{})}
@c EN
Denotes a literal homogeneous vector.
@c JP
リテラルの単一型のベクタを記述します。
@c COMMON
@example
#s8(3 -2 4)
#u32(4154 88357 2 323)
#f32(3.14 0.554525 -3.342)
@end example
@end deftp

@deftp {Function} {@var{TAG}vector?} @r{@var{obj}}
@findex s8vector?
@findex u8vector?
@findex s16vector?
@findex u16vector?
@findex s32vector?
@findex u32vector?
@findex s64vector?
@findex u64vector?
@findex f32vector?
@findex f64vector?
[SRFI-4]
@c EN
Returns @code{#t} if @var{obj} is a @var{TAG}vector, @code{#f} otherwise.
@c JP
@var{obj}が@var{TAG}vectorなら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end deftp

@deftp {Function} {@var{TAG}vector} @r{@var{x} @dots{}}
@findex s8vector 
@findex u8vector
@findex s16vector
@findex u16vector
@findex s32vector
@findex u32vector
@findex s64vector
@findex u64vector
@findex f32vector
@findex f64vector
[SRFI-4]
@c EN
Constructs @var{TAG}vector whose elements are numbers @var{x} @dots{}.
The numbers must be exact integer for exact integer vectors, 
and in the valid range of the vector.
@c JP
数値@var{x} @dots{} を要素に持つ@var{TAG}vectorを作成して返します。
正確な整数のベクタに対しては、数値は正確な整数でなければならず、
また有効な範囲内の値でなければなりません。
@c COMMON
@example
(s8vector 1 2 3) @result{} #s8(1 2 3)
@end example
@end deftp

@deftp {Function} make-@var{TAG}vector @r{@var{len} @var{&optional} @var{fill}}
@findex make-s8vector
@findex make-u8vector
@findex make-s16vector
@findex make-u16vector
@findex make-s32vector
@findex make-u32vector
@findex make-s64vector
@findex make-u64vector
@findex make-f32vector
@findex make-f64vector
[SRFI-4]
@c EN
Constructs a @var{TAG}vector of length @var{len}.  The elements are
initialized by a number @var{fill}.   For exact integer vectors,
@var{fill} must be an exact integer and in the valid range.
If @var{fill} is omitted, the content of the vector is undefined.
@c JP
長さ@var{len}の@var{TAG}vectorを作成して返します。各要素は@var{fill}で
初期化されます。正確な整数のベクタに対しては、@var{fill}は正確な整数でなければならず、
また有効な範囲内の値でなければなりません。
@var{fill}が省略された場合、各要素の初期値は不定です。
@c COMMON
@example
(make-u8vector 4 0) @result{} #u8(0 0 0 0)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-length @r{@var{vec}}
@findex s8vector-length 
@findex u8vector-length
@findex s16vector-length
@findex u16vector-length
@findex s32vector-length
@findex u32vector-length
@findex s64vector-length
@findex u64vector-length
@findex f32vector-length
@findex f64vector-length
[SRFI-4]
@c EN
Returns the length of the @var{TAG}vector @var{vec}.

Note that the generic function @code{size-of} can be used 
to obtain the length of @var{vec} as well,
if you import @code{gauche.collection}
(@xref{gauche.collection - Collection framework}).
@c JP
@var{TAG}vector @var{vec}の長さを返します。

モジュール@code{gauche.collection}をインポートしていれば、
@var{vec}の長さを知るのに、総称関数@code{size-of}を使うこともできます
(@ref{gauche.collection - Collection framework}参照)。
@c COMMON
@example
(s16vector-length '#s16(111 222 333)) @result{} 3

(use gauche.collection)
(size-of '#s16(111 222 333)) @result{} 3
@end example
@end deftp

@deftp {Function} @var{TAG}vector-ref @r{@var{vec} @var{k} &optional @var{fallback}}
@findex s8vector-ref
@findex u8vector-ref
@findex s16vector-ref
@findex u16vector-ref
@findex s32vector-ref
@findex u32vector-ref
@findex s64vector-ref
@findex u64vector-ref
@findex f32vector-ref
@findex f64vector-ref
[SRFI-4+]
@c EN
Returns the @var{k}-th element of @var{TAG}vector @var{vec}.

If the index @var{k} is out of the valid range, an error is signalled
unless an optional argument @var{fallback} is given; in that case,
@var{fallback} is returned.

Note that the generic function @code{ref} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}の@var{k}番目の要素を返します。

@var{k}が有効な範囲外であった場合、通常はエラーが通知されますが、
省略可能な引数@var{fallback}が与えられている場合はそれが返されます。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{ref}を使うこともできます。
@c COMMON

@example
(u16vector-ref '#u16(111 222 333) 1) @result{} 222

(use gauche.collection)
(ref '#u16(111 222 333) 1) @result{} 222
@end example
@end deftp

@deftp {Function} @var{TAG}vector-set! @r{@var{vec} @var{k} @var{n} &optional @var{clamp}}
@findex s8vector-set!
@findex u8vector-set!
@findex s16vector-set!
@findex u16vector-set!
@findex s32vector-set!
@findex u32vector-set!
@findex s64vector-set!
@findex u64vector-set!
@findex f32vector-set!
@findex f64vector-set!
[SRFI-4+]
@c EN
Sets a number @var{n} to the @var{k}-th element of @var{TAG}vector @var{vec}.
Optional @var{clamp} argument specifies the behavior when
@var{n} is out of valid range.   Default is to signal an error.

Note that the setter of the generic function @code{ref} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}の@var{k}番目の要素に数値@var{n}をセットします。
省略可能な引数@var{clamp}が、@var{n}が正しい範囲外の数であった場合の動作を指定します。
デフォルトではエラーが通知されます。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{ref}のsetter手続きを使うこともできます。
@c COMMON
@example
(let ((v (s32vector -439 852 8933)))
  (s32vector-set! v 1 4)
  v)
 @result{} #s32vector(-439 4 8933)

(use gauche.collection)
(let ((v (s32vector -439 852 8933)))
  (set! (ref v 1) 4)
  v)
 @result{} #s32vector(-439 4 8933)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-copy @r{@var{vec} &optional @var{start} @var{end}}
@findex s8vector-copy
@findex u8vector-copy
@findex s16vector-copy
@findex u16vector-copy
@findex s32vector-copy
@findex u32vector-copy
@findex s64vector-copy
@findex u64vector-copy
@findex f32vector-copy
@findex f64vector-copy
@c EN
Copies the srfi-4 vector @var{vec}.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be copied.
@c JP
ベクタ@var{vec}をコピーします。
省略可能な引数@var{start}と@var{end}が与えられた場合、
それらは取り出される要素の範囲を制限します。
@c COMMON

@example
(u8vector-copy '#u8(1 2 3 4))     @result{} #u8(1 2 3 4)
(u8vector-copy '#u8(1 2 3 4) 2)   @result{} #u8(3 4)
(u8vector-copy '#u8(1 2 3 4) 1 3) @result{} #u8(2 3)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-copy! @r{@var{dstvec} @var{srcvec}}
@findex s8vector-copy!
@findex u8vector-copy!
@findex s16vector-copy!
@findex u16vector-copy!
@findex s32vector-copy!
@findex u32vector-copy!
@findex s64vector-copy!
@findex u64vector-copy!
@findex f32vector-copy!
@findex f64vector-copy!
@c EN
@c JP
@c COMMON
@end deftp

@c EN
Using collection and sequence framework, you can perform
various operations on the homogeneous vectors.
@c JP
コレクションやシーケンスフレームワークを使うと、さらに様々な操作を
行うことができます。
@c COMMON

@example
(use gauche.collection)
(use gauche.sequence)

(fold + 0 '#s32(1 2 3 4)) @result{} 10

(map-to <f32vector> * '#f32(3.2 1.1 4.3) '#f32(-4.3 2.2 9.4))
  @result{} #f32(-13.760001 2.420000 40.420002)

(subseq #u32(1 4 3 4 5) 2 4) @result{} #u32(3 4)
@end example


@node Uvector conversion operations, Uvector numeric operations, Uvector basic operations, gauche.uvector - Uniform vectors
@subsection Uvector conversion operations
@c NODE ユニフォームベクタの変換

@deftp {Function} @var{TAG}vector->list @r{@var{vec} &optional @var{start} @var{end}}
@findex s8vector->list
@findex u8vector->list
@findex s16vector->list
@findex u16vector->list
@findex s32vector->list
@findex u32vector->list
@findex s64vector->list
@findex u64vector->list
@findex f32vector->list
@findex f64vector->list
[SRFI-4+]
@c EN
Converts @var{TAG}vector @var{vec} to a list.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be extracted.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}をリストに変換します。
省略可能な引数@var{start}と@var{end}が与えられた場合、
それらは取り出される要素の範囲を制限します。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(u32vector->list '#u32(9 2 5)) @result{} (9 2 5)

(use gauche.collection)
(coerce-to <list> '#u32(9 2 5)) @result{} (9 2 5)
@end example
@end deftp

@deftp {Function} @var{TAG}vector->vector @r{@var{vec} &optional @var{start} @var{end}}
@findex s8vector->vector
@findex u8vector->vector
@findex s16vector->vector
@findex u16vector->vector
@findex s32vector->vector
@findex u32vector->vector
@findex s64vector->vector
@findex u64vector->vector
@findex f32vector->vector
@findex f64vector->vector
@c EN
Converts @var{TAG}vector @var{vec} to a vector.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be copied.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}をベクタに変換します。
省略可能な引数@var{start}と@var{end}が与えられた場合、
それらは取り出される要素の範囲を制限します。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(f32vector->vector '#f32(9.3 2.2 5.5))   @result{} #(9.3 2.2 5.5)
(f32vector->vector '#f32(9.3 2.2 5.5) 2) @result{} #(5.5)

(use gauche.collection)
(coerce-to <vector> '#f32(9.3 2.2 5.5)) @result{} #(9.3 2.2 5.5)
@end example
@end deftp

@deftp {Function} list->@var{TAG}vector @r{@var{list} &optional @var{clamp}}
@findex list->s8vector
@findex list->u8vector
@findex list->s16vector
@findex list->u16vector
@findex list->s32vector
@findex list->u32vector
@findex list->s64vector
@findex list->u64vector
@findex list->f32vector
@findex list->f64vector
[SRFI-4+]
@c EN
Converts a list @var{list} to a @var{TAG}vector.
Optional argument @var{clamp} specifies the behavior when
the element of @var{list} is out of the valid range.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
リスト@var{list}を@var{TAG}vectorに変換します。
省略可能な引数@var{clamp}が、リスト内の要素が正しい範囲外の数であった場合の
動作を指定します。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(list->s64vector '(9 2 5)) @result{} #s64(9 2 5)

(use gauche.collection)
(coerce-to <s64vector> '(9 2 5)) @result{} #s64(9 2 5)
@end example
@end deftp

@deftp {Function} vector->@var{TAG}vector @r{@var{vec} &optional @var{start} @var{end} @var{clamp}}
@findex vector->s8vector
@findex vector->u8vector
@findex vector->s16vector
@findex vector->u16vector
@findex vector->s32vector
@findex vector->u32vector
@findex vector->s64vector
@findex vector->u64vector
@findex vector->f32vector
@findex vector->f64vector
@c EN
Converts a vector @var{vec} to a @var{TAG}vector.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be copied.
Optional argument @var{clamp} specifies the behavior when
the element of @var{vec} is out of the valid range.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
ベクタ@var{vec}を@var{TAG}vectorに変換します。
省略可能な引数@var{start}と@var{end}が与えられた場合、
それらは取り出される要素の範囲を制限します。
省略可能な引数@var{clamp}が、ベクタ内の要素が正しい範囲外の数であった場合の
動作を指定します。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(vector->f64vector '#(3.1 5.4 3.2)) @result{} #f64(3.1 5.4 3.2)

(use gauche.collection)
(coerce-to <f64vector> '#(3.1 5.4 3.2)) @result{} #f64(3.1 5.4 3.2)
@end example
@end deftp

@defun string->s8vector string &optional start end
@defunx string->u8vector string &optional start end
@c EN
Returns an s8vector or u8vector whose byte sequence is the same
as the internal representation of the given string.
Optional range arguments @var{start} and @var{end} specifies
the @emph{character position} inside @var{string} to be
converted.

These procedures are useful when you want to access byte
sequence of the string randomly.
@c JP
与えられた文字列の内部表現のバイト列と同じバイト列を持つs8vectorもしくは
u8vectorを返します。省略可能な範囲引数@var{start}、@var{end}は、
変換される文字列中の文字位置を指定します。

これらの手続きは、文字を構成するバイト列をランダムにアクセスしたい場合などに
有用です。
@c COMMON

@example
(string->u8vector "abc") @result{} #u8(97 98 99)

@c JP
;; 内部コードがEUCの場合
(string->u8vector "いろは") @result{} #u8(164 164 164 237 164 207)
@c COMMON
@end example
@end defun

@defun s8vector->string vec &optional start end
@defunx u8vector->string vec &optional start end
@c EN
Converts a byte sequence in s8vector or u8vector to a string that
has the same byte sequence.  Optional range arguments @var{start} and
@var{end} specifies the byte position in @var{vec} to be converted.

Note that these procedure may result an incomplete string if
@var{vec} contains a byte sequence invalid as the internal encoding
of the string.
@c JP
与えられたs8vectorもしくはu8vector @var{vec}のバイト列と同じ内部バイト列を
持つ文字列を作成して返します。省略可能な範囲引数@var{start}、@var{end}は、
@var{vec}中の変換されるべき範囲をバイト位置で指定します。

@var{vec}中のバイト列が文字列の内部表現として不正な値を持っていた場合は、
不完全な文字列が返されます。
@c COMMON
@end defun

@defun string->s32vector string &optional start end
@defunx string->u32vector string &optional start end
@c EN
Returns an s32vector or u32vector whose elements are
the internal codes of the characters in the string.
Optional range arguments @var{start} and @var{end} specifies
the @emph{character position} inside @var{string} to be
converted.

These procedures are useful when you want to access
the characters in the string randomly.
@c JP
与えられた文字列@var{string}の各文字の内部コードを値として持つ
s32vectorもしくはu32vectorを返します。
省略可能な範囲引数@var{start}、@var{end}は、
変換される文字列中の文字位置を指定します。

これらの手続きは、文字列中の文字をランダムにアクセスする場合に便利です。
@c COMMON
@end defun

@defun s32vector->string vec &optional start end
@defunx u32vector->string vec &optional start end
@c EN
Without @var{start} and @var{end}, these procedures work like this:
@c JP
@var{start}と@var{end}を考えなければ、
これらの手続きは次のコードのような動作をします：
@c COMMON
@example
(lambda (vec) (map-to <string> integer->char vec)))
@end example
@c EN
Optional range arguments @var{start} and @var{end} limits
the range of conversion between them.
@c JP
省略可能な範囲引数@var{start}、@var{end}は、
@var{vec}中の変換されるべき範囲を指定します。
@c COMMON
@end defun

@defun uvector-alias uvector-class vec &optional start end
@c EN
This procedure creates an uvector of class @var{uvector-class}
that shares the storage of the given uniform vector @var{vec}.
If optional @var{start} and @var{end} arugments are given,
only the specified range of @var{vec} is used for the new vector.
Since the storage is shared, modification of the original vector
can be seen from the new vector, or vice versa.
@c JP
この手続きは、クラスが@var{uvector-class}であり、
ユニフォームベクタ@var{vec}のメモリ領域を共有するような
新しいユニフォームベクタを作成して返します。
省略可能な引数@var{start}と@var{end}が与えられた場合は
@var{vec}の内容のうちそれらのインデックスで指定される範囲のみが使われます。
メモリ領域が共有されているので、@var{vec}に加える変更は
新しいベクタから見えますし、その逆も可能です。
@c COMMON

@c EN
The class @var{uvector-class} must be either one of the uniform
vector class, but is not necessary match the class of the
source vector @var{vec}.   In such case, the new vector looks at the same
region of @var{vec}'s memory, but interpretes it differently.
For example, the following code determines whether Gauche
is running on big-endian or little-endian machine:
@c JP
クラス@var{uvector-class}はユニフォームベクタのクラスでなければなりませんが、
@var{vec}のクラスと一致している必要はありません。
そのような場合は、新しいベクタは@var{vec}と同じメモリ領域の値を
異なる値と解釈するかもしれません。
例えば、次のコードはGaucheが走っているマシンが
リトルエンディアンであるかビッグエンディアンであるかを判定します。
@c COMMON

@example
(let ((u8v (uvector-alias <u8vector> #u32(1))))
  (if (zero? (u8vector-ref u8v 0))
      'big-endian 
      'little-endian))
@end example

@c EN
If the @var{uvector-class} is other than s8vector or u8vector,
the region the new vector points has to meet the alignment
requirement.  You can assume the beginning of the source vector
is aligned suitable for any uniform vectors.  So, for example,
if you're creating u32vector from u8vector, the @var{start} and
@var{end} must be multiple of 4 (or, if they're omitted, the length
of the original u8vector must be multiple of 4).
An error is signalled when the given parameters doesn't satisfy
alignment constraint.
@c JP
@var{uvector-class}がs8vectorかu8vector以外の場合、
新しいベクタが指す領域は、そのベクタの要素のアラインメントの要請に
したがっていなければなりません。
ユニフォームベクタの開始点は常に全てのユニフォームベクタのアラインメント要請を
満たします。したがって、例えばu8vectorからu32vectorを作成する場合、
@var{start}および@var{end}は4の倍数でなければなりません
(あるいは、@var{start}/@var{end}が省略された場合、@var{vec}の長さが
4の倍数でなければなりません)。
与えられたパラメータでアラインメントの要請が満たせない場合はエラーが通知されます。
@c COMMON
@end defun


@node Uvector numeric operations, Uvector block I/O, Uvector conversion operations, gauche.uvector - Uniform vectors
@subsection Uvector numeric operations
@c NODE ユニフォームベクタの数値演算

@deftp {Function} @var{TAG}vector-add @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-add! @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-sub @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-sub! @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-mul @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-mul! @r{@var{vec} @var{val} &optional @var{clamp}}
@findex s8vector-add
@findex s8vector-add!
@findex s8vector-sub
@findex s8vector-sub!
@findex s8vector-mul
@findex s8vector-mul!
@findex u8vector-add
@findex u8vector-add!
@findex u8vector-sub
@findex u8vector-sub!
@findex u8vector-mul
@findex u8vector-mul!
@findex s16vector-add
@findex s16vector-add!
@findex s16vector-sub
@findex s16vector-sub!
@findex s16vector-mul
@findex s16vector-mul!
@findex u16vector-add
@findex u16vector-add!
@findex u16vector-sub
@findex u16vector-sub!
@findex u16vector-mul
@findex u16vector-mul!
@findex s32vector-add
@findex s32vector-add!
@findex s32vector-sub
@findex s32vector-sub!
@findex s32vector-mul
@findex s32vector-mul!
@findex u32vector-add
@findex u32vector-add!
@findex u32vector-sub
@findex u32vector-sub!
@findex u32vector-mul
@findex u32vector-mul!
@findex s64vector-add
@findex s64vector-add!
@findex s64vector-sub
@findex s64vector-sub!
@findex s64vector-mul
@findex s64vector-mul!
@findex u64vector-add
@findex u64vector-add!
@findex u64vector-sub
@findex u64vector-sub!
@findex u64vector-mul
@findex u64vector-mul!
@findex f32vector-add
@findex f32vector-add!
@findex f32vector-sub
@findex f32vector-sub!
@findex f32vector-mul
@findex f32vector-mul!
@findex f64vector-add
@findex f64vector-add!
@findex f64vector-sub
@findex f64vector-sub!
@findex f64vector-mul
@findex f64vector-mul!
@c EN
Element-wise arithmetic.  @var{Vec} must be a @var{TAG}vector,
and @var{val} must be either a @var{TAG}vector, a vector, or a list
of the same length as @var{vec}, or a number
(an exact integer for integer vectors, 
and a real number for f32- and f64-vectors).
@c JP
要素毎の計算手続きです。@var{vec}は@var{TAG}vectorでなければなりません。
また、@var{val}は@var{vec}と同じ長さの@var{TAG}vectorかベクタかリスト、
あるいは数値(整数ベクタに対しては正確な整数、実数ベクタに対しては実数)
でなければなりません。
@c COMMON

@c EN
If @var{val} is a @var{TAG}vector, its elements are 
added to, subtracted from, or multiplied by the corresponding
elements of @var{vec}, respectively,
and the results are gathered to a @var{TAG}vector 
and returned.  The destructive version (those have bang `!' in the name)
reuses @var{vec} to store the result.
If the result of calculation goes out of the range of @var{TAG}vector's
element, the behavior is specified by @var{clamp} optional argument.
(For f32vector and f64vector, @var{clamp} argument is ignored and
the result may contain infinity).
@c JP
@var{val}が@var{TAG}vectorの場合、
@var{vec}と対応する要素毎に加算、減算、乗算が行われ、
結果が@var{TAG}vectorとして返されます。
破壊的なバージョン(名前に`!'がついているもの)では、@var{vec}が
結果を格納するために再利用されます。
演算の結果が@var{TAG}vectorの要素の値域外になった場合の動作は
省略可能な引数@var{clamp}によって指定されます。
(f32vectorとf64vectorでは、値域外になった要素にはinfinityが格納され、
@var{clamp}の値は無視されます)。
@c COMMON

@c EN
If @var{val} is a number, it is added to, subtracted from, or
multiplied by each element of @var{vec}, respectively.
@c JP
@var{val}が数値である場合、@var{vec}の各要素とその数値の間で演算が行われます。
@c COMMON

@example
(s8vector-add '#s8(1 2 3 4) '#s8(5 6 7 8)) @result{} #s8(6 8 10 12)
(u8vector-sub '#u8(1 2 3 4) '#u8(2 2 2 2)) @result{} @r{error}
(u8vector-sub '#u8(1 2 3 4) '#u8(2 2 2 2) 'both) @result{} #u8(0 0 1 2)

(f32vector-mul '#f32(3.0 2.0 1.0) 1.5) @result{} #f32(4.5 3.0 1.5)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-div @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-div! @r{@var{vec} @var{val}}
@findex f32vector-div
@findex f32vector-div!
@findex f64vector-div
@findex f64vector-div!
@c EN
Element-wise division of flonum vectors.   These are only defined
for f32vector and f64vector.  @var{val} must be a @var{TAG}vector,
a vector or a list of the same length as @var{vec}, or a real number.
@c JP
要素毎の除算です。これらはf32vectorとf64vectorのみに対して定義されます。
@var{val}は@var{vec}と同じ大きさの@var{TAG}vectorかベクタかリスト、
あるいは実数でなければなりません。
@c COMMON

@example
(f32vector-div '#f32(1.0 2.0 3.0) 2.0) @result{} #f32(0.5 1.0 1.5)
@end example
@end deftp


@deftp {Function} @var{TAG}vector-and @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-and! @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-ior @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-ior! @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-xor @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-xor! @r{@var{vec} @var{val}}
@findex s8vector-and
@findex s8vector-and!
@findex s8vector-ior
@findex s8vector-ior!
@findex s8vector-xor
@findex s8vector-xor!
@findex u8vector-and
@findex u8vector-and!
@findex u8vector-ior
@findex u8vector-ior!
@findex u8vector-xor
@findex u8vector-xor!
@findex s16vector-and
@findex s16vector-and!
@findex s16vector-ior
@findex s16vector-ior!
@findex s16vector-xor
@findex s16vector-xor!
@findex u16vector-and
@findex u16vector-and!
@findex u16vector-ior
@findex u16vector-ior!
@findex u16vector-xor
@findex u16vector-xor!
@findex s32vector-and
@findex s32vector-and!
@findex s32vector-ior
@findex s32vector-ior!
@findex s32vector-xor
@findex s32vector-xor!
@findex u32vector-and
@findex u32vector-and!
@findex u32vector-ior
@findex u32vector-ior!
@findex u32vector-xor
@findex u32vector-xor!
@findex s64vector-and
@findex s64vector-and!
@findex s64vector-ior
@findex s64vector-ior!
@findex s64vector-xor
@findex s64vector-xor!
@findex u64vector-and
@findex u64vector-and!
@findex u64vector-ior
@findex u64vector-ior!
@findex u64vector-xor
@findex u64vector-xor!
@c EN
Element-wise logical (bitwise) operation.
These procedures are only defined for integral vectors.
@var{val} must be a @var{TAG}vector, a vector or a list
of the same length as @var{vec},
or an exact integer.  Bitwise and, inclusive or or exclusive or
is calculated between each element in @var{vec} and the corresponding
element of @var{val} (when @var{val} is a non-scalar value),
or @var{val} itself (when @var{val} is an integer).
The result is returned in a @var{TAG}vector.
The destructive version reuses @var{vec} to store the result.
@c JP
要素毎の論理(ビット)演算です。
これらの手続きは整数ベクタに対してのみ定義されています。
@var{val}は@var{vec}と同じ大きさの@var{TAG}vectorかベクタかリスト、
あるいは正確な整数でなければなりません。@var{vec}の各要素と、対応する@var{val}の要素
(@var{val}が非スカラー値の場合)もしくは@var{val}自身
(@var{val}が整数の場合)とのビット毎のand, inclusive orまたはexclusive or
が計算され、結果が@var{TAG}vectorで返されます。
破壊的なバージョン(名前に`!'がついているもの)では、@var{vec}が
結果を格納するために再利用されます。
@c COMMON
@end deftp

@deftp {Function} @var{TAG}vector-dot @r{@var{vec0} @var{vec1}}
@findex s8vector-dot
@findex s16vector-dot
@findex s32vector-dot
@findex s64vector-dot
@findex u8vector-dot
@findex u16vector-dot
@findex u32vector-dot
@findex u64vector-dot
@findex f32vector-dot
@findex f64vector-dot
@c EN
Calculates the dot product of two @var{TAG}vectors.
The length of @var{vec0} and @var{vec1} must be the same.
@c JP
ふたつの@var{TAG}vectorの内積を計算します。
@var{vec0}と@var{vec1}の長さは等しくなければなりません。
@c COMMON
@end deftp

@deftp {Function} @var{TAG}vector-range-check @r{@var{vec} @var{min} @var{max}}
@findex s8vector-range-check
@findex s16vector-range-check
@findex s32vector-range-check
@findex s64vector-range-check
@findex u8vector-range-check
@findex u16vector-range-check
@findex u32vector-range-check
@findex u64vector-range-check
@findex f32vector-range-check
@findex f64vector-range-check
@c EN
@var{Vec} must be a @var{TAG}vector, and each of @var{min} and @var{max}
must be either a @var{TAG}vector, a vector or a list of the same length
as @var{vec}, or a number, or @code{#f}.

For each element in @var{vec}, this procedure checks if the value
is between @var{minval} and @var{maxval} inclusive, where
@var{minval} and @var{maxval} are the corresponding values of
@var{min} and @var{max} (when @var{min} and/or @var{max} is/are
non-scalar value) or @var{min} and @var{max} themselves (when
@var{min} and/or @var{max} is/are a number).
When @var{min} is @code{#f}, negative infinity is assumed.
When @var{max} is @code{#f}, positive infinity is assumed.

If all the elements in @var{vec} are within the range, @code{#f} is
returned.  Otherwise, the index of the leftmost element of @var{vec}
that is out of range is returned.
@c JP
@var{vec}は@var{TAG}vectorでなければなりません。
@var{min}と@var{max}はそれぞれ、@var{vec}と同じ長さの@var{TAG}vector、
ベクタ、リストのいずれかか、実数もしくは@code{#f}でなければなりません。

@var{vec}の各要素に対して、この手続きはそれが対応する@var{minval}と@var{maxval}
の間にあるかどうかを検査します。@var{minval}と@var{maxval}も範囲に含みます。
ここで、@var{minval}と@var{maxval}は、@var{min}/@var{max}が非スカラー値
であれば@var{vec}の要素に対応するそれぞれの要素、
@var{min}/@var{max}が数値であればその数値そのものです。
@var{min}が@code{#f}の場合、最小値はマイナス無限大と考えられます。
@var{max}が@code{#f}の場合、最大値はプラス無限大と考えられます。

@var{vec}の全ての要素が範囲内であった場合は@var{#f}が返されます。
そうでなければ、範囲を外れた要素のうちもっとも左のものの@var{vec}内での
インデックスが返されます。
@c COMMON

@example
(u8vector-range-check '#u8(3 1 0 2) 0 3)  @result{} #f
(u8vector-range-check '#u8(3 1 0 2) 1 3)  @result{} 2

(u8vector-range-check '#u8(4 32 64 98) 0 '#u8(10 40 70 90))
  @result{} 3

;; Range check in a program
(cond
 ((u8vector-range-check u8v 1 31)
  => (lambda (i)
      (errorf "~sth vector element is out of range: ~s"
              i (u8vector-ref u8v i))))
 (else (do-something u8v)))
@end example
@end deftp

@deftp {Function} @var{TAG}vector-clamp @r{@var{vec} @var{min} @var{max}}
@deftpx {Function} @var{TAG}vector-clamp! @r{@var{vec} @var{min} @var{max}}
@findex s8vector-clamp
@findex s16vector-clamp
@findex s32vector-clamp
@findex s64vector-clamp
@findex u8vector-clamp
@findex u16vector-clamp
@findex u32vector-clamp
@findex u64vector-clamp
@findex f32vector-clamp
@findex f64vector-clamp
@findex s8vector-clamp!
@findex s16vector-clamp!
@findex s32vector-clamp!
@findex s64vector-clamp!
@findex u8vector-clamp!
@findex u16vector-clamp!
@findex u32vector-clamp!
@findex u64vector-clamp!
@findex f32vector-clamp!
@findex f64vector-clamp!
@c EN
@var{Vec} must be a @var{TAG}vector, and each of @var{min} and @var{max}
must be either a @var{TAG}vector, a vector or a list of the same length
as @var{vec}, or a number, or @code{#f}.

Like @var{TAG}vector-range-check, these procedures check if
each element of @var{vec} are within the range between @var{minval}
and @var{maxval} inclusive, which are defived from @var{min} and @var{max}.
If the value is less than @var{minval}, it is replaced by @var{minval}.
If the value is grater than @var{maxval}, it is replaced by @var{maxval}.

@var{TAG}vector-clamp creates a copy of @var{vec} and do clamp
operation on it, while @var{TAG}vector-clamp! modifies @var{vec}.
Both return the clamped vector.
@c JP
@var{vec}は@var{TAG}vectorでなければなりません。
@var{min}と@var{max}はそれぞれ、@var{vec}と同じ長さの@var{TAG}vector、
ベクタ、リストのいずれかか、実数もしくは@code{#f}でなければなりません。

@var{TAG}vector-range-checkと同じように、この手続きは@var{vec}の各要素が
@var{min}および@var{max}で指定される最小値と最大値の間にあるかどうかを
検査します。要素が最小値より小さかった場合はそれが最小値に置き換えられます。
要素が最大値より大きかった場合はそれが最大値に置き換えられます。

@var{TAG}vector-clampは@var{vec}のコピーを作ってそれに対して
クランプ操作を行います。@var{TAG}vector-clamp!は@var{vec}を直接
変更します。どちらもクランプ操作が行われた後の@var{TAG}vectorを返します。
@c COMMON

@example
(s8vector-clamp '#s8(8 14 -3 -22 0) -10 10) @result{} #s8(8 10 -3 -10 0)
@end example
@end deftp

@node Uvector block I/O,  , Uvector numeric operations, gauche.uvector - Uniform vectors
@subsection Uvector block I/O
@c NODE ユニフォームベクタのブロック入出力

@c EN
A uniform vector can be seen as an abstraction of a chunk of memory.
So you might want to use it for binary I/O.  Yes, you can do it.
@c JP
ユニフォームベクタは、メモリの固まりを抽象化しているものと考えることも
できます。それなら、それをバイナリI/Oに使えないでしょうか。もちろんできます。
@c COMMON

@defun read-block! vec &optional iport start end
@c EN
Reads a chunk of data from the given input port @var{iport},
and stores it to the uniform vector @var{vec}.
You can give any uniform vector.
If optional @var{start} and @var{end}
arguments are given, they specify the index range in @var{vec}
that is to be filled, and the rest of the vector remains untouched.
Otherwise, entire vector is used.
If @var{iport} is omitted, the current input port is used.
@c JP
与えられた入力ポート@var{iport}からデータの固まりを読みだし、それを
ユニフォームベクタ@var{vec}に格納します。
どんな種類のユニフォームベクタでも与えることができます。
省略可能な引数@var{start}と@var{end}が与えられた場合は、
それらが@var{vec}中でデータが格納されるべき領域のインデックスの範囲を
示します。その範囲外の@var{vec}の値は変更されません。
@var{start}、@var{end}が与えられなかった場合は@var{vec}全体が使われます。
@var{iport}が省略された場合はカレント入力ポートが使われます。
@c COMMON

@c EN
If the input reached EOF before the required region of @var{vec}
is filled, the rest of the vector is untouched.
@c JP
要求された領域を埋め終る前に入力がEOFに達した場合は、ベクタの残りの部分は
変更されません。
@c COMMON

@c EN
If @var{iport} is already reached EOF when @code{read-block!} is
called, an EOF object is returned.  Otherwise,
the procedure returns the number of @emph{elements} read (not bytes).
@c JP
@code{read-block!}が呼ばれた時既に@var{iport}がEOFに達していた場合は
EOFが、そうでなければ読まれた要素の数 (バイト数ではありません) が返されます。
@c COMMON

@c EN
If the @var{iport} is a buffered port with `modest' or `none'
buffering mode (@xref{File ports}), @code{read-block!} may return
before all the elements in @var{vec} is filled, even if @var{iport}
hasn't reached EOF.  The ports connected to a pipe or a network socket
behave so by default.  If you know there will be enough data arriving and
want to make sure @var{vec} is filled, change the buffering mode of
@var{iport} to `full'.
@c JP
@var{iport}がバッファードポートであり、そのバッファリングモードが
`modest' か `none' であった場合、@code{read-block!}は@var{iport}が
EOFに達していなくても、@var{vec}を埋める前に戻ることがあります
(バッファリングモードについては@ref{File ports})を参照して下さい。
パイプやネットワークに接続されたポートはデフォルトでそのように振舞います。
もし、十分なデータが到着することがわかっており、@var{vec}を確実に埋めたい場合は
ポートのバッファリングモードを`full'に変更して下さい。
@c COMMON

@c EN
The data is read as a byte stream, so if you give uniform vectors
other than s8vector or u8vector, your result may affected by
the endianness of the platform.    Suppose the input stream
has a byte sequence @code{#x01, #x02, #x03, #x04}.  If you read
it into u32vector, the first element you'll get may be
@code{#x01020304} if you're using big-endian architecture,
or @code{#x04030201} if you're using little-endian architecture.
@c JP
データはバイトストリームとして読まれるので、
s8vectorとu8vector以外のユニフォームベクタを与えた場合は
結果がプラットフォームのエンディアンに影響を受けることに注意して下さい。
例えば入力が@code{#x01, #x02, #x03, #x04}というバイトシーケンスだったと
します。これをu32vectorに読み込んだ場合、最初の要素は
ビッグエンディアンアーキテクチャでは@code{#x01020304}になりますが、
リトルエンディアンアーキテクチャでは@code{#x04030201}となるでしょう。
@c COMMON
@end defun


@defun write-block vec &optional oport start end
@c EN
Writes out the content of the uniform vector @var{vec} 'as is'
to the output port @var{oport}.   If @var{oport} is omitted,
the current output port is used.
If optional @var{start} and @var{end} arguments are given,
they specify the index range in @var{vec} to be written out.
This procedure returns an unspecified value.
@c JP
ユニフォームベクタ@var{vec}の内容を「そのまま」@var{oport}に書き出します。
@var{oport}が省略された場合はカレント出力ポートが使われます。
省略可能な引数@var{start}と@var{end}が与えられた場合は、
それらのインデックスの範囲が示す@var{vec}の内容のみが出力されます。
この手続きの返す値は未定義です。
@c COMMON

@c EN
If you write out a uniform vector except s8vector and u8vector, the 
care should be taken about the endianness, as in @code{read-block!}.
The number @code{#x01020304} in your u32vector may be written out
as the byte sequence @code{#x01, #x02, #x03, #x04} or
@code{#x04, #x03, #x02, #x01}, depending on your architecture.
@c JP
@code{s8vector}と@code{u8vector}以外のユニフォームベクタを与えた場合、
@code{read-block!}と同じようにエンディアンの影響を受けることに注意して
下さい。u32vector中の数値@code{#x01020304}は、
プラットフォームによってバイトシーケンス@code{#x01, #x02, #x03, #x04}と
なるかもしれませんし、@code{#x04, #x03, #x02, #x01}となるかもしれません。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node gauche.version - Comparing version numbers,  , gauche.uvector - Uniform vectors, Library modules - Gauche extensions
@section @code{gauche.version} - Comparing version numbers
@c NODE gauche.version - バージョン番号の比較, @code{gauche.version} - バージョン番号の比較

@deftp {Module} gauche.version
@mdindex gauche.version
@c EN
This module provides a convenient procedure to compare
@emph{version numbers} or @emph{revision numbers},
such as "@code{0.5.1}", "@code{3.2-3}" or "@code{8.2pl1}".
Usually each release of software component has
a version number, and you can define order between them.
For example, version "1.2.3" is newer than "1.2" and
older than "2.1".   You can compare those version numbers like this:
@c JP
このモジュールは、バージョン番号(リリース番号)を比較する便利な手続きを提供します。
ここでのバージョン番号とはソフトウェアのリリースにつけられる
"@code{0.5.1}"、"@code{3.2-3}"、"@code{8.2pl1}"といった文字列で、
通常これらの番号間には順序関係が定義できます。
例えば "1.2.3" は "1.2" より新しいが "2.1" より古い、といった具合です。
以下のようにこれらの文字列の順序を比較することができるようになります。
@c COMMON

@example
(version<? "2.2.3" "2.2.11")     @result{} #t
(version<? "2.3.1" "2.3")        @result{} #f
(version<? "2.3.1-1" "2.3.1-10") @result{} #t
(version<? "13a" "5b")           @result{} #f
@end example

@c EN
There are no standard way to name versions, so I chose
one convention.   This won't work for all possible
variations, but I think it covers typical cases.
@c JP
バージョン番号の付け方には特に標準というものはありませんが、
よく使われている方法を採用しました。全ての場合に使えるとはいきませんが、
大抵の場合はカバーできるのではないかと思います。
@c COMMON

@c EN
Strictly speaking, you can only define partial order between
version numbers, for there can be branches.   This module
uses simple measure and just assumes the version numbers
can be fully ordered.
@c JP
厳密に言えば、分岐などの場合があるのでバージョン番号間の関係は半順序関係にしかなりません。
このモジュールでは単純な定義を使って、全順序関係があるものとして扱います。
@c COMMON

@c EN
The version number here is defined by the following syntax.
@c JP
まず、ここでのバージョン番号は以下の構文に従うものとします。
@c COMMON
@example
 <version> : <principal-release>
           | <version> <post-subrelease>
           | <version> <pre-subrelease>
 <principal-release> : <relnum>
 <post-subrelease>   : [.-] <relnum>
 <pre-subrelease>    : _ <relnum>
 <relnum>            : [0-9A-Za-z]+
@end example

@c EN
Typically @code{<relnum>} is composed by numeric part and extension part.
For example, "23a" is composed by an integer 23 and extension "a".
If @code{<relnum>} doesn't begins with digits, we assume its
numeric part is -1.
@c JP
通常@code{<relnum>}は数字部分と、それに続く省略可能な拡張部分とからなります。
例えば "@code{23a}" は数字部分23と拡張部分"@code{a}"からなります。
もし@code{<relnum>}が数字で始まらない場合、その数字部分は-1であると考えることにします。
@c COMMON

@c EN
Then, the order of @code{<relnum>} is defined as follows:
@c JP
@code{<relnum>}の順序関係を次のように定義します。
@c COMMON
@enumerate
@item
@c EN
If relnum A and relnum B have different numeric part, we ignore the
extension and order them numerically, e.g.  "@code{3b}" < "@code{4a}".
@c JP
relnum Aとrelnum Bが異なる数字部分を持っている場合、拡張部分を無視して
数字部分を数値として比較します。例："@code{3b}" < "@code{4a}"。
@c COMMON
@item
@c EN
If relnum A and relnum B have the same numeric part, we compare
extension by alphabetically, e.g.  "@code{4c}" < "@code{4d}"
and "@code{5}" < "@code{5a}".
@c JP
relnum Aとrelnum Bの数字部分が等しい場合、拡張部分を辞書順に比較します。
例："@code{4c}" < "@code{4d}"、"@code{5}" < "@code{5a}"。
@c COMMON
@end enumerate

@c EN
Given the order of @code{<relnum>}, the order of version numbers
are defined as follows:
@c JP
@code{<relnum>}間の順序が定義できたところで、バージョン番号の順序を次のように定義します。
@c COMMON
@enumerate
@item
Decompose each version number into a list of @code{<principal-release>} and
subsequence subrelease components.   We call each element of
the list "release components".
@item
If the first release component of both lists are the same,
remove it from both.  Repeat this until the head of the lists differ.
@item
Now we have the following cases.
@enumerate
@item
Both lists are empty: versions are the same.
@item
One list (A) is empty and the other list (B) has post-subrelease
at head: A is prior to B
@item
One list (A) is empty and the other list (B) has pre-subrelease
at head: B is prior to A
@item
List A's head is post-subrelease and list B's head is
pre-subrelease: B is prior to A
@item
Both lists have post-subrelease or pre-subrelease at head:
compare their relnums.
@end enumerate
@end enumerate

Here are some examples:
@example
"1" < "1.0" < "1.1" < "1.1.1" < "1.1.2" < "1.2" < "1.11"
"1.2.3" < "1.2.3-1" < "1.2.4"
"1.2.3" < "1.2.3a" < "1.2.3b"
"1.2_rc0" < "1.2_rc1" < "1.2" < "1.2-pl1" < "1.2-pl2"
"1.1-patch112" < "1.2_alpha"
@end example

The reason of having @code{<pre-subrelease>} is to allow
"release candidate" or "pre-release" version.
@end deftp

@defun version=? ver1 ver2
@defunx version<? ver1 ver2
@defunx version<=? ver1 ver2
@defunx version>? ver1 ver2
@defunx version>=? ver1 ver2
Returns a boolean value depending on the order of two version number
string @var{ver1} and @var{ver2}.  If the arguments contain invalid
strings as the defined version number, an error is signalled.
@end defun

@defun version-compare ver1 ver2
Compares two version number strings @var{ver1} and @var{ver2},
and returns either -1, 0, or 1, depending whether @var{ver1} is
prior to @var{ver2}, @var{ver1} is the same as @var{ver2}, or
@var{ver1} is after @var{ver2}, respectively.
@end defun

@defun relnum-compare rel1 rel2
This is lower-level procedure of @code{version-compare}.  Compares
two release numbers (relnums) @var{rel1} and @var{rel2}, 
and returns either -1, 0, or 1 depending whether  @var{rel1} is
prior to @var{rel2}, @var{rel1} is the same as @var{rel2}, or
@var{rel1} is after @var{rel2}, respectively.
@end defun

@c ======================================================================
@node Library modules - SRFIs, Library modules - Utilities, Library modules - Gauche extensions, Top
@chapter Library modules - SRFIs
@c NODE ライブラリモジュール - SRFI

@c EN
This chapter lists modules that provides SRFI functionalities.
Note that some of SRFI features are built in Gauche core and
not listed here.  @xref{Standard conformance}, for entire list
of supported SRFIs.
@c JP
この章ではSRFIの機能を提供するモジュールをリストします。
一部のSRFIはGaucheのコアに組み込まれており、
この章には挙げられていないことに注意して下さい。
サポートされている全てのSRFIのリストは@ref{Standard conformance}にあります。
@c COMMON

@c ----------------------------------------------------------------------
@menu
* srfi-0 - Feature conditional::  
* srfi-1 - List library::       
* srfi-2 - And-let*::           
* srfi-4 - Homogeneous vectors::  
* srfi-9 - Record types::       
* srfi-11 - Let-values::        
* srfi-13 - String library::    
* srfi-14 - Character-set library::  
* srfi-19 - Time data types and procedures::  
* srfi-27 - Sources of random bits::  
* srfi-37 - a program argument processor::  
@end menu

@node srfi-0 - Feature conditional, srfi-1 - List library, Library modules - SRFIs, Library modules - SRFIs
@section @code{srfi-0} - Feature conditional

@deftp {Module} srfi-0
@mdindex srfi-0
Provides SRFI-0 @code{cond-expand} macro form.
Now this module is autoloaded when @code{cond-expand} is used,
so you don't need to say @code{(use srfi-0)} explicitly; it is required to
write a portable Scheme program.
@end deftp

@defmac cond-expand (feature-requirement command-or-definition @dots{}) @dots{}
[SRFI-0]
This macro expands to @var{command-or-definition} @dots{} if Gauche
supports @var{feature-requirement}.
In a way, it can be used to absorb the different feature sets supported by
different Scheme implementations.

@var{feature-requiremnt} must be in the following syntax:
@example
@var{feature-requirement}
  : @var{feature-identifier}
  | (and @var{feature-requirement} @dots{})
  | (or  @var{feature-requirement} @dots{})
  | (not @var{feature-requirement})
@end example

@var{feature-identifier} is a symbol that indicates a feature.
If such a feature is supported in Gauche, it satisfies the
@var{feature-requirement}.  You can do boolean combination
of @var{feature-requirement}s to compose more complex conditions.

The macro tests each @var{feature-requirement} in order, and
if one is satisfied, the macro itself expands to the
corresponding @var{command-or-definition} @dots{}.

The last clause may begin with a symbol @code{else} instead of
@var{feature-requirement}.  If no condition is fulfilled before
it, then the macro expands to the @var{command-or-definition}s
of the else clause.  If there's no else clause and no condition
is fulfilled, an error is signalled.

Currently, Gauche recognizes srfi names (e.g. @code{srfi-1})
that it supports (@xref{Standard conformance}, for the list of
supported SRFIs), and a symbol @code{gauche} as @var{feature-identifier}.

Suppose you are writing a program that requires srfi-13 (string library).
In Gauche, the standard way to use srfi-13 is like this:

@example
(use srfi-13)

;; ... your program ...
@end example

However, the 'use' macro is Gauche specific and won't work
on other Scheme implementations.  You can write instead:

@example
(cond-expand
  (srfi-13
    ;; ... your program ...
  ))
@end example

If the implementation supports @code{srfi-13}, the form expands
to your program.  Note that Gauche issues @code{(use srfi-13)}
for you in this case.

The above form signals an error if the implementation doesn't support
srfi-13.  However, you might want to run your program on such implentations
as well, by providing alternative library definitions.

@example
(cond-expand
 (srfi-13
   ;; ... your program ...
 )
 (else
   (load "my-srfi-13-implementation")
   ;; ... your program ...
 ))
@end example
@end defmac

@c ----------------------------------------------------------------------
@node srfi-1 - List library, srfi-2 - And-let*, srfi-0 - Feature conditional, Library modules - SRFIs
@section @code{srfi-1} - List library

@deftp {Module} srfi-1
@mdindex srfi-1
SRFI-1 is a rich collection of list manipulation library
(@ref{srfi-1,[SRFI-1],SRFI-1}).
It is available by saying @code{(use srfi-1)}.
The implementation is based on Olin Shivers's reference implementation.
I splitted it into number of subfiles that will be autoloaded on demand.
@end deftp

@menu
* SRFI-1 List constructors::    
* SRFI-1 List predicates::      
* SRFI-1 List selectors::       
* SRFI-1 List miscellaneous routines::  
* SRFI-1 Fold::                 
* SRFI-1 Filtering & Partitioning::  
* SRFI-1 Searching::            
* SRFI-1 Deletion::             
* SRFI-1 Association lists::    
* SRFI-1 set operations::       
@end menu

@node SRFI-1 List constructors, SRFI-1 List predicates, srfi-1 - List library, srfi-1 - List library
@subsection List constructors

@defun xcons cd ca
[SRFI-1] Equivalent to @code{(cons ca cd)}.  Useful to pass to
higher-order procedures.
@end defun

@defun cons* elt1 elt2 @dots{}
[SRFI-1] Like @code{list}, but the last argument provides the tail of
the constructed list.  This is just a synonym of Gauche built-in procedure
@code{list*}.
@example
(cons* 1 2 3 4) @result{} (1 2 3 . 4)
(cons* 1) @result{} 1
@end example
@end defun

@defun list-tabulate n init-proc
[SRFI-1] Constructs an @var{n}-element list, in which
each element is generated by @code{(@var{init-proc} @i{i})}.
@example
(list-tabulate 4 values) @result{} (0 1 2 3)
@end example
@end defun

@defun circular-list elt1 elt2 @dots{}
[SRFI-1] Constructs a circular list of the elements.
@example
(circular-list 'z 'q) @result{} (z q z q z q @dots{})
@end example
@end defun

@defun iota count &optional (start 0) (step 1)
[SRFI-1] Returns a list of numbers, starting from @var{start},
increasing by @var{step}.
@example
(iota 5) @result{} (0 1 2 3 4)
(iota 5 0 -0.1) @result{} (0 -0.1 -0.2 -0.3 -0.4)
@end example
@end defun

@node SRFI-1 List predicates, SRFI-1 List selectors, SRFI-1 List constructors, srfi-1 - List library
@subsection List predicates

@defun proper-list? x
[SRFI-1] Returns @code{#t} if x is a proper list.
@end defun

@defun circular-list? x
[SRFI-1] Returns @code{#t} if x is a circular list.
@end defun

@defun dotted-list? x
[SRFI-1] Returns @code{#t} if x is a finite, non-nil-terminated list.
This includes non-pair, non-() values (e.g. symbols, numbers),
which are considered to be dotted lists of length 0.
@end defun

@defun null-list? list
[SRFI-1] Returns @code{#t} if @var{list} is the empty list @code{()},
and @var{#f} if @var{list} is a non-null, proper or circular list.
This procedure signals an error if @var{list} is not a proper
or circular list.
@end defun

@defun not-pair? x
[SRFI-1] @code{(lambda (x) (not (pair? x)))}.

SRFI-1 says: Provided as a procedure as it can be useful as
the termination condition for list-processing procedures that wish to
handle all finite lists, both proper and dotted. 
@end defun

@defun list= elt= list @dots{}
[SRFI-1] Determines list equality by comparing every n-th element
of given lists by the procedure @var{elt=}.

It is an error to apply @code{list=} to anything except proper lists.

The equality procedure must be consistent with @code{eq?}, i.e.
@example
(eq? x y) @result{} (elt= x y).
@end example
@end defun

@node SRFI-1 List selectors, SRFI-1 List miscellaneous routines, SRFI-1 List predicates, srfi-1 - List library
@subsection List selectors

@defun  first pair
@defunx second pair
@defunx third pair
@defunx fourth pair
@defunx fifth pair
@defunx sixth pair
@defunx seventh pair
@defunx eighth pair
@defunx ninth pair
@defunx tenth pair
[SRFI-1] Returns n-th element of the (maybe improper) list.
@end defun

@defun car+cdr pair
[SRFI-1] Returns two values, @code{(car pair)} and @code{(cdr pair)}.
@end defun

@defun take x i
@defunx drop x i
[SRFI-1] @code{take} returns the first i elements of list x.
@code{drop} returns all but the first i elements of list x. 
@example
(take '(a b c d e)  2) => (a b)
(drop '(a b c d e)  2) => (c d e)
@end example
@var{x} may be any value:
@example
(take '(1 2 3 . d) 2) => (1 2)
(drop '(1 2 3 . d) 2) => (3 . d)
(drop '(1 2 3 . d) 3) => d
@end example
@code{drop} is exactly equivalent to performing @var{i} cdr operations
on @var{x}.  The returned value shares a common tail with @var{x}.
On the other hand, take always allocates a new list 
for result if the argument is a list of non-zero length.

An error is signalled if @var{i} is past the end of list @var{x}.
@xref{util.list - Additional list library}, for more tolerant version
of @code{take} and @code{drop}.
@end defun

@defun take-right flist i
@defunx drop-right flist i
[SRFI-1] @code{take-right} returns the last @var{i} elements of @var{flist}.
@code{drop-right} returns all but the last @var{i} elements of @var{flist}. 
@example
(take-right '(a b c d e) 2) => (d e)
(drop-right '(a b c d e) 2) => (a b c)
@end example
@var{flist} may be any finite list.
@example
(take-right '(1 2 3 . d) 2) => (2 3 . d)
(drop-right '(1 2 3 . d) 2) => (1)
(take-right '(1 2 3 . d) 0) => d
(drop-right '(1 2 3 . d) 0) => (1 2 3)
@end example
@code{take-right}'s return value always shares a common
tail with @var{flist}.
@code{drop-right} always allocates a new list
if the argument is a list of non-zero length.

An error is signalled if @var{i} is larger than the length of @var{flist}.
@xref{util.list - Additional list library}, for more tolerant version
of @code{take-right} and @code{drop-right}.
@end defun

@defun take! x i
@defunx drop-right! x i
[SRFI-1]  Linear update variants of @var{take} and @var{drop-right}.
Those procedures may destructively modifies @var{x}.

If @var{x} is circular, @code{take!} may return a list
shorter than expected.
@end defun

@defun split-at x i
@defunx split-at! x i
[SRFI-1] @code{split-at} splits the list @var{x} at index @var{i},
returning a list of the first @var{i} elements, and the remaining tail.
@example
(split-at '(a b c d e) 2) @result{} (a b) (c d e)
@end example
@code{split-at!} is the linear-update variant. It may destructively
modifes @var{x} to produce the result. 
@end defun

@defun last pair
[SRFI-1] Returns the last element of the non-empty, finite list @var{pair}.
It is equivalent to @code{(car (last-pair pair))}.
Note that @code{last-pair} is Gauche built-in procedure.
@end defun

@node SRFI-1 List miscellaneous routines, SRFI-1 Fold, SRFI-1 List selectors, srfi-1 - List library
@subsection List miscellaneous routines

@defun length+ x
[SRFI-1] If @var{x} is a proper list, returns its length.
Otherwise, returns @code{#f}.
@end defun

@defun concatenate list-of-lists
@defunx concatenate! list-of-lists!
[SRFI-1] Equivalent to @code{(apply append @var{list-of-lists})} and
@code{(apply append! @var{list-of-lists})}, respectively.
@end defun

@defun append-reverse rev-head tail
@defunx append-reverse! rev-head tail
[SRFI-1] @code{append-reverse} returns @code{(append (reverse rev-head) tail)}.
@code{append-reverse!} is the linear-update variant.
@end defun

@defun zip clist1 clist2 @dots{}
[SRFI-1] Equivalent to @code{(map list clist1 clist2 @dots{})}.
If @code{zip} is passed @var{n} lists, it returns a list as long as
the shortest of these lists, each element of which is an @var{n}-element list
comprised of the corresponding elements from the parameter lists. 
@example
(zip '(one two three) 
     '(1 2 3)
     '(odd even odd even odd even odd even))
     @result{} ((one 1 odd) (two 2 even) (three 3 odd))

(zip '(1 2 3)) @result{} ((1) (2) (3))
@end example
At least one of the argument lists must be finite: 
@example
(zip '(3 1 4 1) (circular-list #f #t)) 
     @result{} ((3 #f) (1 #t) (4 #f) (1 #t))
@end example
@end defun

@defun unzip1 list
@defunx unzip2 list
@defunx unzip3 list
@defunx unzip4 list
@defunx unzip5 list
[SRFI-1] @code{unzip1} takes a list of lists, where every list must
contain at least one element, and returns a list containing the
initial element of each such list.
@code{unzip2} takes a list of lists, where every list
must contain at least two elements, and returns two values:
a list of the first elements, and a list of the second
elements. @code{unzip3} does the same for the first
three elements of the lists, and so on.
@example
(unzip2 '((1 one) (2 two) (3 three))) @result{}
   (1 2 3) @r{and}
   (one two three)
@end example
@end defun

@defun count pred clist1 clist2 @dots{}
[SRFI-1] A procedure @var{pred} is applied to the @var{n}-th element
of given lists, from @var{n} is zero to the length of the
the shortest finite list in the given lists,
and the count of times @var{pred} returned true is returned.
@example
(count even? '(3 1 4 1 5 9 2 5 6)) @result{} 3
(count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)) @result{} 3
@end example
At least one of the argument lists must be finite: 
@example
(count < '(3 1 4 1) (circular-list 1 10)) @result{} 2
@end example
@end defun

@defun count$ pred
Partial application version of @code{count}
@example
((count$ pred) arg @dots{}) === (count pred arg @dots{})
@end example
@end defun

@node SRFI-1 Fold, SRFI-1 Filtering & Partitioning, SRFI-1 List miscellaneous routines, srfi-1 - List library
@subsection List fold, unfold & map

@defun fold kons knil clist1 clist2 @dots{}
[SRFI-1] The fundamental list iterator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@example
(@var{kons} @var{en} @dots{} (@var{kons} @var{e2} (@var{kons} @var{e1} @var{knil})) @dots{} ) 
@end example

If @var{n} list arguments are provided, then the @var{kons}
function must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples:
@example
(fold + 0 '(3 1 4 1 5 9)) @result{} 23 ;@r{sum up the elements}
(fold cons '() '(a b c d e)) @result{} (e d c b a) ;@r{reverse}
(fold cons* '() '(a b c) '(1 2 3 4 5))
    @result{} (c 3 b 2 a 1) ;@r{n-ary case}
@end example
@end defun

@defun fold-right kons knil clist1 clist2 @dots{}
[SRFI-1] The fundamental list recursion operator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@example
(@var{kons} @var{e1} (@var{kons} @var{e2} @dots{} (@var{kons} @var{en} @var{knil})))
@end example

If @var{n} list arguments are provided, then the @var{kons} function
must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples: 
@example
(fold-right cons '() '(a b c d e))
   @result{} (a b c d e) ;@r{copy list}
(fold-right cons* '() '(a b c) '(1 2 3 4 5))
   @result{} (a 1 b 2 c 3) ;@r{n-ary case}
@end example
@end defun

@defun pair-fold kons knil clist1 clist2 @dots{}
@defunx pair-fold-right kons knil clist1 clist2 @dots{}
[SRFI-1] 
Like @code{fold} and @code{fold-right}, but the procedure @var{kons}
gets each @code{cdr} of the given @var{clist}s, instead of @code{car}.
@end defun

@defun reduce f ridentity list
@defunx reduce-right f ridentity list
[SRFI-1]
Variant of @code{fold} and @code{fold-right}.   @var{F} must be a
binary operator, and @var{ridentity} is the value such that for
any value @var{x} that is valid as @var{f}'s input,
@example
 (f x ridentity) @equiv{} ridentity
@end example

These functions effectively do the same thing as @code{fold} or
@code{fold-right}, respectively, but omit application of @var{f}
when @var{list} contains exactly one element, using the nature of
@var{ridentity}.
@end defun

@defun unfold p f g seed &optional tail-gen
[SRFI-1]
Fundamental recursive list constructor.
Defined by the following recursin.

@example
(unfold p f g seed tail-gen) @equiv{}
   (if (p seed)
       (tail-gen seed)
       (cons (f seed)
             (unfold p f g (g seed))))
@end example
That is, @var{p} determines where to stop, @var{g} is used to generate
successive seed value from the current seed value, and @var{f} is used
to map each seed value to a list element.
@end defun

@defun unfold-right p f g seed &optional tail
[SRFI-1]
Fundamental iterative list constructor.
Defined by the following recursin.

@example
(unfold-right p f g seed tail) @equiv{}
  (let lp ((seed seed) (lis tail))
    (if (p seed)
        lis
        (lp (g seed) (cons (f seed) lis))))
@end example
@end defun

@defun append-map f clist1 clist2 @dots{}
@defunx append-map! f clist1 clist2 @dots{}
[SRFI-1]
Equivalent to
@example
  (apply append (map @var{f} @var{clist1} @var{clist2} @dots{}))
  (apply append! (map @var{f} @var{clist1} @var{clist2} @dots{}))
@end example
At least one of the list arguments must be finite. 
@end defun

@defun map! f list1 clist2 @dots{}
[SRFI-1]
The procedure @var{f} is applied to each element of @var{list1} and
corresponding elements of @var{clist}s, and the result is collected
to a list.  Celss in @var{list1} is reused to construct the result list.
@end defun

@defun map-in-order f clist1 clist2 @dots{}
[SRFI-1] A variant of @code{map}, but it guarantees to apply @var{f}
on each elements of arguments in a left-to-right order.
Since Gauche's @code{map} implementation follows the same order,
this function is just a synonym of @code{map}.
@end defun

@defun pair-for-each f clist1 clist2 @dots{}
[SRFI-1]
Like @var{for-each}, but the procedure @var{f} is applied on each @code{cdr}
of @var{clist}s.
@end defun

@defun filter-map  f clist1 clist2 @dots{}
[SRFI-1]
Like @code{map}, but only true values are saved.
At least one of the list arguments must be finite. 
@example
(filter-map (lambda (x) (and (number? x) (* x x)))
            '(a 1 b 3 c 7))
  @result{} (1 9 49)
@end example
@end defun

@defun fold$ kons &optional knil
@defunx fold-right$ kons &optional knil
@defunx reduce$ f &optional ridentity
@defunx reduce-right$ f &optional ridentity
Partial application versions of @code{fold}, @code{fold-right},
@code{reduce}, and @code{reduce-right}.
@end defun

@node SRFI-1 Filtering & Partitioning, SRFI-1 Searching, SRFI-1 Fold, srfi-1 - List library
@subsection List filtering & partitioning

@defun filter pred list
@defunx filter! pred list
[SRFI-1] A procedure @var{pred} is applied on each element of @var{list},
and a list of elements that @var{pred} returned true on it is returned.
@example
(filter odd? '(3 1 4 5 9 2 6)) @result{} (3 1 5 9)
@end example
@code{filter!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@defun remove pred list
@defunx remove! pred list
[SRFI-1] A procedure @var{pred} is applied on each element of @var{list},
and a list of elements that @var{pred} returned false on it is returned.
@example
(remove odd? '(3 1 4 5 9 2 6)) @result{} (4 2 6)
@end example
@code{remove!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@defun partition pred list
@defunx partition! pred list
[SRFI-1] @code{filter} and @code{remove} simultaneously, i.e. 
returns two lists, the first is the result of filtering elements of
@var{list} by @var{pred}, and the second is the result of
removing elements of @var{list} by @var{pred}.
@example
(partition odd? '(3 1 4 5 9 2 6))
  @result{} (3 1 5 9) (4 2 6)
@end example
@code{partition!} is the linear-update variant.  It may destructively
modifies @var{list} to produce the result.
@end defun

@defun filter$ pred
@defunx remove$ pred
@defunx partition$ pred
Partial application versions of @code{filter}, @code{remove} and
@code{partition}.
@end defun


@node SRFI-1 Searching, SRFI-1 Deletion, SRFI-1 Filtering & Partitioning, srfi-1 - List library
@subsection List searching

@defun find pred clist
[SRFI-1] Applies @var{pred} for each element of @var{clist}, from 
left to right, and returns the first element that @var{pred} returns
true on.
@end defun

@defun find-tail pred clist
[SRFI-1]
Applies @var{pred} for each element of @var{clist}, from left to right,
and when @var{pred} returns a true value, returns the pair whose car
is the element.
@end defun

@defun take-while pred clist
@defunx take-while! pred list
[SRFI-1]
Returns the longest initial prefix of @var{clist} whose elements all
satisfy @var{pred}.
@end defun

@defun drop-while pred clist
[SRFI-1]
Drops the longest initial prefix of @var{clist} whose elements all
satisfy @var{pred}, and returns the rest.
@end defun

@defun span pred clist
@defunx span! pred list
@defunx break pred clist
@defunx break! pred list
[SRFI-1]
@code{span} is equivalent to
@code{(values (take-while pred clist) (drop-while pred clist))}.
@code{break} inverts the sense of @var{pred}.
@end defun

@defun any pred clist1 clist2 @dots{}
[SRFI-1]
Applies @var{pred} across each element of @var{clist}s, and
returns true if any application of @var{pred} returns true.
The returned value is the true value @var{pred} returned.
@end defun

@defun every pred clist1 clist2 @dots{}
[SRFI-1]
Applies @var{pred} across each element of @var{clist}s, and
returns true if every application of @var{pred} returns true.
If all applications returns a true value until one of the lists
is exhausted, @code{every} returns the value the last @var{pred}
returned.
@end defun

@defun list-index pred clist1 clist2 @dots{}
[SRFI-1]
Returns the index of the leftmost element that satisfies @var{pred}.
@end defun

@defun member$ item
@defunx find$ pred
@defunx find-tail$ pred
@defunx any$ pred
@defunx every$ pred
Partial application version of @code{member}, @code{find}, @code{find-tail},
@code{any} and @code{every}.
@end defun

@node SRFI-1 Deletion, SRFI-1 Association lists, SRFI-1 Searching, srfi-1 - List library
@subsection List deletion

@defun delete x list &optional elt=
@defunx delete! x list &optional elt=
[SRFI-1]
Equivalent to
@example
  (remove (lambda (y) (elt= x y)) list)
  (remove! (lambda (y) (elt= x y)) list)
@end example
The comparison procedure, @var{elt=}, defaults to @code{equal?}.
@end defun

@defun delete$ x
Partial application version of @code{delete}.
@end defun

@defun delete-duplicates list &optional elt=
@defunx delete-duplicates! list &optional elt=
[SRFI-1]
Removes duplicate elements from @var{list}.
If there are multiple equal elements in @var{list},
the result list only contains the first or leftmost of these
elements in the result. The order of these surviving elements
is the same as in the original list.
The comparison procedure, @var{elt=}, defaults to @code{equal?}.
@end defun

@node SRFI-1 Association lists, SRFI-1 set operations, SRFI-1 Deletion, srfi-1 - List library
@subsection Association lists

@defun alist-cons key datum alist
[SRFI-1] Returns @code{(cons (cons @var{key} @var{datum}) @var{alist})}.
This is an alias of the Gauche builtin procedure @code{acons}.
@end defun

@defun alist-copy alist
[SRFI-1] Returns a fresh copy of @var{alist}.
@end defun

@defun alist-delete key alist &optional =
@defunx alist-delete! key alist &optional =
[SRFI-1]
@end defun

@defun assoc$ item
Partial application version of @code{assoc}.
@end defun

@node SRFI-1 set operations,  , SRFI-1 Association lists, srfi-1 - List library
@subsection Lists as sets

These procedures use lists as a set.

@defun lset@code{<=} elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset= elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-adjoin elt= list elt @dots{}
[SRFI-1]
@end defun

@defun lset-union elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset-intersection elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-difference elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-xor elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset-diff+intersection elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-union! elt= list @dots{}
@defunx lset-intersection! elt= list1 list2 @dots{}
@defunx lset-difference! elt= list1 list2 @dots{}
@defunx lset-xor! elt= list1 @dots{}
@defunx lset-diff+intersection! elt= list1 list2 @dots{}
[SRFI-1]
Linear update variant of the corresponding procedures.
The cells in the first list argument may be reused to construct the result.
@end defun

@c ----------------------------------------------------------------------
@node srfi-2 - And-let*, srfi-4 - Homogeneous vectors, srfi-1 - List library, Library modules - SRFIs
@section @code{srfi-2} - And-let*

@deftp {Module} srfi-2
@mdindex srfi-2
@c EN
Provides SRFI-2 @code{and-let*} macro.
@c JP
SRFI-2の@code{and-let*}マクロを提供します。
@c COMMON
@end deftp

@defmac and-let* (binding @dots{}) body @dots{}
[SRFI-2]
@c EN
In short, it works like @code{let*}, but returns #f immediately
whenever the expression in @var{binding}s evaluates to #f.
@c JP
簡単に言うと、このフォームは@code{let*}のように動作しますが、
@var{bindings}中の式が@code{#f}に評価されたらそこで評価を打ち切り
@code{#f}を返します。
@c COMMON

@c EN
Each @var{binding} should be one of the following form:
@c JP
各@var{binding}は以下のいずれかの形式でなければなりません。
@c COMMON
@table @var
@item (variable expression)
@c EN
The @var{expression} is evaluated; if it yields true value, the value
is bound to @var{variable}, then proceed to the next binding.  If
no more bindings, evaluates @var{body} @dots{}.   If @var{expression}
yieds @code{#f}, stops evaluation and returns @code{#f} from @code{and-let*}.
@c JP
@var{expression}が評価されます。それが真の値を返したら、その値が@var{variable}
に束縛され、次の@var{binding}へと進みます。もう@var{binding}が無ければ
@var{body} @dots{}が評価されます。もし@var{expression}が@code{#f}を返したら、
評価を打ち切り、@code{and-let*}から@code{#f}を返します。
@c COMMON
@item (expression)
@c EN
In this form, @var{variable} is omitted.  @var{Expression} is evaluated
and the result is used just to determine whether we continue or
stop further evaluation.
@c JP
この形式では@var{variable}が省略されています。@var{Expression}が評価され、
その結果は評価を続行するか打ち切るかを判断するためにのみ使われます。
@c COMMON
@end table

@c EN
Let's see some examples.  The following code searches @var{key}
from an assoc-list @var{alist} and returns its value if found.
@c JP
いくつか例を挙げます。次のコードは連想リスト@var{alist}から@var{key}を
探し、見つかったらその値を返します。
@c COMMON
@example
(and-let* ((entry (assoc key alist))) (cdr entry))
@end example

@c EN
If @var{arg} is a string representation of an exact integer, returns its value;
otherwise, returns 0:
@c JP
もし@var{arg}が正確な整数の文字列表現だった場合は@var{num}を返し、そうでなければ
0を返します：
@c COMMON
@example
(or (and-let* ((num (string->number arg))
               ((exact? num))
               ((integer? num)))
      num)
    0)
@end example

@c EN
The following is a hypothetical code that searches a certain server port
number from a few possibilities (environment variable, configuration file,
...)
@c JP
以下のコードはとあるサーバーのポート番号をいくつかの可能性
(環境変数、設定ファイル…)の中から探す仮想的なコードです。
@c COMMON
@example
(or (and-let* ((val (sys-getenv "SERVER_PORT")))
      (string->number val))
    (and-let* ((portfile (expand-path "~/.server_port"))
               ((file-exists? portfile))
               (val (call-with-input-string portfile port->string)))
      (string->number val))
    8080) ; default
@end example

@end defmac

@c ----------------------------------------------------------------------
@node srfi-4 - Homogeneous vectors, srfi-9 - Record types, srfi-2 - And-let*, Library modules - SRFIs
@section @code{srfi-4} - Homogeneous vectors
@c NODE srfi-4 - 単一型のベクタ, @code{srfi-4} - 単一型のベクタ

@deftp {Module} srfi-4
@mdindex srfi-4
SRFI-4 is now implemented in @code{gauche.uvector} module
@xref{gauche.uvector - Uniform vectors}.
This module simply inherits @code{gauche.uvector} for backward-compatibility.
@end deftp

@c ----------------------------------------------------------------------
@node srfi-9 - Record types, srfi-11 - Let-values, srfi-4 - Homogeneous vectors, Library modules - SRFIs
@section @code{srfi-9} - Record types

@deftp {Module} srfi-9
@mdindex srfi-9
Contains a macro to use record types.  A record type is implemented on
top of Gauche's object system.

The SRFI-9 record type is not as powerful as the object system, but
it will be useful if you want your program to be portable.
@end deftp

@defmac define-record-type name (constructor init-tag @dots{}) predicate (field accessor [modifier]) @dots{}
Creates a record type and binds it to @var{name}.
In Gauche, a record type is just a subclass of @code{<record>}.

@var{constructor} is bound to a procedure that creates an instance
of the record type,
which takes as many arguments as @var{init-tag} @dots{}.  Each
@var{init-tag} corresponds to one of the field name, and the fields
of the created record instance is initialized accordingly.  Not all
of fields need to appear in @var{init-tag}; uninitialized fields remain
unbound.

@var{predicate} is bound to a procedure that takes one argument, and
returns #t if the argument is an instance of the defined record type,
#f otherwise.

Followings are field specifications.  The record has fields
@var{field} @dots{}, and each field can be accessed by a method
@var{accessor}.  If @var{modifier} is given to the field, it is bound
to a method that sets the value to the field.

Example:
@example
(define-record-type pare
  (kons x y) pare?
  (x kar set-kar!)
  (y kdr))
 @result{} #<class pare>

(pare? (kons 2 3)) @result{} #t
(pare? (cons 2 3)) @result{} #f

(kar (kons 2 3)) @result{} 2
(kdr (kons 2 3)) @result{} 3

(let ((x (kons 2 3)))
  (set-kar! x -1)
  (kar x)) @result{} -1
@end example

Conceptually, the above example is expanded into the following
sequence of forms.
@example
(define-class pare (<record>) (x y))
(define (kons x y)
  (let ((obj (make pare)))
    (slot-set! obj 'x x) 
    (slot-set! obj 'y y)
    obj))
(define (pare? obj) (is-a? obj pare))
(define-method kar ((obj pare))
  (slot-ref obj 'x))
(define-method set-kar! ((obj pare) value)
  (slot-set! obj 'x value))
(define-method kdr ((obj pare))
  (slot-ref obj 'y))
@end example

@end defmac

@c ----------------------------------------------------------------------
@node srfi-11 - Let-values, srfi-13 - String library, srfi-9 - Record types, Library modules - SRFIs
@section @code{srfi-11} - Let-values

@deftp {Module} srfi-11
@mdindex srfi-11
Defines two macros, @code{let-values} and @code{let*-values}.
They are convenient to use with multiple values (@ref{srfi-11,,[SRFI-11]}).


@end deftp

@defmac let-values ((vars expr) @dots{}) body @dots{}
[SRFI-11]
@var{vars} are a list of variables. @var{expr} is evaluated, and
its first return value is bound to the first variable in @var{vars},
its second return value to the second variable, and so on, then
@var{body} is evaluated.
The scope of @var{expr}s are the outside of @code{let-values} form,
like @code{let}.

@example
(let-values (((a b) (values 1 2))
             ((c d) (values 3 4)))
  (list a b c d)) @result{} (1 2 3 4)

(let ((a 1) (b 2) (c 3) (d 4))
  (let-values (((a b) (values c d))
               ((c d) (values a b)))
    (list a b c d))) @result{} (3 4 1 2)
@end example

@var{vars} can be a dotted list or a single symbol, like the
lambda parameters.

@example
(let-values (((x . y) (values 1 2 3 4)))
  y) @result{} (2 3 4)

(let-values ((x (values 1 2 3 4)))
  x) @result{} (1 2 3 4)
@end example

If the number of values returned by @var{expr} doesn't match
what @var{vars} expects, an error is signalled.
@end defmac

@defmac let*-values ((vars expr) @dots{}) body @dots{}
[SRFI-11]
Same as @code{let-values}, but each @var{expr}'s scope includes
the preceding @var{vars}.

@example
(let ((a 1) (b 2) (c 3) (d 4))
  (let*-values (((a b) (values c d))
                ((c d) (values a b)))
    (list a b c d))) @result{} (3 4 3 4)
@end example
@end defmac

@c ----------------------------------------------------------------------
@node srfi-13 - String library, srfi-14 - Character-set library, srfi-11 - Let-values, Library modules - SRFIs
@section @code{srfi-13} - String library

@deftp {Module} srfi-13
@mdindex srfi-13
Defines a large set of string-related functions.
In Gauche, those functions are splitted to number of files
and the form @code{(use srfi-13)} merely sets up autoloading of
those files.  So it is not likely to slow down the script startup.

See SRFI-13 (@ref{srfi-13, [SRFI-13], SRFI-13})
for the detailed specification and discussion of design issues.
This manual serves as a reference of function API.
Some SRFI-13 functions are Gauche built-in and not listed here.

Note: SRFI-13 documents suggests the name of the module that
implements these functions to be ``string-lib'' and ``string-lib-internals''.
Gauche uses the name ``srfi-13'' for consistency.
@end deftp

@menu
* SRFI-13 General conventions::  
* SRFI-13 String predicates::   
* SRFI-13 String Constructors::  
* SRFI-13 String Selection::    
* SRFI-13 String Comparison::   
* SRFI-13 String Prefixes & Suffixes::  
* SRFI-13 String searching::    
* SRFI-13 String case mapping::  
* SRFI-13 String reverse & append::  
* SRFI-13 String mapping::      
* SRFI-13 String rotation::     
* SRFI-13 other string operations::  
* SRFI-13 String filtering::    
* SRFI-13 Low-level string procedures::  
@end menu

@node SRFI-13 General conventions, SRFI-13 String predicates, srfi-13 - String library, srfi-13 - String library
@subsection General conventions

There are a few common factors in string library API, which I don't
repeat in each function description

@table @emph
@item argument convention
The following argument names imply their types.
@table @var
@item s, s1, s2
Those arguments must be strings.
@item char/char-set/pred
This argument can be a character, a character-set object,
or a predicate that takes a single character and returns a boolean value.
``Applying @var{char/char-set/pred} to a character'' means,
if @var{char/char-set/pred} is a character, it is compared to the given
character; if @var{char/char-set/pred} is a character set, it is
checked if the character set contains the given character; if
@var{char/char-set/pred} is a procedure, it is applied
to the given character.  ``A character satisfies @var{char/char-set/pred}''
means such application to the character yields true value.

@item start, end
Lots of SRFI-13 functions takes these two optional arguments, which
limit the area of input string from @var{start}-th character
(inclusive) to @var{end}-th character (exclusive),
where the operation is performed.
When specified, the condition
0 <= @var{start} <= @var{end} <= @var{length of the string} must be
satisfied.  Default value of @var{start} and @var{end} is
0 and the length of the string, respectively.
@end table

@item `shared' variant
Some functions have variants with ``/shared'' attached to its name.
SRFI-13 defines those functions to allow to share the part of input
string, for better performance.  Gauche doesn't have a concept of
shared string, and these functions are mere synonyms of their
non-shared variants.  However, Gauche @emph{internally} shares
the storage of strings, so generally you don't need to worry
about the overhead of copying substrings.

@item `right' variant
Most functions works from left to right of the input string.
Some functions have variants with ``-right'' to its name, 
that works from right to left.

@end table

@node SRFI-13 String predicates, SRFI-13 String Constructors, SRFI-13 General conventions, srfi-13 - String library
@subsection String predicates

@defun string-null? s
[SRFI-13] Returns @code{#t} if @var{s} is an empty string, @code{""}.
@end defun

@defun string-every char/char-set/pred s &optional start end
[SRFI-13] Sees if every character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-every} returns
the value that is returned at the last application of @var{char/char-set/pred}.
If any of the application returns @code{#f}, @code{string-every}
returns @code{#f} immediately.
@end defun

@defun string-any char/char-set/pred s &optional start end
[SRFI-13] Sees if any character in @var{s} satisfies
@var{char/char-set/pred}.  If so, @code{string-any} returns
the value that is returned by the application.   If no character
satisfies @var{char/char-set/pred}, @code{#f} is returned.
@end defun

@node SRFI-13 String Constructors, SRFI-13 String Selection, SRFI-13 String predicates, srfi-13 - String library
@subsection String Constructors

@defun string-tabulate proc len
[SRFI-13] @var{proc} must be a procedure that takes an integer
argument and returns a character.  @code{string-tabulate}
creates a string, whose @var{i}-th character is calculated by
@code{(proc i)}.
@example
(string-tabulate
  (lambda (i) (integer->char (+ i #x30))) 10)
 @result{} "0123456789"
@end example

@end defun

@defun reverse-list->string char-list
[SRFI-13] @equiv{} @code{(list->string (reverse char-list))}.
@end defun

@node SRFI-13 String Selection, SRFI-13 String Comparison, SRFI-13 String Constructors, srfi-13 - String library
@subsection String selection

@defun substring/shared s start &optional end
[SRFI-13] In Gauche, this is the same as @code{substring}, except
that the @var{end} argument is optional.
@example
(substring/shared "abcde" 2) @result{} "cde"
@end example
@end defun

@defun string-copy! target tstart s &optional start end
[SRFI-13] Copies a string @var{s} into a string
@var{target} from the position @var{tstart}.
Optional @var{start} and @var{end} arguments limits the range of @var{s}.
If the copied string run over the end of @var{target}, an error is
signalled.
@example
(define s (string-copy "abcde"))
(string-copy! s 2 "ZZ")
s @result{} "abZZe"
@end example
@end defun

@defun string-take s nchars
@defunx string-drop s nchars
@defunx string-take-right s nchars
@defunx string-drop-right s nchars
[SRFI-13] Returns the first @var{nchars}-character string of @var{s}
(@code{string-take}) or the string without first @var{nchars}
(@code{string-drop}).  The @code{*-right} variation counts from
the end of string.  It is guaranteed that the returned string is
always a copy of @var{s}, even no character is dropped.
@example
(string-take "abcde" 2) @result{} "ab"
(string-drop "abcde" 2) @result{} "cde"

(string-take-right "abcde" 2) @result{} "cde"
(string-drop-right "abcde" 2) @result{} "ab"
@end example
@end defun

@defun string-pad s len &optional char start end
@defunx string-pad-right s len &optional char start end
[SRFI-13]
@end defun

@defun string-trim s &optional char/char-set/pred start end
@defunx string-trim-right s &optional char/char-set/pred start end
@defunx string-trim-both s &optional char/char-set/pred start end
[SRFI-13]
@end defun

@node SRFI-13 String Comparison, SRFI-13 String Prefixes & Suffixes, SRFI-13 String Selection, srfi-13 - String library
@subsection String comparison

@defun string-compare s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
@defunx string-compare-ci s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string= s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-ci@code{=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-hash s &optional bound start end 
@defunx string-hash-ci s &optional bound start end 
[SRFI-13]
@end defun

@node SRFI-13 String Prefixes & Suffixes, SRFI-13 String searching, SRFI-13 String Comparison, srfi-13 - String library
@subsection String Prefixes & Suffixes

@defun string-prefix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-length-ci s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length-ci s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-prefix? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix? s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-ci? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-ci? s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@node SRFI-13 String searching, SRFI-13 String case mapping, SRFI-13 String Prefixes & Suffixes, srfi-13 - String library
@subsection String searching

@defun string-index s char/char-set/pred &optional start end
@defunx string-index-right s char/char-set/pred &optional start end
[SRFI-13] Looks for the first element in a string @var{s}
that matches @var{char/char-set/pred}, and returns its index.
If @var{char/char-set/pred} is not found in @var{s}, returns @code{#f}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.

@example
(string-index "Aloha oe" #\a) @result{} 4
(string-index "Aloha oe" #[Aa]) @result{} 0
(string-index "Aloha oe" #[\s]) @result{} 5
(string-index "Aloha oe" char-lower-case?) @result{} 1
(string-index "Aloha oe" #\o 3) @result{} 6
@end example


See also the Gauche built-in procedure @code{string-scan}
(@ref{String utilities}), if you need speed over portability.
@end defun

@defun string-skip s char/char-set/pred &optional start end
@defunx string-skip-right s char/char-set/pred &optional start end
[SRFI-13] Looks for the first element that does not match
@var{char/char-set/pred} and returns its index.
If such element is not found, returns @code{#f}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@end defun

@defun string-count s char/char-set/pred &optional start end
[SRFI-13] Counts the number of elements in @var{s}
that matches @var{char/char-set/pred}.
Optional @var{start} and @var{end} limit the range of @var{s} to search.
@end defun

@defun string-contains s1 s2 &optional start1 end1 start2 end2
@defunx string-contains-ci s1 s2 &optional start1 end1 start2 end2
[SRFI-13] Looks for a string @var{s2} inside another string @var{s1}.
If found, returns an index in @var{s1} from where the maching string
begins.  Returns @code{#f} otherwise.
Optional @var{start1}, @var{end1}, @var{start2} and @var{end2}
limits the range of @var{s1} and @var{s2}.

See also the Gauche built-in procedure @code{string-scan}
(@ref{String utilities}), if you need speed over portability.
@end defun

@node SRFI-13 String case mapping, SRFI-13 String reverse & append, SRFI-13 String searching, srfi-13 - String library
@subsection String case mapping

@defun string-titlecase s &optional start end
@defunx string-titlecase! s &optional start end
[SRFI-13]
@end defun

@defun string-upcase s &optional start end
@defunx string-upcase! s &optional start end
[SRFI-13]
@end defun

@defun string-downcase s &optional start end
@defunx string-downcase! s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String reverse & append, SRFI-13 String mapping, SRFI-13 String case mapping, srfi-13 - String library
@subsection String reverse & append

@defun string-reverse s &optional start end
@defunx string-reverse! s &optional start end
[SRFI-13] Returns a string in which the character posisions are reversed
from @var{s}.  @code{string-reverse!} modifies @var{s}.
@example
(string-reverse "mahalo") @result{} "olaham"
(string-reverse "mahalo" 3) @result{} "ola"
(string-reverse "mahalo" 1 4) @result{} "aha"

(let ((s (string-copy "mahalo")))
  (string-reverse! s 1 5)
  s)
  @result{} "mlahao"
@end example
@end defun

@defun string-concatenate string-list
[SRFI-13] Concatenates list of strings.
@example
(string-concatenate '("humuhumu" "nukunuku" "apua" "`a"))
  @result{} "humuhumunukunukuapua`a"
@end example
@end defun

@defun string-concatenate/shared string-list
@defunx string-append/shared s @dots{}
[SRFI-13] ``Shared'' version of @code{string-concatenate} and
@code{string-append}.  In Gauche, these are just synonyms of them.
@end defun

@defun string-concatenate-reverse string-list
@defunx string-concatenate-reverse/shared string-list
[SRFI-13] Reverses @var{string-list} before concatenation.
``Shared'' version works the same in Gauche.
@end defun

@node SRFI-13 String mapping, SRFI-13 String rotation, SRFI-13 String reverse & append, srfi-13 - String library
@subsection String mapping

@defun string-map proc s &optional start end
@defunx string-map! proc s &optional start end
[SRFI-13] @code{string-map} applies @var{proc} on every character of @var{s},
and collects the results into a string and returns it.
On the other hand, @code{string-map!} modifies @var{s}.
@example
(string-map char-upcase "wikiwiki") @result{} "WIKIWIKI"
(string-map char-upcase "wikiwiki" 4) @result{} "WIKI"

(let ((s (string-copy "wikiwiki")))
  (string-map! char-upcase s 4)
  s)
  @result{} "wikiWIKI"
@end example
@end defun

@defun string-fold kons knil s &optional start end
@defunx string-fold-right kons knil s &optional start end
[SRFI-13]
@end defun

@defun string-unfold p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-unfold-right p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-for-each proc s &optional start end
[SRFI-13]
@end defun

@defun string-for-each-index proc s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String rotation, SRFI-13 other string operations, SRFI-13 String mapping, srfi-13 - String library
@subsection String rotation

@defun xsubstring s from &optional to start end
[SRFI-13]
@end defun

@defun string-xcopy! target tstart s sfrom &optional sto start end
[SRFI-13]
@end defun

@node SRFI-13 other string operations, SRFI-13 String filtering, SRFI-13 String rotation, srfi-13 - String library
@subsection Other string operations

@defun string-replace s1 s2 start1 end2 &optional start2 end2
[SRFI-13]
@end defun

@defun string-tokenize s &optional token-set start end
@c EN
[SRFI-13]
Splits the string @var{s} into a list of substrings,
where each substring is a maximal non-empty contiguous
sequence of characters from the character set @var{token-set}.
The default of @var{token-set} is @code{char-set:graphic}
(@xref{SRFI-14 Predefined character-set}).

See also Gauche's built-in @code{string-split} (@xref{String utilities}),
which provides similar features but different criteria.
@c JP
[SRFI-13]
文字列 @var{s} を、@var{token-set} で指定される文字セットで
構成される、空でない最大限連続した文字のシーケンスのそれぞれを
要素とするリストを返します。
@var{token-set} のデフォルト値は @code{char-set:graphic}
(@ref{SRFI-14 Predefined character-set}参照)。

同様の機能を提供する、しかし異なる基準を持つ、Gauche の組み込み手続き
@code{string-split} (@ref{String utilities} 参照) も見て下さい。
@c COMMON
@end defun

@node SRFI-13 String filtering, SRFI-13 Low-level string procedures, SRFI-13 other string operations, srfi-13 - String library
@subsection String filtering

@defun string-filter s char/char-set/pred &optional start end
@defunx string-delete s char/char-set/pred &optional start end
[SRFI-13]
@end defun

@node SRFI-13 Low-level string procedures,  , SRFI-13 String filtering, srfi-13 - String library
@subsection Low-level string procedures

@defun string-parse-start+end proc s args
@defunx string-parse-final-start+end proc s args
[SRFI-13]
@end defun

@defmac let-string-start+end (start end [rest]) proc-exp s-exp args-exp body @dots{}
[SRFI-13]
@end defmac

@defun check-substring-spec proc s start end
@defunx substring-spec-ok? s start end
[SRFI-13]
@end defun

@defun make-kmp-restart-vector s &optional c= start end
[SRFI-13]
@end defun

@defun kmp-step pat rv c i c= p-start
[SRFI-13]
@end defun

@defun string-kmp-partial-search pat rv s i &optional c= p-start s-start s-end
[SRFI-13]
@end defun

@c ----------------------------------------------------------------------
@node srfi-14 - Character-set library, srfi-19 - Time data types and procedures, srfi-13 - String library, Library modules - SRFIs
@section @code{srfi-14} - Character-set library

@deftp {Module} srfi-14
@mdindex srfi-14
@c EN
Implements the character set library defined in SRFI-14
(@ref{srfi-14,,SRFI-14}).  Note that several basic character-set
operations are Gauche's build-in functions.  @xref{Character set}.
@c JP
SRFI-14で定義された文字セットライブラリを実装します
(@ref{srfi-14,,SRFI-14})。
基本的な文字セットの操作はGauche組み込みになっています(@ref{Character set}参照)。
このモジュールでは多くのユーティリティ手続きが追加されます。
@c COMMON
@end deftp

@menu
* SRFI-14 Character-set constructors::  
* SRFI-14 Character-set Comparison::  
* SRFI-14 Character-set iteration::  
* SRFI-14 Character-set query::  
* SRFI-14 Character-set algebra::  
* SRFI-14 Predefined character-set::  
@end menu

@node SRFI-14 Character-set constructors, SRFI-14 Character-set Comparison, srfi-14 - Character-set library, srfi-14 - Character-set library
@subsection Character-set constructors

@defun list->char-set char-list &optional base-cs
@defunx list->char-set! char-list base-cs
[SRFI-14]
@c EN
Constructs a character set from a list of characters @var{char-list}.
If @var{base-cs} is given, it must be a character set, and the characters
in it are added to the result character set.
@code{List->char-set!} is allowed, but not required, to reuse @var{base-cs}
to store the result.
@c JP
与えられた文字のリスト@var{char-list}から文字セットを構築して返します。
文字セット@var{base-cs}が与えられていた場合、返される文字セットは
その文字セットに@var{char-list}中の文字を追加したものとなります。
@code{list->char-set!}は、結果を格納するために@var{base-cs}を
変更するかもしれません。
@c COMMON
@end defun

@defun string->char-set s &optional base-cs
@defunx string->char-set! s base-cs
[SRFI-14]
@c EN
Like @code{list->char-set} and @code{list->char-set!}, 
but take a list of characters from a string @var{s}.
@c JP
追加する文字をリストでなく文字列@var{s}で与えることを除けば
@code{list->char-set}、@code{list->char-set!}と同じです。
@c COMMON
@end defun

@defun char-set-filter pred char-set &optional base-cs
@defunx char-set-filter! pred char-set base-cs
[SRFI-14]
@c EN
Returns a character set containing every character @var{c} in
@var{char-set} such that @code{(@var{pred} @var{c})} returns true.
If a character set @var{base-cs} is given, its content is added to 
the result.  The linear update version @code{char-set-filter!}
is allowed, but not required, to modify @var{base-cs} to store the result.
@c JP
@var{char-set}内の文字のうち、@code{(@var{pred} @var{c})} が真の値を
返すような@var{c}からなる文字セットを作成して返します。
文字セット@var{base-cs}が与えられた場合は、その内容が結果に追加されます。
@code{char-set-filter!}は、結果を格納するために@var{base-cs}を変更するかも
しれません。
@c COMMON
@end defun

@defun ucs-range->char-set lower upper &optional error? base-cs
@defunx ucs-range->char-set! lower upper error? base-cs
[SRFI-14]
@c EN

@c JP
@c COMMON
@end defun

@defun integer-range->char-set lower upper &optional error? base-cs
@defunx integer-range->char-set! lower upper error? base-cs
@c EN
@c JP
@c COMMON
@end defun

@defun ->char-set x
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@node SRFI-14 Character-set Comparison, SRFI-14 Character-set iteration, SRFI-14 Character-set constructors, srfi-14 - Character-set library
@subsection Character-set comparison

@defun char-set= char-set1 @dots{}
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set@code{<=} char-set1 @dots{}
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-hash char-set &optional bound
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@node SRFI-14 Character-set iteration, SRFI-14 Character-set query, SRFI-14 Character-set Comparison, srfi-14 - Character-set library
@subsection Character-set iteration

@defun char-set-cursor char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-ref char-set cursor
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-cursor-next char-set cursor
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun end-of-char-set? ccursor
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-fold kons knil char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-unfold pred fun gen seed &optional base-char-set
@defunx char-set-unfold! pred fun gen seed base-char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-for-each proc char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-map proc char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@node SRFI-14 Character-set query, SRFI-14 Character-set algebra, SRFI-14 Character-set iteration, srfi-14 - Character-set library
@subsection Character-set query

@defun char-set-size char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-count pred char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set->list char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set->string char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-every pred char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@defun char-set-any pred char-set
[SRFI-14]
@c EN
@c JP
@c COMMON
@end defun

@node SRFI-14 Character-set algebra, SRFI-14 Predefined character-set, SRFI-14 Character-set query, srfi-14 - Character-set library
@subsection Character-set algebra

@defun char-set-adjoin char-set char1 @dots{}
@defunx char-set-adjoin! char-set char1 @dots{}
[SRFI-14]
@end defun

@defun char-set-delete char-set char1 @dots{}
@defunx char-set-delete! char-set char1 @dots{}
[SRFI-14]
@end defun

@defun char-set-complement char-set
@defunx char-set-complement! char-set
[SRFI-14]
@end defun

@defun char-set-union char-set @dots{}
@defunx char-set-union! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-intersection char-set @dots{}
@defunx char-set-intersection! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-difference char-set1 char-set2 @dots{}
@defunx char-set-difference! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-xor char-set @dots{}
@defunx char-set-xor! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-diff+intersection char-set1 char-set2 @dots{}
@defunx char-set-diff+intersection! char-set1 char-set2 char-set3 @dots{}
[SRFI-14]
@end defun



@node SRFI-14 Predefined character-set,  , SRFI-14 Character-set algebra, srfi-14 - Character-set library
@subsection Predefined character-set

@defvar char-set:letter
[SRFI-14]
@end defvar

@defvar char-set:blank
[SRFI-14]
@end defvar

@defvar char-set:iso-control
[SRFI-14]
@end defvar

@defvar char-set:digit
@defvarx char-set:hex-digit
[SRFI-14]
@end defvar

@defvar char-set:graphic
[SRFI-14]
@end defvar

@defvar char-set:lower-case
@defvarx char-set:upper-case
@defvarx char-set:title-case
[SRFI-14]
@end defvar

@defvar char-set:printing
[SRFI-14]
@end defvar

@defvar char-set:punctuation
[SRFI-14]
@end defvar

@defvar char-set:whitespace
[SRFI-14]
@end defvar

@defvar char-set:symbol
[SRFI-14]
@end defvar

@defvar char-set:ascii
[SRFI-14]
@end defvar

@defvar char-set:empty
[SRFI-14]
@end defvar

@defvar char-set:full
[SRFI-14]
@end defvar

@c ----------------------------------------------------------------------
@node srfi-19 - Time data types and procedures, srfi-27 - Sources of random bits, srfi-14 - Character-set library, Library modules - SRFIs
@section @code{srfi-19} - Time data types and procedures
@c NODE srfi-19 - 時間のデータ型と手続き, @code{srfi-19} - 時間のデータ型と手続き

@c EN
This SRFI defines various representations of time and date, and
conversion methods among them.
@c JP
このSRFIは、時間と日付に関する様々な表現と、それらの間の変換メソッドを提供します。
@c COMMON

@c EN
On Gauche, time object is supported natively by @code{<time>} class
(@xref{SRFI time}).  Date object is supported by @code{<date>} class
described below.
@c JP
Gaucheでは、timeオブジェクトは@code{<time>}クラスとして組み込みで
サポートされています(@ref{SRFI time}参照)。dateオブジェクトは以下で説明する
@code{<date>}クラスとしてサポートされます。
@c COMMON

@menu
* SRFI-19 Time types::          
* SRFI-19 Time queries::        
* SRFI-19 Time procedures::     
* SRFI-19 Date::                
* SRFI-19 Date reader and writer::  
@end menu

@node SRFI-19 Time types, SRFI-19 Time queries, srfi-19 - Time data types and procedures, srfi-19 - Time data types and procedures
@subsection Time types
@c NODE 時間のタイプ

@c EN
Time type is represented by a symbol.  This module defines
the following constant variables that is bound to its name, for
convenience.
@c JP
時間のタイプはシンボルで表現されます。
このモジュールでは以下の定数が自分の名前に束縛された形で提供されています。
@c COMMON

@defvr {Constant} time-utc
[SRFI-19]
@c EN
UTC time.  Gauche's built-in @code{current-time} always returns
this type (@xref{SRFI time}).
@c JP
UTC timeです。Gaucheの組み込みの@code{current-time}は常にこのタイプの時間を
返します (@ref{SRFI time}参照)。
@c COMMON
@end defvr

@defvr {Constant} time-tai
[SRFI-19]
@c EN
International Atomic Time.  This time is a bit larger than UTC, due to
the leap seconds.
@c JP
International Atomic Time。この時間は閏秒を計算に入れており、
UTCより若干大きな値を取ります。
@c COMMON
@end defvr

@defvr {Constant} time-monotonic
[SRFI-19]
@c EN
Implementation-dependent monotonically increasing time.
In Gauche, this is the same as @code{time-tai}.
@c JP
実装依存の、単調増加する時間。Gaucheの実装ではこれは@code{time-tai}と同じです。
@c COMMON
@end defvr

@defvr {Constant} time-duration
[SRFI-19]
@c EN
Duration between two absolute time points.
@c JP
二つの絶対的な時点の間の期間。
@c COMMON
@end defvr

@defvr {Constant} time-process
[SRFI-19]
@c EN
CPU time in current process.
Gauche calculates this from user time and system time returned by 
POSIX times(3).
@c JP
現在のプロセスのCPU時間。
Gaucheは、POSIX time(3)コールが返すユーザ時間とシステム時間の合計からこの値を
計算します。
@c COMMON
@end defvr

@defvr {Constant} time-thread
[SRFI-19]
@c EN
CPU time in current thread.
In the current implementation, this is the same as @code{time-process}.
@c JP
現在のスレッドのCPU時間。
現在の実装ではこれは@code{time-process}と同じです。
@c COMMON
@end defvr

@node SRFI-19 Time queries, SRFI-19 Time procedures, SRFI-19 Time types, srfi-19 - Time data types and procedures
@subsection Time queries
@c NODE 時間に関する問い合わせ

@defun current-time &optional time-type
[SRFI-19]
@c EN
Extends Gauche built-in @code{current-time} (@xref{SRFI time}) to take
optional @var{time-type} argument to specify the desired time type.
@var{time-type} must be one of the types described in @ref{SRFI-19 Time types}.
@c JP
Gauche組み込みの@code{current-time} (@ref{SRFI time}参照)を拡張して、
必要な時間のタイプを省略可能な引数@var{time-type}で指定できるようにしています。
可能な@var{time-type}の値は@ref{SRFI-19 Time types}で説明されているものです。
@c COMMON
@end defun

@defun current-date &optional tz-offset
[SRFI-19]
@c EN
Returns the current date as an instance of @code{<date>} class
(@xref{SRFI-19 Date}).  If @var{tz-offset} is given, it must be
an offset from UTC in number of seconds.  If @var{tz-offset} is
not given, returns the date in local time zone.
@c JP
現在の日付を@code{<date>}クラスのインスタンスとして返します(@ref{SRFI-19 Date}参照)。
@var{tz-offset}が与えられた場合、それがUTCからのオフセットを表す秒数として
使われます。@var{tz-offset}が与えられなかった場合はローカルタイムゾーンで
表現された日付が返されます。
@c COMMON
@end defun

@defun current-julian-day 
[SRFI-19]
@c EN
Returns the current julian day, a point in time as a real number of
days since -4714-11-24T12:00:00Z (November 24, -4714 at noon, UTC). 
@c JP
現在のJulian dayを返します。Julian dayは
-4714-11-24T12:00:00Z (November 24, -4714 at noon, UTC) からの日数を
実数で表現したものです。
@c COMMON
@end defun

@defun current-modified-julian-day
[SRFI-19]
@c EN
Returns the current modified julian day, a point in time as a real
number of days since 1858-11-17T00:00:00Z
(November 17, 1858 at midnight, UTC). 
@c JP
現在のModified julian dayを返します。Modified julian dayは
1858-11-17T00:00:00Z (November 17, 1858 at midnight, UTC)
からの日数を実数で表現したものです。
@c COMMON
@end defun

@defun time-resolution
[SRFI-19]
@end defun


@node SRFI-19 Time procedures, SRFI-19 Date, SRFI-19 Time queries, srfi-19 - Time data types and procedures
@subsection Time procedures
@c NODE 時間に関する手続き

@defun make-time type seconds nanoseconds
[SRFI-19]
@c EN
Returns an instance of @code{<time>} class with specified initial values.
Equivalent to @code{(make <time> :type type :second seconds :nanosecond nanoseconds)}.
@c JP
与えられた初期値を持つ@code{<time>}クラスのインスタンスを返します。
@code{(make <time> :type type :second seconds :nanosecond nanoseconds)}
と等価です。
@c COMMON
@end defun

@defun time-type time
@defunx time-second time
@defunx time-nanosecond time
@defunx set-time-type! time type
@defunx set-time-second! time second
@defunx set-time-nanosecond! time nanosecond
[SRFI-19]
@c EN
Getter and setter of @code{<time>} object slots.
@c JP
@code{<time>}オブジェクトのスロットのアクセサです。
@c COMMON
@end defun

@defun copy-time time
[SRFI-19]
@c EN
Returns a new instance of @code{<time>} whose content is the same as
given @var{time}
@c JP
与えられた@var{time}と同じ内容の新しい@code{<time>}オブジェクトを返します。
@c COMMON
@end defun

@defun time=? time0 time1
@defunx time<? time0 time1
@defunx time<=? time0 time1
@defunx time>? time0 time1
@defunx time>=? time0 time1
[SRFI-19]
@c EN
Compares two times.  Types of both times must match.
@c JP
二つの時間を比較します。時間のタイプは一致していなければなりません。
@c COMMON
@end defun

@defun time-difference time0 time1
@defunx time-difference! time0 time1
[SRFI-19]
@c EN
Returns the difference of two times, in @code{time-duration} time.
Types of both times must match.  
@code{Time-difference!} modifies @var{time0} to store the result.
@c JP
二つの時間の差を@code{time-duration}タイプの時間として返します。
二つの時間のタイプは一致していなければなりません。
@code{Time-difference!}は結果を格納するために@var{time0}を変更します。
@c COMMON
@end defun

@defun add-duration time0 time-duration
@defunx add-duration! time0 time-duration
@defunx subtract-duration time0 time-duration
@defunx subtract-duration! time0 time-duration
[SRFI-19]
@c EN
Adds or subtracts @var{time-duration} to or from @var{time0}.
Type of returned time is the same as @var{time0}.  Type of
@var{time-duration} must be @code{time-duration}.
@code{add-duration!} and @code{subtract-duration!} reuse
@var{time0} to store the result.
@c JP
@var{time-duration}を@var{time0}に加算、または@var{time0}から減算します。
返される時間のタイプは@var{time0}と同じです。@var{time-duration}のタイプは
@code{time-duration}でなければなりません。
@code{add-duration!}と@code{subtract-duration!}は結果を格納するのに
@var{time0}を再利用します。
@c COMMON
@end defun

@node SRFI-19 Date, SRFI-19 Date reader and writer, SRFI-19 Time procedures, srfi-19 - Time data types and procedures
@subsection Date
@c NODE 日付

@deftp {Class} <date>
@clindex date
@c EN
@c JP
@c COMMON
@end deftp

@defun make-date nanosecond second minute hour day month year zone-offset
[SRFI-19]
@end defun

@defun date?
[SRFI-19]
@end defun

@defun date-nanosecond date
@defunx date-second date
@defunx date-minute date
@defunx date-hour date
@defunx date-day date
@defunx date-month date
@defunx date-year date
@defunx date-zone-offset date
[SRFI-19]
@end defun

@defun date-year-day date
@defunx date-week-day date
@defunx date-week-number date day-of-week-starting-week
[SRFI-19]
@end defun

@defun date->julian-day date
@defunx date->modified-julian-day date
@defunx date->time-monotonic date
@defunx date->time-tai date
@defunx date->time-utc date
[SRFI-19]
Conversions from date to various date/time types.
@end defun

@defun julian-day->date jd &optional tz-offset
@defunx julian-day->time-monotonic jd
@defunx julian-day->time-tai jd
@defunx julian-day->time-utc jd
[SRFI-19]
Conversions from julian-day to various date/time types.
@end defun

@defun modified-julian-day->date jd &optional tz-offset
@defunx modified-julian-day->time-monotonic jd
@defunx modified-julian-day->time-tai jd
@defunx modified-julian-day->time-utc jd
[SRFI-19]
Conversions from modified julian-day to various date/time types.
@end defun

@defun time-monotonic->date time &optional tz-offset
@defunx time-monotonic->julian-day time
@defunx time-monotonic->modified-julian-day time
@defunx time-monotonic->time-tai time
@defunx time-monotonic->time-tai! time
@defunx time-monotonic->time-utc time
@defunx time-monotonic->time-utc! time
[SRFI-19]
Conversions from time-monotonic to various date/time types.
@end defun

@defun time-tai->date time &optional tz-offset
@defunx time-tai->julian-day time
@defunx time-tai->modified-julian-day time
@defunx time-tai->time-monotonic time
@defunx time-tai->time-monotonic! time
@defunx time-tai->time-utc time
@defunx time-tai->time-utc! time
[SRFI-19]
Conversions from time-tai to various date/time types.
@end defun

@defun time-utc->date time &optional tz-offset
@defunx time-utc->julian-day time
@defunx time-utc->modified-julian-day time
@defunx time-utc->time-monotonic time
@defunx time-utc->time-monotonic! time
@defunx time-utc->time-tai time
@defunx time-utc->time-tai! time
[SRFI-19]
Conversions from time-utc to various date/time types.
@end defun

@node SRFI-19 Date reader and writer,  , SRFI-19 Date, srfi-19 - Time data types and procedures
@subsection Date reader and writer
@c NODE 日付の読み書き

@defun date->string date &optional format-string
[SRFI-19]
@end defun

@defun string->date string template-string
[SRFI-19]
@end defun

@c ----------------------------------------------------------------------
@node srfi-27 - Sources of random bits, srfi-37 - a program argument processor, srfi-19 - Time data types and procedures, Library modules - SRFIs
@section @code{srfi-27} - Sources of Random Bits
@c NODE srfi-27 - ランダムビットのソース, @code{srfi-27} - ランダムビットのソース

@deftp {Module} srfi-27
@mdindex srfi-27
This module provides SRFI-27 pseudo random generator interface,
using Mersenne Twister algorithm 
(@xref{math.mt-random - Mersenne-Twister random number generator}) as the backbone.
@end deftp

@defun random-integer n
[SRFI-27]
Returns a random exact integer between [0, @var{n}-1], inclusive,
using the default random source.
To set a random seed for this procedure, use @code{random-source-randomize!}
or @code{random-source-pseudo-randomize!} on @code{default-random-source}.
@end defun

@defun random-real
[SRFI-27]
Returns a random real number between (0, 1), exclusive,
using the default random source.
To set a random seed for this procedure, use @code{random-source-randomize!}
or @code{random-source-pseudo-randomize!} on @code{default-random-source}.
@end defun

@defvar default-random-source
[SRFI-27]
Keeps the default random source that is used by @code{random-integer}
and @code{random-real}.
@end defvar

@defun make-random-source
[SRFI-27]
Creates and returns a new random source.
In the current Gauche implementation, it is just a @code{<mersenne-twister>}
object.  It may be changed in the future implementation.
@end defun

@defun random-source? obj
[SRFI-27]
Returns @code{#t} if @var{obj} is a random source object.
@end defun

@defun random-source-state-ref s
@defunx random-source-state-set! s state
[SRFI-27]
Gets and sets the "snapshot" of the state of the random source @var{s}.
@var{State} is an opaque object whose content depends on the backbone
generator.
@end defun

@defun random-source-randomize! s
[SRFI-27]
Makes an effort to set the state of the random source @var{s} to 
a truly random state.  The current implementation uses the current
time and the process ID to set the random seed.
@end defun

@defun random-source-pseudo-randomize! s i j
[SRFI-27]
Changes the state of the random source @var{s} into the initial state 
of the (@var{i}, @var{j})-th independent random source, 
where @var{i} and @var{j} are non-negative integers. 
This procedure can be used to reuse a random source @var{s} as large 
number of independent random source, indexed by two non-negative integers.
Note that this procedure is entirely deterministic. 
@end defun

@defun random-source-make-integers s
[SRFI-27]
Returns a procedure, that takes one integer argument @var{n} and
returns a random integer between 0 and @var{n}-1 inclusive for every
invocation, from the random source @var{s}.
@end defun

@defun random-source-make-reals s &optional unit
[SRFI-27]
Returns a procedure, that takes no argument and
returns a random real between 0 and 1 exclusive for
every invocation, from the random source @var{s}.
If @var{unit} is given, the random real the returned procedure
generates will be quantized by the given @var{unit}, where 
0 < @var{unit} < 1.
@end defun

@c ----------------------------------------------------------------------
@node srfi-37 - a program argument processor,  , srfi-27 - Sources of random bits, Library modules - SRFIs
@section @code{srfi-37} - args-fold: a program argument processor

@deftp {Module} srfi-37
@mdindex srfi-37
This module implements @code{args-fold},
yet another procedure to process command-line
arguments, defined in SRFI-37 (@ref{srfi-37,[SRFI-37],SRFI-37}).

Unlike @code{gauche.parseopt}
(@xref{gauche.parseopt - Parsing command-line options}),
@code{args-fold} provides functional interface, i.e. 
the user's states are explicitly passed via parser's argument and
return values, and also follows POSIX and GNU getopt guidelines,
including long options.
@end deftp

@defun args-fold args options unrecognized-proc operand-proc &rest seeds
Processes program options @var{args} from left to right,
according to given option specification @var{options},
and two procedures @var{unrecognized-proc} and @var{operand-proc}.

@var{Options} is a list of option objects, explained below.
Each option object keeps the name(s) of the option, 
a flag to specify whether the option takes
an argument or not, and a procedure to process that option
(we'll call it @emph{option procedure}).  

@code{Args-fold} recognizes both single-character options (short options)
and long options.  A short option must begin with single hyphen
(e.g. @code{-a}), while long option must begin with double hyphens
(e.g. @code{--help}).   Short options can be
concatenated, e.g. @code{-abc} or @code{-a -b -c}.
Both a short option and a long option can take
required or optional arguments.   Required short-option argument
can appear with or without space after the option, e.g.
@code{-afoo} or @code{-a foo}.
Long-option argument can appear after character '@code{=}' or
space, e.g. @code{--long=foo} or @code{--long foo}.

When @code{args-fold} encounters a command-line argument that cannot
be an option argument, and doesn't begin with hyphen, the argument is
treated as an @emph{operand}.   @code{Args-fold} allows operands and
options to be interleaved.  However, if @code{args-fold} encounters
'@code{--}', the rest of arguments are treated as operands,
regardless of beginning with hyphen or not.

When the given option matches one of option object in @var{options},
the option procedure is called as follows:
@example
(@var{option-proc} @var{option} @var{name} @var{arg} @var{seed} @dots{})
@end example
where @var{option} is the matched option object, @var{name} is
the string actually used to specify the option, @var{arg} is
the option argument (or @code{#f} if there's none), and
@var{seed} @dots{} is the user's state information.
@var{Option-proc} must return as many arguments as @var{seed}s.

When @code{args-fold} encounters an option that doesn't match
any of the option objects, it creates a new option object
for the option and calls @var{unrecognized-proc}
with the same arguments as @var{option-proc}.  

When @code{args-fold} finds an operand, @var{operand-proc}
is called as follows:
@example
(@var{operand-proc} @var{operand} @var{seed} @dots{})
@end example
@var{Operand-proc} must return as many arguments as @var{seed}s.

The caller's state should be explicitly passed around seed arguments
and return values.  The initial seed values are @var{seed}s given
to @code{args-fold}.  The values returned from option procedure,
@var{unrecognized-proc} and @var{operand-proc} are used as the seed
arguments of next invocation of those procedures.  The values
returned from the last call to the procedures are returned
from @code{args-fold}.
@end defun

@defun option names require-arg? optional-arg? processor
Creates an option object with the passed properties.

@var{Names} is a list of characters and/or strings.
A character is used for a short option, and a string is used
for a long option.

Two flags, @var{require-arg?} and @var{optional-arg?}
indicates whether the option should take an option argument,
or may take an option argument.  

@var{Processor} is the option processor procedure.

Note that, if an option argument is passed using '@code{=}'
character, it is passed to the option procedure even if 
the option has @code{#f} in both @var{require-arg?}
and @var{optional-arg?}.  It is up to the option procedure
to deal with the argument.

It should also be noted that the optional option argument
for a short option is only recognized if it is given
without whitespace after the short option.  That is, if
a short option '@code{d}' is marked to take optional option argument,
then '@code{-dfoo}' is interpreted as '@code{-d}' with argument '@code{foo}',
but '@code{-d foo}' is interpreted as '@code{-d}' without argument
and an operand @code{foo}.  If '@code{d}' is marked to
take required option argument, however, both are interpreted
as '@code{-d}' with argument '@code{foo}'.
@end defun

@defun option? obj
Returns @code{#t} if @var{obj} is an option object,
@code{#f} otherwise.
@end defun

@defun option-name option
@defunx option-required-arg? option
@defunx option-optional-arg? option
@defunx option-processor
Returns the properties of an option object @var{option}.
@end defun

A simple example:

@example
(use srfi-37)

(define options
 (list (option '(#\d "debug") #f #t
               (lambda (option name arg debug batch paths files)
                 (values (or arg "2") batch paths files)))
       (option '(#\b "batch") #f #f
               (lambda (option name arg debug batch paths files)
                 (values debug #t paths files)))
       (option '(#\I "include") #t #f
               (lambda (option name arg debug batch paths files)
                 (values debug batch (cons arg paths) files)))))

(define (main args)
  (receive (debug-level batch-mode include-paths files)
    (args-fold (cdr args)
               options
               (lambda (option name arg . seeds)         ; unrecognized
                 (error "Unrecognized option:" name))
               (lambda (operand debug batch paths files) ; operand
                 (values debug batch paths (cons operand files)))
               0      ; default value of debug level
               #f     ; default value of batch mode
               '()    ; initial value of include paths
               '()    ; initial value of files
               )
     (print "debug level = " debug-level)
     (print "batch mode = " batch-mode)
     (print "include paths = " (reverse include-paths))
     (print "files = " (reverse files))
     0))
@end example



@c ======================================================================
@node Library modules - Utilities, References, Library modules - SRFIs, Top
@chapter Library modules - Utilities
@c NODE ライブラリモジュール - ユーティリティ


@c ----------------------------------------------------------------------
@menu
* dbm - Generic DBM interface::  
* dbm.gdbm - GDBM interface::   
* dbm.ndbm - NDBM interface::   
* dbm.odbm - Original DBM interface::  
* file.filter - Filtering file content::  
* file.util - Filesystem utilities::  
* math.const - Mathematic constants::  
* math.mt-random - Mersenne-Twister random number generator::  
* rfc.822 - RFC822 message parsing::  
* rfc.base64 - Base64 encoding/decoding::  
* rfc.cookie - HTTP cookie handling::  
* rfc.hmac - HMAC keyed-hashing::  
* rfc.http - HTTP::             
* rfc.md5 - MD5 message digest::  
* rfc.quoted-printable - Quoted-printable encoding/decoding::  
* rfc.sha1 - SHA1 message digest::  
* rfc.uri - URI parsing and construction::  
* slib - SLIB::                 
* text.csv - CSV tables::       
* text.gettext - Dealing with localized messages::  
* text.html-lite - Simple HTML document construction::  
* text.parse - Parsing input stream::  
* text.tr - Transliterate characters::  
* text.tree - Lazy text construction::  
* util.combinations - Combination library::  
* util.digest - Message digester framework::  
* util.isomorph - Determine isomorphism::  
* util.list - Additional list library::  
* util.queue - Queue::          
* util.toposort - Topological sort::  
* www.cgi - CGI Utility::       
@end menu

@node dbm - Generic DBM interface, dbm.gdbm - GDBM interface, Library modules - Utilities, Library modules - Utilities
@section @code{dbm} - Generic DBM interface
@c NODE dbm - 汎用DBMインタフェース, @code{dbm} - 汎用DBMインタフェース

@deftp {Module} dbm
@mdindex dbm
@c EN
DBM-like libraries provides an easy way to store values to a file,
indexed by keys.  You can think it as a persistent associative memory.
@c JP
DBM系のライブラリはキーでインデックスされた値をファイルに格納する簡単な方法を
提供します。一種の永続的な連想記憶と言えるでしょう。
@c COMMON

@c EN
This modules defines @code{<dbm>} abstract class, which has
a common interface to use various DBM-type database packages.
As far as you operate on the already opened database,
importing @code{dbm} module is enough.
@c JP
このモジュールが定義する抽象クラス@code{<dbm>}は、DBM系ライブラリへの
統一されたインタフェースを提供します。@code{dbm}モジュールだけをインポートすれば、
既にオープンされたデータベースを操作することができます。
@c COMMON

@c EN
To create or open a database, you need a concrete implementation
of the database.  Gauche currently has the following impelentations.
Each module defines its own low-level accessing functions
as well as the common interface.
Note that your system may not have one or more of those DBM libraries;
Gauche defines only what the system provides.
@c JP
データベースをオープンしたり作成したりするには、dbmインタフェースを実装した
モジュールが必要になります。今のところGaucheでは以下の実装が使えます。
それぞれのモジュールは、dbmインタフェース共通の手続きの他に、
直接実装を操作できる低レベルの手続きも提供します。
システムによっては以下のインタフェースの全てが実装されているわけではないことに
注意してください。Gaucheではシステムが提供する実装のみを定義します。
@c COMMON

@table @code
@item dbm.gdbm
@c EN
GDBM library (@xref{dbm.gdbm - GDBM interface}).
@c JP
GDBMライブラリ (@ref{dbm.gdbm - GDBM interface}参照).
@c COMMON

@item dbm.ndbm
@c EN
NDBM library (@xref{dbm.ndbm - NDBM interface}).
@c JP
NDBMライブラリ (@ref{dbm.ndbm - NDBM interface}参照).
@c COMMON

@item dbm.odbm
@c EN
DBM library  (@xref{dbm.odbm - Original DBM interface}).
@c JP
DBMライブラリ  (@ref{dbm.odbm - Original DBM interface}参照).
@c COMMON
@end table
@end deftp

@c EN
The following code shows a typical usage of the database.
@c JP
以下にdbmデータベースの使用例を示します。
@c COMMON

@example
(use dbm)         ; @r{dbm abstract interface}
(use dbm.gdbm)    ; @r{dbm concrete interface}

; @r{open the database}
(define *db* (dbm-open <gdbm> :path "mydb" :rw-mode :write))

; @r{put the value to the database}
(dbm-put! *db* "key1" "value1")

; @r{get the value from the database}
(define val (dbm-get *db* "key1"))

; @r{iterate over the database}
(dbm-for-each *db* (lambda (key val) (foo key val)))

; @r{close the database}
(dbm-close *db*)
@end example

@menu
* Opening and closing a dbm database::  
* Accessing a dbm database::    
* Iterating on a database::     
@end menu

@node Opening and closing a dbm database, Accessing a dbm database, dbm - Generic DBM interface, dbm - Generic DBM interface
@subsection Opening and closing a dbm database
@c NODE DBMデータベースのオープンとクローズ

@deftp {Class} <dbm>
@clindex dbm
@c EN
An abstract class for dbm-style database.  Defindes the common
database operations.   This class has the following instance slots.
They must be set before the database is actually opened by
@code{dbm-open}.

The concrete class may add more slots for finer control on the database,
such as locking.
@c JP
DBM系のデータベースのための抽象クラスです。データベースへの共通のオペレーションを
定義します。以下のインスタンススロットを持ちます。これらのスロットの値は
@code{dbm-open}によってデータベースがオープンされる前にセットされて
いなければなりません。

具体クラスは、データベースの操作をより細かく行うための追加のスロット(例えばロックを
行うかどうか)を持つかもしれません。
@c COMMON

@defivar <dbm> path
@c EN
Pathname of the dbm database.  Some dbm implementation may append
suffixes to this.
@c JP
データベースファイルのパス名。dbmの実装によっては、このパスにサフィックスが追加されます。
@c COMMON
@end defivar

@defivar <dbm> rw-mode
@c EN
Specifies read/write mode.  Can be either one of the following keywords:
@table @code
@item :read
The database will be opened in read-only mode.  The database file must
exist when @code{dbm-open} is called.  This is the default value.
@item :write
The database will be opened in Read-write mode.
If the database file does not exist, @code{dbm-open} creates one.
@item :create
The database will be created and opened in Read-write mode.
If the database file exists, @code{dbm-open} truncates it.
@end table
@c JP
読み書きのモードを指定します。以下の値のいずれかを取ります。
@table @code
@item :read
データベースは@code{dbm-open}によって読みだし専用モードでオープンされます。
オープンされる時点でデータベースは存在していなければなりません。
@item :write
データベースは@code{dbm-open}によって読み書き可能なモードでオープンされます。
データベースが存在しなければ、@code{dbm-open}は新しいデータベースを作成します。
@item :create
@code{dbm-open}によって新しいデータベースが作成され、読み書き可能なモードでオープンされます。
既にデータベースが存在していた場合、その内容はクリアされます。
@end table
@c COMMON
@end defivar

@defivar <dbm> file-mode
@c EN
Specifies the file permissions (as @code{sys-chmod}) to create the
database.  The default value is @code{#o664}.
@c JP
データベースが作成されるときのファイルパーミッションを指定します。
デフォルトは@code{#o664}です。
@c COMMON
@end defivar

@defivar <dbm> key-convert
@defivarx <dbm> value-convert
@c EN
By default, you can use only strings for both key and values.  With this
option, however, you can specify how to convert other Scheme values to/from
string to be stored in the database.   The possible values are the
followings:
@table @asis
@item @code{#f}
The default value.  Keys (values) are not converted.  They must be
a string.
@item @code{#t}
Keys (values) are converted to its string representation, using 
@code{write}, to store in the database, and converted
back to Scheme values, using @code{read}, to retrieve from the database.
The data must have an external representation that can be read back.
(But it is not checked when the data is written; you'll get an error
when you read the data).  The key comparison is done in the string
level, so the external representation of the same key must match.
@item a list of two procedures
Both procedure must take a single argument.  The first procedure must
receive a Scheme object and returns a string.  It is used to convert
the keys (values) to store in the database.  The second procedure
must receive a string and returns a Scheme object.  It is used to
convert the stored data in the database to a Scheme object.
The key comparison is done in the string
level, so the external representation of the same key must match.
@end table
@c JP
デフォルトでは、dbmデータベースはキーにも値にも文字列しか使うことはできません。
これらのスロットによって、それ以外のSchemeオブジェクトを取り扱う方法を指定することが
できます。以下の値のいずれかが可能です。
@table @asis
@item @code{#f}
デフォルトの値です。キーあるいは値は変換されません。それらは文字列でなければなりません。
@item @code{#t}
キーあるいは値は@code{write}を使って文字列に変換されデータベースに格納されます。
そして@code{read}を使って文字列からSchemeオブジェクトへと変換されます。
後で@code{read}で読みこめるようなキーあるいは値のみを扱うことができます。
(但し、dbmライブラリは書き込み時にそれが後で読み込めるかどうかのチェックは行いません)。
キーの比較は文字列に変換された後で行われるので、同じ値となるキーは同じ文字列表現を
持つ必要があります。
@item 二つの手続きのリスト
どちらの手続きも一つの引数を取ります。最初の手続きはSchemeオブジェクトを受け取り、
文字列を返します。キーあるいは値をデータベースに格納する時に呼ばれます。
二つ目の手続きは文字列を受け取りSchemeオブジェクトを返します。データベースから
キーあるいは値を取り出す時に呼ばれます。
キーの比較は文字列に変換された後で行われるので、同じ値となるキーは同じ文字列に
変換される必要があります。
@end table
@c COMMON
@end defivar
@end deftp

@deftp {Metaclass} <dbm-meta>
@clindex dbm-meta
@c EN
A metaclass of @code{<dbm>} and its subclasses.
@c JP
@var{<dbm>}クラス及びそのサブクラスのメタクラスです。
@c COMMON
@end deftp

@deffn {Method} dbm-open (dbm <dbm>)
@c EN
Opens a dbm database.  @var{dbm} must be an instance of
one of the concrete classes that derived from the @code{<dbm>} class,
and its slots must be set appropriately.   On success, it returns
the @var{dbm} itself.  On failure, it signals an error.
@c JP
DBMデータベースをオープンします。@var{dbm}は、@code{<dbm>}クラスを継承した
具体クラスのインスタンスでなければなりません。また、そのスロットには適切な値が
セットされている必要があります。オープンに成功したら@var{dbm}自身が返されます。
失敗した場合はエラーが報告されます。
@c COMMON
@end deffn

@deffn {Method} dbm-open (dbm-class <dbm-meta>) options @dots{}
@c EN
A convenient method that creates dbm instance and opens it.
It is defined as follows.
@c JP
DBMインスタンスを作成してオープンするための便利なメソッドです。
次のように定義されます。
@c COMMON
@example
(define-method dbm-open ((class <class>) . initargs)
  (dbm-open (apply make class initargs)))
@end example
@end deffn

@c EN
Database file is closed when it is garbage collected.
However, to ensure the modification is properly synchornized,
you should close the database explicitly.
@c JP
データベースファイルはガベージコレクトされる際にクローズされますが、
変更を正しくデータベースに反映するには、明示的にクローズした方が良いでしょう。
@c COMMON

@deffn {Method} dbm-close (dbm @code{<dbm>})
@c EN
Closes a database @var{dbm}.  Once the database is closed, any
operation to access the database content raises an error.
@c JP
データベース@var{dbm}をクローズします。データベースがクローズされると、
それ以降のアクセスオペレーションはエラーとなります。
@c COMMON
@end deffn

@deffn {Method} dbm-closed? (dbm @code{<dbm>})
@c EN
Returns true if a database @var{dbm} is already closed, false otherwise.
@c JP
データベース@var{dbm}が既にクローズされていたら@code{#t}を返します。
@c COMMON
@end deffn

@node Accessing a dbm database, Iterating on a database, Opening and closing a dbm database, dbm - Generic DBM interface
@subsection Accessing a dbm database
@c NODE DBMデータベースのアクセス

@c EN
Once a database is opened, you can use the following methods
to access individual key/value pairs.
@c JP
データベースがオープンされたら、以下のアクセスメソッドが使えます。
@c COMMON

@deffn {Method} dbm-put! (dbm @code{<dbm>}) key value
@c EN
Put a @var{value} with @var{key}.
@c JP
値@var{value}をキー@var{key}と関連付けて保存します。
@c COMMON
@end deffn

@deffn {Method} dbm-get (dbm @code{<dbm>}) key &optional default
@c EN
Get a value associated with @var{key}.  If no value exists for @var{key}
and @var{default} is specified, it is returned.  If no value exists for
@var{key} and @var{default} is not specified, an error is signalled.
@c JP
キー@var{key}に関連付けられた値を返します。もし値が存在しなければ、@var{default}が
与えられていればそれを返し、そうでなければエラーを報告します。
@c COMMON
@end deffn

@deffn {Method} dbm-exists? (dbm @code{<dbm>}) key
@c EN
Return true if a value exists for @var{key}, false otherwise.
@c JP
キー@var{key}に関連付けられた値が存在すれば@code{#t}を返します。
@c COMMON
@end deffn

@deffn {Method} dbm-delete! (dbm @code{<dbm>}) key
@c EN
Delete a value associated with @var{key}.  
@c JP
キー@var{key}に関連付けられた値を消去します。値が存在しない場合は何もしません。
@c COMMON
@end deffn


@node Iterating on a database,  , Accessing a dbm database, dbm - Generic DBM interface
@subsection Iterating on a dbm database
@c NODE DBMデータベース上の繰り返し処理

@c EN
To walk over the entire database, following methos are provided.
@c JP
全データベースを渡り歩く処理のために、以下のメソッドが用意されています。
@c COMMON

@deffn {Method} dbm-fold (dbm @code{<dbm>}) procedure knil
@c EN
The basic iterator.
For each key/value pair, @var{procedure} is called as
@code{(@var{procedure} @var{key} @var{value} @var{r})},
where @var{r} is @var{knil} for the fist call of @var{procedure},
and the return value of the previous call for subsequent calls.
Returns the result of the last call of @var{procedure}.
If no data is in the database, @var{knil} is returned.

The following method returns the sum of all the integer values.
@c JP
基本的な繰り返し処理です。データベース内の各キー／値のペアに関して、手続き
@var{procedure}が @code{(@var{procedure} @var{key} @var{value} @var{r})},
のように呼ばれます。ここで@var{r}は、最初の@var{procedure}の呼び出しの時には@var{knil}
が、以降の呼び出しの時にはその直前の@var{procedure}が返した値が渡されます。
最後の@var{procedure}の戻り値が@code{dbm-fold}の戻り値となります。
データベース中にデータがひとつもなければ@var{knil}がそのまま返されます。

次の例は、データベース中の整数の値を全て加算します。
@c COMMON
@example
(dbm-fold dbm (lambda (k v r) (if (integer? v) (+ v r) r) 0))
@end example
@end deffn

@deffn {Method} dbm-for-each (dbm @code{<dbm>}) procedure
@c EN
For each key/value pair in the database @var{dbm}, @var{procedure}
is called.  Two arguments are passed to @var{procedure}---a key and
a value.   The result of @var{procedure} is discarded.
@c JP
データベース内の各キー／値のペアに関して、手続き@var{procedure}を呼び出します。
@var{procedure}にはキーと値が渡されます。@var{procedure}の戻り値は捨てられます。
@c COMMON
@end deffn

@deffn {Method} dbm-map (dbm @code{<dbm>}) procedure
@c EN
For each key/value pair in the database @var{dbm}, @var{procedure}
is called.  Two arguments are passed to @var{procedure}---a key and
a value.   The result of @var{procedure} is accumulated to a list
which is returned as a result of @code{dbm-map}.
@c JP
データベース内の各キー／値のペアに関して、手続き@var{procedure}を呼び出します。
@var{procedure}にはキーと値が渡されます。@var{procedure}の戻り値はリストに
集められて@code{dbm-map}の戻り値となります。
@c COMMON
@end deffn


@c ----------------------------------------------------------------------
@node dbm.gdbm - GDBM interface, dbm.ndbm - NDBM interface, dbm - Generic DBM interface, Library modules - Utilities
@section @code{dbm.gdbm} - GDBM interface

@deftp {Module} dbm.gdbm
@mdindex dbm.gdbm
@end deftp

@deftp {Class} <gdbm>
@clindex gdbm
@c EN
Inherits @code{<dbm>}.  Provides an implementation for GDBM library.
This module is only installed when your system already has GDBM
(1.8.0 is preferred, but works with older 1.7.x with some limitations).
@c JP
@code{<dbm>} を継承します。GDBM ライブラリのための実装を提供します。
このモジュールは、すでにあなたのシステムにすでに GDBM がある場合にのみ
インストールされます(バージョン 1.8.0 が推奨されますが、いくつかの制限が
あるだけで古い 1.7.x でも動作します)。
@c COMMON

@defivar <gdbm> sync
@end defivar
@defivar <gdbm> nolock
@end defivar
@defivar <gdbm> bsize
@end defivar
@end deftp

@c EN
Besides the unified DBM interface (@xref{dbm - Generic DBM interface}),
this module provides the following low-level functions that provides
direct access to the gdbm API.  See gdbm manual for details of these
APIs.
@c JP
統合された DBM インターフェース (@xref{dbm - Generic DBM interface}) の
他に、このモジュールでは GDBM API への直接のアクセスを提供する以下の
低レベルな手続きを提供しています。これらの API の詳細については GDBM の
マニュアルを見て下さい。
@c COMMON

@defun gdbm-open path &optional size rwmode fmode error-callback

@defvar GDBM_READER
@end defvar

@defvar GDBM_WRITER
@end defvar

@defvar GDBM_WRCREAT
@end defvar

@defvar GDBM_NEWDB
@end defvar

@defvar GDBM_FAST
@end defvar

@defvar GDBM_SYNC
@end defvar

@defvar GDBM_NOLOCK
@end defvar
@end defun

@defun gdbm-close gdbm-object
@end defun

@defun gdbm-closed? gdbm-object
@end defun

@defun gdbm-store key value &optional flag


@defvar GDBM_INSERT
@end defvar

@defvar GDBM_REPLACE
@end defvar

@end defun


@defun gdbm-fetch gdbm-object key
@end defun


@defun gdbm-delete gdbm-object key
@end defun


@defun gdbm-firstkey gdbm-object
@end defun


@defun gdbm-nextkey gdbm-object key
@end defun


@defun gdbm-reorganize gdbm-object
@end defun


@defun gdbm-sync gdbm-object
@end defun


@defun gdbm-exists gdbm-object key
@end defun


@defun gdbm-strerror errno
@end defun


@defun gdbm-setopt gdbm-object option value

@defvar GDBM_CACHESIZE
@end defvar

@defvar GDBM_FASTMODE
@end defvar

@defvar GDBM_SYNCMODE
@end defvar

@defvar GDBM_CENTFREE
@end defvar

@defvar GDBM_COALESCEBLKS
@end defvar
@end defun

@defun gdbm-version
@end defun

@defun gdbm-errno
@end defun

@c ----------------------------------------------------------------------
@node dbm.ndbm - NDBM interface, dbm.odbm - Original DBM interface, dbm.gdbm - GDBM interface, Library modules - Utilities
@section @code{dbm.ndbm} - NDBM interface

@deftp {Module} dbm.ndbm
@mdindex dbm.ndbm
@end deftp

@deftp {Class} <ndbm>
@clindex ndbm
@c EN
Inherits @code{<dbm>}.  Provides an implementation for NDBM library.
This module is only installed when your system already has NDBM.
@c JP
@code{<dbm>} を継承します。NDBM ライブラリのための実装を提供します。
このモジュールはあなたのシステムにすでに NDBM がある場合にのみ
インストールされます。
@c COMMON
@end deftp

@c EN
Besides the unified DBM interface (@xref{dbm - Generic DBM interface}),
this module provides the following low-level functions that provides
direct access to the ndbm API.  See ndbm manual for details of these
APIs.
@c JP
統合された DBM インターフェース (@xref{dbm - Generic DBM interface}) の
他に、このモジュールでは NDBM API への直接のアクセスを提供する以下の
低レベルな手続きを提供しています。これらの API の詳細については NDBM の
マニュアルを見て下さい。
@c COMMON

@defun ndbm-open path flags mode
@end defun

@defun ndbm-close ndbm-object
@end defun

@defun ndbm-closed? ndbm-object
@end defun

@defun ndbm-store ndbm-object key content &optional flag
@end defun

@defun ndbm-fetch ndbm-object key
@end defun

@defun ndbm-delete ndbm-object key
@end defun

@defun ndbm-firstkey ndbm-object
@end defun

@defun ndbm-nextkey ndbm-object
@end defun

@defun ndbm-error ndbm-object
@end defun

@defun ndbm-clear-error ndbm-object
@end defun

@c ----------------------------------------------------------------------
@node dbm.odbm - Original DBM interface, file.filter - Filtering file content, dbm.ndbm - NDBM interface, Library modules - Utilities
@section @code{dbm.odbm} - Original DBM interface

@deftp {Module} dbm.odbm
@mdindex dbm.odbm
@end deftp

@deftp {Class} <odbm>
@clindex odbm
@c EN
Inherits @code{<dbm>}.  Provides an implementation for legacy DBM
library.
This module is only installed when your system already has DBM.

The biggest limitation of the legacy DBM is that you can only open
one database at a time.  You can create a multiple @code{<odbm>}
instances, but you can open at most one of it at a time, or
you'll get an error.
@c JP
@code{<dbm>} を継承しています。レガシーな DBM ライブラリのための実装を
提供します。このモジュールは、あなたのシステムにすでに DBM がある場合にのみ
インストールされます。

レガシー DBM の最大の制限は、データベースを一時に一つしか開けないことです。
複数の @code{<odbm>} のインスタンスを作ることができますが、一時に一つしか
開くことが出来ず、一つ以上開こうとするとエラーになります。
@c COMMON
@end deftp

@c EN
Besides the unified DBM interface (@xref{dbm - Generic DBM interface}),
this module provides the following low-level functions that provides
direct access to the dbm API.  See dbm manual for details of these
APIs.
@c JP
統合された DBM インターフェース (@xref{dbm - Generic DBM interface}) の
他に、このモジュールでは DBM API への直接のアクセスを提供する以下の
低レベルな手続きを提供しています。これらの API の詳細については DBM の
マニュアルを見て下さい。
@c COMMON

@defun odbm-init path
@end defun

@defun odbm-close
@end defun

@defun odbm-store key value
@end defun

@defun odbm-fetch key
@end defun

@defun odbm-delete key
@end defun

@defun odbm-firstkey
@end defun

@defun odbm-nextkey key
@end defun


@c ----------------------------------------------------------------------
@c @node Pseudo DBM interface, gauche.charconv - Character code conversion, Original DBM interface, Library modules
@c @section @code{dbm.pdbm} - Pseudo DBM interface

@c ----------------------------------------------------------------------
@node file.filter - Filtering file content, file.util - Filesystem utilities, dbm.odbm - Original DBM interface, Library modules - Utilities
@section @code{file.filter} - Filtering file content
@c NODE file.filter - ファイルのフィルタ, @code{file.filter} - ファイルのフィルタ

@deftp {Module} file.filter
@mdindex file.filter
@c EN
This module provides utilities for a common pattern in
filter-type commands, that is, to take an input, to process
the content, and to write the result.   The common occurring
pattern is:

@itemize @bullet
@item
Input may be a specified file, or an input port
(the current input port by default).
@item
Output may be a specified file, or an output port
(the current output port by default).
@item
Output may be a temporary file, which will be renamed
upon completion of the processing.
@item
Output file may be removed when an error occurs
in the processing.
@end itemize
@c JP
このモジュールは、フィルター型のコマンド、
すなわち入力を読み込み、処理をして結果を書き出すような場合に
共通するパターンに使えるユーティリティ手続きを提供します。
共通するパターンとは：

@itemize @bullet
@item
入力は指定されたファイルかポートで、デフォルトはカレント入力ポート。
@item
出力は指定されたファイルかポートで、デフォルトはカレント出力ポート。
@item
出力は一時ファイルに書き出すこともできて、
その場合は処理が終了した時点で指定されたファイルにリネーム。
@item
処理途中でエラーが起こった場合に出力ファイルを削除
@end itemize
@c COMMON
@end deftp

@defun file-filter proc &keyword input output temporary-file keep-output?
@c EN
Calls @var{proc} with two arguments, an input port and 
an output port.   Returns the result(s) of @var{proc}.
The input port and output port are chosen depending on the keyword arguments.
@c JP
二つの引数、入力ポートと出力ポートを引数として@var{proc}を呼び出し、
その結果を返します。
入力ポートと出力ポートはキーワード引数により決定されます。
@c COMMON

@table @code
@item input
@c EN
The argument must be either an input port or a string
that specifies a file name.
If it's an input port, it is passed to @var{proc} as is.
If it's a string, the named file is opened for input and the resulting
port is passed to @var{proc}, and the port is closed when @var{proc}
returns.
If this argument is omitted, the current input port is passed.
@c JP
この引数は入力ポートかファイル名を示す文字列でなければなりません。
入力ポートの場合、それはそのまま@var{proc}に渡されます。
文字列が渡された場合は、そのファイル名を持つファイルを入力用にオープンし、
そのポートが@var{proc}に渡され、またこのポートは@var{proc}が戻った時に閉じられます。
この引数が省略された場合は、現在の入力ポートが渡されます。
@c COMMON
@item output
@c EN
The argument must be either an output port or a string
that specifies a file name.
If it's an output port, it is passed to @var{proc} as is.
If it's a string, the named file is opened for output
(unless @var{temporary-file} is given, in that case
a temporary file is opened instead), and the resulting port
is passed to @var{proc}.  This port is closed when @var{proc} returns.
If this argument is omitted, the current output port is passed.
@c JP
この引数は入力ポートかファイル名を示す文字列でなければなりません。
出力ポートの場合、それはそのまま@var{proc}に渡されます。
文字列が渡された場合は、そのファイル名を持つファイルを出力用にオープンし、
そのポートが@var{proc}に渡されます (但し、@var{temporary-file}
引数が渡された時はそれに指定されるファイルが一時ファイルとしてオープンされます)。
オープンされたポートは@var{proc}が戻った時に閉じられます。
この引数が省略された場合は、現在の出力ポートが渡されます。
@c COMMON
@item temporary-file
@c EN
If a string file name is given to this argument, the named file
is opened for output during the processing, instead of the file
name as @var{output}.   The output port @var{proc} receives
is connected to this file.  When @var{proc}
returns normally, the file is renamed to the name given to @var{output}
keyword argument.

If the given file name begins with characters except @code{"/"}, @code{"./"}
or @code{"../"}, the directory of the file name given to @var{output} argument
is attached before it.
Furthermore, a unique name is attached to the temporary file name
(the temporary file is opened by @code{sys-mkstemp}.)

This argument is ignored when @var{output} argument is not a string
file name.
@c JP
文字列でファイル名が渡された場合、処理の間の出力先として@var{output}に指定された
ファイルのかわりにそのファイルがオープンされます。
@var{proc}にはその一時ファイルへの出力ポートが渡されます。
@var{proc}が正常に返って来た時点で、一時ファイルは@var{output}に指定された
ファイルへとリネームされます。

もし一時ファイル名が@code{"/"}、@code{"./"}、@code{"../"}以外の
文字で始まっていた場合は、@var{output}に与えられたファイル名のディレクトリが
一時ファイルの前に追加されます。さらに、ユニークなサフィックスが一時ファイルの後に
追加されます(一時ファイルは@code{sys-mkstemp}を使ってオープンされます)。

この引数は、@var{output}にファイル名が与えられなかった場合は無視されます。
@c COMMON
@item keep-output?
@c EN
If a true value is given, the output is not deleted even
when @var{proc} signals an error.
By default, the output (or the temporary file when
@var{temporary-file} is given) will be deleted on error.
@c JP
真の値が与えられた場合、@var{proc}がエラーになった場合でも出力ファイルを削除しません。
デフォルトでは、出力ファイル(もしくは@var{temporary-file}が与えられた場合は
そのファイル)はエラーの場合には削除されます。
@c COMMON
@end table
@end defun

@c ----------------------------------------------------------------------
@node file.util - Filesystem utilities, math.const - Mathematic constants, file.filter - Filtering file content, Library modules - Utilities
@section @code{file.util} - Filesystem utilities
@c NODE file.util - ファイルシステムユーティリティ, @code{file.util} - ファイルシステムユーティリティ

@deftp {Module} file.util
@mdindex file.util
@c EN
Provides convenient utility functions handling files and directories.
Those functions are built on top of the primitive system
procedures described in @ref{Filesystems}.
@c JP
ファイルやディレクトリを扱う便利な手続き群を提供します。
これらの手続きは@ref{Filesystems}で述べられたプリミティブなシステム手続きの上に
構築されています。
@c COMMON

@c EN
Many procedures in this module takes a keyword argument @var{follow-link?},
which specifies the behavior when the procedure sees a symbolic link.
If true value is given to @var{follow-link?} (which is the default),
the procedure operates on the file referenced by the link; if false is 
given, it operates on the link itself.
@c JP
このモジュール内の多くの手続きは@var{follow-link?}というキーワード引数を取ります。
これは手続きがシンボリックリンクに出会ったときの動作を指定します。@var{follow-link?}が
真であれば、手続きはリンクの指す先のファイルに作用します。これがデフォルトの振舞いです。
@var{follow-link?}に@code{#f}が渡された場合は手続きはリンクそのものに作用します。
@c COMMON
@end deftp

@c EN
Note on the naming convention: Some Scheme implementations "create"
new directories and files, while the others "make" them.
Some implementations "delete" them, while the others "remove" them.
It seems that both conventions are equally popular.
So Gauche provides @emph{both}.
@c JP
名前つけ規則に関する注記：ファイルやディレクトリを
作成するのに@code{"create"}という語を使う処理系と@code{"make"}を
使う処理系があります。ファイルやディレクトリを削除するのにも@code{"remove"}と
@code{"delete"}の流派があります。どちらも同じくらい広く使われているようなので、
Gaucheでは@emph{両方の}名前を提供することにしました。
@c COMMON

@menu
* Directory utilities::         
* Pathname utilities::          
* File attribute utilities::    
* File operations::             
@end menu

@node Directory utilities, Pathname utilities, file.util - Filesystem utilities, file.util - Filesystem utilities
@subsection Directory utilities
@c NODE ディレクトリユーティリティ

@defun current-directory &optional new-directory
@c EN
When called with no argument, this returns the pathname of the current
working directory.  When called with a string argument @var{new-directory},
this sets the current working directory of the process to it.
If the process can't change directory to @var{new-directory}, an error is
signalled.

This function is in ChezScheme, MzScheme and some other Scheme
implementations.
@c JP
引数無しで呼ばれた場合、カレントディレクトリを返します。
文字列@var{new-directory}が与えられた場合はプロセスのカレントディレクトリを
@var{new-directory}に変更します。変更が出来なかった場合はエラーとなります。

この関数はChezSchemeやMzSchemeなどいくつかのScheme処理系に見られます。
@c COMMON
@end defun

@defun home-directory &optional user
@c EN
Returns the home directory of the given @var{user},
which may be a string user name or an integer user id.
If @var{user} is omitted, the current user is assumed.
If the given user cannot be found, or the home directory
of the user cannot be determined, @code{#f} is returned.
@c JP
名前または整数のユーザidで与えられたユーザ@var{user}のホームディレクトリを
返します。@var{user}が省略された場合はカレントユーザが使われます。
与えられたユーザが見付けられないか、ホームディレクトリを決定できなかった場合は
@code{#f}が返されます。
@c COMMON
@end defun

@defun directory-list path &keyword children? add-path? filter
@c EN
Returns a list of entries in the directory @var{path}.
The result is sorted by dictionary order.

By default, only the basename (the last component) of the entries
returned.   If @var{add-path?} is given and true, @var{path} is appended
to each entry.  If @var{children?} is given and true, @code{"."} and 
@code{".."} are excluded from the result.  If @var{filter} is given,
it must be a predicate that takes one argument.  It is called on
every element of the entry basename, and only the entries on which
@code{filter} returns true are included in the result.

If @var{path} is not a directory, an error is signalled.
@c JP
ディレクトリ@var{path}中のエントリのリストを返します。
リストは文字列順にソートされます。

デフォルトではエントリのベースネーム(パスの最後のコンポーネント)のみが
返されますが、キーワード引数@var{add-path?}に真の値が与えられた時は
@var{path}が各エントリの前に追加されます。
@var{children?}に真の値が与えられた時は、カレントディレクトリと親ディレクトリが
リストから除かれます。@var{filter}引数は、もし与えられれば、一つの引数を取る
手続きでなければなりません。ディレクトリ中の各エントリを引数としてその手続きが呼ばれ、
真を返したエントリのみが結果に含まれます。

@var{path}がディレクトリでない場合はエラーが報告されます。
@c COMMON

@example
(directory-list "test")
 @result{} ("." ".." "test.scm" "test.scm~")

(directory-list "test" :add-path? #t)
 @result{} ("test/." "test/.." "test/test.scm" "test/test.scm~")

(directory-list "test" :children? #t)
 @result{} ("test.scm" "test.scm~")

(directory-list "test" :children? #t :add-path? #t
   :filter (lambda (e) (not (string-suffix? "~" e))))
 @result{} ("test/test.scm")
@end example
@end defun

@defun directory-list2 path &keyword children? add-path? filter follow-link?
@c EN
Like @code{directory-list}, but returns two values; the first one is a list
of subdirectories, and the second one is a list of the rest.
The keyword arguments @var{children?}, @code{add-path?} and @var{filter}
are the same as @code{directory-list}.

Giving false value to @var{follow-link?} makes @code{directory-list2}
not follow the symbolic links; if the @var{path} contains a
symlink to a directory,
it will be included in the first list if @var{follow-link?}
is omitted or true,
while it will be in the second list if @var{follow-link?} is false.
@c JP
@code{directory-list}に似ていますが、ふたつの値を返します。最初の値は
@var{path}内にあるサブディレクトリのリストで、次の値はそれ以外のエントリのリストです。
キーワード引数@var{children?}、@code{add-path?}、@var{filter}は
@code{directory-list}と同じ意味をもちます。

偽の値を@var{follow-link?}に与えると、@var{path}内のシンボリックリンクを
辿りません；すなわち、@var{path}内にディレクトリへのシンボリックリンクがあった場合、
デフォルト、もしくは@var{follow-link?}に真の値が与えられた場合は
それは最初のリスト(サブディレクトリ)に入りますが、@var{follow-link?}
に偽の値が与えられた場合は後者のリスト(その他のエントリ)に入ります。
@c COMMON
@end defun

@defun directory-fold path proc knil &keyword lister follow-link?
@c EN
A fundamental directory traverser.
Conceptually it works as follows, in recursive way.
@c JP
ディレクトリ探索の最も基本的な手続きです。基本的な動作は以下に示すような再帰的なものです。
@c COMMON

@c EN
@itemize @bullet
@item
If @var{path} is not a directory, calls 
@code{(@var{proc} @var{path} @var{knil})} and returns the result.
@item
If @var{path} is a directory, calls
@code{(@var{lister} @var{path} @var{knil})}.  The procedure @var{lister}
is expected to return a list of pathnames.  Then
@code{directory-fold} is called on each returned pathname.
Each result of @code{directory-fold} is passed as the @var{knil}
argument of the next recursive invocation.
Returns the result of the last recursive call.
@end itemize
@c JP
@itemize @bullet
@item
@var{path}がディレクトリでない場合は@code{(@var{proc} @var{path} @var{knil})} を
評価し、結果を返します。
@item
@var{path}がディレクトリであった場合、まず
@var{(@var{lister} @var{path} @var{knil})} を評価します。
手続き@var{lister}はパス名のリストを返さなければなりません。
続いて、@code{directory-fold}が各パス名に対して再帰的に呼ばれます。
各呼び出しの結果が次の再帰呼び出しの@var{knil}の値に使われます。
@end itemize
@c COMMON

@c EN
The default procedure of @var{lister} is just a call to @code{directory-list},
as follows.
@c JP
デフォルトの@var{lister}は@code{directory-list}を次のように呼び出すものです。
@c COMMON
@example
(lambda (path knil)
  (directory-list path :add-path? #t :children? #t)))))
@end example

@c EN
Note that @var{lister} shouldn't return the given path itself (@code{"."})
nor the parent directory (@code{".."}), or the recursion wouldn't
terminate.  Also note @var{lister} is expected to return a path accesible
from the current directory, i.e. if @var{path} is @code{"/usr/lib/foo"} and
it contains @code{"libfoo.a"} and @code{"libfoo.so"}, @var{lister} should
return @code{'("/usr/lib/foo/libfoo.a" "/usr/lib/foo/libfoo.so")}.
@c JP
@var{lister}は@var{path}自身への参照 (@code{"."}) やその親ディレクトリへの参照を
返してはなりません。また、@var{lister}の戻り値は現在のディレクトリからアクセス可能な
パス名でなければなりません。例えば@var{path}が@code{"/usr/lib/foo"}であり、
そのディレクトリが@code{"libfoo.a"}と@code{"libfoo.so"}を含んでいた場合、
@var{lister}は@code{'("/usr/lib/foo/libfoo.a" "/usr/lib/foo/libfoo.so")}
のようなリストを返す必要があります。
@c COMMON

@c EN
The keyword argument @var{follow-link?} is used to determine whether
@var{lister} should be called on a symbolic link pointing to a directory.
When @var{follow-link?} is true (default), @var{lister} is called
with the symbolic link if it points to a directory.
When @var{follow-link?} is false, @var{proc} is not called.
@c JP
キーワード引数@var{follow-link?}はディレクトリを指しているシンボリックリンクに対して
@var{lister}を呼ぶかどうかを決定します。@var{follow-link?}が真(デフォルト値)である
場合はそのようなシンボリックリンクに対しても@var{lister}が呼ばれます。
一方、@var{follow-link?}が偽であればシンボリックリンクに対しては@var{proc}が呼ばれます。
@c COMMON

@c EN
The following examble returns a list of pathnames of the emacs backup files
(whose name ends with "~") under the given path.
@c JP
次の例は、与えられたpath以下からemacsのバックアップファイル ("~"で終る名を持つファイル)
のリストを返します。
@c COMMON
@example
(use srfi-13) ;; for string-suffix?
(directory-fold path
                (lambda (entry result) 
                  (if (string-suffix? "~" entry)
                      (cons entry result)
                      result))
                '())
@end example

@end defun

@defun make-directory* name &optional perm
@defunx create-directory* name &optional perm
@c EN
Creates a directory @var{name}.  If the intermediate path to the
directory doesn't exist, they are also created
(like @code{mkdir -p} command on Unix).   If the directory
@var{name} already exist, these procedure does nothing.
@var{Perm} specifies the integer flag for permission bits of the
directory.
@c JP
ディレクトリ@var{name}を作成します。@var{name}に至るパスが存在しない
場合は必要なディレクトリが作成されます (Unixの@code{mkdir -p}コマンドと
同様です)。ディレクトリ@var{name}が既に存在していた場合は何もしません。
@var{perm}は作成されるディレクトリのパーミッションビットを指定します。
@c COMMON
@end defun


@defun remove-directory* name
@defunx delete-directory* name 
@c EN
Deletes directory @var{name} and its content recursively 
(like @code{rm -r} command on Unix).   Symbolic links are not
followed.
@c JP
ディレクトリ@var{name}とその内容を再帰的に消去します
(Unixの@code{rm -r}コマンドと同様です)。シンボリックリンクは辿られません。
@c COMMON
@end defun


@node Pathname utilities, File attribute utilities, Directory utilities, file.util - Filesystem utilities
@subsection Pathname utilities
@c NODE パスネームユーティリティ

@defun build-path base-path component @dots{}
@c EN
Appends pathname components @var{component} to the @var{base-path}.
@var{Component} can be a symbol @code{up} or @code{same};
in Unix, they are synonym to @code{".."} and @code{"."}.
This API is taken from MzScheme.
@c JP
パス名のコンポーネント@var{component}を@var{base-path}に追加します。
@var{Component}はシンボル@code{up}または@code{same}であっても
構いません; Unixではそれらは@code{".."}または@code{"."}と等価です。
このAPIはMzSchemeから採られました。
@c COMMON
@end defun

@defun absolute-path? path
@defunx relative-path? path
@c EN
Returns @code{#t} if @var{path} is absolute or relative, respectively.
@c JP
@var{path}がそれぞれ絶対パスまたは相対パスならば@code{#t}を返します。
@c COMMON
@end defun

@defun expand-path path
@c EN
Expands tilda-notation of @var{path} if it contains one.
Otherwise, @var{path} is returned.  This function does not
check if @var{path} exists and/or readable.
@c JP
@var{path}がチルダ表記を含んでいたらそれを展開したものを返します。
そうでなければ@var{path}そのものを返します。この手続きは@var{path}が
存在しアクセス可能であるかどうかはチェックしません。
@c COMMON
@end defun

@defun resolve-path path
@c EN
Expands @var{path} like @code{expand-path},
then resolve symbolic links for every components
of the path.  If @var{path} does not exist, or contains dangling link,
or contains unreadable directory, an error is signalled.
@c JP
@var{path}を@code{expand-path}と同様に展開し、
続いて@var{path}の各コンポーネントに対してそれがシンボリックリンクであればリンク先の
ものに置き換えてゆきます。@var{path}が存在しないパスを指していたり、
シンボリックリンクの先が存在しなかったり、読み出せないディレクトリがあった場合は
エラーとなります。
@c COMMON
@end defun

@defun simplify-path path
@c EN
Remove 'up' (@code{".."}) components and 'same' (@code{"."}) components
from @var{path} as much as possible.
This function does not access the filesystem.
@c JP
@var{path}から、親ディレクトリへの参照(@code{".."})と自分自身への参照(@code{"."})を
出来る限り取り除きます。この手続きはファイルシステムへはアクセスしません。
@c COMMON
@end defun

@defun find-file-in-paths name &keyword paths pred
@c EN
Looks for a file that has name @var{name} in the given list of pathnames
@var{paths} and that satisfies a predicate @var{pred}.  If found,
the absolute pathname of the file is returned.  Otherwise, @code{#f}
is returned.

If @var{name} is an absolute path, only the existence of @var{name}
and whether it satisfies @var{pred} are checked.

The default value of @var{paths} is taken from the environment variable
@code{PATH}, and the default value of @var{pred} is @code{file-is-executable?}
(@xref{File attribute utilities}).  That is, @code{find-file-in-paths}
searches the named executable file in the command search paths
by default.
@c JP
名前@var{name}を持ち、述語@var{pred}を満たすファイルをパス名のリスト@var{paths}
から探します。見つかった場合はファイルの絶対パス名を、見つからなかった場合は
@code{#f}を返します。

@var{name}が絶対パス名で与えられた場合はそれが存在するかどうかと
@var{pred}を満たすかどうかのみがチェックされます。

@var{paths}のデフォルト値は環境変数@code{PATH}から取られます。また、
@var{pred}のデフォルト値は@code{file-is-executable?}
(@ref{File attribute utilities}参照)です。すなわち、デフォルトでは
この手続きはコマンドサーチパスから実行可能ファイルを探すのに使えます。
@c COMMON

@example
(find-file-in-paths "ls")
  @result{} "/bin/ls"

@c EN
;; @r{example of searchin user preference file of my application}
@c JP
;; @r{アプリケーション"myapp"のユーザプレファレンスファイルを探す例}
@c COMMON
(find-file-in-paths "userpref"
  :paths `(,(expand-path "~/.myapp")
           "/usr/local/share/myapp"
           "/usr/share/myapp")
  :pred  file-is-readable?)
@end example
@end defun

@node File attribute utilities, File operations, Pathname utilities, file.util - Filesystem utilities
@subsection File attibute utilities
@c NODE ファイル属性ユーティリティ

@defun file-type path &keyword follow-link?
@defunx file-perm path &keyword follow-link?
@defunx file-mode path &keyword follow-link?
@defunx file-ino path &keyword follow-link?
@defunx file-dev path &keyword follow-link?
@defunx file-rdev path &keyword follow-link?
@defunx file-nlink path &keyword follow-link?
@defunx file-uid path &keyword follow-link?
@defunx file-gid path &keyword follow-link?
@defunx file-size path &keyword follow-link?
@defunx file-atime path &keyword follow-link?
@defunx file-mtime path &keyword follow-link?
@defunx file-ctime path &keyword follow-link?
@c EN
These functions return the attribute of file/directory specified by
@var{path}.  The attribute name corresponds to the slot name of
@code{<sys-stat>} class (@xref{File stats}).
If the named path doesn't exist, @code{#f} is returned.

If @var{path} is a symbolic link, these functions queries the
attributes of the file pointed by the link, unless
an optional argument @var{follow-link?} is given and false.

MzScheme and Chicken have @code{file-size}.  Chicken also has
@code{file-modification-time}, which is @code{file-mtime}.
@c JP
これらの手続きは@var{path}で示されるファイルやディレクトリのアトリビュートを
返します。アトリビュート名は@code{<sys-stat>}のスロット名に対応しています。
@ref{File stats}を参照して下さい。@var{path}で示されるファイルが
存在しなければ@code{#f}が返されます。

@var{path}がシンボリックリンクだった場合、オプショナルな引数
@var{follow-link?} に偽の値が与えられていない限り、これらの手続きは
リンクの指す先のファイルに関する情報を返します。

MzSchemeとChickenには@code{file-size}があります。
Chickenには@code{file-modification-time}があり、これは@code{file-mtime}と
同じです。
@c COMMON
@end defun

@defun file-is-readable? path
@defunx file-is-writable? path
@defunx file-is-executable? path
@c EN
Returns @code{#t} if @var{path} exists and readable/writable/executable
by the current effective user, respectively.
This API is taken from STk.
@c JP
@var{path}が存在して、現在の実効ユーザがそれぞれ読み取り/書き込み/実行可能なら@code{#t}を
返します。
このAPIはSTkから取られました。
@c COMMON
@end defun

@defun file-eq? path1 path2
@defunx file-eqv? path1 path2
@defunx file-equal? path1 path2
@c EN
Compares two files specified by @var{path1} and @var{path2}.
@code{file-eq?} and @code{file-eqv?} checks if @var{path1} and @var{path2}
refers to the identical file, that is, whether they are on the same
device and have the identical inode number.  The only difference is
when the last component of @var{path1} and/or @var{path2} is a symbolic
link, @code{file-eq?} doesn't resolve the link (so compares the links
themselves) while @var{file-eqv?} resolves the link and compares the
files referred by the link(s).
@c JP
@var{path1}と@var{path2}で示されるファイルを比較します。
@code{file-eq?}と@code{file-eqv?}は@var{path1}と@var{path2}が
全く同一のファイルを参照しているかどうか、すなわち、同じデバイス上にあり同じ
inode番号を持つかどうかをチェックします。二つの手続きの違いは、
@code{path1}や@var{path2}の最後のコンポーネントがシンボリックリンクで
あった場合に、@var{file-eq?}はリンクそのものの比較をするが
@code{file-eqv?}はリンクを辿った先のファイルの比較をする、という点です。
@c COMMON

@c EN
@code{file-equal?} compares @var{path1} and @var{path2} considering their
content, that is, when two are not the identical file in the sense of
@code{file-eqv?}, @code{file-equal?} compares their content and returns
@code{#t} if all the bytes match.
@c JP
@code{file-equal?}は@var{path1}と@var{path2}をその内容まで考慮して比較します。
すなわち、二つのファイルが@code{file-eqv?}の意味で同一でなかった場合、
@code{file-equal?}はファイルの内容を比較し、全てが一致した場合に@code{#t}を返します。
@c COMMON

@c EN
The behavior of @code{file-equal?} is undefined
when @var{path1} and @var{path2} are both directories.
Later, it may be extended to scan the directory contents.
@c JP
@var{path1}と@var{path2}ともにディレクトリが与えられた場合の
@code{file-equal?}の動作は未定義です。将来、ディレクトリ内容を
スキャンするような拡張が加えられるかもしれません。
@c COMMON
@end defun

@deffn {Generic Function} file-mtime=? f1 f2
@deffnx {Generic Function} file-mtime<? f1 f2
@deffnx {Generic Function} file-mtime<=? f1 f2
@deffnx {Generic Function} file-mtime>? f1 f2
@deffnx {Generic Function} file-mtime>=? f1 f2
@c EN
Compares file modification time stamps.  There are a bunch of methods defined,
so each argument can be either one of the followings.

@itemize @bullet
@item
String pathname.   The mtime of the specified path is used.
@item
@code{<sys-stat>} object (@xref{File stats}).
The mtime is taken from the stat structure.
@item
@code{<time>} object.  The time is used as the mtime.
@item
Number.  It is considered as the number of seconds since Unix Epoch, and
used as mtime.
@end itemize
@c JP
二つのファイルの変更時間を比較します。それぞれの引数に対して、
次のような型のオブジェクトが渡せるようなメソッドが定義されています。

@itemize @bullet
@item
文字列のパス名。そのパス名で示されるファイルから変更時間が取られます。
@item
@code{<sys-stat>}オブジェクト (@xref{File stats})。
stat構造体から変更時間が取られます。
@item
@code{<time>}オブジェクト。その示す時間が変更時間と考えられます。
@item
数値。変更時間をUnix Epochからの秒数で表したものと見なされます。
@end itemize
@c COMMON

@example
@c EN
;; @r{compare "foo.c" is newer than "foo.o"}
@c JP
;; @r{"foo.c" より "foo.o" が新しいかどうか調べる}
@c COMMON
(file-mtime>? "foo.c" "foo.o")

@c EN
;; @r{see if "foo.log" is updated within last 24 hours}
@c JP
;; @r{"foo.log"が過去24時間以内に更新されたかどうかを調べる}
@c COMMON
(file-mtime>? "foo.c" (- (sys-time) 86400))
@end example
@end deffn

@deffn {Generic Function} file-ctime=? f1 f2
@deffnx {Generic Function} file-atime=? f1 f2
@findex file-ctime<?
@findex file-ctime<=?
@findex file-ctime>?
@findex file-ctime>=?
@findex file-atime<?
@findex file-atime<=?
@findex file-atime>?
@findex file-atime>=?
@c EN
Same as @code{file-mtime=?}, except these checks file's change time
and access time, respectively.
All the variants of @code{<}, @code{<=}, @code{>}, @code{>=} are also
defined.
@c JP
@code{file-mtime=?}と同じですが、ファイルの属性変更時間とアクセス時間に
関して比較します。
@code{<}, @code{<=}, @code{>}, @code{>=}を使う関数も同様に定義されています。
@c COMMON
@end deffn

@node File operations,  , File attribute utilities, file.util - Filesystem utilities
@subsection File operations
@c NODE ファイル操作

@defun touch-file path
@c EN
Updates timestamp of @var{path} to the current time.  If @var{path} 
doesn't exist, a new file with size zero is created.
See also @code{sys-utime} (@xref{File stats}).
@c JP
@var{path}のタイムスタンプを現在の時刻に更新します。
@var{path}が存在しなかった場合はそのファイルを作成します。
@ref{File stats}の@code{sys-utime}も参照して下さい。
@c COMMON
@end defun

@defun copy-file src dst &keyword if-exists backup-suffix safe keep-timestamp
@c EN
Copies file from @var{src} to @var{dst}.  The source file @var{src} must exist.
The behavior when the destination @var{dst} exists varies by the keyword
argument @var{if-exists};

@table @code
@item :error
(Default) Signals an error when @var{dst} exists.
@item :supersede
Replaces @var{dst} to the copy of @code{src}. 
@item :backup
Keeps @var{dst} by renaming it.
@item #f
Doesn't copy and returns @code{#f} when @var{dst} exists.
@end table
@c JP
ファイル@var{src}を@var{dst}へコピーします。コピー元ファイル@var{src}は
存在していなければなりません。コピー先ファイル@var{dst}が存在していた場合の
ふるまいはキーワード引数@var{if-exists}によって以下のように指定されます。

@table @code
@item :error
(デフォルト) @var{dst}が存在していたらエラーを通知する。
@item :supersede
@var{dst}を@code{src}のコピーで置き換える。
@item :backup
@var{dst}の名前を変えてキープする。
@item #f
@var{dst}が存在していたらコピーをせず@code{#f}を返す。
@end table
@c COMMON

@c EN
@code{Copy-file} returns @code{#t} after completion.
@c JP
@code{copy-file}はコピーが完了したら@code{#t}を返します。
@c COMMON

@c EN
If @var{if-exists} is @code{:backup}, the keyword argument @var{backup-suffix}
specifies the suffix attached to the @var{dst} to be renamed.
The default value is @code{".orig"}.
@c JP
@var{if-exists}が@code{:backup}である場合、
@var{dst}がリネームされる名前は
@var{dst}にキーワード引数@var{backup-suffix}で指定されるサフィックスを
付けたものとなります。デフォルト値は@code{".orig"}です。
@c COMMON

@c EN
By default, @code{copy-file} starts copying to @var{dst} directly.
However, if the keyword argument @var{safe} is a true value,
it copies the file to a temporary file in the same directory of @var{dst},
then renames it to @var{dst} when copy is completed.
If copy is interrupted for some reason, the filesystem is "rolled back"
properly.
@c JP
デフォルトでは@code{copy-file}は直接@var{dst}にコピーを行いますが、
キーワード引数@var{safe}に真の値が与えられた場合は、@var{dst}と同じディレクトリ
内の一時ファイルにまずコピーし、それが完了した時点で@var{dst}へとリネームします。
コピーが何らかの理由で中断された場合、ファイルシステムはコピー前の状態へと
「ロールバック」されます。
@c COMMON

@c EN
If the keyword argument @var{keep-timestamp} is true, @code{copy-file}
sets the destination's timestamp to the same as the source's timestamp
after copying.
@c JP
キーワード引数@var{keep-timestamp}に真の値が与えられた場合は、
@code{copy-file}はコピー後にコピー先のファイルのタイムスタンプを
コピー元のタイムスタンプに合わせます。
@c COMMON
@end defun

@defun move-file src dst &keyword if-exists backup-suffix
@c EN
Moves file @var{src} to @var{dst}.   The source @var{src} must exist.
The behavior when @var{dst} exists varies by the keyword argument
@var{if-exists}, as follows.
@table @code
@item :error
(Default) Signals an error when @var{dst} exists.
@item :supersede
Replaces @var{dst} by @code{src}. 
@item :backup
Keeps @var{dst} by renaming it.
@item #f
Doesn't move and returns @code{#f} when @var{dst} exists.
@end table
@c JP
ファイル@var{src}を@var{dst}へ移動します。移動元ファイル@var{src}は
存在していなければなりません。移動先ファイル@var{dst}が存在した場合の
ふるまいはキーワード引数@var{if-exists}によって以下のように指定されます。
@table @code
@item :error
(デフォルト) @var{dst}が存在していたらエラーを通知する。
@item :supersede
@var{dst}を@code{src}で置き換える。
@item :backup
@var{dst}の名前を変えてキープする。
@item #f
@var{dst}が存在していたら移動をせず@code{#f}を返す。
@end table
@c COMMON

@c EN
@code{Move-file} returns @code{#t} after completion.
@c JP
@code{move-file}は移動が完了したら@code{#t}を返します。
@c COMMON

@c EN
If @var{if-exists} is @code{:backup}, the keyword argument @var{backup-suffix}
specifies the suffix attached to the @var{dst} to be renamed.
The default value is @code{".orig"}.
@c JP
@var{if-exists}が@code{:backup}である場合、@var{dst}がリネームされる
名前は@var{dst}にキーワード引数@var{backup-suffix}で指定されるサフィックスを
付けたものとなります。デフォルト値は@code{".orig"}です。
@c COMMON

@c EN
The file @var{src} and @var{dst} can be on the different filesystem.
In such a case, @code{move-file} first copies @var{src} to the
temporary file on the same directory as @var{dst}, then renames
it to @var{dst}, then removes @var{src}.
@c JP
ファイル@var{src}と@var{dst}は別のファイルシステム上にあっても構いません。
その場合、@code{move-file}はまず@var{src}を@var{dst}と同じディレクトリの
一時ファイルにコピーし、それを@var{dst}にリネームし、それから
@var{src}を消去します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node math.const - Mathematic constants, math.mt-random - Mersenne-Twister random number generator, file.util - Filesystem utilities, Library modules - Utilities
@section @code{math.const} - Mathematic constants
@c NODE math.const - 定数, @code{math.const} - 定数

@deftp {Module} math.const
@mdindex math.const
This module defines several commonly-used mathematic constants.
@end deftp

@defvr {Constant} pi
@defvrx {Constant} pi/2
@defvrx {Constant} pi/4
@defvrx {Constant} pi/180
@defvrx {Constant} 1/pi
@defvrx {Constant} 180/pi
@c EN
Bound to pi, pi/2, pi/4, pi/180, 1/pi and 180/pi, respectively.
@c JP
それぞれ、π、π/2、π/4、π/180、1/π、180/πです。
@c COMMON
@end defvr

@defvr {Constant} e
e.
@end defvr

@c ----------------------------------------------------------------------
@node math.mt-random - Mersenne-Twister random number generator, rfc.822 - RFC822 message parsing, math.const - Mathematic constants, Library modules - Utilities
@section @code{math.mt-random} - Mersenne Twister Random number generator
@c NODE math.mt-random - Mersenne Twister乱数発生器, @code{math.mt-random} - Mersenne Twister乱数発生器

@deftp {Module} math.mt-random
@mdindex math.mt-random
Provides a pseudo random number generator (RNG) based on 
"Mersenne Twister" algorithm developed by Makoto Matsumoto and
Takuji Nishimura.   It is fast, and has huge period of 2^19937-1.
See @ref{MT,,MT}, for details about the algorithm.
@end deftp

@deftp {Class} <mersenne-twister>
@clindex mersenne-twister
A class to encapsulate the state of Mersenne Twister RNG.
Each instance of this class has its own state, and can be used
as an independent source of random bits if initialized
by individual seed.

The random seed value can be given at the instantiation time
by @code{:seed} initialization argument, or by using
@code{mt-random-set-seed!} described below.

@example
(define m (make <mersenne-twister> :seed (sys-time)))

(mt-random-real m) @result{} 0.10284287848537865
(mt-random-real m) @result{} 0.463227748348805
(mt-random-real m) @result{} 0.8628500643709712
@dots{}
@end example
@end deftp

@defun mt-random-set-seed! mt seed
Sets random seed value @var{seed} to the Mersenne Twister RNG @var{mt}.
@var{Seed} can be an arbitrary positive exact integer,
or arbitrary length of u32vector (@xref{srfi-4 - Homogeneous vectors}).
If it is an integer, the lower 32bits are used for initialization.
If it is a u32vector, up to 624 elements are used for initialization.
@end defun

@defun mt-random-get-state mt
@defunx mt-random-set-state! mt state
Retrieves and reinstalls the state of Mersenne Twister RNG @var{mt}.
The state is represented by a u32vector of 625 elements.  The state
can be stored elsewhere, and then restored to an instance of
@code{<mersenne-twister>} to continue to generate the pseudo random
sequence.
@end defun

@defun mt-random-real mt
@defunx mt-random-real0 mt
Returns a random real number between 0.0 and 1.0.
1.0 is not included in the range.  @code{Mt-random-real} doesn't
include 0.0 either, while @code{mt-random-real0} does.
Excluding 0.0 is from the draft SRFI-27.
@end defun

@defun mt-random-integer mt range
Returns a random exact positive integer between 0 and @var{range}-1.
@var{Range} can be any positive exact integer.
@end defun

@defun mt-random-fill-u32vector! mt u32vector
@defunx mt-random-fill-f32vector! mt f32vector
@defunx mt-random-fill-f64vector! mt f64vector
Fills the given uniform vector by the random numbers.
For @code{mt-random-fill-u32vector!}, the elements are filled
by exact positive integers between 0 and 2^32-1.
For @code{mt-random-fill-f32vector!} and
@code{mt-random-fill-f64vector!}, it is filled by an inexact
real number between 0.0 and 1.0, exclusive.

If you need a bunch of random numbers at once, these are much
faster than getting one by one.
@end defun

@c ----------------------------------------------------------------------
@node rfc.822 - RFC822 message parsing, rfc.base64 - Base64 encoding/decoding, math.mt-random - Mersenne-Twister random number generator, Library modules - Utilities
@section @code{rfc.822} - RFC822 message parsing
@c NODE rfc.822 - RFC822メッセージ形式, @code{rfc.822} - RFC822メッセージ形式

@deftp {Module} rfc.822
@mdindex rfc.822
@c EN
Defines a set of functions that parses and constructs the ``Internet
Message Format'', a text format used to exchange e-mails.
The most recent specification can be found in
RFC2822 (@ref{rfc2822,[RFC2822],RFC2822}).
The format was originally defined in RFC 822, and people still 
call it ``RFC822 format'', hence I named this module.
In the following document, I also refer to the format as ``RFC822 format''.

Say @code{(use rfc.822)} to use this module.
@c JP
電子メールを交換する際に使用されるテキストのフォーマット、"インターネット・
メッセージ・フォーマット" をパーズ/生成する手続きを定義しています。
最新の仕様は、RFC2822 (@ref{rfc2822,[RFC2822],RFC2822}) にあります。
このフォーマットは最初 RFC 822 で定義されたため、未だに"RFC822形式"と
呼ばれています。それがこのモジュール名の由来です。
以下では、このフォーマットを"RFC822形式"と呼んでいます。

このモジュールを使うためには、@code{(use rfc.822)} として下さい。
@c COMMON
@end deftp

@defun rfc822-header->list iport &optional strict?
@c EN
Reads RFC822 format message from an input port @var{iport},
until it reaches the end of the message header.
The header fields are unfolded, and broken into a list of the following
format:
@c JP
入力ポート @var{iport} から、メッセージ・ヘッダの終わりに達するまで、
RFC822 形式のメッセージを読み込みます。
ヘッダ・フィールドは以下のフォーマットのリストに展開、分離されます。
@c COMMON
@example
((name body) @dots{})
@end example
@c EN
@var{Name} @dots{} are the field names, and @var{body} @dots{} are
the corresponding field body, both as strings.
Field names are converted to lower-case characters.
Field bodies are not modified, except the folded line is concatenated,
CRLFs removed.
The order of fields are preserved.
@c JP
@var{Name} @dots{} はフィールド名で、@var{body} @dots{} は対応するフィールドの
ボディ、ともに文字列です。
フィールド名は小文字に変換されます。フィールドのボディは、たたまれている
行が連結され CRLF が削除される以外は変更されません。
フィールドの順番は保存されます。
@c COMMON
@end defun

@defun rfc822-parse-date string
@c EN
Takes RFC-822 type date string, and returns eight values:
@c JP
RFC822 形式の日付文字列を取り、8つの値を返します。
@c COMMON
@example
year, month, day-of-month, hour, minutes, seconds, timezone, day-of-week.
@end example

@c EN
@emph{Timezone} is an offset from UT in minutes.
@emph{Day-of-week} is a day from sunday,
and may be #f if that information is not available.
If the string is not parsable, all the elements are #f.

Note: This function follows the new definition of date format in RFC2822,
but may fail to recognize "obsolete" format, which allows arbitrary
comments appear between words.
@c JP
@emph{Timezone} は UT(グリニッジ標準時)からの分単位のオフセットです。
@emph{Day-of-week} は日曜日から数えた曜日で、情報が不足している場合は #f です。
文字列がパーズ不可能ならば、全ての要素が #f になります。

注意: この手続きは、RFC2822 の新しい日付形式の定義に従っています。
ワードの間に任意のコメントが許されている「旧式の」フォーマットは
認識しそこねるかもしれません。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node rfc.base64 - Base64 encoding/decoding, rfc.cookie - HTTP cookie handling, rfc.822 - RFC822 message parsing, Library modules - Utilities
@section @code{rfc.base64} - Base64 encoding/decoding
@c NODE rfc.base64 - Base64エンコーディング, @code{rfc.base64} - Base64エンコーディング

@deftp {Module} rfc.base64
@mdindex rfc.base64
@c EN
This module defines a few functions to encode/decode Base64 format,
defined in RFC 2045 (@ref{rfc2045, [RFC2045], RFC2045}), section 6.3.
@c JP
このモジュールでは、RFC 2045 (@ref{rfc2045, [RFC2045], RFC2045}) で
定義されている Base64 フォーマットへエンコード/デコードするいくつかの
手続きを定義しています。
@c COMMON
@end deftp

@defun base64-encode
@c EN
Reads byte stream from the current input port, encodes it in Base64
format and writes the result character stream to the current output port.
The conversion ends when it reads EOF from the current input port.
@c JP
現在の入力ポートからバイト・ストリームを読み込み、それを Base64 フォーマットに
エンコードし、現在の出力ポートに文字ストリームとして書き出します。
現在の入力ポートから EOF を読み込むと変換を終了します。
@c COMMON
@end defun

@defun base64-encode-string string
@c EN
Converts contents of @var{string} to Base64 encoded format.
Input string can be either complete or incomplete string;
it is always interpreted as a byte sequence.
@c JP
@var{string} の内容を Base64 でエンコードされたフォーマットに変換します。
入力となる文字列は、完全文字列でも不完全文字列でも良いです。
常にバイト・シーケンスとして扱われます。
@c COMMON
@end defun

@defun base64-decode
@c EN
Reads character stream from the current input port, decodes it from Base64
format and writes the result byte stream to the current output port.
The conversion ends when it reads EOF or the termination character
(@code{=}).  The characters which does not in legal Base64 encoded character
set are silently ignored.
@c JP
現在の入力ポートから文字ストリームを読み込み、それを Base64 フォーマットとして
デコードし、現在の出力ポートにバイトストリームとして書き出します。
変換は EOF か、終端文字 (@code{=}) を読み込むと終了します。
Base64 でエンコードされた文字として適当でない文字は沈黙のまま無視されます。
@c COMMON
@end defun

@defun base64-decode-string string
@c EN
Decodes a Base64 encoded string @var{string} and returns
the result as a string.
The conversion terminates at the end of @var{string} or
the termination character (@code{=}).
The characters which does not in legal Base64 encoded character
set are silently ignored.
@c JP
Base64 でエンコードされた文字列 @var{string} をデコードして文字列を返します。
変換は @var{string} の終わりか、終端文字 (@code{=}) で終了します。
Base64 でエンコードされた文字として適当でない文字は沈黙のまま無視されます。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node rfc.cookie - HTTP cookie handling, rfc.hmac - HMAC keyed-hashing, rfc.base64 - Base64 encoding/decoding, Library modules - Utilities
@section @code{rfc.cookie} - HTTP cookie handling
@c NODE rfc.cookie - HTTPクッキー, @code{rfc.cookie} - HTTPクッキー

@deftp {Module} rfc.cookie
@mdindex rfc.cookie
@c EN
Defines a set of functions to parse and construct a ``cookie'' information
defined in RFC 2965 (@ref{rfc2965,,RFC2965}).
@c JP
RFC 2965 (@ref{rfc2965,,RFC2965}) で定義されている「クッキー」情報を
パースしたり構築したりするための手続きを定義しています。
@c COMMON
@end deftp

@defun parse-cookie-string string &optional version
@c EN
Parse a cookie string @var{string}, which is the value of ``Cookie''
request header.  Usually, the same information is available to CGI
program via the environemnt variable @code{HTTP_COOKIE}.

If the cookie version is known, via ``Cookie2'' request header,
the integer version must be passed to @var{version}.  Otherwise,
@code{parse-cookie} figures out the version from @var{string}.

The result has the following format.
@c JP
リクエスト・ヘッダの Cookie の値のクッキー文字列 @var{string} を
パースします。通常、CGI プログラムでは、同じ情報は環境変数
@var{HTTP_COOKIE} を通して利用できます。

リクエスト・ヘッダ Cookie2 を通してクッキーのバージョンが分かる
場合は、@var{version} へ整数のバージョンとして渡されなければなりません。
そうでなければ、@code{parse-cookie} は @var{string} からバージョンを
取り出します。

結果は以下のフォーマットを持ちます。
@c COMMON
@example
((<name> <value> [:path <path>] [:domain <domain>] [:port <port>])
 @dots{})
@end example
@c EN
where @var{<name>} is the attribute name, and @var{<value>} is
the corresponding value.  If the attribute doesn't have value,
@var{<value>} is @code{#f}.  (Note that it differs from the attribute
having null value, @code{""}.)
If the attribute has path, domain or port options, it is given
as a form of keyword-value pair.
@c JP
@var{<name>} は属性名で、@var{<value>} は対応する値です。
属性が値を持たない場合、@var{<value>} は @code{#f} になります。
(属性が NULL 値を持つ場合は、@code{""} となることに注意。)
属性がパスやドメイン、ポート番号のオプションを持つ場合は、
キーワード-値のペアの形式で与えられます。
@c COMMON
@end defun

@defun construct-cookie-string specs &optional version
@c EN
Given list of cookie specs, creates a cookie string suitable for
@code{Set-cookie2} or @code{Set-cookie} header.

Optional @var{version} argument specifies cookie protocol version.
0 for the old Netscape style format, and 1 for RFC2965 style format.
When omitted, version 1 is assumed.

Each cookie spec has the following format.
@c JP
与えられたクッキーの仕様のリストから、@code{Set-cookie2} か
@code{Set-cookie} ヘッダに適切なクッキー文字列を作ります。

オプションの @var{version} 引数は、クッキー・プロトコルのバージョンを
指定するものです。0 は古い Netscape スタイルのフォーマットで、1 は
RFC2965 スタイルのフォーマットです。省略された場合、1 が指定されたものと
されます。

クッキーの仕様は以下のフォーマットを持ちます。
@c COMMON
@example
(<name> <value> [:comment <comment>] [:comment-url <url>]
                [:discard <bool>] [:domain <domain>]
                [:max-age <age>] [:path <path>]
                [:port <port-list>] [:secure <bool>]
                [:version <version>] [:expires <date>])
@end example
@c EN
Where,
@table @code
@item <name>
A string.  Name of the cookie.
@item <value>
Value of the cookie.  May be a string, or @code{#f} if no value is needed.
@item <comment> <url> <domain> <path> <port-list>
Strings.
@item <bool>
Boolean value
@item <age> <version>
Integers
@item <date>
Either an integer (seconds since Epoch) or a formatted date string
following the netscape cookie specification.
@end table
@c JP
@table @code
@item <name>
文字列。クッキーの名前。
@item <value>
クッキーの値。文字列か、値が必要なければ @code{#f} 。
@item <comment> <url> <domain> <path> <port-list>
文字列。
@item <bool>
真偽値。
@item <age> <version>
整数。
@item <date>
整数(エポックからの秒数)か、Netscape のクッキー仕様に従うフォーマットされた
日付文字列。
@end table
@c COMMON

@c EN
The attribute values are quoted appropriately.  If the specified attribute
is irrelevant for the @var{version}, it is ignored.  So you can pass
the same specs to generate both old-style and new-style cookie strings.

Return value is a list of cookie strings, each of which stands for
each cookie.  For old-style protocol (using @code{Set-cookie} header)
you must send each of them by individual header.  For new-style
protocol (using @code{Set-cookie2} header), you can join them
with comma and send it at once.  See RFC2965 for further details.

Some examples:
@c JP
属性値は適切にクォートされます。指定された属性が @var{version} に不適切な
場合は無視されます。古いスタイルと新しいスタイルの両方のクッキー文字列を
作るために同じ仕様を渡すことができます。

戻り値はそれぞれのクッキー文字列のリストです。(@code{Set-cookie} を使う)
古いスタイルのプロトコルでは、それぞれを独立したヘッダとして送らなければ
なりません。(@code{Set-cookie2} ヘッダを使う)新しいプロトコルでは、
それらをカンマで繋ぎ、一度に送ることができます。詳細は RFC2965 を見て下さい。

いくつかの例を示します。
@c COMMON
@example
(construct-cookie-string
   `(("name" "foo" :domain "foo.com" :path "/"
                   :expires ,(+ (sys-time) 86400) :max-age 86400)))
 @result{} ("name=foo;Domain=foo.com;Path=/;Max-age=86400")

(construct-cookie-string
   `(("name" "foo" :domain "foo.com" :path "/"
                   :expires ,(+ (sys-time) 86400) :max-age 86400))
   0)
 @result{}
 ("name=foo;Domain=foo.com;Path=/;Expires=Sun, 09-Sep-2001 01:46:40 GMT")
@end example
@end defun

@c ----------------------------------------------------------------------
@node rfc.hmac - HMAC keyed-hashing, rfc.http - HTTP, rfc.cookie - HTTP cookie handling, Library modules - Utilities
@section @code{rfc.hmac} - HMAC keyed-hashing

@deftp {Module} rfc.hmac
@mdindex rfc.hmac
This module implements HMAC algorithm,
Keyed-hashing for message authentication, defined in RFC 2104.

For simple batched keyed hashing, you can use high-level API 
@code{hmac-digest} and @code{hmac-digest-string}.
Or you can create @code{<hmac>} object and update its state
as the data coming in.
@end deftp

@deftp {Class} <hmac>
@clindex hmac
Keeps state informatoin of HMAC algorithm.
Key and the hashing algorithm should be given at the construction
time, using @code{:key} and @code{:hasher} keyword-arguments respectively.
You can pass any class object that implements message digest 
interface (@xref{util.digest - Message digester framework}),
such as @code{<md5>} (@xref{rfc.md5 - MD5 message digest})
or @code{<sha1>} (@xref{rfc.sha1 - SHA1 message digest}).

Example:
@example
(make <hmac> :key (make-byte-string 16 #x0b) :hasher <md5>)
@end example
@end deftp

@deffn {Method} hmac-update! (hmac <hmac>) data
Updates the internal state of @var{hmac} by @var{data},
which must be represented by a (possibly incomplete) string.
@end deffn

@deffn {Method} hmac-final! (hmac <hmac>)
Finalizes the internal state of @var{hmac} and returns the
hashed string in incomplete string.
You can use @code{digest-hexify}
(@xref{util.digest - Message digester framework}) to obtain "hexified"
result.
Once finalized, you can't call @code{hmac-update!} or @code{hmac-final!}
on @var{hmac}.
@end deffn

@deffn {Method} hmac-digest &keyword key hasher
Creates an @code{<hmac>} object and hash the data stream
from the current input port, then returns the hashed result
in an incomplete string.
@end deffn

@deffn {Method} hmac-digest-string string &keyword key hasher
Creates an @code{<hmac>} object and hash the data in @var{string},
then returns the hashed result in an incomplete string.
@end deffn

@c ----------------------------------------------------------------------
@node rfc.http - HTTP, rfc.md5 - MD5 message digest, rfc.hmac - HMAC keyed-hashing, Library modules - Utilities
@section @code{rfc.http} - HTTP

@deftp {Module} rfc.http
@mdindex rfc.http
@c EN
This module provides a simple client API for
HTTP/1.1, defined in RFC2616, "Hypertext Transfer Protocol -- HTTP/1.1"
@c JP
このモジュールは、RFC2616 "Hypertext Transfer Protocol -- HTTP/1.1"
で定義されているHTTP/1.1に対する簡単なクライアントAPIを提供します。
@c COMMON
(@ref{rfc2616, [RFC2616], RFC2616}).

@c EN
Current API implements only a part of the protocol.
Only GET, HEAD, and POST requests are supported,
it doesn't talk with HTTP/1.0 server yet,
and it doesn't support HTTP/1.1 advanced features
such as persistent connection.
Support for those features may be added in the future versions.
@c JP
現在のAPIは、プロトコルの一部のみ実装されています。
GET、HEAD、POSTリクエストのみがサポートされており、
HTTP/1.0のサーバーとはうまく通信できません。
また、HTTP/1.1の先進的機能、例えば永続的接続などはサポートしていません。
これらの機能は、将来のバージョンで追加されるでしょう。
@c COMMON
@end deftp

@defun http-get server request-uri &keyword sink flusher no-redirect @dots{}
@defunx http-head server request-uri &keyword no-redirect @dots{}
@defunx http-post server request-uri body &keyword sink flusher no-redirect @dots{}

@c EN
Send http GET, HEAD and POST requests to the http @var{server},
respectively, and returns the server's reply.

If the server returns "3xx" redirection reply, these procedures
try to follow the URI returned in the "location" reply message header
by default.  See the "keyword arguments" heading below to suppress
redirection following.
@c JP
@var{server}に、それぞれHTTPのGET、HEAD、POSTリクエストを送り、
サーバの応答を返します。

サーバが "3xx" のリダイレクトを指示する応答を返した場合、これらの手続きは
デフォルトで、応答のメッセージヘッダの "location" で返されるURIに従うよう
試みます。リダイレクションを抑制するには、下の"キーワード引数"を参照してください。
@c COMMON

@c EN
@strong{Required arguments:}
The @var{server} argument specifies http server name in a string.
A server name can be optionally followed by colon and a port number.
@c JP
@strong{必須の引数:}
@var{server}引数では、文字列でHTTPサーバ名を指定します。
サーバ名は、オプションでコロンに続いてポート番号を付加できます。
@c COMMON
Examples: @code{"w3c.org"}, @code{"mycompany.com:8080"}.

@c EN
The @var{request-uri} argument is the request-uri specified in
RFC2616; usually, this is the path part of http url.

@code{Http-post} takes the third argument, @var{body}, which is
a string to be posted to the server.   The body is sent "as is";
the caller has to take care of necessary escaping or encoding.

So, the most simple form of retrieving the content will be
something like this:
@c JP
@var{request-uri}引数は、RFC2616で規定されているリクエストURIで、通常これは
HTTP URLのパス部分です。

@code{http-post}は、サーバへポストされる文字列、@var{body}を第3引数として
取ります。ボディは"そのまま"送られるので、呼び出し側は必要なエスケープや
エンコーディングを行う必要があります。

あるURLのコンテンツを取得する最もシンプルなフォームは次のようになるでしょう。
@c COMMON
@example
(http-get "www.shiro.dreamhost.com" "/scheme/index.html")
@end example

@c EN
Access via proxy can be done by specifying proxy server to @var{server}
and passing the entire URI to @var{request-uri}, but the author
haven't tested yet.
@c JP
プロクシを通してのアクセスは、@var{server}にプロクシ・サーバを指定し、
@var{request-uri}に完全なURIを渡すことで行えますが、まだテストされていません。
@c COMMON

@c EN
@strong{Return values:}
All procedures return three values.

The first value is the status code defined in RFC2616
in a string (such as "200" for success, "404" for "not found").
@c JP
@strong{戻り値:}
全ての手続きは3つの値を返します。

1つ目は、RFC2616で定義されているステータスコードの文字列値(例えば、成功時の
200、"Not found"の404など)です。
@c COMMON

@c EN
The second value is a list of parsed headers---each element of list
is a list of @code{(@var{header-name} @var{value} @dots{})}, 
where @var{header-name} is a string name of the header
(such as "content-type" or "location"), and @var{value} is
the corresponding value in a string.  The header name is converted
to lowercase letters.  The value is untouched except that "soft line breaks"
are removed, as defined in RFC2822.   If the server returns
more than one headers with the same name, their values are
consolidated to one list.  Except that, the order of the header list
in the second return value is the same as the order in the server's reply.
@c JP
2つ目は、パーズされたヘッダのリストで、リストの要素は@code{(@var{header-name}
@var{value} @dots{})}です。@var{header-name}はヘッダの文字列名(例えば、
"content-type"や"location"など)で、@var{value}は対応する値の文字列値です。
ヘッダ名は小文字に変換されます。値は、RFC2822で定義されている無指定行区切
(ソフト・ライン・ブレイク)が除かれる以外はそのままです。
サーバが同じ名前のヘッダを1つ以上返した場合は、
1つのリストに統合されます。それ以外では、2つ目の戻り値に
おけるヘッダのリストの順番は、サーバの応答での順番と同じです。
@c COMMON

@c EN
The third value is for the message body of the server's reply.
By default, it is a message body itself in a string.   If the server's
reply doesn't have a body, the third value is @code{#f}.  You can
change how the message body is handled by keyword arguments; for example,
you can directly store the returned message body to a file without
creating intermediate string.  The details are explained below.
@c JP
3つ目の戻り値は、サーバの応答におけるメッセージボディです。
デフォルトでは、文字列で表現されたメッセージボディそのものです。
サーバの応答がボディを持たない場合、3つ目の戻り値は@code{#f}です。
キーワード引数によって、メッセージボディがどのように扱われるかを制御できます。
例えば、中間的な文字列を作らずに、返されたメッセージボディを直接ファイルに
格納することが出来ます。詳細は以下で説明しています。
@c COMMON

@c EN
@strong{Keyword arguments:}
By default, these procedures only attaches @code{"Host"} header
field to the request message.  You can give keyword arguments
to add more header fields.
@c JP
@strong{キーワード引数:}
デフォルトで、これらの手続きはリクエストメッセージに@code{"Host"}ヘッダ・フィールドを
追加するだけです。他のヘッダ・フィールドを追加するためにキーワード引数を
与えることができます。
@c COMMON
@example
(http-get "foo.bar.com" "/index.html"
  :accept-language "ja"
  :user-agent "My Scheme Program/1.0")
@end example

@c EN
The following keyword arguments are recognized by the procedure
and do not appear in the request headers.
@c JP
以下のキーワード引数は手続きによって解釈され、リクエストヘッダには現れません。
@c COMMON

@table @var
@item no-redirect
@c EN
If a true value is given, suppress the redirection tracking;
i.e. the procedures return "3xx" message as is.
@c JP
真の値が与えられた場合、リダイレクションには従わなくなります。すなわち、
手続きは"3xx"のメッセージをそのまま返します。
@c COMMON
@item sink, flusher
@c EN
You can customize how the message body is handled by these
keyword arguments.  You have to pass an output port to @var{sink},
and a procedure that takes two arguments to @var{flusher}.

When the procedure starts receiving the message body, it
feeds the received chunk to @var{sink}.  When the procedure
receives entire message body, @var{flusher} method is called
with @var{sink} and a list of message header fields (in the
same format to be returned in the second value from the procedure).
The return value of @var{flusher} becomes the third return value
from the procedure.

So, the default value of @var{sink} is a newly opened string
port and the default value of @var{flusher} is
@code{(lambda (sink headers) (get-output-string sink))}.

The following example saves the message body directly to a file,
without allocating (potentially very big) string buffer.
@c JP
これらのキーワード引数によりメッセージ・ボディがどのように扱われるかを
カスタマイズできます。@var{sink}には出力ポートを、@var{flusher}には2引数を
取る手続きを渡さなければなりません。

手続きがメッセージ・ボディを受信し始めると、@var{sink}へ受け取った
データ片をフィードします。手続きがメッセージ・ボディを受信し終わると、
@var{flusher}に与えられた手続きが、@var{sink}と(手続きからの2つ目の
戻り値と同じフォーマットの)メッセージ・ヘッダ・フィールドのリストとともに
呼び出されます。@var{flusher}の戻り値が、手続きからの3つ目の戻り値と
なります。

したがって、@var{sink}のデフォルト値は、新しく開かれた文字列ポートで、
@var{flusher}のデフォルト値は@code{(lambda (sink headers) (get-output-string sink))}
とも言えます。

以下のサンプルは、(とても大きい可能性のある)文字列バッファを作らずに、
メッセージ・ボディを直接ファイルに保存します。
@c COMMON
@example
(call-with-output-file "page.html"
  (lambda (out)
    (http-get "www.schemers.org" "/"
       :sink out :flusher (lambda _ #t))))
@end example

@end table

@end defun

@c ----------------------------------------------------------------------
@node rfc.md5 - MD5 message digest, rfc.quoted-printable - Quoted-printable encoding/decoding, rfc.http - HTTP, Library modules - Utilities
@section @code{rfc.md5} - MD5 message digest
@c NODE rfc.md5 - MD5メッセージダイジェスト, @code{rfc.md5} - MD5メッセージダイジェスト

@deftp {Module} rfc.md5
@mdindex rfc.md5
This module implements MD5 message digest algorithm, defined in
RFC 1321 (@ref{rfc1321, [RFC1321], RFC1321}).
The module extends util.digest 
(@xref{util.digest - Message digester framework}).
@end deftp

@deftp {Class} <md5>
@clindex md5
The instance of this class keeps internal state of MD5 digest algorithm.

This class implements @code{util.digest} framework interface,
@code{digest-update!}, @code{digest-final!}, 
@code{digest}, and @code{digest-string}.
@xref{util.digest - Message digester framework}, for detailed explanation
of these methods.
@end deftp

Besides the digester framework, this module provides to 
short-cut procedures.

@defun md5-digest
Reads data from the current input port until EOF, and returns
its digest in an incomplete string.
@end defun

@defun md5-digest-string string
Digest the data in @var{string}, and returns the result 
in an incomplete string.
@end defun

@c ----------------------------------------------------------------------
@node rfc.quoted-printable - Quoted-printable encoding/decoding, rfc.sha1 - SHA1 message digest, rfc.md5 - MD5 message digest, Library modules - Utilities
@section @code{rfc.quoted-printable} - Quoted-printable encoding/decoding
@c NODE rfc.quoted-printable - Quoted-printableエンコーディング, @code{rfc.quoted-printable} - Quoted-printableエンコーディング

@deftp {Module} rfc.quoted-printable
@mdindex rfc.quoted-printable
This module defines a few functions to encode/decode Quoted-printable format,
defined in RFC 2045 (@ref{rfc2045, [RFC2045], RFC2045}), section 6.7.
@end deftp

@defun quoted-printable-encode
Reads byte stream from the current input port, encodes it in Quoted-printable
format and writes the result character stream to the current output port.
The conversion ends when it reads EOF from the current input port.
@end defun

@defun quoted-printable-encode-string string
Converts contents of @var{string} to Quoted-printable encoded format.
Input string can be either complete or incomplete string;
it is always interpreted as a byte sequence.
@end defun

@defun quoted-printable-decode
Reads character stream from the current input port,
decodes it from Quoted-printable
format and writes the result byte stream to the current output port.
The conversion ends when it reads EOF.
If it encounters illegal character sequence (such as '=' followed 
by non-hexadecimal characters), it copies them literally to the output.
@end defun

@defun quoted-printable-decode-string string
Decodes a Quoted-printable encoded string @var{string} and returns
the result as a string.
@end defun

@c ----------------------------------------------------------------------
@node rfc.sha1 - SHA1 message digest, rfc.uri - URI parsing and construction, rfc.quoted-printable - Quoted-printable encoding/decoding, Library modules - Utilities
@section @code{rfc.sha1} - SHA1 message digest
@c NODE rfc.sha1 - SHA1メッセージダイジェスト, @code{rfc.sha1} - SHA1メッセージダイジェスト

@deftp {Module} rfc.sha1
@mdindex rfc.sha1
This module implements US Secure Hash Algorithm 1 (SHA1), 
defined in RFC 3174 (@ref{rfc3174, [RFC3174], RFC3174}).
The module extends util.digest 
(@xref{util.digest - Message digester framework}).
@end deftp

@deftp {Class} <sha1>
@clindex sha1
The instance of this class keeps internal state of SHA1 digest algorithm.

This class implements @code{util.digest} framework interface,
@code{digest-update!}, @code{digest-final!}, 
@code{digest}, and @code{digest-string}.
@xref{util.digest - Message digester framework}, for detailed explanation
of these methods.
@end deftp

Besides the digester framework, this module provides to 
short-cut procedures.

@defun sha1-digest
Reads data from the current input port until EOF, and returns
its digest in an incomplete string.
@end defun

@defun sha1-digest-string string
Digest the data in @var{string}, and returns the result 
in an incomplete string.
@end defun

@c ----------------------------------------------------------------------
@node rfc.uri - URI parsing and construction, slib - SLIB, rfc.sha1 - SHA1 message digest, Library modules - Utilities
@section @code{rfc.uri} - URI parsing and construction
@c NODE URIの解析と作成, @code{rfc.uri} - URIの解析と作成

@deftp {Module} rfc.uri
@mdindex rfc.uri
@c EN
Provides a set of functions to parse Uniform Resource Identifiers
defined in RFC 2396 (@ref{rfc2396, [RFC2396], RFC2396}).
@c JP
RFC 2396 (@ref{rfc2396, [RFC2396], RFC2396})で定義されている
Uniform Resource Identifiers をパーズする関数を提供します。
@c COMMON
@end deftp

@defun uri-scheme&specific uri
@defunx uri-decompose-hierarchical specific
@defunx uri-decompose-authority authority
@c EN
General parser of URI.  These functions does not decode
URI encoding.

@code{uri-scheme&specific} takes a URI @var{uri}, and
returns two values, its scheme part and its scheme-specific part.
If @var{uri} doesn't have a scheme part, @var{#f} is returned for it.
@c JP
URIの一般的なパーザです。これらの関数はURIエンコーディングを
デコードしません。

@code{uri-scheme&specific} は URI @var{uri} を引数に取り、
スキーム部分と、そのスキーム特有の部分を表す2つの値を返します。
@var{uri} がスキーム部分を持たない場合、@var{#f} を返します。
@c COMMON
@example
(uri-scheme&specific "mailto:sclaus@@north.pole")
  @result{} "mailto" @r{and} "sclaus@@north.pole"
(uri-scheme&specific "/icons/new.gif")
  @result{} #f @r{and} "/icons/new.gif"
@end example

@c EN
If the URI scheme uses hierarchical notation, i.e.
``@code{//@var{authority}/@var{path}?@var{query}#@var{fragment}}'',
you can pass
the scheme-specific part to @code{uri-decompose-hierarchical}
and it returns four values, @var{authority}, @var{path}, @var{query}
and @var{fragment}.
@c JP
URI が階層的な記法を用いている場合、すなわち、
``@code{//@var{authority}/@var{path}?@var{query}#@var{fragment}}''
のような場合、スキーム特有の部分を @code{uri-decompose-hierarchical}
に渡すと、@var{authority}、@var{path}、@var{query}、@var{fragment}
の4つの値が返ります。
@c COMMON
@example
(uri-decompose-hierarchical "//www.foo.com/about/company.html")
  @result{} "www.foo.com"@r{,} "/about/company.html"@r{,} #f @r{and} #f
(uri-decompose-hierarchical "//zzz.org/search?key=%3fhelp")
  @result{} "zzz.org"@r{,} "/search"@r{,} "key=%3fhelp" @r{and} #f
(uri-decompose-hierarchical "//jjj.jp/index.html#whatsnew")
  @result{} "jjj.jp"@r{,} "/index.html"@r{,} #f @r{and} "whatsnew"
(uri-decompose-hierarchical "my@@address")
  @result{} #f@r{,} #f@r{,} #f @r{and} #f
@end example

@c EN
Furthermore, you can parse @var{authority} part of the
hierarchical URI by @code{uri-decompose-authority}.
It returns @var{userinfo}, @var{host} and @var{port}.
@c JP
さらに、階層的 URI の @var{authority} の部分を
@code{uri-decompose-authority} に渡すと、@var{userinfo}、
@var{host}、@var{port} が返ります。
@c COMMON
@example
(uri-decompose-authority "yyy.jp:8080")
  @result{} #f@r{,} "yyy.jp" @r{and} "8080"
(uri-decompose-authority "mylogin@@yyy.jp")
  @result{} "mylogin"@r{,} "yyy.jp" @r{and} #f
@end example
@end defun

@defun uri-compose &keyword scheme userinfo host port authority path path* query fragment specific
@c EN
Compose a URI from given components.
There can be various combinations of components to create a valid
URI---the following diagram shows the possible 'paths' of
combinations:
@c JP
与えられたコンポーネントから URI を構成します。
妥当な URI を作成するためのコンポーネントの組み合わせはたくさんあります。
以下のダイアグラムは、考え得る組み合わせの方法を示しています。
@c COMMON

@example
        /-----------------specific-------------------\
        |                                            |
 scheme-+------authority-----+-+-------path*---------+-
        |                    | |                     |
        \-userinfo-host-port-/ \-path-query-fragment-/
@end example

@c EN
If @code{#f} is given to a keyword argument, it is
equivalent to the absense of that keyword argument.
It is particulary useful to pass the results of
parsed uri.

If a component contains a character that is not appropriate
for that component, it must be properly escaped before
being passed to @code{url-compose}.

Some examples:
@c JP
キーワード引数に @code{#f} が与えられた場合、それはキーワード引数が
指定されないことと等価です。これは URI をパーズした結果を渡す場合に
特に有用です。

コンポーネントに適切でない文字が含まれている場合は、
@code{url-compose} に渡す前に正しくエスケープされなければなりません。

いくつかの例を示します。
@c COMMON
@example
(uri-compose :scheme "http" :host "foo.com" :port 80
             :path "/index.html" :fragment "top")
  @result{} "http://foo.com:80/index.html#top"

(uri-compose :scheme "http" :host "foo.net"
             :path* "/cgi-bin/query.cgi?keyword=foo")
  @result{} "http://foo.net/cgi-bin/query.cgi?keyword=foo"

(uri-compose :scheme "mailto" :specific "a@@foo.org")
  @result{} "mailto:a@@foo.org"

(receive (authority path query fragment)
   (uri-decompose-hierarchical "//foo.jp/index.html#whatsnew")
 (uri-compose :authority authority :path path
              :query query :fragment fragment))
  @result{} "//foo.jp/index.html#whatsnew"
@end example
@end defun

@defun uri-decode &keyword :cgi-decode
@defunx uri-decode-string string &keyword :cgi-decode
@c EN
Decodes ``URI encoding'', i.e. @code{%}-escapes.
@code{uri-decode} takes input from the current input port,
and writes decoded result to the current output port.
@code{uri-decode-string} takes input from @var{string} and
returns decoded string.

If @var{cgi-decode} is true, also replaces @code{+} to a space character.
@c JP
URI エンコーディング、すなわち、@code{%}でエスケープされた URI 文字列を
デコードします。@code{uri-decode} は現在の入力ポートから入力を受け取り、
デコードした結果を現在の出力ポートに書き出します。
@code{uri-decode-string} は @var{string} を入力とし、デコードした
文字列を返します。

@var{cgi-decode} が真の場合は、@code{+} がスペース文字に置換されます。
@c COMMON
@end defun

@defun uri-encode &keyword :noescape
@defunx uri-encode-string string &keyword :noescape
@c EN
Encodes unsafe characters by @code{%}-escape.  @code{uri-encode}
takes input from the current input port and writes the result to
the current output port.  @code{uri-encode-string} takes input
from @var{string} and returns the encoded string.

By default, characters that are not specified ``unreserved'' in
RFC2396 are escaped.  You can pass different character set
to @var{noescape} argument to keep from being encoded.

The multibyte characters are encoded as the octed stream of Gauche's
native multibyte representation.
@c JP
安全でない文字を、@code{%}によるエスケープでエンコードします。
@code{uri-encode} は現在の入力ポートから入力を受け取り、
結果を現在の出力ポートに書き出します。
@code{uri-encode-string} は @var{string} を入力とし、エンコードした
文字列を返します。

デフォルトでは、RFC2396 で"非予約文字"として規定されていない文字は
エスケープされます。@var{noescape} 引数に異なる文字セットを渡すことで、
それらがエンコードされるのを抑止することができます。

マルチバイト文字は、Gauche のネイティブなマルチバイト表現の
オクテット・ストリームとしてエンコードされます。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node slib - SLIB, text.csv - CSV tables, rfc.uri - URI parsing and construction, Library modules - Utilities
@section @code{slib} - SLIB interface

@deftp {Module} slib
@mdindex slib
@c EN
This module is the interface to the Aubrey Jaffer's SLIB.
To use SLIB, say @code{(use slib)}.   SLIB itself is not included
in Gauche distribution.   If you don't have it on your system,
get it from @uref{http://www-swiss.ai.mit.edu/~jaffer/SLIB.html}.
@c JP
このモジュールはAubrey Jaffer氏のSLIBへのインタフェースです。
SLIBがインストールされている場合、@code{(use slib)} とすれば
SLIBの機能が使えるようになります。
SLIBそのものはGaucheのディストリビューションには含まれていません。
あなたのシステムにまだインストールされていない場合は
@uref{http://www-swiss.ai.mit.edu/~jaffer/SLIB.html}から入手することができます。
@c COMMON

@c EN
This module redefines @code{require}, shadowing the Gauche's original
@code{require}.  If it gets a symbol as an argument, it works as
SLIB's @code{require}, while if it gets a string, it works as
Gauche's @code{require}.   The same applies to @code{provide} and
@code{provided?}.
@c JP
このモジュールは@code{require}を再定義し、Gaucheオリジナルの@code{require}を
シャドウします。@code{require}にシンボルが渡された場合はSLIBの@code{require}
のように動作します。@code{require}に文字列が渡された場合はGaucheの@code{require}
のように動作します。@code{provide}と@code{provided?}についても同様です。
@c COMMON

@c EN
All SLIB symbol bindings, loaded by @code{require}, stay in the
module @code{slib}.
@c JP
@code{require}でロードされる、SLIBで導入されるすべての定義は、
@code{slib}モジュール内で行われます。
@c COMMON
@end deftp

@example
(use slib)         ; @r{load and set up slib}
(require 'getopt)  ; @r{load SLIB's getopt module}
(require "foo")    ; @r{load Gauche's foo module}
@end example

@c ----------------------------------------------------------------------
@node text.csv - CSV tables, text.gettext - Dealing with localized messages, slib - SLIB, Library modules - Utilities
@section @code{text.csv} - CSV tables

@deftp {Module} text.csv
@mdindex text.csv
@c EN
Provides a function to parse/generate CSV (comma separated value) tables.
Actually, the separater is not limited to comma; you can customize it.

CSV format is widely used to exchange table-type data in plain text,
although there are apparently no ``formal'' specification.

CSV table is consisted by a series of @var{records}, separated by
a newline.  Each record contains number of @var{fields}, separated
by a separator character (by default, a comma).  A field can contain
comma or newline if quoted, i.e. surrounded by double-quote characters.
To include double-quote character in a quoted field, use two
consecutive double-quote character.   Usually, the whitespaces around
the field are ignored.
@c JP
CSV (カンマ区切りの値) の表をパーズ/生成するための手続きを提供します。
実際には、区切り文字はカンマに制限されず、カスタマイズできます。

CSV 形式は、「正式な」仕様が無さそうなのにも関わらず、プレーン・テキストで
表形式のデータを交換するために広く使われています。

CSV の表は、改行で区切られた @var{record} の連続で構成されます。
それぞれのレコードは、区切り文字(デフォルトではカンマ)で区切られた
複数の @var{field} を含みます。フィールドは、クォートされている
(二重引用符で囲まれている)場合は、カンマや改行を含むことができます。
クォートされたフィールドに二重引用符を含めるには、2つの連続する
二重引用符を使います。通常、フィールドの前後の空白は無視されます。
@c COMMON
@c example here

@end deftp

@c EN
Right now, the following two low-level procedures are exported.
A plan is to provide higher features, such as labelling fields
and automatic conversions.
@c JP
現時点では、以下の2つの低レベルな手続きが提供されています。
フィールドにラベル付けをしたり、自動的に変換するなどの
より高レベルな機能の提供を計画しています。
@c COMMON

@defun make-csv-reader separator
@c EN
Returns a procedure with one argument, input port.
When the procedure is called, it reads one record from the port,
and returns a list of fields.
If input reaches EOF, it returns EOF.
@c JP
入力ポートを唯一の引数として取る手続きを返します。
手続きが呼ばれると、ポートからレコードを1つ読み込み、フィールドの
リストを返します。入力ポートが EOF に達すると、EOF を返します。
@c COMMON
@end defun

@defun make-csv-writer separator &optional newline
@c EN
Returns a procedure with two arguments, output port and
a list of fields.  When the procedure is called, it
outputs a @var{separator}-separated fields with proper escapes,
to the output port.   You can also specify the record delimiter
string by @var{newline}; for example, you can pass @code{"\r\n"}
to prepare a file to be read by Windows programs.
@c JP
出力ポートとフィールドのリストの2つの引数を取る手続きを返します。
手続きが呼ばれると、@var{separator} で区切られたフィールドを
正しくエスケープして出力ポートに出力します。レコードの区切り文字列を
@var{newline} で指定することもできます。例えば、ファイルが Windows の
プログラムでも読めるように、@code{"\r\n"} を渡すことができます。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node text.gettext - Dealing with localized messages, text.html-lite - Simple HTML document construction, text.csv - CSV tables, Library modules - Utilities
@section @code{text.gettext} - Dealing with localized messages

@deftp {Module} text.gettext
@mdindex text.gettext
A module that provides a utility to deal with localized messages.
The API is pretty similar to GNU's gettext, and the messages
are read from @file{*.po} file, so that you can use the GNU texttext
toolchain to prepare localized messages.
However, the code is written from scratch by Alex Shinn and
doesn't depend on GNU's gettext library.

This implementation extends GNU's gettext API in the following ways:
@itemize @bullet
@item It can read from multiple message files in cascaded way,
      allowing applications to share a part of message files.
@item It supports multiple locale/domain simultaneously.
@end itemize
@end deftp

The following procedures are gettext-like APIs.

@defun textdomain domain-name
Selects the domain named by @var{domain-name} as the default domain.

Returns an @emph{accessor procedure} which packages information of
the domain, instead of just a domain name.

You can pass @code{#f} as @var{domain-name} just to get the default
domain accessor procedure.
@end defun

@defun gettext msg-id
Returns a translated message of @var{msg-id}.  If there's no
translated message, @var{msg-id} itself is returned.
@end defun

@defun bindtextdomain domain dirs
Sets the search path of domain @var{domain} to @var{dirs}, which 
may be just a single directory name or a list of directory names.
@end defun

@defun dgettext domain msg-id
@defunc dcgettext domain msg-id locale
Returns a translated message of @var{msg-id} in @var{domain}.
@code{Dcgettext} takes @var{locale} as well.
@end defun

The following procedure is more flexible interface, on top of which
the above APIs.

@defun make-gettext &optional domain locale dirs gettext-cached? lookup-cached?
Returns a @emph{access procedure}, which can be called like this:
@end defun

@c ----------------------------------------------------------------------
@node text.html-lite - Simple HTML document construction, text.parse - Parsing input stream, text.gettext - Dealing with localized messages, Library modules - Utilities
@section @code{text.html-lite} - Simple HTML document construction

@deftp {Module} text.html-lite
@mdindex text.html-lite
@c EN
Provides procedures to construct an HTML document easily.
For example, you can construct an HTML table by the following code:
@c JP
HTML ドキュメントを簡単に構築するための手続きを提供します。
例えば、以下のコードは HTML のテーブルを構築します。
@c COMMON
@example
(html:table
  (html:tr (html:th "Item No") (html:th "Quantity"))
  (html:tr (html:td 1) (html:td 120))
  (html:tr (html:td 2) (html:td 30))
  (html:tr (html:td 3) (html:td 215)))
@end example
@c EN
See the description of @code{html:@var{element}} below for details.

This module does little check for the constructed html documents,
such as whether the attributes are valid, and whether the content
of the element matches DTD.  It does not provide a feature to parse
the html document neither.  Hence the name `lite'.
@c JP
詳細については、以下の @code{html:@var{element}} の説明を見てください。

このモジュールでは生成されたHTMLドキュメントに関して、
例えばアトリビュートに有効な値が入っているか、要素の内容はDTDを満たしているか、
等のチェックをほとんど行いません。また、HTMLをパーズする関数も提供されません。
それが「lite」の名の由来です。
@c COMMON
@end deftp

@defun html-escape
@defunx html-escape-string string
@c EN
Escapes the ``unsafe'' characters in HTML.  @code{html-escape}
reads input string from the current input port and writes the result
to the current output port.   @code{html-escape-string} takes the
input from @var{string} and returns the result in a string.
@c JP
HTML に含まれる"安全でない"文字をエスケープします。
@code{html-escape} は、現在の入力ポートから文字列を読み込み、
結果を現在の出力ポートへ書き出します。@code{html-escape-string} は
@var{string} を入力とし、文字列を返します。
@c COMMON
@end defun

@defun html-doctype &keyword type
@c EN
Returns a doctype declaration for an HTML document.
@var{type} can be either one of @code{:strict}, @code{:transitional},
or @code{:frameset}, corresponding HTML4.01 strict, transitional or
frameset DTD, respectively.
@c JP
HTML ドキュメントの文書型宣言を返します。
@var{type} は、@code{:strict}、@code{:transitional}、@code{:frameset}
のいずれかで、それぞれ HTML 4.01 strict、transitional、frameset の
DTD に対応します。
@c COMMON
@end defun

@deftp {Function} html:@var{element} @var{args} @dots{}
@findex html:a
@findex html:abbr
@findex html:acronym
@findex html:address
@findex html:area
@findex html:b
@findex html:base
@findex html:bdo
@findex html:big
@findex html:blockquote
@findex html:body
@findex html:br
@findex html:button
@findex html:caption
@findex html:cite
@findex html:code
@findex html:col
@findex html:colgroup
@findex html:dd
@findex html:del
@findex html:dfn
@findex html:div
@findex html:dl
@findex html:dt
@findex html:em
@findex html:fieldset
@findex html:form
@findex html:h1
@findex html:h2
@findex html:h3
@findex html:h4
@findex html:h5
@findex html:h6
@findex html:head
@findex html:hr
@findex html:html
@findex html:i
@findex html:img
@findex html:input
@findex html:ins
@findex html:kbd
@findex html:label
@findex html:legend
@findex html:li
@findex html:link
@findex html:map
@findex html:meta
@findex html:noscript
@findex html:object
@findex html:ol
@findex html:optgroup
@findex html:option
@findex html:p
@findex html:param
@findex html:pre
@findex html:q
@findex html:samp
@findex html:script
@findex html:select
@findex html:small
@findex html:span
@findex html:strong
@findex html:style
@findex html:sub
@findex html:sup
@findex html:table
@findex html:tbody
@findex html:td
@findex html:textarea
@findex html:tfoot
@findex html:th
@findex html:thead
@findex html:title
@findex html:tr
@findex html:tt
@findex html:ul
@findex html:var
@c EN
Construct an HTML element @var{element}.  Right now,
the following elements are provided.
(The elements defined in HTML 4.01 DTD,
@uref{http://www.w3.org/TR/html4/sgml/dtd.html}).
@c JP
@var{element} の HTML 要素を構築します。現時点では以下の要素が
サポートされています。
(HTML 4.01 DTD @uref{http://www.w3.org/TR/html4/sgml/dtd.html}
に定義されている要素です)。
@c COMMON
@example
a        abbr       acronym    address     area      b
base     bdo        big        blockquote  body      br
button   caption    cite       code        col       colgroup
dd       del        dfn        div         dl        dt
em       fieldset   form       h1          h2        h3
h4       h5         h6         head        hr        html
i        img        input      ins         kbd       label
legend   li         link       map         meta      noscript
object   ol         optgroup   option      p         param
pre      q          samp       script      select    small
span     strong     style      sub         sup       table
tbody    td         textarea   tfoot       th        thead
title    tr         tt         ul          var
@end example

@c EN
The result of these functions is a tree of text segments,
which can be written out to a port by @code{write-tree} or
can be converted to a string by @code{tree->string}
(@xref{text.tree - Lazy text construction}).

You can specify attributes of the element by using a keyword-value
notation before the actual content.
@c JP
これらの手続きは、テキスト・セグメントのツリーを返すので、
@code{write-tree} でポートに書き出したり、@code{tree->string} で
文字列に変換したりできます
(@ref{text.tree - Lazy text construction}参照)。

要素のアトリビュートは要素の内容に先立つキーワード-値の表記で指定することができます。
@c COMMON
@example
(tree->string (html:a :href "http://foo/bar" "foobar"))
  @result{}
  "<a href=\"http://foo/bar\">foobar</a>\n"

(tree->string
  (html:table :width "100%" :cellpading 0 "content here"))
  @result{}
  "<table width=\"100%\" cellpadding=\"0\">content here</table>\n"
@end example

@c EN
The boolean value given to the attribute has a special meaning.
If @code{#t} is given, the attribute is rendered without a value.
If @code{#f} is given, the attribute is not rendered.
@c JP
属性に与える真偽値は特別な意味を持ちます。
@code{#t} が与えられると、属性は値なしでレンダリングされます。
@code{#f} が与えられると、属性それ自体がレンダリングされません。
@c COMMON
@example
(tree->string (html:table :border #t))
  @result{} "<table border></table>\n"

(tree->string (html:table :border #f))
  @result{} "<table></table>\n"
@end example

@c EN
Special characters in attribute values are escaped by the function,
but the ones in the content are not.  It is caller's responsibility
to escape them.

The functions signal an error if a content is given to the
HTML element that doesn't take a content.   They do not
check if the given attribute is valid, neither
if the given content is valid for the element.
@c JP
属性の値における特別な文字は、手続きによってエスケープされますが、
要素の内容にある特別な文字はエスケープされません。それをエスケープ
するのは呼び出し側の責任です。

内容を持たない HTML 要素に内容を与えると手続きはエラーを通知します。
手続きは、与えられた属性が妥当であるか、与えられた内容がその要素に
とって妥当であるかのチェックはしません。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node text.parse - Parsing input stream, text.tr - Transliterate characters, text.html-lite - Simple HTML document construction, Library modules - Utilities
@section @code{text.parse} - Parsing input stream

@deftp {Module} text.parse
@mdindex text.parse
@c EN
A collection of utilities that does simple parsing from
the input port.   The API is inspired, and compatible with
Oleg Kiselyov's input parsing library (@ref{oleg1,,OLEG1}).
His library is used in lots of other libraries, notably,
a full-Scheme XML parser/generator SSAX (@ref{ssax,,SSAX}).

You can use this module in place of his
@code{input-parse.scm} and @code{look-for-str.scm}.

I reimplemented the functions to be efficient on Gauche.
Especially, usage of @code{string-set!} is totally avoided.
I extended the interface a bit so that they can deal with character sets
and predicates, as well as a list of characters.

These functions work sequentially on the given input port,
that is, they read from the port as much as they need, without
buffering extra characters.
@c JP
入力ポートに対して単純な解析を行うユーティリティのコレクションです。
API は Oleg Kiselyov 氏の入力解析ライブラリ (@ref{oleg1,,OLEG1}) に
触発され、互換性を持つものです。氏のライブラリは、他のたくさんの
ライブラリで使われています。特に、Scheme のみで書かれたパーサ/ジェネレータ
である SSAX (@ref{ssax,,SSAX}) が挙げられます。

このモジュールは、氏の @code{input-parse.scm} や @code{look-for-str.scm}
の代わりに使うことができます。

Gauche で効果的になるように手続きを再実装しました。特に、@code{string-set!}
の使用は完全に取り除きました。インターフェースを少し拡張したので、
文字セットや述語、文字のリストにも使うことができます。

これらの手続きは、与えられた入力ポートに対してシーケンシャルに動作します。
それは、ポートから必要なだけ読み、余分な文字をバッファリングしないということです。
@c COMMON
@end deftp

@defun find-string-from-port? str in-port &optional max-no-chars
@c EN
Looks for a string @var{str} from the input port @var{in-port}.
The optional argument @var{max-no-chars} limits the maximum number of
characters to be read from the port; if omitted, the search span is
until EOF.

If @var{str} is found, this function returns the number of characters
it has read.   The next read from @var{in-port} returns the next char
of @var{str}.  If @var{str} is not found, it returns @code{#f}.

Note: Although this procedure has `@code{?}' in its name,
it may return non-boolean value, contrary to the Scheme convention.
@c JP
入力ポート @var{in-port} から、文字列 @var{str} を探します。
オプショナル引数 @var{max-no-chars} は、ポートから読み込まれる最大文字数を
制限します。省略されると、検索する範囲は EOF までとなります。

@var{str} が見つかると、手続きはすでに読み込んだ文字の数を返します。
@var{in-port} の次回の読み込みは、@var{str} の次の文字を返します。
@var{str} が見つからない場合、@code{#f} が返ります。

注意: この手続きはその名前に「@code{?}」がつきますが、Scheme の慣習に反し、
真偽値ではない値を返すことがあります。
@c COMMON
@end defun

@defun peek-next-char &optional port
@c EN
Discards the current character and peeks the next character from @var{port}.
Useful to look ahead one character.
If @var{port} is omitted, the current input port is used.
@c JP
現在の文字を破棄し、@var{port} から次の文字を読みます。一文字先読みするのに
便利です。@var{port} が省略されると、現在の入力ポートが使われます。
@c COMMON
@end defun

@c EN
In the following functions, @var{char-list} refers to one of the
followings:
@itemize @bullet
@item
A character set.
@item
A list of characters, character sets and/or symbol @code{*eof*}.
@end itemize
That denotes a set of characters.  If a symbol @code{*eof*} is
included, the EOF condition is also included.  Without @code{*eof*},
the EOF condition is regarded as an error.
@c JP
以下の手続きでは、@var{char-list} は次のどれかを意味します。
@itemize @bullet
@item
文字セット。
@item
文字、文字セット、シンボル @code{*eof*} の任意の組み合わせのリスト。
@end itemize
[That denotes a set of characters.] シンボル @code{*eof*} が含まれる場合、
EOF の条件もまた含まれます。@code{*eof*} が含まれない場合、EOF の条件は
エラーとして扱われます。
@c COMMON

@defun assert-curr-char char-list string &optional port
@c EN
Reads a character from @var{port}.  If it is included in @var{char-list},
returns the character.  Otherwise, signals an error with a message
containing @var{string}.
If @var{port} is omitted, the current input port is used.
@c JP
@var{port} から文字を読みます。その文字が @var{char-list} に含まれている場合は
その文字を返します。そうでなければ、@var{string} を含むメッセージとともに
エラーを通知します。
@c COMMON
@end defun

@defun skip-until char-list/number &optional port
@c EN
@var{char-list/number} is either a char-list or a number.
If it is a number; it reads that many characters and returns @code{#f}.
If the input is not long enough, an error is signalled.
If @var{char-list/number} is a char-list, it reads from @var{port}
until it sees a character that belongs to the char-list.
Then the character is returned.
If @var{port} is omitted, the current input port is used.
@c JP
@var{char-list/number} は、文字のリストか数です。
数の場合、たくさんの文字を読んで、@code{#f} を返します。
入力が十分に長くない場合は、エラーが通知されます。
@var{char-list/number} が文字のリストの場合、その文字リストに属する文字に
出会うまで @var{port} を読み込み、その文字を返します。
@var{port} が省略された場合、現在の入力ポートが使われます。
@c COMMON
@end defun

@defun skip-while char-list &optional port
@c EN
Reads from @var{port} until it sees a character that does not
belong to @var{char-list}.  The character remains in the stream.
If it reaches EOF, an EOF is returned.
If @var{port} is omitted, the current input port is used.

This example skips whitespaces from input.  Next read from
port returns the first non-whitespace character.
@c JP
@var{char-list} に属しない文字に出会うまで、@var{port} を読み込みます。
文字はストリームに残されます。EOF に達したら EOF が返されます。
@var{port} が省略された場合、現在の入力ポートが使われます。

この例では、入力から空白スペースをスキップしています。ポートからの次の
読み込みは、最初の空白スペースでない文字を返します。
@c COMMON
@example
(skip-while #[\s] port)
@end example
@end defun

@defun next-token prefix-char-list break-char-list &optional comment port
@c EN
Skips any number of characters in @var{prefix-char-list},
then collects the characters until it sees @var{break-char-list}.
The collected characters are returned as a string.
The break character remains in the @var{port}.

If the function encounters EOF and @code{*eof*} is not included in
@var{break-char-list}, an error is signalled with @var{comment} is
included in the message.
@c JP
@var{prefix-char-list} に含まれる文字はいくつでもスキップします。
そして、@var{break-char-list} に含まれる文字に出会うまで、文字を
蓄積します。蓄積された文字群は文字列として返されます。
中断文字は @var{port} に残されます。

手続きが EOF に達し、@code{*eof*} が @var{break-char-list} に含まれていない
場合、@var{comment} が含まれたメッセージとともにエラーが通知されます。
@c COMMON
@end defun

@defun next-token-of char-list/pred &optional port
@c EN
Reads and collects the characters as far as
it belongs to @var{char-list/pred}, then returns them as a string.
The first character that doesn't belong to @var{char-list/pred} remains
on the port.

@var{char-list/pred} may be a char-list or a predicate that takes
a character.   If it is a predicate, each character is passed to it,
and the character is regarded to ``belong to'' @var{char-list/pred}
when it returns a true value.
@c JP
読み込んだ文字が @var{char-list/pred} にある限り蓄積し、文字列として
返します。@var{char-list/pred} に含まれない最初の文字はポートに残されます。

@var{char-list/pred} は文字のリストか文字を取る述語です。述語の場合、
それぞれの文字がその述語に渡され、真の値が返る場合はその文字は
@var{char-list/pred} に属するとみなされます。
@c COMMON
@end defun

@defun read-string n &optional port
@c EN
Reads up to @var{n} characters, collects them into a string, and returns it.
If the input stream contains less characters, the returns string contains
as many characters available.
@c JP
@var{n} 文字まで読み込み、文字列として蓄積しそれを返します。
入力ストリームに含まれる文字のほうが少ない場合、有効な文字を可能な限り
含む文字列が返ります。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node text.tr - Transliterate characters, text.tree - Lazy text construction, text.parse - Parsing input stream, Library modules - Utilities
@section @code{text.tr} - Transliterate characters
@c NODE text.tr - 文字変換, @code{text.tr} - 文字変換

@deftp {Module} text.tr
@mdindex text.tr
@c EN
This module implements a transliterate function,
that substitutes characters of the input string.
This functionality is realized in Unix @code{tr(1)} command,
and incorporated in various programs such as @code{sed(1)}
and @code{perl}.

Gauche's @code{tr} is aware of multibyte characters.
@c JP
このモジュールは、入力ストリームから指定の文字を置き換えて出力する、
文字変換(transliterate)機能を提供します。
Unixの@code{tr(1)}コマンドで実装され、@code{sed}や@code{perl}にも
採り入れられている機能です。

Gaucheの@code{tr}はマルチバイト文字／文字列を正しく扱います。
@c COMMON
@end deftp

@defun tr from-list to-list &keyword :complement :delete :squeeze :table-size :input :output
@c EN
Reads from @var{input} and writes to @var{output},
with transliterating characters in @var{from-list} to the
corresponding ones in @var{to-list}.  Characters that doesn't
appear in @var{from-list} are passed through.
@c JP
@var{input}から文字を読み込み、その文字が@var{from-list}内にあれば
対応する@var{to-list}内の文字に置き換えて、@var{output}へと書き出します。
@var{from-list}に無い文字はそのまま@var{output}へと渡されます。
@c COMMON

@c EN
The default values of @var{input} and @var{output} are
current input port and current output port, respectively.
@c JP
@var{input}と@var{output}の既定値はそれぞれ現在の入力ポートと
出力ポートです。
@c COMMON

@c EN
Both @var{from-list} and @var{to-list} must be strings.
They may contain the following special syntax.
Other characters that doesn't fits in the syntax are taken as they are.
@c JP
@var{from-list}と@var{to-list}は文字列でなければなりません。
その中には次のような表記を使うことができます。それ以外の文字はそのまま使われます。
@c COMMON

@table @code
@item @b{x-y}
@c EN
Expanded to the increasing sequence of characters from @code{x} to @code{y},
inclusive.  The order is determined by the internal character
encoding system; generally it is safer to limit use of this within
the range of the same character class.   The character @code{x}
must be before @code{y}.
@c JP
文字@code{x}から文字@code{y}までの文字の昇順の並びと解釈されます。
@code{x}と@code{y}は含まれます。文字の並びはGaucheの内部文字エンコーディングに
よって決定されるので、一般には@code{x}と@code{y}は同じキャラクタクラスの中に
止めておいた方が安全でしょう。@code{x}は@code{y}より小さくなければなりません。
@c COMMON

@item @b{x*n}
@c EN
Repeat @code{x} for @code{n} times.  @code{n} is a decimal number notation.
Meaningful only in
@var{to-list}; it is an error to use this form in @var{from-list}.
If @code{n} is omitted or zero, @code{x} is repeated until @var{to-list}
matches the length of @var{from-list} (any character after it is ignored).
@c JP
文字@code{x}の@code{n}個の並び。@code{n}は10進数で表記された数値です。
これは@var{to-list}でのみ有効で、@var{from-list}で使うとエラーになります。
@code{n}が省略されるか0の場合、@code{x}は@var{to-list}の長さが@var{from-list}
の長さに達するまで繰り返されます(その場合、@var{to-list}の残りは無視されます)。
@c COMMON

@item @b{@code{\}x}
@c EN
Represents @code{x} itself.  Use this escape to avoid a special
character to be interpreted as itself.   Note that if you place
a backslash in a string, you must write @code{\\}, for the Scheme
reader also interprets backslash as a special character.

There's no special sequence to represent non-graphical characters,
for you can put such characters by the string syntax.
@c JP
文字@code{x}それ自身。特殊文字そのものを埋め込みたい場合に使います。
文字列のリーダも@code{\}を解釈するので、@code{\\}と書かねばならないことに注意
して下さい。

グラフィカルでない文字のための構文はありません。文字列リーダの構文を使って
そのような文字を文字列に含めることができます。
@c COMMON
@end table

@c EN
Here's some basic examples.
@example
;; @r{swaps case of input}
(tr "A-Za-z" "a-zA-Z")

;; @r{replaces 7-bit non-graphical characters to `?'}
(tr "\x00-\x19\x7f" "?*")
@end example
@c JP
いくつか例を挙げます。
@example
;; @r{大文字と小文字を交換します}
(tr "A-Za-z" "a-zA-Z")

;; @r{ひらがなとかたかなを交換します}
(tr "ぁ-んァ-ン" "ァ-ンぁ-ん")

;; @r{7ビットのノングラフィカルな文字を`?'に変換します}
(tr "\x00-\x19\x7f" "?*")
@end example
@c COMMON

@c EN
If @var{to-list} is shorter than @var{from-list}, the behavior
depends on the keyword argument @var{delete}.  If a true value is
given,  characters that appear in @var{from-list} but not
in @var{to-list} are deleted.   Otherwise, 
the extra characters in @var{from-list} are just passed through.
@c JP
@var{to-list}が@var{from-list}より短い場合、動作はキーワード引数@var{delete}に
依存します。もし真の値が@var{delete}に与えられれば、@var{from-list}に現われて
@var{to-list}に対応するものがない文字は入力から取り除かれます。そうでなければ
そのような文字はそのまま出力されます。
@c COMMON

@c EN
When a true value is specified to @var{complement},
the character set in @var{from-list} is complemented.
Note that it implies @emph{huge} set of characters,
so it is not very useful unless either output character
set is a single character (using `*') or used with
@code{delete} keyword.
@c JP
真の値が@var{complement}に与えられた場合、@var{from-list}の文字の
補集合が@var{from-list}として使われます。この文字集合は極めて大きくなる
可能性があることに注意してください。従って、一般にこのオプションは
@var{to-list}に`*'を使ってそれらの文字を一文字にマッピングするか、
@code{delete}オプションと併用するかしないとあまり意味がありません。
@c COMMON

@c EN
When a true value is specified to @var{squeeze},
the sequence of the same replaced characters is squeezed to one.
If @var{to-list} is empty, the sequence of the same characters
in @var{from-list} is squeezed.
@c JP
真の値が@var{squeeze}に与えられた場合、同じ文字への置換が2つ以上並ぶ場合に
2つめ以降の文字が削除されます。@var{to-list}が空の場合は、@var{from-list}
に含まれる文字で同一文字が並んだ場合に2つめ以降の文字が削除されます。
@c COMMON

@c EN
Internally, @code{tr} builds a table to map the characters for
efficiency.  Since Gauche can deal with potentially huge set
of characters, it limits the use of the table for only smaller
characters (<256 by default).  If you want to transliterate
multibyte characters on the large text, however, you might want 
to use larger table, trading off the memory usage.  You can specify
the internal table size by @var{table-size} keyword argument.
For example, if you transliterate lots of EUC-JP hiragana text
to katakana, you may want to set table size greater than 42483
(the character code of the last katakana).
@c JP
内部的に、@code{tr}はキャラクタのマッピングのためにテーブルを使用します。
但し、Gaucheでは極めて大きな文字セットを扱うため、テーブルはキャラクタコードの
小さい文字のみに対して使われます(デフォルトではコード255以下の文字)。
もし、より大きな文字を頻繁に変換することが分かっていて、メモリを余分に使っても
速度を上げたい場合は、このテーブルの大きさを@var{table-size}キーワード引数で
指定することができます。例えばEUC-JPコードで大量の平仮名と片仮名を変換する場合は、
@var{table-size}を42483以上にすると、全ての変換がテーブルルックアップで
行われます。
@c COMMON

@c EN
Note that the pre-calculation to build the transliterate table
needs some overhead.  If you want to call @code{tr} many times
inside loop, consider to use @code{build-transliterator} described below.
@c JP
@code{tr}が変換テーブルを計算するのにいくらかオーバーヘッドがあることに
注意して下さい。内側のループで@code{tr}を繰り返し呼ぶような場合は
下に示す@code{build-transliterator}を使った方が良いでしょう。
@c COMMON
@end defun

@defun string-tr string from-list to-list &keyword :complement :delete :squeeze :table-size
@c EN
Works like @code{tr}, except that input is taken from a string @var{string}.
@c JP
入力を@var{string}から取って変換結果を文字列で返す以外は@code{tr}と同じです。
@c COMMON
@end defun

@defun build-transliterator from-list to-list &keyword :complement :delete :squeeze :table-size :input :output
@c EN
Returns a procedure that does the actual transliteration.  This effectively
``pre-compiles'' the internal data structure.   If you want to run
@code{tr} with the same sets repeatedly, you may build the procedure
once and apply it repeatedly, saving the overhead of initialization.
@c JP
実際の変換動作をする手続きを作成して返します。内部データのセットアップを済ませるため、
同じ文字変換セットに対して@code{tr}を繰り返し呼ぶような場合は、この手続きを用いることで
初期化のオーバヘッドを軽減することができます。
@c COMMON

@example
(with-input-from-file "huge-file.txt"
  (lambda ()
    (let loop ((line (read-line)))
      (unless (eof-object? line) (tr "A-Za-z" "a-zA-Z")))))

@c EN
;; @r{runs more efficiently...}
@c JP
;; @r{以下の方が効率良く動作します...}
@c COMMON

(with-input-from-file "huge-file.txt"
  (lambda ()
    (let ((ptr (build-transliterator "A-Za-z" "a-zA-Z")))
      (let loop ((line (read-line)))
        (unless (eof-object? line) (ptr))))))
@end example

@end defun

@c ----------------------------------------------------------------------
@node text.tree - Lazy text construction, util.combinations - Combination library, text.tr - Transliterate characters, Library modules - Utilities
@section @code{text.tree} - Lazy text construction

@deftp {Module} text.tree
@mdindex text.tree
@c EN
Defines simple but commonly used functions for a text construction.

When you generate a text by a program, 
It is a very common operation to concatenate text segments.
However, using string-append repeatedly causes unnecessary
copying of intermediate strings, and sometimes such intermediate
strings are discarded due to the error situation (for example,
think about constucting an HTML document in the CGI script).

The efficient technique is to delay concatenation of those
text segments until it is needed.  In Scheme it is done very
easily by just consing the text segments together, thus forming
a tree of text, and then traverse the tree to construct a text.
You can even directly writes out the text during traversal,
avoiding intermediate string buffer.
(Hans Boehm's ``cord'' library, which comes with his garbage
collector library, uses this technique and proves it is very
efficient for editor-type application).

Although the traversal of the tree can be written in a
few lines of Scheme, I provide this module in the spirits
of OnceAndOnlyOnce.   Also it's easier if we have a common interface.
@c JP
テキストを生成する場合によく使われるシンプルな手続きを定義します。

プログラムでテキストを生成する場合、テキストの断片をつなぎ合わせて行く操作が
非常に多く現われます。しかし単純に@code{string-append}を繰り返し
呼んでしまうと、中間結果の文字列を保持するためだけにメモリアロケーションが多発しますし、
途中でエラーが発生した場合にその中間結果は結局捨てられてしまうかもしれません
(例えば、CGIスクリプト中でHTMLドキュメントを構築してゆくような場合を考えてみて下さい)。

よく知られた効率の良い方法は、テキストの断片をつなぎ合わせるのを本当に必要に
なるまで遅らせることです。Schemeではそれは非常に簡単です。単に断片をコンス
していって木構造を作り、最後にそれをトラバースしてテキストを作成するのです。
場合によっては、トラバースしながらテキストを出力すれば事足りてしまうので、
中間結果のバッファを持つ必要さえありません。
(Hans Boehmのガベージコレクションライブラリに附属している ``cord'' ライブラリ
はこのテクニックを実装したもので、エディタ等のアプリケーションで非常に効率良く
動作することが知られています)。

木構造をトラバースする手続きなどほんの2〜3行で書けてしまいますが、
「一度、そして一度だけ」の精神の下に、このモジュールを提供します。
インタフェースが統一されてたほうが便利ですしね。
@c COMMON
@end deftp

@deffn {Generic Function} write-tree tree &optional out
@c EN
Writes out an @var{tree} as a tree of text, to the output port @var{out}.
If @var{out} is omitted, the current output port is used.

Two methods are defined for this generic function, as shown below.
If you have more complex behavior, you can define more methods
to customize the behavior.
@c JP
@var{tree}をテキストの木構造とみなして、出力ポート@var{out}に出力します。
@var{out}が省略された場合は現在の出力ポートが使われます。

下に示す2つのメソッドが定義されています。より複雑な動作をさせたい場合は、
単純なリストの替わりにノードとなるクラスを定義して、それにメソッドを定義するようにすれば
動作をカスタマイズできます。
@c COMMON
@end deffn

@deffn {Method} write-tree ((tree <list>) out)
@deffnx {Method} write-tree ((tree <top>) out)
@c EN
Default methods.  For a list, @code{write-tree} is recursively
called for each element.  Any objects other than list is written out
using @code{display}.
@c JP
@code{write-tree}の既定の動作です。@var{tree}がリストなら、その要素それぞれに
ついて@code{write-tree}を呼び出します。それ以外のオブジェクトに関しては
@code{display}を呼んで出力します。
@c COMMON
@end deffn

@defun tree->string tree
@c EN
Just calls the @code{write-tree} method for @var{tree} using
an output string port, and returns the result string.
@c JP
出力文字列ポートを作成して@code{write-tree}を呼び、生成された文字列を返します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node util.combinations - Combination library, util.digest - Message digester framework, text.tree - Lazy text construction, Library modules - Utilities
@section @code{util.combinations} - Combination library

@deftp {Module} util.combinations
@mdindex util.combinations
This module implements several useful procedures of
combinations, permutations and related operations.

Most procedures in the module have two variants: a procedure without
star (e.g. @code{permutations}) treats all elements in the given
set distinct, while a procedure with star (e.g. @code{permutations*})
considers duplication.  The procedures with star take optional @var{eq}
argument that is used to test equality, which defaults to @code{eqv?}.
@end deftp

@defun permutations set
@defunx permutations* set &optional eq
Returns a list of all permutations of a list @var{set}.

@example
(permutations '(a b c))
  @result{} ((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))

(permutations '(a a b))
  @result{} ((a a b) (a b a) (a a b) (a b a) (b a a) (b a a))

(permutations* '(a a b))
  @result{} ((a a b) (a b a) (b a a))
@end example

The number of possible permutations explodes if @var{set} has
more than several elements.  Use with care.  If you want to process
each permutation at a time, consider @code{permutations-for-each} below.
@end defun

@defun permutations-for-each proc set
@defunx permutations*-for-each proc set &optional eq
For each permutation of a list @var{set}, calls @var{proc}.
Returns an undefined value.
@end defun

@defun combinations set n
@defunx combinations* set n &optional eq
Returns a list of all possible combinations of @var{n} elements out
of a list @var{set}.

@example
(combinations '(a b c) 2)
  @result{} ((a b) (a c) (b c))

(combinations '(a a b) 2)
  @result{} ((a a) (a b) (a b))

(combinations* '(a a b) 2)
  @result{} ((a a) (a b))
@end example

Watch out the explosion of combinations when @var{set} is large.
@end defun

@defun combinations-for-each proc set n
@defunx combinations*-for-each proc set n &optional eq
Calls @var{proc} for each combination of @var{n} elements out of @var{set}.
Returns an undefined value.
@end defun

@defun power-set set
@defunx power-set* set &optional eq
Returns power set (all subsets) of a list @var{set}.

@example
(power-set '(a b c))
  @result{} (() (a) (b) (c) (a b) (a c) (b c) (a b c))

(power-set* '(a a b)
  @result{} (() (a) (b) (a a) (a b) (a a b))
@end example
@end defun

@defun power-set-for-each proc set
@defunx power-set*-for-each proc set &optional eq
Calls @var{proc} for each subset of @var{set}.
@end defun

@defun power-set-binary set
Returns power set of @var{set}, like @code{power-set}, but in different order.
@code{Power-set-binary} traverses subset space in depth-first order,
while @code{power-set} in breadth-first order.

@example
(power-set-binary '(a b c))
  @result{} (() (c) (b) (b c) (a) (a c) (a b) (a b c))
@end example
@end defun

@defun cartesian-product list-of-sets
@defunx cartesian-product-right list-of-sets
Returns a cartesian product of sets in @var{list-of-sets}.
@code{Cartesian-product} construct the result in left fixed order
(the rightmost element varies first), while 
@code{cartesian-product-right} in right fixed order
(the leftmost element varies first).

@example
(cartesian-product '((a b c) (0 1)))
  @result{} ((a 0) (a 1) (b 0) (b 1) (c 0) (c 1))

(cartesian-product-right '((a b c) (0 1)))
  @result{} ((a 0) (b 0) (c 0) (a 1) (b 1) (c 1))
@end example
@end defun

@c ----------------------------------------------------------------------
@node util.digest - Message digester framework, util.isomorph - Determine isomorphism, util.combinations - Combination library, Library modules - Utilities
@section @code{util.digest} - Message digester framework
@c NODE util.digest - メッセージダイジェストフレームワーク, @code{util.digest} - メッセージダイジェストフレームワーク

@deftp {Module} util.digest
@mdindex util.digest
This module provides a base class and common interface for 
message digest algorithms, such as MD5 (@xref{rfc.md5 - MD5 message digest})
and SHA1 (@xref{rfc.sha1 - SHA1 message digest}).
@end deftp

@deftp {Class} <message-digest-algorithm-meta>
@clindex message-digest-algorithm-meta
A metaclass of message digest algorithm implementation.
@end deftp

@deftp {Class} <message-digest-algorithm>
@clindex message-digest-algorithm
A base class of message digest algorithm implementation.
@end deftp

The concrete subclass of message digest algorithm has to
implement the following methods.

@deffn {Generic function} digest-update! algorithm data
Takes the instance of massage-digest algorithm, and updates it
with the data @var{data}, represented in a (possibly incomplete) string.
@end deffn

@deffn {Generic function} digest-final! algorithm
Finalizes the instance of message-digest algorithm, and
returns the digest result in an incomplete string.
@end deffn

@deffn {Generic function} digest class
A wrapper of digest routines.  Given message-digest algorithm @var{class},
this function reads the input data from current input port until EOF,
and returns the digest result in an incomplete string.
@end deffn

@deffn {Generic function} digest-string class string
A wrapper of digest routines.  Given message-digest algorithm @var{class},
this function reads the input data from @var{string},
and returns the digest result in an incomplete string.
@end deffn

@defun digest-hexify digest-result
An utility procedure.  Given the result of digest, @var{digest-result},
converts it to a hexified string.
@end defun

@c ----------------------------------------------------------------------
@node util.isomorph - Determine isomorphism, util.list - Additional list library, util.digest - Message digester framework, Library modules - Utilities
@section @code{util.isomorph} - Determine isomorphism
@c NODE util.isomorph - 同型判定, @code{util.isomorph} - 同型判定

@deftp {Module} util.isomorph
@mdindex util.isomorph
@c EN
Provides a procedure that determines whether two structures are
isomorphic.
@c JP
二つの構造が同型かどうかを判定する手続きを提供するモジュールです。
@c COMMON
@end deftp

@defun isomorphic? obj1 obj2 &optional context
@c EN
Returns @code{#t} if @var{obj1} and @var{obj2} are isomorphic.

@var{context} is used if you want to call @code{isomorphic?}
recursively inside @code{object-isomorphic?} described below.
@c JP
@var{obj1}と@var{obj2}が同型であれば@code{#t}を返します。

省略可能な引数@var{context}は、下で説明する@code{object-isomorphic?}
の中から@code{isomorphic?}を再帰的に呼び出す場合に使います。
@c COMMON

@example
(isomorphic? '(a b) '(a b)) @result{} #t

(define x (cons 0 0))
(define y (cons 0 0))
(isomorphic? (cons x x)
             (cons x y))
 @result{} #f
(isomorphic? (cons x x)
             (cons y y))
 @result{} #t
@end example
@end defun

@deffn {Generic Function} object-isomorphic? obj1 obj2 context
@c EN
With this method, you can customize how to determine isomorphism of
two objects.  Basically, you will call @code{isomorphic?} recursively
for each slots of object you want to traverse; the method should return
@code{#t} if all of the test succeeds, or return @code{#f} otherwise.
@var{context} is an opaque structure
that keeps the traversal context, and you should pass it to
@code{isomorphic?} as is.

The default method returns @code{#t} if @var{obj1} and @var{obj2} are
equal (in the sense of @code{equal?}).
@c JP
このメソッドで、二つのオブジェクトの同型判定処理をカスタマイズできます。
基本的には、オブジェクトのトラバースしたいスロットに対して@code{isomorphic?}を順に適用し、
全てが成功すれば@code{#t}を、一つでも失敗すれば@code{#f}を返すようにします。
@var{context}はトラバースのコンテクストを保持しているオブジェクトです。そのまま
@code{isomorphic?}に渡して下さい。

デフォルトメソッドは、@var{obj1}と@var{obj2}が@code{equal?}の意味で等しければ
@code{#t}を返します。
@c COMMON
@end deffn

@c ----------------------------------------------------------------------
@node util.list - Additional list library, util.queue - Queue, util.isomorph - Determine isomorphism, Library modules - Utilities
@section @code{util.list} - Additional list library

@deftp {Module} util.list
@mdindex util.list
This module provides list utility functions which are not in srfi-1
(@xref{srfi-1 - List library}) but generally useful.

See also @ref{gauche.collection - Collection framework}
and @ref{gauche.sequence - Sequence framework}, for
these modules also defines useful generic functions that can
be used for lists.
@end deftp

@defun take* list k &optional fill? padding
Returns a list that consists of the first @var{k} elements in
@var{list}, like SRFI-1's @code{take}, except this procedure
is more tolerant.  That is, if @var{list}
is shorter than @var{k}, @code{take*} doesn't signals an error.
Instead, it returns a copy of @var{list} by default (or the optional
argument @var{fill?} is @code{#f}).   If @var{fill?} is true,
@var{padding} is added to the result to make its length @var{k}.
The default value of @var{padding} is @code{#f}.

@example
(take* '(a b c d) 3)       @result{} (a b c)
(take* '(a b c d) 6)       @result{} (a b c d)
(take* '(a b c d) 6 #t)    @result{} (a b c d #f #f)
(take* '(a b c d) 6 #t 'z) @result{} (a b c d z z)
@end example
@end defun

@defun drop* list k
Returns a list that the first @var{k} elements of @var{list} is
dropped, like SRFI-1's @code{drop}, except this procedure
is more tolerant.  If @var{list} is shorter than @var{k},
an empty list is returned.

@example
(drop* '(a b c d) 3)       @result{} (d)
(drop* '(a b c d) 5)       @result{} ()
@end example
@end defun

@defun take-right* list k &optional fill? padding
Like @code{take*}, but counts from right of @var{list}.
If needed, @var{padding} is added on left of the result.
@end defun

@defun drop-right* list k
Like @code{drop*}, but counts from right of @var{list}.
@end defun

@defun split-at* list k &optional fill? padding
More tolerant version of SRFI-1's @code{split-at}.
Returns the results of @code{take*} and @var{drop*}.

@example
(split-at* '(a b c d) 6 #t 'z)
  @result{} (a b c d z z) @r{and} ()
@end example
@end defun

@defun slices list k &optional fill? padding
Splits @var{list} into the sublists (slices) where the length of
each slice is @var{k}.
If the length of @var{list} is not a multiple of @var{k},
the last slice is dealt in the same way as @code{take*}; that is,
it is shorter than @var{k} by default, or added @var{padding} if
@var{fill?} is true.

@example
(slices '(a b c d e f g) 3)
  @result{} ((a b c) (d e f) (g))
(slices '(a b c d e f g) 3 #t 'z)
  @result{} ((a b c) (d e f) (g z z))
@end example
@end defun

@c ----------------------------------------------------------------------
@node util.queue - Queue, util.toposort - Topological sort, util.list - Additional list library, Library modules - Utilities
@section @code{util.queue} - Queue
@c NODE util.queue - キュー, @code{util.queue} - キュー

@deftp {Module} util.queue
@mdindex util.queue
@c EN
Provides a queue (FIFO).   This implementation is tuned for speed
than safety; a queue is simply a pair that keeps head and tail of
the queue, and minimal check is done in most of the operations.

SLIB (@xref{slib - SLIB}) provides the queue library that is safer.
This API is upper compatible to the SLIB's.
The idea is that this queue is used inside other procedure or
structure that you know you don't need the strict checks.
Use either one depending on your requirement.
@c JP
キュー(FIFO)機能を提供します。この実装は安全さよりスピードに重点を置いています。
キューは単に先頭と末尾のpairで表現され、多くのオペレーションでキューが正しいかどうかは
チェックされません。

SLIB (@ref{slib - SLIB}参照)にはより安全なキューの実装があります。
このAPIはSLIBの実装の上位互換です。特定の手続きや構造体の中だけで使うため、
厳しいチェックが必要でない場合にはこのモジュールを使うのが良く、そうでない場合は
SLIBのものが良いでしょう。要求仕様によって使い分けて下さい。
@c COMMON
@end deftp

@defun make-queue
@c EN
Creates and returns an empty queue.
@c JP
空のキューを作って返します。
@c COMMON
@end defun

@defun queue? obj
@c EN
Returns @code{#t} if @var{obj} is a queue.  This operation checks
@var{obj} is really in a shape of the queue.
@c JP
@var{obj}がキューであれば@code{#t}を返します。この操作に限り、@var{obj}が
本当にキューの構造をしているかどうかのチェックがなされます。
@c COMMON
@end defun

@defun queue-empty? queue
@c EN
Returns @code{#t} if @var{obj} is an empty queue.
@c JP
@var{obj}が空のキューであれば@code{#t}を返します。
@c COMMON
@end defun

@defun queue-length queue
@c EN
Returns the number of the items in the queue.
@c JP
キューの中にあるアイテムの数を返します。
@c COMMON
@end defun

@defun enqueue! queue obj &optional more-objs @dots{}
@c EN
Add @var{obj} to the end of @var{queue}.  You may give more than
one object, and each of them are enqueued in order.
(Note: SLIB version doesn't take the optional arguments).
@c JP
@var{obj}をキュー@var{queue}の末尾に追加します。
一つ以上の@var{obj}を与えることができ、その場合はそれらが順にenqueueされます。
(註：SLIBの@code{enqueue!}はオプショナルな引数を取りません)。
@c COMMON
@end defun

@defun queue-push! queue obj &optional more-objs @dots{}
@c EN
Add @var{obj} in front of @var{queue}.  You may give more than
one object, and each of them are pushed in order.
(Note: SLIB version doesn't take the optional arguments).
@c JP
@var{obj}をキュー@var{queue}の先頭に追加します。
一つ以上の@var{obj}を与えることができ、その場合はそれらが順にpushされます。
(註：SLIBの@code{queue-push!}はオプショナルな引数を取りません)。
@c COMMON
@end defun

@defun dequeue! queue
@defunx queue-pop! queue
@c EN
Take one object from the front of the queue @var{queue} and returns it.
Both function works the same, but @code{queue-pop!} may be used to
emphasize it works with @code{queue-push!}.  An error is signalled
if @var{queue} is empty.
@c JP
キュー@var{queue}の先頭からひとつ要素を取って返します。
二つの手続きは全く同じ動作をします。@code{queue-pop!}は@code{queue-push!}と
ペアで使われていることを強調したいときに使うと良いでしょう。キューが空の場合は
エラーが報告されます。
@c COMMON
@end defun

@defun dequeue-all! queue
@c EN
Returns the whole content of the queue by a list, with emptying
@var{queue}.   If @var{queue} is already empty, returns an empty list.
See also @code{queue->list} below.
@c JP
キューの全ての内容をリストにして返します。キューそのものは空になります。
キューが既に空の場合は空リストが返されます。
下の@code{queue->list}も参照してください。
@c COMMON
@end defun

@defun queue-front queue
@defunx queue-rear queue
@c EN
Peek the head or the tail of the queue and returns the object, respectively.
@var{util.queue - Queue} is not modified.  An error is signalled
if @var{queue} is empty.
@c JP
キュー@var{queue}の先頭もしくは末尾の要素を返します。キューそのものは変更されません。
キューが空の場合はエラーが報告されます。
@c COMMON
@end defun

@defun list->queue list
@c EN
Returns a new queue whose content is the elements in @var{list},
in the given order.
@c JP
与えられたリスト@var{list}の各要素をその順で持つようなキューを作成して返します。
@c COMMON
@end defun

@defun queue->list queue
@c EN
Returns a list whose content is the items in the queue in order.
Unlike @code{dequeue-all!}, the content of @var{queue} remains intact.

In Gauche, @code{queue->list} copies the content of the queue to a
freshly allocated list, while @code{dequeue-all!} doesn't copy but
directly returns the queue's internal list.   There are some Scheme
systems that has @code{queue->list} but doesn't guarantee the content
is copied, so if you're planning to share the code among these
implementations, it's better not to rely on the fact that
@code{queue->list} copies the content.
@c JP
キュー@var{queue}の内容をリストにして返します。
@code{dequeue-all!}と異なり、キューそのものの内容は変化しません。

Gaucheでは@code{queue->list}は新しいリストをアロケートしてキューの
内容をコピーします (@code{dequeue-all!}はコピーをせずにキューの内部の
リストをそのまま返します)。組込みで@code{queue->list}を持っているScheme
実装がいくつかありますが、その中には@code{queue->list}がキューの
内容をコピーすることを保証していないものがあるので、それらの処理系と
共有するコードでは@code{queue->list}がリストをコピーすることを
あてにしない方が良いでしょう。
@c COMMON
@end defun

@defun find-in-queue pred queue
@c EN
Returns the first item in @var{queue} that satisfies a
predicate @var{pred}.  The order of arguments follows
@code{find} in SRFI-1 (@xref{SRFI-1 Searching}).
@c JP
キュー内の要素のうち述語@var{pred}を満たす最初の要素を返します。
引数の順序はSRFI-1の@code{find}に揃えました (@ref{SRFI-1 Searching}参照)。
@c COMMON
@end defun

@defun remove-from-queue! pred queue
@c EN
Removes all items in the queue that satisfies @var{pred}.
Returns @code{#t} if any item is removed.  Otherwise returns @code{#f}.
The order of arguments follows
@code{remove} in SRFI-1 (@xref{SRFI-1 Filtering & Partitioning}).
@c JP
キューから、述語@var{pred}を満たす要素を全て取り除きます。
要素が削除された場合は@code{#t}が、そうでなければ@code{#f}が返されます。
引数の順序はSRFI-1の@code{remove}に揃えました (@ref{SRFI-1 Filtering & Partitioning}参照)。
@c COMMON
@end defun

@c EN
Note on portability:
Scheme48 has @code{delete-from-queue!}, which takes object to remove
rather than predicate, and also takes arguments in reversed order
(i.e. queue comes first).   Avoid conflicting with that I intentionally
left out @code{delete-from-queue!}; it's easy to write one in either
Scheme48 compatible way or consistent to SRFI-1 argument order.
@c JP
移植性に関する註：Scheme48には、述語ではなく削除するオブジェクトそのものを取る
@code{delete-from-queue!}がありますが、引数の順序が逆(キューが先)になっています。
まぎらわしい衝突を避けるため、敢えて@code{delete-from-queue!}は
提供しませんでした。@code{remove-from-queue!}を使えば、Scheme48互換の方法でも、
あるいはSRFI-1と一貫性のある方法でも@code{delete-from-queue!}をすぐ書けるでしょう。
@c COMMON

@c ----------------------------------------------------------------------
@node util.toposort - Topological sort, www.cgi - CGI Utility, util.queue - Queue, Library modules - Utilities
@section @code{util.toposort} - Topological sort
@c NODE util.toposort - トポロジカルソート, @code{util.toposort} - トポロジカルソート

@deftp {Module} util.toposort
@mdindex util.toposort
@c EN
Implements topological sort algorithm.
@c JP
トポロジカルソートのアルゴリズムを実装します。
@c COMMON
@end deftp

@defun topological-sort graph &optional eqproc
@c EN
@var{Graph} represents a directed acyclic graph (DAG) by a list
of connections, where each connection is the form
@example
(<node> <downstream> <downstream2> ...)
@end example
that means a node @code{<node>} is connected to other nodes
@code{<downstream>} etc.   @code{<node>} can be arbitrary
object, as far as it can be compared by the procedure @var{eqproc},
which is @var{eqv?} by default (@xref{Equivalence}).
Returns a list of @code{<node>}s sorted topologically.

If the graph contains circular reference, an error is signalled.
@c JP
@var{Graph}は有向非循環グラフ(DAG)を表現するリストです。
リストの各要素は次の形をしています。
@example
(<node> <downstream> <downstream2> ...)
@end example
これで、ノード@code{<node>}から別のノード@code{<downstream>}等への接続が
あることを表現します。@code{<node>}はどんなオブジェクトであっても構いませんが、
同一性の判定が@var{eqproc}で行えなければなりません。@var{eqproc}の既定値は
@code{eqv?}です (@ref{Equivalence}参照)。
トポロジカルにソートされたノードのリストを返します。

グラフに循環が検出された場合はエラーとなります。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node www.cgi - CGI Utility,  , util.toposort - Topological sort, Library modules - Utilities
@section @code{www.cgi} - CGI utility
@c NODE www.cgi - CGIユーティリティ, @code{www.cgi} - CGIユーティリティ

@deftp {Module} www.cgi
@mdindex www.cgi
@c EN
Provides a few basic functions useful to write a CGI script.

In order to write CGI script easily, you may want to use
other modules, such as @code{rfc.uri} (@xref{rfc.uri - URI parsing and construction}),
@code{text.html-lite} (@xref{text.html-lite - Simple HTML document construction}) and
@code{text.tree} (@xref{text.tree - Lazy text construction}).

Note: it seems that there is no active formal specification for CGI.
See @uref{http://w3c.org/CGI/} for more information.
@c JP
CGIスクリプトを書くのに便利ないくつかの基本的な手続きを提供します。

CGIスクリプトを手軽に書くにはこのモジュールの他に、
@code{rfc.uri} (@ref{rfc.uri - URI parsing and construction})、
@code{text.html-lite} (@ref{text.html-lite - Simple HTML document construction})、
@code{text.tree} (@ref{text.tree - Lazy text construction}) 等のモジュールを併せて
使うとよいでしょう。

注：現在有効な、CGIに関する「正式な」仕様というのはどうも無いようです。
@uref{http://w3c.org/CGI/}あたりを参照して下さい。
@c COMMON
@end deftp

@defun cgi-parse-parameters &keyword :query-string :merge-cookies
@c EN
Parses query string and returns associative list of parameters.
When a keyword argument @var{query-string} is given, it is used
as a source query string.  Otherwise, the function checks the environment
variable @code{REQUEST_METHOD} and obtain the query string
depending on the value (either from stdin or from the environment
variable @code{QUERY_STRING}).
If such an environment variable is not defined and
the current input port is a terminal, the function prompts the user
to type parameters; useful for interactive debugging.
@c JP
CGIプログラムに渡されたquery stringをパーズして、パラメータの連想リストにして
返します。文字列がキーワード引数@var{query-string}に与えられればそれがパーズすべき
query stringとなります。その引数が渡されなければこの手続きは環境変数@code{REQUEST_METHOD}を
参照し、その値によって標準入力もしくは
環境変数@code{QUERY_STRING}からquery stringが取られます。
そのような環境変数が定義されておらず、かつ現在の入力ポートが端末である場合、
インタラクティブにデバッグをしているものと考えて、
この手続きはプロンプトを出してユーザにパラメータの入力を促します。
@c COMMON

@c EN
When a true value is given to @var{merge-cookies}, the cookie
values obtained from the environment variable @code{HTTP_COOKIE}
are appended to the result.
@c JP
キーワード引数@var{merge-cookies}に真の値が与えられた場合は、
環境変数@code{HTTP_COOKIE}からクッキーの値が読まれ、解析されて
結果に追加されます。
@c COMMON

@c EN
Note that the query parameter may have multiple values,
so @code{cdr} of each element in the result is a list, not an atom.
If no value is given to the parameter, @code{#t} is placed as its value.
See the following example:
@c JP
パラメータは複数の値を取り得るため、結果のパラメータに対応する値は常にリストになります。
パラメータに値が与えられていなければ、結果のパラメータに対する値には@code{#t}が置かれます。
次の例を参照して下さい。
@c COMMON
@example
(cgi-parse-parameters
  :query-string "foo=123&bar=%22%3f%3f%22&bar=zz&buzz")
 @result{} (("foo" "123") ("bar "\"??\"" "zz") ("buzz #t))
@end example
@end defun

@defun cgi-get-parameter name params &keyword :default :list :convert
@c EN
A convenient function to obtain a value of the parameter @var{name} from
parsed query string @var{params}, which is the value
@code{cgi-parse-parameters} returns.
@c JP
@code{cgi-parse-parameters}が返す、パーズされたQuery文字列@var{params}から、
名前@var{name}を持つパラメータの値を簡単に取り出すための手続きです。
@c COMMON

@c EN
Unless true value is given to @var{list}, the returned value is
a scalar value.  If more than one value is associated to @var{name},
only the first value is returned.  If @var{list} is true, the
returned value is always a list, even @var{name} has only one value.
@c JP
キーワード引数@var{list}に真の値が与えられていなければ、
返される値はスカラー値です。パラメータ@var{name}に複数の値が与えられた場合でも、
最初の値のみが返されます。@var{list}に真の値が与えられれば、返されるのは
常に値のリストとなります。
@c COMMON

@c EN
After the value is retrieved, you can apply a procedure to
convert the string value to the appropriate type by giving
a procedure to the @var{convert} argument.  The procedure must
take one string argument.  If @var{list} is true, the convert
procedure is applied to each values.
@c JP
キーワード引数@var{convert}に手続きを与えると、対応する値が取り出された後でその
手続きが値を引数として呼ばれます。これによって値を文字列から必要な型へと変換することが
できます。@var{list}に真の値が与えられている場合、変換手続きは各値に対して呼ばれ、
その結果のリストが@var{cgi-get-parameter}から返されます。
@c COMMON

@c EN
If no value is defined for @var{name}, a value given to the keyword
argument @var{default} is returned; the default value of @var{default}
is @code{#f} if @var{list} is false, or @code{()} otherwise.
@c JP
パラメータ@var{name}に対応する値が無ければ、@var{default}に与えられた値がそのまま
返されます。@var{default}が省略された場合、@var{list}が偽であれば@code{#f}が、
真であれば@code{()}が返されます。
@c COMMON
@end defun

@defun cgi-header &keyword content-type location cookies
@c EN
Creates a text tree (@xref{text.tree - Lazy text construction}) for the
HTTP header of the reply message.  The most simple form is
like this:
@c JP
HTTPリプライメッセージのヘッダを、テキストツリー形式(@ref{text.tree - Lazy text construction}参照)
で作成して返します。最も簡単な呼び出しでは次のようになります。
@c COMMON
@example
(tree->string (cgi-header))
  @result{} "Content-type: text/html\r\n\r\n"
@end example

@c EN
You can specify alternative content-type by the keyword argument
@var{content-type}.   If you want to set cookies to the client,
specify a list of cookie strings to the keyword argument @var{cookies}.
You can use @code{construct-cookie-string} (@xref{rfc.cookie - HTTP cookie handling})
to build such a list of cookie strings.
@c JP
キーワード引数@var{content-type}によってContent typeを指定できます。
また、@var{cookies}にクッキー文字列のリストを渡すことにより、
クライアントにクッキーを設定できます。クッキー文字列を構築するには手続き
@code{construct-cookie-string} (@ref{rfc.cookie - HTTP cookie handling}参照)
が使えます。
@c COMMON

@c EN
The keyword argument @var{location} may be used to generate
a @code{Location:} header to redirect the client to the specified URI.
@c JP
キーワード引数@var{location}は、@code{Location}ヘッダを作成して
クライアントを別のURIに誘導するのに使えます。
@c COMMON
@end defun

@defun cgi-main proc &keyword on-error merge-cookies
@c EN
A convenient wrapper function for CGI script.
This function calls @code{cgi-parse-parameters}, then calls
@var{proc} with the result of @code{cgi-parse-parameters}.
The keyword argument @var{merge-cookies} is passed to
@code{cgi-parse-parameters}.
@c JP
CGIスクリプトのための便利なラッパー手続きです。
この手続きは、まず@code{cgi-parse-parameters}を呼び出してCGIスクリプトに
渡されたパラメータを解析し、続いてその結果を引数として@var{proc}を呼び出します。
キーワード引数@var{merge-cookies}は、与えられればそのまま
@code{cgi-parse-parameters}に渡されます。
@c COMMON

@c EN
@var{proc} has to return a tree of strings
(@xref{text.tree - Lazy text construction}), including the HTTP header.
@code{cgi-main} outputs the returned tree to the current output port
by @code{write-tree}, then returns zero.
@c JP
手続き@var{proc}はHTTPヘッダを含むドキュメントを
テキストツリー構造(@ref{text.tree - Lazy text construction}参照)で
返さなければなりません。@code{cgi-main}はそれを@code{write-tree}を使って
現在の出力ポートに書き出し、0を返します。
@c COMMON

@c EN
If an error is signalled in @var{proc}, it is caught and an HTML
page reporting the error is generated.  You can customize the
error page by providing a procedure to the @var{on-error} keyword argument.
The procedure takes an @code{<exception>} object (@xref{Exception object}),
and has to return a tree of string for the error reporting HTML
page, including an HTTP header.
@c JP
もし@var{proc}内でエラーが起こった場合、そのエラーは捕捉されて、エラーを報告する
HTMLページが作成されて出力されます。このエラーページは、@var{on-error}キーワード引数に
手続きを渡すことでカスタマイズできます。@var{on-error}に渡された手続きは
エラー発生時に@code{<exception>}オブジェクト(@ref{Exception object}参照)
を引数として呼ばれ、HTTPヘッダを含むドキュメントをテキストツリー構造で返さねばなりません。
@c COMMON

@c EN
The following example shows the parameters given to the CGI program.
@c JP
以下の例はCGIに渡されたパラメータ全てをテーブルにして表示します。
@c COMMON

@example
#!/usr/local/bin/gosh

(use text.html-lite)
(use www.cgi)

(define (main args)
  (cgi-main
    (lambda (params)
      `(,(cgi-header)
        ,(html-doctype)
        ,(html:html
          (html:head (html:title "Example"))
          (html:body
           (html:table
            :border 1
            (html:tr (html:th "Name") (html:th "Value"))
            (map (lambda (p)
                   (html:tr
                    (html:td (html-escape-string (car p)))
                    (html:td (html-escape-string (x->string (cdr p))))))
                 params))))
       ))))
@end example
@end defun

@c ======================================================================
@node References, C to Scheme mapping, Library modules - Utilities, Top
@appendix References
@c NODE 参考文献

@table @asis
@anchor{r5rs}
@item [R5RS]
R. Kelsey, W. Clinger, J. Rees (eds.),
Revised^5 Report on the Algorithmic Language Scheme,
Higher-Order and Symbolic Computation, 11(1), September, 1998
and ACM SIGPLAN Notices, 33(9), October, 1998. @*
@url{http://www.schemers.org/Documents/Standards/R5RS/}.

@anchor{onecont}
@item [1CC]
Carl Bruggeman, Oscar Waddell and R. Kent Dybvig,
Representing control in the presence of one-shot continuations,
in @i{Proceedings of SIGPLAN '96}, pp. 99--107, 1996.

@anchor{mop}
@item [MOP]
Gregor Kiczales, Jim Des Rivieres, Daniel Bobrow,
The Art of Metaobject Protocol, 
The MIT Press.

@anchor{fairthreads}
@item [FairThreads]
F. Boussinot, Java Fair Threads, @*
@url{http://www-sop.inria.fr/mimosa/rp/FairThreads/html/FairThreads.html}.

@anchor{rfc1321}
@item [RFC1321]
R. Rivest,
The MD5 Message-Digest Algorithm. @*
April 1992. @*
@url{ftp://ftp.isi.edu/in-notes/rfc1321.txt}.

@anchor{rfc2045}
@item [RFC2045]
N. Freed, N. Borenstein: Multipurpose Internet Mail Extension
(MIME) Part One: Format of Internet Message Bodies,
November 1996. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2045.txt}.

@anchor{rfc2396}
@item [RFC2396]
T. Berners-Lee, R. Fielding, L. Masinter,
Uniform Resource Identifiers (URI): Generic Syntax,
August 1998. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2396.txt}.

@anchor{rfc2616}
@item [RFC2616]
R. Fielding et al, Hypertext Transfer Protocol -- HTTP/1.1, June 1999. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2616.txt}.

@anchor{rfc2822}
@item [RFC2822]
P. Resnick (ed.), Internet Message Format, April 2001. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2822.txt}.

@anchor{rfc2965}
@item [RFC2965]
D. Kristol, L. Montulli, HTTP State Management Mechanism,
October 2000. @*
@url{ftp://ftp.isi.edu/in-notes/rfc2965.txt}.

@anchor{rfc3174}
@item [RFC3174]
D. Eastlake, 3rd and P. Jones,
US Secure Hash Algorithm 1 (SHA1). @*
September 2001. @*
@url{ftp://ftp.isi.edu/in-notes/rfc3174.txt}.

@anchor{srfi-0}
@item [SRFI-0]
Marc Feeley, Feature-based conditional expansion construct, May  1999.@*
@url{http://srfi.schemers.org/srfi-0/srfi-0.html}.

@anchor{srfi-1}
@item [SRFI-1]
Olin Shivers, List Library, October 1999. @*
@url{http://srfi.schemers.org/srfi-1/srfi-1.html}.

@anchor{srfi-2}
@item [SRFI-2]
Oleg Kiselyov, @code{AND-LET*}: an @code{AND} with local bindings, a guarded 
@code{LET*} special form, March 1998. @*
@url{http://srfi.schemers.org/srfi-2/srfi-2.html}.

@anchor{srfi-4}
@item [SRFI-4]
Marc Feeley, Homogeneous numeric vector types, May 1999.@*
@url{http://srfi.schemers.org/srfi-4/srfi-4.html}.

@anchor{srfi-6}
@item [SRFI-6]
William D Clinger, Basic String Ports, July 1999. @*
@url{http://srfi.schemers.org/srfi-6/srfi-6.html}.

@anchor{srfi-8}
@item [SRFI-8]
John David Stone, receive: Binding to multiple values, August 1999. @*
@url{http://srfi.schemers.org/srfi-8/srfi-8.html}.

@anchor{srfi-9}
@item [SRFI-9]
Richard Kelsey, Defining Record Types, September 1999.@*
@url{http://srfi.schemers.org/srfi-9/srfi-9.html}.

@anchor{srfi-10}
@item [SRFI-10]
Oleg Kiselyov, @code{#,} external form, January 2000.@*
@url{http://srfi.schemers.org/srfi-10/srfi-10.html}.

@anchor{srfi-11}
@item [SRFI-11]
Lars T Hansen, Syntax for receiving multiple values, March 2000. @*
@url{http://srfi.schemers.org/srfi-11/srfi-11.html}.

@anchor{srfi-13}
@item [SRFI-13]
Olin Shivers, String Libraries, December 2000. @*
@url{http://srfi.schemers.org/srfi-13/srfi-13.html}.

@anchor{srfi-14}
@item [SRFI-14]
Olin Shivers, Character-set Library, December 2000. @*
@url{http://srfi.schemers.org/srfi-14/srfi-14.html}.

@anchor{srfi-17}
@item [SRFI-17]
Per Bothner, Generalized @code{set!}, July 2000. @*
@url{http://srfi.schemers.org/srfi-17/srfi-17.html}.

@anchor{srfi-18}
@item [SRFI-18]
Marc Feeley, Multithreading Support, April 2000. @*
@url{http://srfi.schemers.org/srfi-18/srfi-18.html}.

@anchor{srfi-19}
@item [SRFI-19]
Will Fitzgerald, Time Data Types and Procedures, August 2000. @*
@url{http://srfi.schemers.org/srfi-19/srfi-19.html}.

@anchor{srfi-21}
@item [SRFI-21]
Marc Feeley, Readl-time Multithreading Support, April 2000. @*
@url{http://srfi.schemers.org/srfi-21/srfi-21.html}.

@anchor{srfi-22}
@item [SRFI-22]
Martin Gasbichler and Michael Sperber, 
Running Scheme Scripts on Unix, January 2002. @*
@url{http://srfi.schemers.org/srfi-22/srfi-22.html}.

@anchor{srfi-23}
@item [SRFI-23]
Stephan Housen, Error reporting mechanism, April 2001.@*
@url{http://srfi.schemers.org/srfi-23/srfi-23.html}.

@anchor{srfi-25}
@item [SRFI-25]
Jussi Piitulainen, Multi-dimensional Array Primitives, June 2002.@*
@url{http://srfi.schemers.org/srfi-25/srfi-25.html}.

@anchor{srfi-26}
@item [SRFI-26]
Sebastian Egner, Notation for Specializing Parameters without Currying, June 2002.@*
@url{http://srfi.schemers.org/srfi-26/srfi-26.html}.

@anchor{srfi-27}
@item [SRFI-27]
Sebastian Egner, Sources of Random Bits, June 2002.@*
@url{http://srfi.schemers.org/srfi-27/srfi-27.html}.

@anchor{srfi-28}
@item [SRFI-28]
Scott G. Miller, Basic Format Strings, June 2002.@*
@url{http://srfi.schemers.org/srfi-28/srfi-28.html}.


@anchor{srfi-37}
@item [SRFI-37]
Anthony Carrico, Args-fold: a program argument processor, Jan. 2003.@*
@url{http://srfi.schemers.org/srfi-37/srfi-37.html}.

@anchor{ssax}
@item [SSAX]
Oleg Kiselyov, XML and Scheme, @*
@url{http://pobox.com/~oleg/ftp/Scheme/xml.html}.@*
The SSAX distribution is also available at sourceforge:@*
@url{http://ssax.sourceforge.net/}.

@anchor{MT}
@item [MT]
M. Matsumoto and T. Nishimura, "Mersenne Twister: A 623-dimensionally
equidistributed uniform pseudorandom number generator", ACM Trans. on
Modeling and Computer Simulation Vol. 8, No. 1, Januray pp.3-30 1998.@*
@url{http://www.math.keio.ac.jp/~matumoto/emt.html}

@anchor{oleg1}
@item [OLEG1]
Oleg Kiselyov, Making sense of an input stream,@*
@url{http://pobox.com/~oleg/ftp/Scheme/parsing.html}.

@anchor{oleg2}
@item [OLEG2]
Oleg Kiselyov, General ways to traverse collections,,@*
@url{http://pobox.com/~oleg/ftp/Scheme/enumerators-callcc.html}.
2000.
@end table

@c ======================================================================
@node C to Scheme mapping, Indices, References, Top
@appendix C to Scheme mapping
@c NODE CとSchemeの関数の対応

@c EN
For the convenience of the programmers familiar to C, 
I composed a simple table of C operators and library functions with
the corresponding Scheme functions.
@c JP
Cに馴染んだプログラマのために、Cのオペレータとライブラリ関数からSchemeの関数への
対応表を示しておきます。
@c COMMON

@table @code
@item +
R5RS arithmetic procedure @code{+}.   @xref{Arithmetics}.
@item +=
Gauche @code{inc!} macro.  @xref{Assignments}.
@item -
R5RS arithmetic procedure @code{-}.   @xref{Arithmetics}.
@item -=
Gauche @code{dec!} macro.  @xref{Assignments}.
@item ->
Gauche @code{slot-ref} is something close to this.  @xref{Accessing Instance}.
@item * (binary)
R5RS arithmetic procedure @code{*}.   @xref{Arithmetics}.
@item * (unary)
No equivalent procedure.  Scheme doesn't have explicit notation of
pointers.
@item *=
No equivalent procedure.
@item /
R5RS arithmetic procedure @code{/}.   @xref{Arithmetics}.
@item /=
No equivalent procedure.
@item & (binary)
Gauche @code{logand}.  @xref{Bitwise operations}.
@item & (unary)
No equivalent procedure.  Scheme doesn't have explicit notation of
pointers.
@item &&
R5RS syntax @code{and}.  @xref{Conditionals}.
@item &=
No equivalent procedure.
@item |
Gauche @code{logior}.  @xref{Bitwise operations}.
@item ||
R5RS syntax @code{or}.  @xref{Conditionals}.
@item |=
No equivalent procedure.
@item ^
Gauche @code{logxor}.  @xref{Bitwise operations}.
@item =
R5RS syntax @code{set!}.  @xref{Assignments}.
@item ==
R5RS equivalence procedure, @code{eq?}, @code{eqv?} and @code{equal?}.
@xref{Equivalence}.
@item <
@itemx <=
R5RS arithmetic procedure @code{<} and @code{<=}.
@xref{Numerical comparison}.  Unlike C operator, Scheme version
is transitive.
@item <<
Gauche @code{ash}.  @xref{Bitwise operations}.
@item <<=
No equivalent procedure.
@item >
@itemx >=
R5RS arithmetic procedure @code{>} and @code{>=}.
@xref{Numerical comparison}.  Unlike C operator, Scheme version
is transitive.
@item >>
Gauche @code{ash}.  @xref{Bitwise operations}.
@item >>=
No equivalent procedure.
@item %
R5RS operator @code{modulo} and @code{remainder}.  @xref{Arithmetics}.
@item %=
No equivalent procedure.
@item []
R5RS @code{vector-ref} (@xref{Vectors}) is something close.
Or you can use Gauche's generic function @code{ref} (@xref{gauche.sequence - Sequence framework})
for arbitrary sequences.
@item .
Gauche @code{slot-ref} is something close to this.  @xref{Accessing Instance}.
@item ~
Gauche @code{lognot}.  @xref{Bitwise operations}.
@item ~=
No equivalent procedure.
@item !
R5RS procedure @code{not}.  @xref{Booleans}.
@item !=
No equivalent procedure.
@item abort
Gauche @code{sys-abort}.   @xref{Program termination}
@item abs
R5RS @code{abs}.  @xref{Arithmetics}.
@item access
Gauche @code{sys-access}.  @xref{File stats}.
@item acos
R5RS @code{acos}.  @xref{Arithmetics}.
@item alarm
Gauche @code{sys-alarm}.   @xref{Miscellaneous system calls}.
@item asctime
Gauche @code{sys-asctime}.  @xref{Time}.
@item asin
R5RS @code{asin}.  @xref{Arithmetics}.
@item assert
No equivalent function in Gauche.
@item atan
@itemx atan2
R5RS @code{atan}.  @xref{Arithmetics}.
@item atexit
No equivalent function in Gauche, but the "after" thunk of active
dynamic handlers are called when @code{exit} is called.
@xref{Program termination}, and @xref{Continuation}.
@item atof
@itemx atoi
@itemx atol
You can use @code{string->number}.  @xref{Numerical conversions}.
@item bsearch
No equivalent function in Gauche.
@item calloc
Allocation is handled automatically in Scheme.
@item ceil
R5RS @code{ceiling}.  @xref{Arithmetics}.
@item cfgetispeed
@itemx cfgetospeed
@itemx cfsetispeed
@itemx cfsetospeed
Gauche @code{sys-cfgetispeed}, @code{sys-cfgetospeed},
@code{sys-cfsetispeed}, @code{sys-cfsetospeed}.  @xref{gauche.termios - Termios}.
@item chdir
Gauche @code{sys-chdir}.   @xref{Other file operations}.
@item chmod
Gauche @code{sys-chmod}.   @xref{File stats}.
@item chown
Gauche @code{sys-chown}.   @xref{File stats}
@item clearerr
Not supported yet.
@item clock
No equivalent function in Gauche.  You can use @code{sys-times}
to get information about CPU time.
@item close
You can't directly close the file descriptor, but when you use
@code{close-input-port} or @code{close-output-port}, underlying
file is closed.  Some port-related functions, such as
@code{call-with-output-file}, automatically closes the file
when operation is finished.  The file is also closed when
its governing port is garbage collected.
@xref{Common port operations}.
@item closedir
No equivalent function in Gauche.  You can use
@code{sys-readdir} to read the directory entries at once.
@xref{Directories}.
@item cos
@itemx cosh
@code{cos} and @code{cosh}.  @xref{Arithmetics}.
@item creat
A file is implictly created by default when you open it for writing.
See @ref{File ports} for more control over the creation of files.
@item ctermid
Gauche @code{sys-ctermid}.  @xref{System Inquiry}.
@item ctime
Gauche @code{sys-ctime}.  @xref{Time}.
@item cuserid
No equivalent function.  This is removed from the newer POSIX.
You can use alternative functions, such as @code{sys-getlogin} or
@code{sys-getpwuid} with @code{sys-getuid}.
@item difftime
Gauche @code{sys-difftime}.  @xref{Time}.
@item div
You can use R5RS @code{quotient} and @code{remainder}.
@xref{Arithmetics}.
@item dup
@itemx dup2
No equivalent function.  If you want to use this function to
set up I/Os for the child process, you can use `iomap' argument
of @code{sys-exec}.  @xref{Fork and exec}.
@item execl
@itemx execle
@itemx execlp
@itemx execv
@itemx execve
@itemx execvp
Gauche @code{sys-exec}.  @xref{Fork and exec}.
For higher level interface, @ref{gauche.process - High Level Process Interface}.
@item exit
@item _exit
Use @code{exit} or @code{sys-exit}, depends on what you need.
@xref{Program termination}.
@item exp
R5RS @code{exp}.  @xref{Arithmetics}.
@item fabs
R5RS @code{abs}.  @xref{Arithmetics}.
@item fclose
You can't directly close the file stream, but when you use
@code{close-input-port} or @code{close-output-port}, underlying
file is closed.  Some port-related functions, such as
@code{call-with-output-file}, automatically closes the file
when operation is finished.  The file is also closed when
its governing port is garbage collected.
@item fcntl
Implented as @code{sys-fcntl} in @code{gauche.fcntl} module.
@xref{gauche.fcntl - Low-level file operations}.
@item fdopen
Gauche's @code{open-input-fd-port} or @code{open-output-fd-port}.
@xref{File ports}.
@item feof
Not supported yet.
@item ferror
Not supported yet.
@item fflush
Gauche's @code{flush}.   @xref{Output}.
@item fgetc
Use @code{read-char} or @code{read-byte}.  @xref{Input}.
@item fgetpos
Use Gauche's @code{port-tell} (@xref{Common port operations})
@item fgets
Use @code{read-line} or @code{read-block}.    @xref{Input}.
@item fileno
@code{port-file-numer}.   @xref{Common port operations}.
@item floor
R5RS @code{floor}.   @xref{Arithmetics}.
@item fmod
Gauche's @code{fmod}.
@item fopen
R5RS @code{open-input-file} or @code{open-output-file}
corresponds to this operation.  @xref{File ports}.
@item fork
Gauche's @code{sys-fork}.   @xref{Fork and exec}.
@item forkpty
Use @code{sys-forkpty}.  @xref{gauche.termios - Termios}.
@item fpathconf
Not supported.
@item fprintf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item fputc
Use @code{write-char} or @code{write-byte}.  @xref{Output}.
@item fputs
Use @code{display}.  @xref{Output}.
@item fread
Not directly supported.  If you want to read a chunk
of bytes, you may be able to use @code{read-block}.
@item free
You don't need this in Scheme.
@item freopen
Not supported.
@item frexp
Gauche's @code{frexp}
@item fscanf
Not supported.  For general case, you have to write a parser.
If you can keep the data in S-exp, you can use @code{read}.
If the syntax is very simple, you may be able to utilize
@code{string-tokenize} in @code{srfi-14} (@ref{srfi-13 - String library}),
and/or regular expression stuff (@ref{Regular expression},
also @ref{gauche.regexp - Regular expression utilities}.
@item fseek
Use Gauche's @code{port-seek} (@xref{Common port operations})
@item fsetpos
Use Gauche's @code{port-seek} (@xref{Common port operations})
@item fstat
Gauche's @code{sys-stat}.  @xref{File stats}.
@item ftell
Use Gauche's @code{port-tell} (@xref{Common port operations})
@item fwrite
Not directly supported.  If you want to write a chunk of bytes,
you can simply use @code{display}.  @xref{Output}.
@item getc
@itemx getchar
Use @code{read-char} or @code{read-byte}.  @xref{Input}.
@item getcwd
Gauche's @code{sys-getcwd}.   @xref{System Inquiry}.
@item getdomainname
Gauche's @code{sys-getdomainname}.  @xref{System Inquiry}.
@item getegid
Gauche's @code{sys-getegid}.   @xref{System Inquiry}.
@item getenv
Gauche's @code{sys-getenv}.   @xref{Environment Inquiry}.
@item geteuid
Gauche's @code{sys-geteuid}.   @xref{System Inquiry}.
@item gethostname
Gauche's @code{sys-gethostname}.  @xref{System Inquiry}.
@item getgid
Gauche's @code{sys-getgid}.   @xref{System Inquiry}.
@item getgrgid
@itemx getgrnam
Gauche's @code{sys-getgrgid} and @code{sys-getgrnam}.  @xref{Unix group}.
@item getgroups
Gauche's @code{sys-getgroups}.   @xref{System Inquiry}.
@item getlogin
Gauche's @code{sys-getlogin}.  @xref{System Inquiry}.
@item getpgrp
Gauche's @code{sys-getpgrp}.   @xref{System Inquiry}.
@item getpid
@itemx getppid
Gauche's @code{sys-getpid}.   @xref{System Inquiry}.
@item getpwnam
@itemx getpwuid
Gauche's @code{sys-getpwnam} and @code{sys-getpwuid}.  @xref{Unix users}.
@item gets
Use @code{read-line} or @code{read-block}.  @xref{Input}.
@item gettimeofday
Gauche's @code{sys-gettimeofday}.   @xref{Time}.
@item getuid
Gauche's @code{sys-getuid}.  @xref{System Inquiry}.
@item gmtime
Gauche's @code{sys-gmtime}.   @xref{Time}.
@item isalnum
Not directly supported, but you can use R5RS @code{char-alphabetic?} and
@code{char-numeric?}.  @xref{Characters}.   You can also use
character set.  @xref{Character set}, also @ref{srfi-14 - Character-set library}.
@item isalpha
R5RS @code{char-alphabetic?}.  @xref{Characters}.  See also
@ref{Character set} and @ref{srfi-14 - Character-set library}.
@item isatty
Gauche's @code{sys-isatty}.   @xref{Other file operations}.
@item iscntrl
Not directly supported, but you can use
@code{(char-set-contains? char-set:iso-control c)} with @code{srfi-14}.
@xref{srfi-14 - Character-set library}.
@item isdigit
R5RS @code{char-numeric?}.  @xref{Characters}. 
You can also use @code{(char-set-contains? char-set:digit c)}
with @code{srfi-14}.   @xref{srfi-14 - Character-set library}.
@item isgraph
Not directly supported, but you can use
@code{(char-set-contains? char-set:graphic c)} with @code{srfi-14}.
@xref{srfi-14 - Character-set library}.
@item islower
R5RS @code{char-lower-case?}.  @xref{Characters}.
You can also use @code{(char-set-contains? char-set:lower-case c)}
with @code{srfi-14}.   @xref{srfi-14 - Character-set library}.
@item isprint
Not directly supported, but you can use
@code{(char-set-contains? char-set:printing c)} with @code{srfi-14}.
@xref{srfi-14 - Character-set library}.
@item ispunct
Not directly supported, but you can use
@code{(char-set-contains? char-set:punctuation c)} with @code{srfi-14}.
@xref{srfi-14 - Character-set library}.
@item isspace
R5RS @code{char-whitespace?}.  @xref{Characters}.
You can also use @code{(char-set-contains? char-set:whitespace c)}
with @code{srfi-14}.   @xref{srfi-14 - Character-set library}.
@item isupper
R5RS @code{char-upper-case?}.  @xref{Characters}.
You can also use @code{(char-set-contains? char-set:upper-case c)}
with @code{srfi-14}.   @xref{srfi-14 - Character-set library}.
@item isxdigit
Not directly supported, but you can use
@code{(char-set-contains? char-set:hex-digit c)} with @code{srfi-14}.
@xref{srfi-14 - Character-set library}.
@item kill
Gauche's @code{sys-kill}.  @xref{Signal}.
@item labs
R5RS @code{abs}.  @xref{Arithmetics}.
@item ldexp
Gauche's @code{ldexp}.
@item ldiv
Use R5RS @code{quotient} and @code{remainder}.
@xref{Arithmetics}.
@item link
Gauche's @code{sys-link}.  @xref{Directory manipulation}.
@item localeconv
Gauche's @code{sys-localeconv}. @xref{Locale}.
@item localtime
Gauche's @code{sys-localtime}.  @xref{Time}.
@item log
R5RS @code{log}.  @xref{Arithmetics}.
@item log10
Not directly supported.  @code{log10(z)} @equiv{} @code{(/ (log z) (log 10))}.
@item longjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item lseek
Use Gauche's @code{port-seek} (@xref{Common port operations})
@item malloc
Not necessary in Scheme.
@item mblen
@itemx mbstowcs
@itemx mbtowc
Gauche handles multibyte strings internally, so generally you don't 
need to care about multibyte-ness of the string.   @code{string-length}
always returns a number of characters for a string in supported
encoding.   If you want to convert the character encoding,
see @ref{gauche.charconv - Character code conversion}.
@item memcmp
@itemx memcpy
@itemx memmove
@itemx memset
No equivalent functions.
@item mkdir
Gauche's @code{sys-mkdir}.  @xref{Directory manipulation}.
@item mkfifo
Gauche's @code{sys-mkfifo}.
@item mkstemp
Gauche's @code{sys-mkstemp}.   @xref{Directory manipulation}.
Use this instead of tmpnam.
@item mktime
Gauche's @code{sys-mktime}.  @xref{Time}.
@item modf
Gauche's @code{modf}.
@item open
Not directly supported.
R5RS @code{open-input-file} or @code{open-output-file}
corresponds to this operation.  @xref{File ports}.
@item opendir
Not directly supported.
You can use @code{sys-readdir} to read the directory entries at once.
@xref{Directories}.
@item openpty
Use @code{sys-openpty}.  @xref{gauche.termios - Termios}.
@item pathconf
Not supported.
@item pause
Gauche's @code{sys-pause}.  @xref{Miscellaneous system calls}.
@item perror
No equivalent function in Gauche.  System calls generally throws an
error (@code{<system-error>}), including the description of the reason
of failure.
@item pipe
Gauche's @code{sys-pipe}.  @xref{Other file operations}.
@item pow
R5RS @code{expt}.  @xref{Arithmetics}.
@item printf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item putc
@itemx putchar
Use @code{write-char} or @code{write-byte}.  @xref{Output}.
@item puts
Use @code{display}.   @xref{Output}.
@item qsort
Gauche's @code{sort} and @code{sort!} provides a convenient way to sort
list of items.  @xref{Comparison and sorting}.
@item raise
No equivalent function in Gauche.  Scheme function @code{raise} (SRFI-18)
is to raise an exception.   You can use @code{(sys-kill (sys-getpid) SIG)}
to send a signal @code{SIG} to the current process.
@item rand
Not supported directly, but on most platforms a better RNG is available
as @code{sys-random}.  @xref{Miscellaneous system calls}.
@item read
Not supported directly, but you may be able to use
@code{read-block} (@xref{Input}) or
@code{read-block!} (@xref{Uvector block I/O}).
@item readdir
Not supported directly.   Gauche's @code{sys-readdir} reads
the directly at once.  @xref{Directories}.
@item readlink
Gauche's @code{sys-readlink}.  @xref{Directory manipulation}.
This function is available on systems that support symbolink links.
@item realloc
Not necessary in Scheme.
@item remove
Gauche's @code{sys-remove}.  @xref{Directory manipulation}.
@item rename
Gauche's @code{sys-rename}.  @xref{Directory manipulation}.
@item rewind
Not supported yet.
@item rewinddir
Not supported directly.
You can use @code{sys-readdir} to read the directory entries at once.
@xref{Directories}.
@item rmdir
Gauche's @code{sys-rmdir}.  @xref{Directory manipulation}.
@item scanf
Not supported.  For general case, you have to write a parser.
If you can keep the data in S-exp, you can use @code{read}.
If the syntax is very simple, you may be able to utilize
@code{string-tokenize} in @code{srfi-14} (@ref{srfi-13 - String library}),
and/or regular expression stuff (@ref{Regular expression},
also @ref{gauche.regexp - Regular expression utilities}.
@item select
Gauche @code{sys-select}.  @xref{I/O multiplexing}.
@item setbuf
Not necessary.
@item setgid
Gauche's @code{sys-setgid}.
@item setjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item setlocale
Gauche's @code{sys-setlocale}.  @xref{Locale}.
@item setpgid
Gauche's @code{sys-setpgid}.  @xref{System Inquiry}.
@item setsid
Gauche's @code{sys-setsid}.  @xref{System Inquiry}.
@item setuid
Gauche's @code{sys-setuid}.  @xref{System Inquiry}.
@item setvbuf
Not necessary.
@item sigaction
You can use @code{set-signal-handler!} to install signal handlers.
@xref{Handling signals}.
@item sigaddset
@itemx sigdelset
@itemx sigemptyset
@itemx sigfillset
Gauche's @code{sys-sigset-add!} and @code{sys-sigset-delete!}.
@xref{Signals and signal sets}.
@item sigismember
Not supported yet.
@item siglongjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item signal
You can use @code{with-signal-handlers} to install signal handlers.
@xref{Handling signals}.
@item sigpending
Not supported yet.
@item sigprocmask
Signal mask is handled internally.  @xref{Handling signals}.
@item sigsetjmp
R5RS @code{call/cc} provides similar (superior) mechanism.
@xref{Continuation}.
@item sigsuspend
Gauche's @code{sys-sigsuspend}.  @xref{Masking and waiting signals}.
@item sin
@itemx sinh
Use @code{sin} and @code{sinh}.   @xref{Arithmetics}.
@item sleep
Gauche's @code{sys-sleep}.  @xref{Miscellaneous system calls}.
@item sprintf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item sqrt
R5RS @code{sqrt}.  @xref{Arithmetics}.
@item srand
Not supported directly, but on most platforms a better RNG is available
as @code{sys-srandom}.  @xref{Miscellaneous system calls}.
@item sscanf
Not supported.  For general case, you have to write a parser.
If you can keep the data in S-exp, you can use @code{read}.
If the syntax is very simple, you may be able to utilize
@code{string-tokenize} in @code{srfi-14} (@ref{srfi-13 - String library}),
and/or regular expression stuff (@ref{Regular expression},
also @ref{gauche.regexp - Regular expression utilities}.
@item stat
Gauche's @code{sys-stat}.  @xref{File stats}.
@item strcasecmp
R5RS @code{string-ci=?} and other comparison functions.
@xref{String Comparison}.
@item strcat
R5RS @code{string-append}.  @xref{String utilities}.
@item strchr
SRFI-13 @code{string-index}.  @xref{SRFI-13 String searching}.
@item strcmp
R5RS @code{string=?} and other comparison functions.
@xref{String Comparison}.
@item strcoll
Not supported yet.
@item strcpy
R5RS @code{string-copy}.    @xref{String utilities}.
@item strcspn
Not directly supported, but you can use SRFI-13 @code{string-skip}
with a character set.  @xref{SRFI-13 String searching}.
@item strerror
Not supported.
@item strftime
Gauche's @code{sys-strftime}.  @xref{Time}.
@item strlen
R5RS @code{string-length}.   @xref{String Accessors & Modifiers}.
@item strncat
Not directly supported, but you can use @code{string-append} and
@code{substring}.
@item strncasecmp
SRFI-13 @code{string-compare-ci} provides the most flexible
(but a bit difficult to use) functionality.
@xref{SRFI-13 String Comparison}.
If what you want is just to check the fixed-length prefixes of two
string matches, you can use SRFI-13 @code{string-prefix-ci?}.
@item strncmp
SRFI-13 @code{string-compare} provides the most flexible
(but a bit difficult to use) functionality.
@xref{SRFI-13 String Comparison}.
If what you want is just to check the fixed-length prefixes of two
string matches, you can use SRFI-13 @code{string-prefix?}.
@xref{SRFI-13 String Prefixes & Suffixes}.
@item strncpy
SRFI-13 @code{substring}.  @xref{String utilities}.
@item strpbrk
Not directly supported, but you can use SRFI-13 @code{string-skip}
with a character set.  @xref{SRFI-13 String searching}.
@item strrchr
SRFI-13 @code{string-index-right}.  @xref{SRFI-13 String searching}.
@item strspn
Not directly supported, but you can use SRFI-13 @code{string-index}
with a character set.  @xref{SRFI-13 String searching}.
@item strstr
SRFI-13 @code{string-contains}.  @xref{SRFI-13 String searching}.
@item strtod
You can use R5RS @code{string->number}.   @xref{Numerical conversions}.
@item strtok
SRFI-13 @code{string-tokenize}.  @xref{SRFI-13 other string operations}.
@item strtol
@itemx strtoul
You can use R5RS @code{string->number}.   @xref{Numerical conversions}.
@item strxfrm
Not supported yet.
@item symlink
Gauche's @code{sys-symlink}.  @xref{Directory manipulation}.
This function is available on systems that support symbolink links.
@item sysconf
Not supported yet.
@item system
Gauche @code{sys-system}.   @xref{Fork and exec}.
It is generally recommended to use the process library
(@ref{gauche.process - High Level Process Interface}).
@item tan
@itemx tanh
R5RS @code{tan} and Gauche @code{tanh}.  @xref{Arithmetics}.
@item tcdrain
@item tcflow
@item tcflush
@item tcgetattr
@item tcgetpgrp
@item tcsendbreak
@item tcsetattr
@item tcsetpgrp
Corresponding functions are: @code{sys-tcdrain}, @code{sys-tcflow},
@code{sys-tcflush}, @code{sys-tcgetattr}, @code{sys-tcgetpgrp},
@code{sys-tcsendbreak}, @code{sys-tcsetattr}, @code{sys-tcsetpgrp.}
@xref{gauche.termios - Termios}
@item time
Gauche's @code{sys-time}.  @xref{Time}.
@item times
Gauche's @code{sys-times}.  @xref{System Inquiry}.
@item tmpfile
Not exactly supported.
@item tmpnam
Gauche's @code{sys-tmpnam}.
This function is provided since it is in POSIX, but its use is
discouraged for the potential security risk.  Use @code{sys-mkstemp}
instead.   @xref{Directory manipulation}.
@item tolower
@itemx toupper
R5RS @code{char-upcase} and @code{char-downcase}.   @xref{Characters}.
@item ttyname
Gauche's @code{sys-ttyname}.  @xref{Other file operations}.
@item tzset
Not supported yet.
@item umask
Gauche's @code{sys-umask}.  @xref{Directory manipulation}.
@item uname
Gauche's @code{sys-uname}.  @xref{System Inquiry}.
@item ungetc
Not directly supported.  You can use @code{peek-char} to look
one character ahead, instead of pushing back.
@item unlink
Gauche's @code{sys-unlink}.  @xref{Directory manipulation}.
@item utime
Gauche's @code{sys-utime}.  @xref{File stats}.
@item va_arg
@itemx va_end
@itemx va_start
Not necessary, for Scheme handles variable number of arguments naturally.
@item vfprintf
@itemx vprintf
@itemx vsprintf
Not directly supported, but Gauche's @code{format}
provides similar functionality.  @xref{Output}.
SLIB has @code{printf} implementation.
@item wait
Gauche's @code{sys-wait}.  @xref{Wait}.
@item waitpid
Gauche's @code{sys-waitpid}.  @xref{Wait}.
@item wcstombs
@itemx wctomb
Gauche handles multibyte strings internally, so generally you don't 
need to care about multibyte-ness of the string.   @code{string-length}
always returns a number of characters for a string in supported
encoding.   If you want to convert the character encoding,
see @ref{gauche.charconv - Character code conversion}.
@item write
R5RS @code{display} (@xref{Output}).
Or @code{write-block} (@xref{Uvector block I/O}).
@end table

@c Appendix : Common Lisp to Scheme mapping
@c Appendix : Perl to Scheme mapping
@c Appendix : Python to Scheme mapping?

@c ======================================================================
@node Indices,  , C to Scheme mapping, Top
@appendix Indices
@c NODE 索引

@menu
* Function and Syntax Index::   
* Module Index::                
* Class Index::                 
* Variable Index::              
@end menu

@node Function and Syntax Index, Module Index, Indices, Indices
@appendixsec Function and Syntax Index
@c NODE 手続きと構文索引
@printindex fn

@node Module Index, Class Index, Function and Syntax Index, Indices
@appendixsec Module Index
@c NODE モジュール索引
@printindex md


@node Class Index, Variable Index, Module Index, Indices
@appendixsec Class Index
@c NODE クラス索引

For readability, the surrounding @code{<} and @code{>} are stripped off.

@printindex cl

@node Variable Index,  , Class Index, Indices
@appendixsec Variable Index
@c NODE 変数索引
@printindex vr


@contents
@bye

