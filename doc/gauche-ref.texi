\input texinfo  @c -*-texinfo-*-
@comment %**start of header
@setfilename gauche-ref
@settitle Gauche Reference Manual
@comment %**end of header

@c $Id: gauche-ref.texi,v 1.3 2001-05-17 09:04:21 shirok Exp $

@iftex
@finalout
@parskip 4pt plus 1pt
@end iftex

@titlepage
@title Gauche Reference Manual
@subtitle version 0.3.10
@author Shiro Kawai (shiro@@acm.org)

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001 Shiro Kawai (shiro@@acm.org)

@end titlepage

@node Top, Introduction, (dir), (dir)
@top

@ifnottex
This is a reference manual of Gauche, an R5RS Scheme implementation.
@end ifnottex


@node Introduction
@chapter Introduction

This is a programmers' guide and reference of Gauche Scheme system.
Here I tried to describe Gauche's implementation precisely,
sometimes with background design choices.
The target audiences are those who already know Scheme and
want to write useful programs in Gauche.

For those who are new to Scheme, it'll be easier to start
from some kind of tutorial.  I'm planning to write one.

This manual only deals with Scheme side of things.  Gauche has
another face, a C interface.   Details of it is discussed
in a separate document I'm planning.
Those who wants to use Gauche as an embedded language, or wants
to write an extension, need that volume.

@node Overview of Gauche
@section Overview of Gauche

Gauche is a Scheme language interpreter, almost conformant of
"Revised^5 Report on the Algorithmic Language Scheme".
Gauche has also various extensions, such as CLOS-like object system,
module system, and regular expression matcher,
so that it can be used in the daily works of programmers and system
administrators, and/or an extensible embedded scripting language.

There are lots of Scheme implementations out there.
Some even say there are more Scheme implementations than
the applications written in Scheme.
Partly because Scheme is very good as a test bench 
to explore various programming language concepts.  Partly
because it's purely fun to write a language system, and
Scheme is small enough to encourage it (although it's
implementation involves lots of technically challenges).

There is even a pracical reason to have lots of Scheme systems.
When implementing a language, you always have to decide
one strategy that fits best for your goal,
out of some possible implementation designs.
Since different goals may require different choices,
there can't be a single "right" implementation of the language.

So, what are Gauche's goals and strengths?
Basically, Gauche aims to the areas where people currently
use Python, Perl or Tcl.  The scripting work such that
you need to build something quick, and you may use it only several
times and discard it, while sometimes the code lives much longer
than you expected first.

No, I'm not trying to replace those languages.
However, there are jobs in that application domain to which
Scheme style of programming fits.  Those scripting languages,
although started from simple concepts, have eventually involved
lots of modern programming language concepts such as object orientation
and first-class closures.  There have been demands to include
those fancy concepts.  Then, why don't we use a language
carefully designed with those concepts from the beginning,
at least for the problems that requires those fancy concepts?

@node Notations
@section Notations




@node Structure of this document
@section Structure of this document




@c ======================================================================
@node Concepts
@chapter Concepts

In this chapter I describe a few Gauche's design concepts
that help you to understand how Gauche works.

@node Compilation
@section Compilation

Gauche is a Scheme interpreter, in the sense that it reads
a Scheme form at a time and evaluates it.   Actually,
Gauche compiles every form into an intermediate form
before executing.  



@node Module System
@section Module System

Gauche adopts a simple module system that allows
modularlized development of large software.

A higher level interface is simple enough from the user's point
of view.   When you want to use the features provided by module
@code{foo}, you just need to say @code{(use foo)} in your code.
This form is a macro and interpreted at compile time.




The @code{use} mechanism is built on top of two independent
mechanisms, namespace separation and file loading mechanism.
Those two can be used separately, although it is much more
convenient when used together.






@node Objects
@section Objects


@node Multibyte Strings
@section Multibyte Strings


@c ======================================================================
@node Invoking Gosh
@chapter Invoking Gosh



@c ======================================================================
@node Core Syntax
@chapter Core Syntax

@node Literals
@section Literals

@defspec quote datum
[R5RS]
@end defspec




@node Making Procedures
@section Making Procedures

@defspec lambda formals body
[R5RS]
@end defspec


@node Assignments
@section Assignments

Gauche adopts the concept of "generalized set!"
specified in @uref{http://srfi.schemers.org/srfi-17/srfi-17.html, SRFI-17}.

@defspec set! variable expression
@defspecx set! location expression
[R5RS][SRFI-17]
@end defspec

@defun setter proc
[SRFI-17]
@end defun

@defun getter-with-setter get set
[SRFI-17]
@end defun


@node Conditionals
@section Conditionals


@defspec if test consequent alternate
@defspecx if test consequent
[R5RS]
@end defspec


@defspec cond clause1 clause2 @dots{}
[R5RS]
@end defspec


@defspec case key clause1 clause2 @dots{}
[R5RS]
@end defspec


@defspec and test @dots{}
[R5RS]
@end defspec


@defspec or test @dots{}
[R5RS]
@end defspec

@defspec when test . body
@defspecx unless test . body
@end defspec

@node Binding constructs
@section Binding constructs


@defspec let bindings body
[R5RS]
@end defspec

@defspec let* bindings body
[R5RS]
@end defspec

@defspec letrec bindings body
[R5RS]
@end defspec


@defspec receive formals expression body
[SRFI-8]
@end defspec

@node Sequencing
@section Sequencing


@defspec begin
[R5RS]
@end defspec


@node Iteration
@section Iteration

@defspec do ((variable init step) @dots{}) (test expr @dots{}) body
[R5RS]
@end defspec


@defspec let name bindings body
[R5RS]
@end defspec


@node Quasiquotation
@section Quasiquotation

@defspec quasiquote template
[R5RS]
@end defspec


@node Definitions
@section Definitions

@defspec define variable expression
@defspecx define (variable formals) body
[R5RS]
@end defspec


@node Modules
@section Modules

@node Module syntax
@subsection Module syntax

@defspec define-module name body
@end defspec

@defspec select-module name
@end defspec

@defspec with-module name body
@end defspec

@defspec export symbol @dots{}
@end defspec

@defspec import module-name @dots{}
@end defspec

@defmac use name
@end defmac


@node Module introspection
@subsection Module introspection

@deftp {Builtin Class} <module>
@end deftp

@defun module? obj
@end defun

@defun module-name module
@defunx module-imports module
@defunx module-exports module
@defunx module-table module
@end defun

@defun find-module name
@end defun

@defun all-modules
@end defun

@c ======================================================================
@node Macros
@chapter Macros

@node Hygienic Macros
@section Hygienic Macros

@defspec define-syntax name transformer-spec
[R5RS]
@end defspec

@defspec let-syntax ((name transformer-spec) @dots{}) body
@defspecx letrec-syntax ((name transformer-spec) @dots{}) body
[R5RS]
@end defspec

@defspec syntax-rules literals clause1 clause2 @dots{}
[R5RS]
@end defspec


@node Traditional Macros
@section Traditional Macros

@defspec define-macro (name formals) body
@end defspec

@node Macro Expansion
@section Macro Expansion

@defspec %macro-expand form
@defspecx %macro-expand1 form
@end defspec


@c ======================================================================
@node Core library
@chapter Core library

@c ----------------------------------------------------------------------
@node Equivalence
@section Equivalence

@defun eq? obj1 obj2
[R5Rs]
@end defun

@defun eqv? obj1 obj2
[R5Rs]
@end defun

@defun equal? obj1 obj2
[R5Rs]
@end defun

@c ----------------------------------------------------------------------
@node Numbers
@section Numbers

@node Number classes
@subsection Number classes

@deftp {Builtin Class} <number>
@deftpx {Builtin Class} <complex>
@deftpx {Builtin Class} <real>
@deftpx {Builtin Class} <integer>
@end deftp

@node Numerical predicates
@subsection Numerical predicates

@defun number? obj
@defunx complex? obj
@defunx real? obj
@defunx rational? obj
@defunx integer? obj
[R5Rs]
@end defun

@defun exact? obj
@defunx inexact? obj
[R5Rs]
@end defun

@defun zero? z
[R5Rs]
@end defun

@defun positive? x
@defunx negative? x
[R5Rs]
@end defun

@defun odd? n
@defunx even? n
[R5RS]
@end defun

@node Numerical comparison
@subsection Numerical comparison

@defun = z1 z2 z3 @dots{}
@defunx < x1 x2 x3 @dots{}
@defunx <= x1 x2 x3 @dots{}
@defunx > x1 x2 x3 @dots{}
@defunx >= x1 x2 x3 @dots{}
[R5RS]
@end defun


@defun max x1 x2 @dots{}
@defunx min x1 x2 @dots{}
[R5RS]
@end defun

@node Arithmetics
@subsection Arithmetics

@defun + z @dots{}
@defunx * z @dots{}
[R5RS]
@end defun


@defun - z1 z2 @dots{}
@defunx / z1 z2 @dots{}
[R5RS]
@end defun

@defun abs z @dots{}
[R5RS+]
@end defun

@defun quotient n1 n2
@defunx remainder n1 n2
@defunx modulo n1 n2
[R5RS]
@end defun

@defun gcd n @dots{}
@defunx lcm n @dots{}
[R5RS]
@end defun

@defun numerator q
@defunx denominator q
[R5RS]
@end defun


@defun floor x
@defunx ceiling x
@defunx truncate x
@defunx round x
[R5RS]
@end defun


@defun exp z
@defunx log z
@defunx sin z
@defunx cos z
@defunx tan z
@defunx asin z
@defunx acos z
@defunx atan z
@defunx atan x y
[R5RS]
@end defun


@defun sinh z
@defunx cosh z
@defunx tanh z
@defunx asinh z
@defunx acosh z
@defunx atanh z

@end defun


@defun sqrt z
[R5RS]
@end defun


@defun expt z1 z2
[R5RS]
@end defun

@node Numericaln conversions
@subsection Numerical conversions


@defun make-rectangular x1 x2
@defunx make-polar x1 x2
@defunx real-part z
@defunx imag-part z
@defunx magnitude z
@defunx angle z
[R5RS]
@end defun


@defun exact->inexact z
@defunx inexact->exact z
[R5RS]
@end defun

@defun numebr->string z [radix]
@defunx string->number string [radix]
[R5RS]
@end defun

@node Logical operations
@subsection Logical operations

@defun ash n count
@end defun

@defun logand n1 n2
@end defun

@defun logior n1 n2
@end defun

@defun logxor n1 n2
@end defun

@defun lognot n
@end defun

@node Booleans
@section Booleans

@deftp {Builtin Class} <boolean>
@end deftp

@defun not obj
[R5RS]
@end defun

@defun boolean? obj
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Pairs and Lists
@section Pairs and Lists

@node Pair and null class
@subsection Pair and null class

@deftp {Builtin Class} <list>
@end deftp

@deftp {Builtin Class} <null>
@end deftp

@deftp {Builtin Class} <pair>
@end deftp

@node List predicates
@subsection List predicates

@defun pair? obj
[R5RS]
@end defun

@defun null? obj
[R5RS]
@end defun

@defun list? obj
[R5RS]
@end defun

@node List constructors
@subsection List constructors

@defun cons obj1 obj2
[R5RS]
@end defun

@defun acons obj1 obj2 obj3
[SRFI-1]
@end defun

@defun make-list len [fill]
[SRFI-1]
@end defun

@defun list obj @dots{}
[R5RS]
@end defun

@defun list* obj @dots{}
@end defun

@defun list-copy list
[SRFI-1]
@end defun


@node List accessors and modifiers
@subsection List accessors and modifiers

@defun car pair
@defunx cdr pair
[R5RS]
@end defun

@defun set-car! pair obj
@defunx set-cdr! pair obj
[R5RS]
@end defun

@defun caar pair
@defunx cadr pair
@defunx cdar pair
@defunx cddr pair
@defunx caaar pair
@defunx caadr pair
@defunx cadar pair
@defunx caddr pair
@defunx cdaar pair
@defunx cdadr pair
@defunx cddar pair
@defunx cdddr pair
@defunx caaaar pair
@defunx caaadr pair
@defunx caadar pair
@defunx caaddr pair
@defunx cadaar pair
@defunx cadadr pair
@defunx caddar pair
@defunx cadddr pair
@defunx cdaaar pair
@defunx cdaadr pair
@defunx cdadar pair
@defunx cdaddr pair
@defunx cddaar pair
@defunx cddadr pair
@defunx cdddar pair
@defunx cddddr pair
[R5RS]
@end defun

@defun length list
[R5RS]
@end defun

@defun list-tail list k
[R5RS]
@end defun

@defun list-ref list k
[R5RS]
@end defun

@defun last-pair list
[SRFI-1]
@end defun


@node Other list procedures
@subsection Other list procedures

@defun append list @dots{}
[R5RS]
@end defun

@defun append! list @dots{}
[SRFI-1]
@end defun


@defun reverse list
[R5RS]
@end defun

@defun reverse! list
[SRFI-1]
@end defun


@defun memq obj list
@defunx memv obj list
[R5RS]
@end defun

@defun member obj list [=]
[R5RS+][SRFI-1]
@end defun

@defun assq obj list
@defunx assv obj list
[R5RS]
@end defun

@defun assoc obj list [=]
[R5RS+][SRFI-1]
@end defun


@c ----------------------------------------------------------------------
@node Symbols
@section Symbols

@deftp {Builtin Class} <symbol>
@end  deftp

@defun symbol? obj
[R5RS]
@end defun

@defun symbol->string symbol
[R5RS]
@end defun

@defun string->symbol string
[R5RS]
@end defun

@defun gensym [prefix]
@end defun


@c ----------------------------------------------------------------------
@node Keywords
@section Keywords

@deftp {Builtin Class} <keyword>
@end  deftp

@defun keyword? obj
@end defun

@defun make-keyword name
@end defun

@defun get-keyword key list [fallback]
@end defun

@c ----------------------------------------------------------------------
@node Identifiers
@section Identifiers

@deftp {Builtin Class} <identifier>
@end  deftp

@defun identifier? obj
@end defun

@defun identifier->symbol identiifer
@end defun


@c ----------------------------------------------------------------------
@node Characters
@section Characters

@deftp {Builtin Class} <char>
@end  deftp

@defun char? obj
[R5RS]
@end defun

@defun char=? char1 char2
@defunx char<? char1 char2
@defunx char<=? char1 char2
@defunx char>? char1 char2
@defunx char>=? char1 char2
[R5RS]
@end defun

@defun char-ci=? char1 char2
@defunx char-ci<? char1 char2
@defunx char-ci<=? char1 char2
@defunx char-ci>? char1 char2
@defunx char-ci>=? char1 char2
[R5RS]
@end defun

@defun char-alphabetic? char
@defunx char-numeric? char
@defunx char-whitespace? char
@defunx char-upper-case? char
@defunx char-loser-case? char
[R5RS]
@end defun

@defun char->integer char
@defunx integer->char n
[R5RS]
@end defun

@defun char-upcase char
@defunx char-downcase char
[R5RS]
@end defun

@defun gauche-character-encoding
@end defun


@c ----------------------------------------------------------------------
@node Character Set
@section Character Set

@deftp {Builtin Class} <char-set>
@end deftp

@defun char-set? obj
[SRFI-14]
@end defun

@defun char-set-contains? char-set char
[SRFI-14]
@end defun

@defun char-set char @dots{}
[SRFI-14]
@end defun

@defun char-set-copy char-set
[SRFI-14]
@end defun



@c ----------------------------------------------------------------------
@node Strings
@section Strings

@deftp {Builtin Class} <string>
@end deftp

@node String Predicates
@subsection String Predicates

@defun string? obj
[R5RS]
@end defun

@defun string-complete? obj
@end defun

@node String Constructors
@subsection String Constructors

@defun make-string k [char]
[R5RS]
@end defun

@defun string char @dots{}
[R5RS]
@end defun

@node String Accessors & Modifiers
@subsection String Accessors & Modifiers

@defun string-length string
[R5RS]
@end defun

@defun string-size string
@end defun

@defun string-ref string k
[R5RS]
@end defun

@defun string-byte-ref string k
@end defun

@defun string-set! string k char
[R5RS]
@end defun

@defun string-byte=set! string k byte
@end defun

@node String Comparison
@subsection String Comparison

@defun string=? string1 string2
@defunx string-ci=? string1 string2
[R5RS]
@end defun

@defun string<? string1 string2
@defunx string<=? string1 string2
@defunx string>? string1 string2
@defunx string>=? string1 string2
@defunx string-ci<? string1 string2
@defunx string-ci<=? string1 string2
@defunx string-ci>? string1 string2
@defunx string-ci>=? string1 string2
[R5RS]
@end defun

@node String Utilities
@subsection String Utilities

@defun substring string start end
[R5RS]
@end defun

@defun string-append string @dots{}
[R5RS]
@end defun

@defun string->list string [start end]
@defunx list->string list
[R5RS+][SRFI-13]
@end defun

@defun string-copy string [start end]
[R5RS+][SRFI-13]
@end defun

@defun string-fill! string char [start end]
[R5RS+][SRFI-13]
@end defun

@defun string-join strs [delim grammer]
[SRFI-13]
@end defun

@defun string-split s char
@end defun


@node String Pointers
@subsection String Pointers

@defun make-string-pointer str [index]
@end defun

@defun string-pointer? obj
@end defun

@defun string-pointer-next! sp
@defunx string-pointer-prev! sp
@end defun

@defun string-pointer-set! sp index
@end defun

@defun string-pointer-substring sp &keyword (after #f)
@end defun

@defun string-pointer-index sp
@end defun

@c ----------------------------------------------------------------------
@node Regular Expression
@section Regular Expression

@deftp {Builtin Class} <regexp>
@end deftp

@deftp {Builtin Class} <regmatch>
@end deftp

@defun string->regexp string
@end defun

@defun rxmatch regexp str
@end defun

@defun rxmatch-substring match &optional (i 0)
@defunx rxmatch-start match &optional (i 0)
@defunx rxmatch-end match &optional (i 0)
@end defun

@c ----------------------------------------------------------------------
@node Vectors
@section Vectors

@deftp {Builtin Class} <vector>
@end deftp

@defun vector? obj
[R5RS]
@end defun

@defun make-vector k &optional fill
[R5RS]
@end defun

@defun vector obj @dots{}
[R5RS]
@end defun

@defun vector-length vector
[R5RS]
@end defun

@defun vector-ref vector k
[R5RS]
@end defun

@defun vector-set! vector k obj
[R5RS]
@end defun

@defun vector->list vector
@defunx list->vector list
[R5RS]
@end defun

@defun vector-fill! vector fill
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Hashtables
@section Hashtables

@deftp {Builtin Class} <hash-table>
@end deftp

@defun make-hash-table args
@end defun

@defun hash-table?
@end defun

@defun hash-table-get hash key &optional default
@end defun

@defun hash-table-put! hash key value
@end defun

@defun hash-table-exists? hash key
@end defun

@defun hash-table-for-each hash proc
@end defun

@defun hash-table-keys hash
@defunx hash-table-values hash
@end defun

@defun hash-table-stat hash
@end defun


@c ----------------------------------------------------------------------
@node Control features
@section Control features

@node Procedures
@subsection Procedures

@deftp {Builtin Class} <procedure>
@end deftp

@defun procedure? obj
[R5RS]
@end defun

@defun apply proc arg1 @dots{} args
[R5RS]
@end defun

@defun map proc list1 list2 @dots{}
[R5RS]
@end defun

@defun for-each proc list1 list2 @dots{}
[R5RS]
@end defun

@node Continuation and escaping
@subsection Continuation and escaping


@defun call-with-current-continuation proc
@defunx call/cc
[R5RS]
@end defun

@defun dynamic-wind before thunk after
[R5RS]
@end defun

@node Multiple values
@subsection Multiple values

@defun values obj @dots{}
[R5RS]
@end defun

@defun call-with-values producer consumer
[R5RS]
@end defun


@node Delayed Evaludation
@subsection  Delayed Evaludation

@defspec delay expression
[R5RS]
@end defspec

@defun force promise
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Eval
@section Eval

@defun eval expr env
[R5RS]
@end defun

@defun null-environment
@defunx interaction-environment
@defunx scheme-report-environment version
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Input and Output
@section Input and Output

@defun input-port? obj
@defunx output-port? obj
[R5RS]
@end defun

@defun port-closed? port
@end defun


@defun current-input-port
@defunx current-output-port
[R5RS]
@end defun

@defun current-error-port
@end defun

@defun with-input-from-port port thunk
@defunx with-output-to-port port thunk
@defunx with-error-to-port port thunk
@end defun

@defun close-input-port port
@defunx close-output-port port
[R5RS]
@end defun

@defun port-name port
@end defun

@defun port-current-line
@end defun

@defun port-file-number
@end defun

@node File ports
@subsection File ports

@defun open-inupt-file filename
[R5RS]
@end defun

@defun open-output-file filename
[R5RS]
@end defun

@defun call-with-input-file string proc
@defunx call-with-output-file string proc
[R5RS]
@end defun

@defun with-input-from-file string thunk
@defunx with-output-to-file string thunk
[R5RS]
@end defun


@node String ports
@subsection String ports

@defun open-input-string string
[SRFI-6]
@end defun

@defun open-output-string
[SRFI-6]
@end defun

@defun get-output-string
[SRFI-6]
@end defun

@defun call-with-input-string string proc
@end defun

@defun call-with-output-string proc
@end defun

@defun with-input-from-string string thunk
@end defun

@defun with-output-to-string thunk
@end defun


@node Procedural ports
@subsection Procedural ports

@node Input
@subsection Input 

@defun read &optional port
[R5RS]
@end defun

@defun read-char &optional port
[R5RS]
@end defun

@defun peek-char &optional port
[R5RS]
@end defun

@defun read-byte &optional port
@end defun

@defun read-line &optional port
@end defun

@defun eof-object? obj
[R5RS]
@end defun

@defun char-ready? port
[R5RS]
@end defun


@node Output
@subsection Output

@defun write obj &optional port
[R5RS]
@end defun

@defun display obj &optional port
[R5RS]
@end defun

@defun newline &optional port
[R5RS]
@end defun

@defun write-char char &optional port
[R5RS]
@end defun

@defun write-byte byte &optional port
@end defun

@defun write* obj &optional port
@end defun

@defun format port string arg @dots{}
@end defun


@c ----------------------------------------------------------------------
@node Loading Programs
@section Loading Programs

@defun load file &keyword (error-if-not-found #t)
[R5RS+]
@end defun

@defun load-from-port port
@end defun

@defun dynamic-load file &keyword init-function
@end defun

@defspec add-load-path path &optional (afterp #f)
@end defspec

@defspec require feature
@end defspec

@defun provide feature
@end defun

@defun provided? feature
@end defun

@defmac autoload file var @dots{}
@end defun


@c ----------------------------------------------------------------------
@node System interface
@section System interface


@node Program termination
@subsection Program termination

@defun exit &optional code
@end defun

@node Environment Inquiry
@subsection Environment Inquiry

@defun sys-getenv name
@end defun

@defun gauche-version
@defunx gauche-architecture
@defunx gauche-library-directory
@defunx gauche-architecture-directory
@defunx gauche-site-library-directory
@defunx gauche-site-architecture-directory
@end defun

@node Filesystems
@subsection Filesystems

@node Directories
@subsubsection Directories

@defun sys-readdir
@end defun

@defun sys-glob
@end defun

@node Directory manipulation
@subsubsection Directory manipulation

@defun sys-remove filenmae
@end defun

@defun sys-rename old new
@end defun

@defun sys-tmpnam
@end defun

@defun sys-link existing new
@end defun

@defun sys-rmdir pathname
@end defun

@defun sys-unlink pathname
@end defun

@defun sys-symlink existing new
@end defun

@node Pathnames
@subsubsection Pathnames

@defun sys-normalize-pathname pathname &keyword absolute expand canonicalize
@end defun

@defun sys-basename
@defunx sys-dirname
@end defun

@node File stats
@subsubsection File stats

@deftp {Builtin Class} <sys-stat>
@end deftp

@defun sys-stat path
@end defun

@defun sys-lstat path
@end defun

@defun sys-fstat fd
@end defun

@defun sys-access pathname amode
@end defun

@node Other file operations
@subsubsection Other file operations

@defun sys-chdir dir
@end defun

@defun sys-pipe &keyword name buffered?
@end defun

@defun sys-isatty port-or-fd
@end defun

@defun sys-ttyname port-or-fd
@end defun

@node Unix groups and passwords
@subsection Unix groups and passwords

@node Unix Group
@subsubsection Unix Group

@deftp {Builtin Class} <sys-group>
@end deftp

@defun sys-getgrid gid
@defunx sys-getgrnam name
@end defun

@defun sys-gid->group->name gid
@defunx sys-group-name->gid name
@end defun

@node Unix Password
@subsubsection Unix Password

@deftp {Builtin Class} <sys-passwd>
@end deftp

@defun sys-getpwuid uid
@defunx sys-getpwnam name
@end defun

@defun sys-uid->user-name uid
@defunx sys-user-name->uid
@end defun


@node Password encryption
@subsubsection Password encryption

@defun sys-crypt key salt
@end defun

@node Locale
@subsection Locale

@defun sys-setlocate category locale
@end defun


@node Signal
@subsection Signal

@defvar SIGABRT
@defvarx SIGALRM
@defvarx SIGCHLD
@defvarx SIGCONT
@defvarx SIGFPE
@defvarx SIGHUP
@defvarx SIGILL
@defvarx SIGINT
@defvarx SIGKILL
@defvarx SIGPIPE
@defvarx SIGQUIT
@defvarx SIGSEGV
@defvarx SIGSTOP
@defvarx SIGTSTP
@defvarx SIGTTIN
@defvarx SIGTTOU
@defvarx SIGUSR1
@defvarx SIGUSR2

@end defvar

@defun sys-kill pid sig
@end defun


@node System Inquiry
@subsection System Inquiry

@defun sys-uname
@end defun

@defun sys-getcwd
@end defun

@defun sys-getgid
@defunx sys-getegid
@end defun

@defun sys-getuid
@defunx sys-geteuid
@end defun

@defun sys-getgroups
@end defun

@defun sys-getlogin
@end defun

@defun sys-getpgrp
@end defun

@defun sys-getpid
@defunx sys-getppid
@end defun




@node Time
@subsection Time

@defun sys-times
@end defun

@deftp {Builtin Class} <sys-time>
@end deftp

@deftp {Builtin Class} <sys-tm>
@end deftp

@defun sys-time
@end defun

@defun sys-gmtime time
@end defun

@defun sys-localtime time
@end defun

@defun sys-ctime time
@end defun

@defun sys-difftime time1 time0
@end defun

@defun sys-asctime tm
@end defun

@defun sys-strftime format tm
@end defun

@defun sys-mktime tm
@end defun

@defin sys-tm->alist tm
@end defun


@node Unix process management
@subsection Unix process management

@node Fork and exec
@subsubsection Fork and exec

@defun sys-system command
@end defun

@defun sys-fork
@end defun

@defun sys-exec command args &optional iomap
@end defun


@node Wait
@subsubsection Wait

@defun sys-wait
@end defun

@defun sys-waitpid pid &keyword nohang untraced
@end defun

@defun sys-wait-exited? status
@defunx sys-wait-exit-status status
@end defun

@defun sys-wait-signaled? status
@defunx sys-wait-termsig status
@end defun

@defun sys-wait-stopped? status
@defunx sys-wait-stopsig status
@end defun


@node Miscellaneous
@subsection Miscellaneous

@defun sys-pause
@end defun

@defun sys-sleep seconds
@end defun

@c ======================================================================
@node Object System
@chapter Object System

@c ----------------------------------------------------------------------
@node General Inquiry
@section  General Inquiry

@defun class-of obj
@end defun

@defun is-a? obj class
@end defun

@c ----------------------------------------------------------------------
@node Defining class
@section Defining class

@defmac define-class name supers (slot-spec @dots{}) option @dots{}
@end defmac


@c ----------------------------------------------------------------------
@node Defining methods
@section Defining methods

@defmac define-generic name
@end defmac

@defmac define-method name specs body
@end defmac

@c ----------------------------------------------------------------------
@node Creating Instance
@section Creating Instance

@deffn {Generic Function} make class arg @dots{}
@end deffn

@deffn {Method} make (class <class>) arg @dots{}
@end deffn

@deffn {Method} make (class <method>)  arg @dots{}
@deffnx {Method} make (class <generic>)  arg @dots{}
@end deffn

@deffn {Method} initialize (class <class>) initargs
@end deffn

@c ----------------------------------------------------------------------
@node Accessing Instance
@section Accessing Instance

@defun slot-ref obj slot
@end defun

@defun slot-set! obj slot
@end defun

@defun slot-bound? obj slot
@end defun

@defun slot-exists? slot
@end defun

@deffn {Generic Function} slot-unbound
@end deffn

@deffn {Method} slot-unbound (class <class>) obj slot
@end deffn

@deffn {Generic Function} slot-missing
@end deffn

@deffn {Method} slot-missing (class <class>) obj slot &optional value
@end deffn


@defun class-slot-ref class slot-name
@defunx class-slot-set! class slot-name obj
@end defun

@c ----------------------------------------------------------------------
@node Metaobject protocol
@section Metaobject procotol

@node System metaclasses
@subsection System metaclasses

@deftp {Class} <class>
@end deftp

@deftp {Class} <generic>
@end deftp

@deftp {Class} <method>
@end deftp

@deftp {Class} <object>
@end deftp


@node Class introspection
@subsection Class introspection

@node Class metaobject
@subsubsection Class metaobject

@defun class-name class
@end defun

@defun class-precedence-list class
@end defun

@defun class-direct-supers class
@end defun

@defun class-direct-slots class
@end defun

@defun class-slots
@end defun

@node Slot definition
@subsubsection Slot definition

@defun class-slot-definition class slot-name
@end defun

@defun class-slot-accessor class slot-name
@end defun

@defun slot-definition-name slot-def
@end defun
@defun slot-definition-allocation slot
@end defun

@defun slot-definition-getter slot
@defunx slot-defininion-setter slot
@defunx slot-definition-accessor slot
@end defun

@defun slot-definition-options slot-def
@defunx slot-definition-option slot-def key &optional default
@end defun

@node Class instantiation
@subsection Class instantiation

@node Customizing slot access
@subsection Customizing slot access

@node Method instantiation
@subsection Method instantiation

@node Customizing method application
@subsection Customizing method application



@c ======================================================================
@node Libarary Modules
@chapter Library Modules


@c ----------------------------------------------------------------------
@node Process interface
@section @code{gauche.process} - Object-oriented interface for processes

@deftp {Class} <process>
@end deftp

@defun run-process command arg @dots{}
@end defun

@defun process? obj
@end defun

@deffn {Method} process-pid (process <process>)
@end deffn

@deffn {Method} process-command (process <process>)
@end deffn

@deffn {Method} process-status (process <process>)
@end deffn

@deffn {Method} process-input (process <process>)
@deffnx {Method} process-output (process <process>)
@deffnx {Method} process-error (process <process>)
@end deffn

@defun process-alive? process
@end defun

@defun process-list
@end defun

@defun process-wait process
@end defun

@defun process-send-signal process signal
@end defun

@defun process-kill process
@defunx process-stop process
@defunx process-continue process
@end defun

@c ----------------------------------------------------------------------
@node Regular expression library
@section @code{gauche.regexp} - Regular expression library

@c ----------------------------------------------------------------------
@node Serializer
@section @code{gauche.serializer} - Serializer

@c ----------------------------------------------------------------------
@node Unit Testing
@section @code{gauche.test} - Unit Testing

@defun test name 
@end defun

@defun test-start module-name
@end defun

@defun test-section section-name
@end defun

@defun test-end
@end defun

@c ----------------------------------------------------------------------
@node Base64 encoding/decoding
@section @code{rfc.base64} - Base64 encoding/decoding

@defun base64-encode
@end defun

@defun base64-encode-string string
@end defun

@defun base64-decode
@end defun

@defun base64-decode-string string
@end defun


@c ----------------------------------------------------------------------
@node Feature Conditional
@section @code{srfi-0} - Feature Conditional


@c ----------------------------------------------------------------------
@node List library
@section @code{srfi-1} - List library


@c ----------------------------------------------------------------------
@node And-let*
@section @code{srfi-2} - And-let*


@c ----------------------------------------------------------------------
@node Homogeneous Vectors
@section @code{srfi-4} - Homogeneous Vectors


@c ----------------------------------------------------------------------
@node Let-values
@section @code{srfi-11} - Let-values


@c ----------------------------------------------------------------------
@node String library
@section @code{srfi-13} - String library


@c ----------------------------------------------------------------------
@node Character-set library
@section @code{srfi-14} - Character-set library



@c ======================================================================
@node References
@unnumbered References




@c ======================================================================
@node Function and Syntax Index
@unnumbered Function and Syntax Index
@printindex fn

@node Class Index
@unnumbered Class Index
@printindex tp

@node Variable Index
@unnumbered Variable Index
@printindex vr


@contents
@bye
