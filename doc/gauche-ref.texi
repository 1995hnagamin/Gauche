\input texinfo  @c -*-texinfo-*-
@comment %**start of header
@setfilename gauche-ref
@settitle Gauche Reference Manual
@comment %**end of header

@c $Id: gauche-ref.texi,v 1.14 2001-06-02 11:13:06 shirok Exp $

@c module and class index
@defcodeindex md
@defcodeindex cl

@iftex
@finalout
@parskip 4pt plus 1pt
@end iftex

@titlepage
@title Gauche Reference Manual
@subtitle version 0.3.13
@author Shiro Kawai (shiro@@acm.org)

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001 Shiro Kawai (shiro@@acm.org)

@end titlepage

@node Top, Introduction, (dir), (dir)
@top

@ifnottex
This is a reference manual of Gauche, an R5RS Scheme implementation.
@end ifnottex


@node Introduction
@chapter Introduction

This is a programmers' guide and reference manual of
the Gauche Scheme system.
Here I tried to describe Gauche's implementation precisely,
sometimes referring to background design choices.

The target readers are those who already know Scheme and
want to write useful programs in Gauche.
For those who are new to Scheme, it'll be easier to start
from some kind of tutorial.  I'm planning to write one.

This manual only deals with Scheme side of things.  Gauche has
another face, a C interface.   Details of it is discussed
in a separate document I'm planning.
Those who wants to use Gauche as an embedded language, or wants
to write an extension, need that volume.

For the Scheme side, I tried to make this manual self-contained,
i.e. as far as you want to look up Gauche's features you don't
need to refer to other documents, for reader's convenience.
For example, description of functions defined in the standard
documents are included in this manual, instead of saying
"see this document".   However, this document is not a verbatim
copy of the standard document; sometimes I omit detailed
discussions in the standard documents, for brevity.
I put pointers to the original documents, so consult them if you
need to refer to the standards.

If you're reading this document off-line, you may find the most
recent version on the web @uref{http://www.shiro.dreamhost.com/scheme/gauche/}.

@node Overview of Gauche
@section Overview of Gauche

Gauche is a script interpreter, based on Scheme.
Gauche conforms the language standard
"Revised^5 Report on the Algorithmic Language Scheme"
(@uref{http://www.schemers.org/Documents/Standards/R5RS/HTML/}),
and supports various common libraries defined in SRFIs
(@uref{http://srfi.schemers.org}).

The goal of Gauche is to provide a handy tool for
programmers and system administrators to handle
daily works conveniently and efficiently in the production environment.

@table @b
@item Quick startup

In the production environment, there are situations that 
you write a ten-line Scheme script which does a simple but useful thing,
and others invoke it from 
from their shell scripts (or Perl, Phthon, Tcl, whatever) very frequently.
You don't want to use a big fat scripting engine that takes half a second
to start up for this kind of scripts, or people start writing their own
libraries in their own favorite languages.
Sharing scripts, not only code, is very important in the practical
situation, and you want to have a reasonably lightweight interpreter
to populate your scripts.

Gauche includes a set of most common features in its executable,
while splits less common stuffs into libraries which are to be loaded
on demand, to make itself start quickly.

@item Modular development

Richness of libraries is one of the criteria on which
people choose scripting language, so you want to include as many
libraries as possible.  You cannot, however, write everything by
your own.   The key to enrich the libraries are the framework to
allow and to encourage people to write reusable, modulalized code.

Gauche has several mechanisms to realize this framework.
The simple and clean module system, a powerful CLOS-like object
syste with a metaobject protocol, and feature based on-demand
file loading system are the elements.
@xref{Module System}, for details.

@item Multibyte strings

We can no longer live happily in ASCII-only or 1-byte-per-character world.
Nowadays you have to exchange text information in various encodings,
some of them have much more characters than 256 (or, in fact, more than 65536).
The practical language implementations are required to handle
multibyte (wide) characters in some way.

Gauche supports multibyte strings natively, providing robust and
consistent support than @i{ad hoc} library-level implementation.
@xref{Multibyte Strings}, for details.

@item System interface

Although Scheme abstracts lots of details of the machine,
sometimes you have to bypass these high-level layers and
go down to the basement to make things work.

Gauche has built-in support of most of POSIX.1 system calls.
Other modules, such as networking module, usually provide
both high-level abstract interface and low-level interface.

@item Powerful I/O

No real application can be written without dealing with I/O.
Scheme neatly abstracts I/O as a port, but defines least operations on it.
Gauche uses a port object as a unified abstraction, but 


@item Clean C API



@end table





@node Notations
@section Notations

In this manual, each entry is represented like this:

@deftp {Category} foo arg1 arg2
[spec] Description of foo @dots{}
@end deftp

@var{Category} denotes the category of the entry @b{foo}.
The following category will appear in this manual:

@table @asis
@item Function
A Scheme function.
@item Special Form
A special form (in the R5RS term, ``syntax'').
@item Macro
A macro.
@item Module
A module
@item Class
A class.
@item Reader Syntax
A lexical syntax that is interpreted by the reader.
@end table

For functions, special forms and macros, the entry may followed
by one or more arguments.  In the argument list, the following notations
may appear:

@table @var
@item arg @dots{}
This notation may appear in special forms and macros, and indicates
zero or more arguments.
@item &optional x y z
@itemx &optional (x x-default) (y y-default) z
Indicates it may take up to three optional arguments.
The second form specifies default values.
Note that Gauche doesn't really support Common-Lisp style
@code{&optional} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@item &keyword x y z
@itemx &keyword (x x-default) (y y-default) z
Indicates it may take keyword arguments @var{x}, @var{y} and @var{z.}
Note that Gauche doesn't really support Common-Lisp style
@code{&keyword} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@item &rest args
Indicates it may take rest arguements.
Note that Gauche doesn't really support Common-Lisp style
@code{&rest} argument specifier in the lambda list.
I use this notation since it is useful to indicate valid pattern of arguments.
@end table

The description of the entry follows the entry line.
If the specification of the entry comes from some standard or
implementation, its origin is noted in the bracket at the beginning
of the description.  The following origins are noted:

@table @asis
@item [R5RS]
The entry works as specified in ``Revised^5 Report of Algorithmic Language
Scheme.''.
@item [SRFI-@var{n}]
The entry works as specified in SRFI-@var{n}.
@item [POSIX]
The API of the entry reflects the API specified in POSIX.
@end table


@node Structure of this document
@section Structure of this document




@c ======================================================================
@node Concepts
@chapter Concepts

In this chapter I describe a few Gauche's design concepts
that help you to understand how Gauche works.

@node Compilation
@section Compilation

Gauche is a Scheme interpreter, in the sense that it reads
a Scheme form at a time and evaluates it.   Actually,
Gauche compiles every form into an intermediate form
before executing.  



@node Module System
@section Module System

Gauche adopts a simple module system that allows
modularlized development of large software.

A higher level interface is simple enough from the user's point
of view.   When you want to use the features provided by module
@code{foo}, you just need to say @code{(use foo)} in your code.
This form is a macro and interpreted at compile time.




The @code{use} mechanism is built on top of two independent
mechanisms, namespace separation and file loading mechanism.
Those two can be used separately, although it is much more
convenient when used together.


@node Objects
@section Objects

Gauche has a CLOS-style object system, with metaobject protocol.
For those who are familiar with SmallTalk style object system,
the CLOS-style multimethod may look strange.  I describe several
characteristics of Gauche object system here.
@xref{Object System}, for details.

@table @emph
@item Everything is an object.
In Gauche, everything is an object in the sense that you can
query its class, and various meta information of the object
at run time.

@item Method is dispatched by all of its arguments.
Unlike other object-oriented languages such as C++, Objective-C,
Python, Ruby, etc., in which a method always belong to a single
class, Gauche methods don't 


@end table

@node Multibyte Strings
@section Multibyte Strings


@c ======================================================================
@node Invoking Gosh
@chapter Invoking Gosh

@deftp {Program} gosh [options] [--] [file arg @dots{}]
@code{Gosh} is Gauche's interpreter.   Without @var{file}s,
it reads a Scheme expression from the standard input, evaluates it,
and prints the result, and repeat that until it reads EOF or
is terminated.

If @var{file} is specified, @code{gosh} loads the file as a Scheme
program and exits.  The command line arguments following @var{file}
is passed to the Scheme program as program arguments.
@end deftp

@deftp {Command Option} -I path
@end deftp

@deftp {Command Option} -q
@end deftp

@deftp {Command Option} -V
@end deftp

@deftp {Command Option} -u module
@end deftp

@deftp {Command Option} -f function
@end deftp


@c ======================================================================
@node Core Syntax
@chapter Core Syntax

@c ----------------------------------------------------------------------
@node Literals
@section Literals

@defspec quote datum
[R5RS]
@end defspec

@c ----------------------------------------------------------------------
@node Making Procedures
@section Making Procedures

@defspec lambda formals body @dots{}
[R5RS]
@end defspec


@c ----------------------------------------------------------------------
@node Assignments
@section Assignments

Gauche adopts the concept of generalized @code{set!}
specified in SRFI-17.

@defspec set! symbol expression
@defspecx set! (proc arg @dots{}) expression
[R5RS][SRFI-17] First, @var{expression} is evaluated.
In the first form, the binding of @var{symbol} is modified
so that next reference of @var{symbol} will return
the result of @var{expression}.
If @var{symbol} is not locally bound, the global variable named @var{symbol}
must already exist, or an error is signalled.

The second form is equivalent to
@example
((setter @var{proc}) @var{arg} @dots{} @var{expression})
@end example
@end defspec

@defun setter proc
[SRFI-17]
@end defun

@defun getter-with-setter get set
[SRFI-17]
@end defun


@c ----------------------------------------------------------------------
@node Conditionals
@section Conditionals


@defspec if test consequent alternate
@defspecx if test consequent
[R5RS] @var{Test} is evaluated.  If it yields a true value,
@var{consequent} is evaluated.  Otherwise, @var{alternative} is
evaluated.  If @var{alternative} is not provided, it results undefined value.
@end defspec


@defspec cond clause1 clause2 @dots{}
[R5RS]
@end defspec


@defspec case key clause1 clause2 @dots{}
[R5RS]
@end defspec


@defspec and test @dots{}
[R5RS] 
@end defspec


@defspec or test @dots{}
[R5RS]
@end defspec

@defspec when test body @dots{}
@defspecx unless test body @dots{}
Evaluates @var{test}.  If it yields true value (or false in case of
@code{unless}), @var{body} @dots{} are evaluated sequentially, and
the result of the last evaluation is returned.  Otherwise, undefined
value is returned.
@end defspec

@node Binding constructs
@section Binding constructs

@defspec let bindings body
[R5RS]
@end defspec

@defspec let* bindings body
[R5RS]
@end defspec

@defspec letrec bindings body
[R5RS]
@end defspec


@defspec receive formals expression body
[SRFI-8]
@end defspec

@node Sequencing
@section Sequencing


@defspec begin
[R5RS]
@end defspec


@node Iteration
@section Iteration

@defspec do ((variable init step) @dots{}) (test expr @dots{}) body
[R5RS]
@end defspec


@defspec let name bindings body
[R5RS]
@end defspec


@c ----------------------------------------------------------------------
@node Quasiquotation
@section Quasiquotation

@defspec quasiquote template
[R5RS]
@end defspec


@c ----------------------------------------------------------------------
@node Definitions
@section Definitions

@defspec define variable expression
@defspecx define (variable formals) body
[R5RS]
@end defspec

@c ----------------------------------------------------------------------
@node Modules
@section Modules

Module is an object that maps symbols onto @emph{bindings}.

Unlike CommonLisp's packages, which map names to symbols,
in Gauche symbols are always @code{eq?} if two have the
same name.  However, different bindings can be associated
to the same symbol, that yield different values.




@node Module syntax
@subsection Module syntax

@defspec define-module name body @dots{}
If a module named @var{name} does not exist, create one.
Then compiles and evaluates @var{body} sequentially in the module.
@end defspec

@defspec select-module name
Makes a module named @var{name} as the current module.
It is an error if no module named @var{name} exists.

If @code{select-module} is used in the Scheme file, its effect is
limited inside the file, i.e. even if you load/require a file that uses
@code{select-module} internallly, the current module of requirer is
not affected.
@end defspec

@defspec with-module name body @dots{}
Compiles and evaluates @var{body} sequentially in the module
named @var{name}.  If no moudle named @var{name}, an error is signalled.
@end defspec

@defspec export symbol @dots{}
Makes bindings of @var{symbol}s in the current module available
to modules that imports the current module.
@end defspec

@defspec export-all
Makes all bindings in the current module available to modules
that imports it.
@end defspec

@defspec import module-name @dots{}
Makes all exported bindings in the module named @var{module-name}
available in the current module.   The named modules should exist
when the compiler sees this special form.
@end defspec

@defspec current-module
Evaluates to the current module in the compile context.
Note that this is a special form, not a function.
Module in Gauche is statically determined at compile time.
@lisp
(define-module foo
  (export get-current-module)
  (define (get-current-module) (module-name (current-module))))

(define-module bar
  (import foo)
  (get-current-module)) @result{} foo @r{; not bar}
@end lisp
@end defspec

@defmac use name
A convenience macro that combines module imports and on-demand
file loading.  Basically, @code{(use foo)} is equivalent
to the following two forms:
@example
(require "foo")
(import foo)
@end example
That is, it loads the library file named ``@code{foo}'' which
defines a module named @code{foo} init, and then import the module
@code{foo} into the current module.

Although the files and modules are orthogonal concept,
it is practically convenient to separate files by modules.
Gauche doesn't force you to do so, and you can always use
@code{require} and @code{import} separately.  However, all
modules provided with Gauche are arranged so that they can be
used by @code{use} macro.

If a module is too big to fit in one file, you can split them
into several subfiles and one main file.  The main file defines
the module, and either loads, requires, or autoloads subfiles.

If @var{name} contains periods `@code{.}', it is replaced to `@code{/}'
in the file name.to be @code{require}d, for example,
@code{(use foo.bar.baz)} is expanded to:
@example
(require "foo/bar/baz")
(import foo.bar.baz)
@end example
This is not very Scheme-ish way, but nevertheless practical.
(The alternative design is to use a list of symbols to represent
hierarchical file/module configuration, as in Guile.)
@end defmac

@node Module introspection
@subsection Module introspection

@deftp {Builtin Class} <module>
@clindex module
A module class.
@end deftp

@defun module? obj
Returns true if @var{obj} is a module.
@end defun

@defun find-module name
Returns a module object whose name is a symbol @var{name}.
If the named module doesn't exist, @code{#f} is returned.
@end defun

@defun all-modules
Returns a list of modules currently known to the system.
@end defun

@defun module-name module
@defunx module-imports module
@defunx module-exports module
@defunx module-table module
Accessors of a module object.  Returns the name of the module (a symbol),
list of imported modules, list of exported symbols, and a hash table
that maps symbols to bindings, of the @var{module} are returned,
respectively.

If the @var{module} exports all symbols, @code{module-exports} returns
@code{#t}.

It is an error to pass non-module object.
@end defun

@node Predefined modules
@subsection Predefined modules

Several modules are predefined in Gauche.

@deftp {Builtin Module} null
@mdindex null
This module corresponds to the null environment referred in R5RS.
This module contains only syntactic bindings of built-in Gauche
special forms.
@end deftp

@deftp {Builtin Module} scheme
@mdindex scheme
This module contains all the binding of @code{null} module,
and the binding of procedures defined in R5RS.
@end deftp

@deftp {Builtin Module} gauche
@mdindex gauche
This module contains all the bindings of @code{scheme} module,
plus Gauche specific built-in procedures.
@end deftp

@deftp {Builtin Module} user
@mdindex user
This module is the default module the user code is compiled.
all the bindings of @code{gauche} module is imported.
@end deftp

@c ======================================================================
@node Macros
@chapter Macros

Gauche supports both R5RS hygienic macros and
traditional macros.

@node Hygienic Macros
@section Hygienic Macros

@defspec define-syntax name transformer-spec
[R5RS]
@end defspec

@defspec let-syntax ((name transformer-spec) @dots{}) body
@defspecx letrec-syntax ((name transformer-spec) @dots{}) body
[R5RS]
@end defspec

@defspec syntax-rules literals clause1 clause2 @dots{}
[R5RS]
@end defspec


@node Traditional Macros
@section Traditional Macros

@defspec define-macro (name formals) body @dots{}

@end defspec

@node Macro Expansion
@section Macro Expansion

@defspec %macro-expand form
@defspecx %macro-expand1 form
@end defspec


@c ======================================================================
@node Core library
@chapter Core library

@c ----------------------------------------------------------------------
@node Equivalence
@section Equivalence

@defun eq? obj1 obj2
[R5RS]
@end defun

@defun eqv? obj1 obj2
[R5RS]
@end defun

@defun equal? obj1 obj2
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Numbers
@section Numbers

@node Number classes
@subsection Number classes

@deftp {Builtin Class} <number>
@deftpx {Builtin Class} <complex>
@deftpx {Builtin Class} <real>
@deftpx {Builtin Class} <integer>
@clindex number
@clindex complex
@clindex real
@clindex integer
These classes consist a hierarchy of representation of numbers.
Note that these classes does not exactly corresponds to the
number hierarchy defined in R5RS.  Especially, 
only exact integers are the instances of the @code{<integer>}
class.  That is,
@lisp
(integer? 1) @result{} #t
(is-a? 1 <integer>) @result{} #t

(integer? 1.0) @result{} #t
(is-a? 1.0 <integer>) @result{} #f
@end lisp
@end deftp

@node Numerical predicates
@subsection Numerical predicates

@defun number? obj
@defunx complex? obj
@defunx real? obj
@defunx rational? obj
@defunx integer? obj
[R5RS]
@end defun

@defun exact? obj
@defunx inexact? obj
[R5RS]
@end defun

@defun zero? z
[R5RS]
@end defun

@defun positive? x
@defunx negative? x
[R5RS]
@end defun

@defun odd? n
@defunx even? n
[R5RS]
@end defun

@node Numerical comparison
@subsection Numerical comparison

@defun @code{=} z1 z2 z3 @dots{}
@defunx @code{<} x1 x2 x3 @dots{}
@defunx @code{<=} x1 x2 x3 @dots{}
@defunx @code{>} x1 x2 x3 @dots{}
@defunx @code{>=} x1 x2 x3 @dots{}
[R5RS]
@end defun


@defun max x1 x2 @dots{}
@defunx min x1 x2 @dots{}
[R5RS]
@end defun

@node Arithmetics
@subsection Arithmetics

@defun @code{+} z @dots{}
@defunx @code{*} z @dots{}
[R5RS]
@end defun


@defun @code{-} z1 z2 @dots{}
@defunx @code{/} z1 z2 @dots{}
[R5RS]
@end defun

@defun abs z @dots{}
[R5RS+]
@end defun

@defun quotient n1 n2
@defunx remainder n1 n2
@defunx modulo n1 n2
[R5RS]
@end defun

@defun gcd n @dots{}
@defunx lcm n @dots{}
[R5RS]
@end defun

@defun numerator q
@defunx denominator q
[R5RS]
@end defun


@defun floor x
@defunx ceiling x
@defunx truncate x
@defunx round x
[R5RS]
@end defun


@defun exp z
@defunx log z
@defunx sin z
@defunx cos z
@defunx tan z
@defunx asin z
@defunx acos z
@defunx atan z
@defunx atan x y
[R5RS]
@end defun


@defun sinh z
@defunx cosh z
@defunx tanh z
@defunx asinh z
@defunx acosh z
@defunx atanh z
Hyperbolic trigonometric functions.
@end defun

@defun sqrt z
[R5RS]
@end defun

@defun expt z1 z2
[R5RS]
@end defun

@node Numericaln conversions
@subsection Numerical conversions

@defun make-rectangular x1 x2
@defunx make-polar x1 x2
@defunx real-part z
@defunx imag-part z
@defunx magnitude z
@defunx angle z
[R5RS]
@end defun

@defun exact->inexact z
@defunx inexact->exact z
[R5RS]
@end defun

@defun number->string z [radix]
@defunx string->number string [radix]
[R5RS]
@end defun

@node Logical operations
@subsection Logical operations

@defun ash n count
Shifts integer @var{n} left with @var{count} bits.
If @var{count} is negative, @code{ash} shifts @var{n} right with
@minus{}@var{count} bits.
Negative @var{n} is interpreted as 2's complement numbers
with 1's continue infinitely on the left side of the number.
@end defun
        
@defun logand n1 n2
@defunx logior n1 n2
@defunx logxor n1 n2
Returns bitwise and, bitwise inclusive or and bitwise exclusive or
of two integers @var{n1} and @var{n2}.
@end defun

@defun lognot n
Returns bitwise not of an integer @var{n}.
@end defun

@node Booleans
@section Booleans

@deftp {Builtin Class} <boolean>
@clindex boolean
A boolean class.  Only @code{#t} and @var{#f} belong to this class.
@end deftp

@defun not obj
[R5RS] Returns @code{#t} if and only if @var{obj} is @code{#t},
and returns @code{#f} otherwise.
@end defun

@defun boolean? obj
[R5RS] Returns @code{#t} if and only if @var{obj} is a boolean
value, and returns @code{#f} otherwise.
@end defun

@c ----------------------------------------------------------------------
@node Pairs and Lists
@section Pairs and Lists

@node Pair and null class
@subsection Pair and null class

@deftp {Builtin Class} <list>
@clindex list
An abstract class respresents lists.   A parent class of @code{<null>}
and @code{<pair>}.

Note that a cirular list is also an instance of the @code{<list>} class,
while R5RS procedure @code{list?} returns false on the circular lists.
@lisp
(use srfi-1)
(list? (circular-list 1 2)) @result{} #f
(is-a? (circular-list 1 2) <list>) @result{} #t
@end lisp
@end deftp

@deftp {Builtin Class} <null>
@clindex null
A class of empty list.  @code{()} is the only instance.
@end deftp

@deftp {Builtin Class} <pair>
@clindex pair
A class of pairs.
@end deftp

@node List predicates
@subsection List predicates

@defun pair? obj
[R5RS]
@end defun

@defun null? obj
[R5RS]
@end defun

@defun list? obj
[R5RS]
@end defun

@node List constructors
@subsection List constructors

@defun cons obj1 obj2
[R5RS] Constructs a pair of @var{obj1} and @var{obj2} and returns it.
@lisp
(cons 'a 'b) @result{} (a . b)
@end lisp
@end defun

@defun acons obj1 obj2 obj3
Returns @code{(cons (cons @var{obj1} @var{obj2}) @var{obj3})}.
Useful to put an entry at the head of an associative list.
@lisp
(acons 'a 'b '((c . d))) @result{} ((a . b) (c . d))
@end lisp
@end defun

@defun make-list len &optional fill
[SRFI-1] Makes a proper list of length @var{len}.  If optional argument
@var{fill} is provided, each element is initialized by it.  Otherwise
each element is undefined.
@lisp
(make-list 5 #t) @result{} (#t #t #t #t #t)
@end lisp
@end defun

@defun list obj @dots{}
[R5RS] Makes a list, whose elements are @var{obj} @dots{}.
@lisp
(list 1 2 3) @result{} (1 2 3)
(list) @result{} ()
@end lisp
@end defun

@defun list* obj1 obj2 @dots{}
Like @code{list}, but the last argument becomes cdr of the last pair.
SRFI-1 defines the same function with the name @var{cons*}.
@lisp
(list* 1 2 3) @result{} (1 2 . 3)
(list* 1) @result{} 1
@end lisp
@end defun

@defun list-copy list
[SRFI-1] Shallow copies @var{list}.  If @var{list} is circular,
this function diverges.
@end defun


@node List accessors and modifiers
@subsection List accessors and modifiers

@defun car pair
@defunx cdr pair
[R5RS] Returns car and cdr of @var{pair}, respectively.
@end defun

@defun set-car! pair obj
@defunx set-cdr! pair obj
[R5RS] Modifies car and cdr of @var{pair}, by @var{obj}, respectively.
@end defun

@defun caar pair
@defunx cadr pair
@defunx cdar pair
@defunx cddr pair
@defunx caaar pair
@defunx caadr pair
@defunx cadar pair
@defunx caddr pair
@defunx cdaar pair
@defunx cdadr pair
@defunx cddar pair
@defunx cdddr pair
@defunx caaaar pair
@defunx caaadr pair
@defunx caadar pair
@defunx caaddr pair
@defunx cadaar pair
@defunx cadadr pair
@defunx caddar pair
@defunx cadddr pair
@defunx cdaaar pair
@defunx cdaadr pair
@defunx cdadar pair
@defunx cdaddr pair
@defunx cddaar pair
@defunx cddadr pair
@defunx cdddar pair
@defunx cddddr pair
[R5RS]
@end defun

@defun length list
[R5RS]
@end defun

@defun list-tail list k
[R5RS]
@end defun

@defun list-ref list k
[R5RS]
@end defun

@defun last-pair list
[SRFI-1]
@end defun


@node Other list procedures
@subsection Other list procedures

@defun append list @dots{}
[R5RS]
@end defun

@defun append! list @dots{}
[SRFI-1]
@end defun


@defun reverse list
[R5RS]
@end defun

@defun reverse! list
[SRFI-1]
@end defun


@defun memq obj list
@defunx memv obj list
[R5RS]
@end defun

@defun member obj list [=]
[R5RS+][SRFI-1]
@end defun

@defun assq obj list
@defunx assv obj list
[R5RS]
@end defun

@defun assoc obj list [=]
[R5RS+][SRFI-1]
@end defun


@c ----------------------------------------------------------------------
@node Symbols
@section Symbols

@deftp {Builtin Class} <symbol>
@clindex symbol
A builting class for symbols.
@end  deftp

@defun symbol? obj
[R5RS] Returns true if and only if @var{obj} is a symbol.
In Gauche, all symbols are @emph{interned}, i.e. two symbols with
the same print name are always @code{eq?}.
@end defun

@defun symbol->string symbol
[R5RS] Returns the name of @var{symbol} in a string.  Returned
string is immutable.
@end defun

@defun string->symbol string
[R5RS] Returns a symbol whose name is @var{string}.
If the named symbol hasn't existed, this function creates one.
@end defun

@defun gensym &optional prefix
@end defun

@c ----------------------------------------------------------------------
@node Keywords
@section Keywords

@deftp {Builtin Class} <keyword>
@clindex keyword
@end  deftp

@defun keyword? obj
@end defun

@defun make-keyword name
@end defun

@defun get-keyword key list [fallback]
@end defun

@c ----------------------------------------------------------------------
@node Identifiers
@section Identifiers

@deftp {Builtin Class} <identifier>
@clindex identifier
@end  deftp

@defun identifier? obj
@end defun

@defun identifier->symbol identiifer
@end defun


@c ----------------------------------------------------------------------
@node Characters
@section Characters

@deftp {Builtin Class} <char>
@clindex char
@end  deftp

@deftp {Reader Syntax} @code{#\@i{charname}}
Denotes a literal character.

When the reader reads @code{#\}, it fetches a sbusequent character.
If it is one of @code{()[]@{@}" \|;#}, this is a character literal of itself.
Otherwise, the reader reads subsequent characters until it sees
a non word-constituent character.  If only one character is read,
it is the character.  Otherwise, the reader matches the read characters
with predefined character names.  If it doesn't match any, an error
is signalled.
@end deftp

@defun char? obj
[R5RS]
@end defun

@defun char@code{=}? char1 char2
@defunx char@code{<}? char1 char2
@defunx char@code{<=}? char1 char2
@defunx char@code{>}? char1 char2
@defunx char@code{>=}? char1 char2
[R5RS]
@end defun

@defun char-ci@code{=}? char1 char2
@defunx char-ci@code{<}? char1 char2
@defunx char-ci@code{<=}? char1 char2
@defunx char-ci@code{>}? char1 char2
@defunx char-ci@code{>=}? char1 char2
[R5RS]
@end defun

@defun char-alphabetic? char
@defunx char-numeric? char
@defunx char-whitespace? char
@defunx char-upper-case? char
@defunx char-lower-case? char
[R5RS]
@end defun

@defun char->integer char
@defunx integer->char n
[R5RS]
@end defun

@defun char-upcase char
@defunx char-downcase char
[R5RS]
@end defun

@defun gauche-character-encoding
@end defun


@c ----------------------------------------------------------------------
@node Character Set
@section Character Set

@deftp {Builtin Class} <char-set>
@clindex char-set
Character set class.  Character set object represents a set of characters.
Gauche provides built-in support of character set creation and
a predicate that tests whether a character is in the set or not.

Further operations, such as set algebra, is defined in SRFI-14
module (See @ref{Character-set library}).
@end deftp

@deftp {Reader Syntax} @code{#[@i{char-set-spec}]}
@end deftp

@defun char-set? obj
[SRFI-14] Returns true if and only if @var{obj} is a character set object.
@end defun

@defun char-set-contains? char-set char
[SRFI-14] Returns true if and only if a character set object
@var{char-set} contains a character @var{char}.
@end defun

@defun char-set char @dots{}
[SRFI-14] Creates a character set that contains @var{char} @dots{}.
@end defun

@defun char-set-copy char-set
[SRFI-14] Copies a character set @var{char-set}.
@end defun


@c ----------------------------------------------------------------------
@node Strings
@section Strings

@deftp {Builtin Class} <string>
@clindex string
A string class.   In Gauche, a string can be viewed in two ways:
a sequence of characters, or a sequence of bytes.
@end deftp

@node String Predicates
@subsection String Predicates

@defun string? obj
[R5RS] Returns if and only if @var{obj} is a string.
@end defun

@defun string-immutable? obj
Returns true if and only if @var{obj} is an immutable string.
@end defun

@defun string-incomplete? obj
@end defun

@node String Constructors
@subsection String Constructors

@defun make-string k &optional char
[R5RS] Returns a string of length @var{k}.  If optional @var{char} is given,
the new string is filled with it.  Otherwise, the string is filled with
a whitespace.  The result string is always complete.

Note that the algorithm to allocate a string by @code{make-string} and
then fills it one character at a time is @emph{extremely} inefficient
in Gauche, and should be avoided.   You can use an output string port
for a string construction.   Even creating a list of characters and
using @code{list->string} is faster than using @code{make-string} and
@code{string-set!}.
@end defun

@defun string char @dots{}
[R5RS] Returns a string consisted by @var{char} @dots{}.
@end defun

@node String Accessors & Modifiers
@subsection String Accessors & Modifiers

@defun string-length string
[R5RS] Returns a length of (possibly incomplete) string @var{string}.
@end defun

@defun string-size string
Returns a size of (possibly incomplete) @var{string}.
A size of string is a number of bytes @var{string} occupies on memory.
The same string may have different sizes if the native encoding scheme
differs.

For incomplete string, its length and its size always match.
@end defun

@defun string-ref cstring k
[R5RS] Returns @var{k}-th character of a complete string @var{cstring}.
@var{k} must be greater than or equal to zero, and less than
@code{(string-length @var{cstring})}.

It is an error to pass an incomplete string.
@end defun

@defun string-byte-ref string k
Returns @var{k-th} byte of a (possibly incomplete) string @var{string}.
Returned value is an integer in the range between 0 and 255.
@var{k} must be greater than or equal to zero, and less than
@code{(string-size @var{string})}.
@end defun

@defun string-set! string k char
[R5RS]
@end defun

@defun string-byte-set! string k byte
@end defun

@node String Comparison
@subsection String Comparison

@defun string=? string1 string2
@defunx string-ci=? string1 string2
[R5RS]
@end defun

@defun string@code{<}? string1 string2
@defunx string@code{<=}? string1 string2
@defunx string@code{>}? string1 string2
@defunx string@code{>=}? string1 string2
@defunx string-ci@code{<}? string1 string2
@defunx string-ci@code{<=}? string1 string2
@defunx string-ci@code{>}? string1 string2
@defunx string-ci@code{>=}? string1 string2
[R5RS]
@end defun

@node String Utilities
@subsection String Utilities

@defun substring string start end
[R5RS]
@end defun

@defun string-append string @dots{}
[R5RS]
@end defun

@defun string->list string &optional start end
@defunx list->string list
[R5RS+][SRFI-13]
@end defun

@defun string-copy string &optional start end
[R5RS+][SRFI-13]
@end defun

@defun string-fill! string char &optional start end
[R5RS+][SRFI-13]
@end defun

@defun string-join strs &optional delim grammer
[SRFI-13]
@end defun

@defun string-split s char
@end defun


@node String Pointers
@subsection String Pointers

@deftp {Builtin Class} <string-pointer>
@clindex string-pointer
String pointer is an object to access string efficiently in sequential
order (either forward or backward).

Higher level string iterators and accessors are constructed on top of 
this primitive.  @xref{String library}, for details.
It is highly recommended to use SRFI-13 functions instead of these
string pointer objects, for portability.
@end deftp

@defun make-string-pointer str &optional index
@end defun

@defun string-pointer? obj
@end defun

@defun string-pointer-next! sp
@defunx string-pointer-prev! sp
@end defun

@defun string-pointer-set! sp index
@end defun

@defun string-pointer-substring sp &keyword (after #f)
@end defun

@defun string-pointer-index sp
@end defun

@node Incomplete strings
@subsection Incomplete strings

@defun string-complete->incomplete str
@end defun

@defun string-incomplete->complete str
@end defun

@c ----------------------------------------------------------------------
@node Regular Expression
@section Regular Expression

@deftp {Builtin Class} <regexp>
@clindex regexp
@end deftp

@deftp {Builtin Class} <regmatch>
@clindex regmatch
@end deftp

@deftp {Reader Syntax} @code{#/@i{regexp-spec}/}
@end deftp

@defun string->regexp string
@end defun

@defun rxmatch regexp string
@var{Regexp} is a regular expression object.
A string @var{string} is matched by
@var{regexp}.  If it matches, the function returns a @code{<regmatch>}
object.  Otherwise it returns @code{#f}.

This corresponds to scsh's @code{regexp-search}.
@end defun

@defun rxmatch-substring match &optional (i 0)
@defunx rxmatch-start match &optional (i 0)
@defunx rxmatch-end match &optional (i 0)
@var{Match} is a match object returned by @code{rxmatch}.
If @var{i} equals to zero, the functions return
start, end or the substring of entire match, respectively.
With positive integer @var{I}, it returns those of @var{I}-th
submatches.  It is an error to pass other values to @var{I}.

It is allowed to pass @code{#f} to @var{match} for convenience.
The functions return @code{#f} in such case.

These functions correspond to scsh's @code{match:start}, @code{match:end}
and @code{match:substring}.
@end defun

Seel also @ref{Regular expression utilities}, which defines
useful macros to deal with regular expression matching.

@c ----------------------------------------------------------------------
@node Vectors
@section Vectors

@deftp {Builtin Class} <vector>
@clindex vector
@end deftp

@defun vector? obj
[R5RS]
@end defun

@defun make-vector k &optional fill
[R5RS]
@end defun

@defun vector obj @dots{}
[R5RS]
@end defun

@defun vector-length vector
[R5RS]
@end defun

@defun vector-ref vector k
[R5RS]
@end defun

@defun vector-set! vector k obj
[R5RS]
@end defun

@defun vector->list vector
@defunx list->vector list
[R5RS]
@end defun

@defun vector-fill! vector fill
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Hashtables
@section Hashtables

@deftp {Builtin Class} <hash-table>
@clindex hash-table
@end deftp

@defun make-hash-table args
@end defun

@defun hash-table?
@end defun

@defun hash-table-get hash key &optional default
@end defun

@defun hash-table-put! hash key value
@end defun

@defun hash-table-exists? hash key
@end defun

@defun hash-table-for-each hash proc
@end defun

@defun hash-table-keys hash
@defunx hash-table-values hash
@end defun

@defun hash-table-stat hash
@end defun


@c ----------------------------------------------------------------------
@node Control features
@section Control features

@node Procedures
@subsection Procedures

@deftp {Builtin Class} <procedure>
@clindex procedure
@end deftp

@defun procedure? obj
[R5RS]
@end defun

@defun apply proc arg1 @dots{} args
[R5RS]
@end defun

@defun map proc list1 list2 @dots{}
[R5RS]
@end defun

@defun for-each proc list1 list2 @dots{}
[R5RS]
@end defun

@node Continuation and escaping
@subsection Continuation and escaping


@defun call-with-current-continuation proc
@defunx call/cc
[R5RS]
@end defun

@defun dynamic-wind before thunk after
[R5RS]
@end defun

@node Multiple values
@subsection Multiple values

@defun values obj @dots{}
[R5RS]
@end defun

@defun call-with-values producer consumer
[R5RS]
@end defun


@node Delayed Evaludation
@subsection  Delayed Evaludation

@defspec delay expression
[R5RS]
@end defspec

@defun force promise
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Eval
@section Eval

@defun eval expr env
[R5RS]
@end defun

@defun null-environment
@defunx interaction-environment
@defunx scheme-report-environment version
[R5RS]
@end defun

@c ----------------------------------------------------------------------
@node Input and Output
@section Input and Output

@node Ports
@subsection Ports

@deftp {Builtin Class} <port>
@clindex port
A port class.   A port is Scheme's way of abstraction of I/O channel.
Gauche extends a port in number of ways so that it can be used
in wide range of applications.

Standard Scheme (R5RS) essentially defines a port as an entity that
you can fetch a character at a time and
look one character ahead from an input port, 
and put a character at a time to an output port.
Other R5RS I/O routines can be built on top of them.

Besides this basics, Gauche's port can handle the following
opertaions.

@table @asis
@item Byte I/O
You can read/write one byte at a time, instead of a character.
Some ports allow you to mix byte I/O and character I/O;
you can set the policy of handling such cases.

@item Block I/O
You can read/write a specified number of byte sequences.
This can be an efficient way of moving block of data,
if the port's underlying implementation supports block I/O
operation (for example, if the underyling port is a unix buffered
stream, this operation uses @code{fread} or @code{fwrite}).

@item Conversion
Some ports can be used to convert a data stream from one format
to another; one of such applications is character code conversion
ports, provided by @code{gauche.charconv} module
(@xref{Character code conversion}, for details).
You can define a procedural ports, in both Scheme and C, 
to implement other functionality.
@end table

@end deftp

@defun input-port? obj
@defunx output-port? obj
[R5RS] Returns true if @var{obj} is an input port and an output port,
respectively.
@end defun

@defun port-closed? port
Returns true if @var{obj} is a port and it is already closed.
A closed port can't be reopened.
@end defun

@defun current-input-port
@defunx current-output-port
[R5RS] Returns the current input port and the current output port, 
respectively.
@end defun

@defun current-error-port
Returns the current output port.
@end defun

@defun with-input-from-port port thunk
@defunx with-output-to-port port thunk
@defunx with-error-to-port port thunk
@end defun

@defun close-input-port port
@defunx close-output-port port
[R5RS]
@end defun

@defun port-name port
@end defun

@defun port-current-line
@end defun

@defun port-file-number
@end defun

@defun copy-port src dst &keyword unit
Copies data from an input port @var{src} to an output port @var{dst},
until eof is read from @var{src}.


@end defun


@node File ports
@subsection File ports

@defun open-input-file filename
[R5RS]
@end defun

@defun open-output-file filename
[R5RS]
@end defun

@defun call-with-input-file string proc
@defunx call-with-output-file string proc
[R5RS]
@end defun

@defun with-input-from-file string thunk
@defunx with-output-to-file string thunk
[R5RS]
@end defun


@node String ports
@subsection String ports

@defun open-input-string string
[SRFI-6]
@end defun

@defun open-output-string
[SRFI-6]
@end defun

@defun get-output-string
[SRFI-6]
@end defun

@defun call-with-input-string string proc
@end defun

@defun call-with-output-string proc
@end defun

@defun with-input-from-string string thunk
@end defun

@defun with-output-to-string thunk
@end defun


@node Procedural ports
@subsection Procedural ports

@node Input
@subsection Input 

@defun read &optional iport
[R5RS]
@end defun

@defun read-char &optional iport
[R5RS]
@end defun

@defun peek-char &optional iport
[R5RS]
@end defun

@defun read-byte &optional iport
Reads one byte from an input port @var{iport}, and returns an integer
in the range between 0 and 255.
If @var{iport} has already reached EOF, an eof object is returned.
@end defun

@defun read-line &optional iport
Reads one line (a sequence of bytes terminated by a newline character or EOF)
and returns a string.  The terminating newline is not included.
If @var{iport} has already reached EOF, an eof object is returned.
@end defun

@defun read-block nbytes &optional iport
Reads @var{nbytes} bytes from @var{iport}, and returns an incomplete
string consisted by those bytes.  The size of returned string may
shorter than @var{nbytes} when @var{iport} doesn't have enough bytes
to fill.  If @var{iport} has already reached EOF, an eof object is returned.

Note: if you want to write a chunk of bytes (incomplete string) to a port,
use @code{display}.
@end defun

@defun eof-object? obj
[R5RS] Returns true if @var{obj} is an EOF object.
@end defun

@defun char-ready? port
[R5RS]
@end defun


@node Output
@subsection Output

@defun write obj &optional port
[R5RS]
@end defun

@defun display obj &optional port
[R5RS]
@end defun

@defun newline &optional port
[R5RS]
@end defun

@defun write-char char &optional port
[R5RS]
@end defun

@defun write-byte byte &optional port
@end defun

@defun write* obj &optional port
@end defun

@defun format port string arg @dots{}
@end defun


@c ----------------------------------------------------------------------
@node Loading Programs
@section Loading Programs

@defun load file &keyword (error-if-not-found #t)
[R5RS+]
@end defun

@defun load-from-port port
@end defun

@defun dynamic-load file &keyword init-function
@end defun

@defspec add-load-path path &optional (afterp #f)
@end defspec

@defspec require feature
@end defspec

@defun provide feature
@end defun

@defun provided? feature
@end defun

@defmac autoload file symbol @dots{}
@end defmac


@c ----------------------------------------------------------------------
@node System interface
@section System interface

Gauche supports most of POSIX.1 functions and other system functions
popular among Unix variants as built-in procedures.

The procedures with name @code{sys-}@var{name} usually correspond to the
system call @var{name}.  I tried to keep the interface similar
whenever reasonable.  Sometimes Gauche has other routines that
are higher level than system calls, nevertheless I try to
provide lower level routines as well.

@node Program termination
@subsection Program termination

@defun exit &optional code
[POSIX]
@end defun

@node Environment Inquiry
@subsection Environment Inquiry

@defun sys-getenv name
[POSIX]
Returns the value of the environment variable @var{name} as a string,
or @code{#f} if the environment variable is not defined.
@end defun

@defun gauche-version
@defunx gauche-architecture
@defunx gauche-library-directory
@defunx gauche-architecture-directory
@defunx gauche-site-library-directory
@defunx gauche-site-architecture-directory
These functions returns a string that tells information about Gauche
interpreter itself.
@end defun

@node Filesystems
@subsection Filesystems

@node Directories
@subsubsection Directories

@defun sys-readdir path
@var{path} must be a string that denotes valid pathname of an existing
directory.  This function returns a list of strings of the directory
entries.  The returned list is not sorted.  An error is signalled
if @var{path} doesn't exists or is not a directory.
@end defun

@defun sys-glob pattern
An interface to @code{glob(3)} function.  @var{pattern} is a file pattern
like sh(1): a character `@code{?}' matches any single character, 
`@code{*}' matches zero or more characters, `@code{[abc]}' matches
either `@code{a}', `@code{b}' or `@code{c}'.  If no pathname matches
@var{pattern}, an empty list is returned.

If the undelying platform doesn't have @code{glob()}, this function
signals an error of "feature not supported".
@end defun

@node Directory manipulation
@subsubsection Directory manipulation

@defun sys-remove filenmae
[POSIX]
Remove @var{filename}.
@end defun

@defun sys-rename old new
[POSIX]
@end defun

@defun sys-tmpnam
[POSIX]
@end defun

@defun sys-link existing new
[POSIX]
@end defun

@defun sys-rmdir pathname
[POSIX]
@end defun

@defun sys-unlink pathname
[POSIX]
@end defun

@defun sys-symlink existing new
@end defun

@node Pathnames
@subsubsection Pathnames

@defun sys-normalize-pathname pathname &keyword absolute expand canonicalize
Converts @var{pathname} according to the way specified by keyword arguments.
@table @code
@item absolute
  If this keyword arugment is given and true, and @var{pathname} is not
  an absolute pathname, it is converted to an absolute pathname by
  appending the current working directory in front of @var{pathname}.
@item expand
  If this keyword argument is given and true, and @var{pathname} begins
  with `@code{~}', it is expanded as follows:
@itemize @bullet
@item
    If @var{pathname} is consisted entirely by ``@code{~}'', or begins
    with ``@code{~/}'', then the character ``@code{~}'' is replaced
    for the pathname of the current user's home directory.
@item
    Otherwise, characters following `@code{~}' until either `@code{/}' or
    the end of @var{pathname} are taken as a user name, and the user's
    home directory is replaced in place of it.  If there's no such
    user, an error is signalled.
@end itemize
@item canonicalize
  Tries to remove pathname components ``@code{.}'' and ``@code{..}''.
  The pathname interpretation is done purely in textural level, i.e.
  it doesn't access filesystem to see the conversion reflects the
  real files.  It may be a problem if there's a symbolic links to
  other directory in the path.
@end table
@end defun

@defun sys-basename pathname
@defunx sys-dirname pathname
@code{sys-basename} returns a basename, that is the last component of
@var{pathname}.  @code{sys-dirname} returns the components of @var{pathname}
but the last one.   If @var{pathname} has a trailing `@code{/}', 
it is simply ignored.
@example
(sys-basename "foo/bar/bar.z") @result{} "bar.z"
(sys-basename "coo.scm") @result{} "coo.scm"
(sys-dirname "foo/bar/bar.z") @result{} "foo/bar/"
(sys-dirname "coo.scm") @result{} "."
@end example
These functions doesn't check if @var{pathname} really exists.

Some boundary cases:
@example
(sys-basename "") @result{} ""
(sys-dirname "") @result{} "."

(sys-basename "/") @result{} ""
(sys-dirname "/") @result{} "/"
@end example
@end defun

@node File stats
@subsubsection File stats

@deftp {Builtin Class} <sys-stat>
@clindex sys-stat
An object that represents @code{struct stat}.
@end deftp

@defun sys-stat path
[POSIX]
@end defun

@defun sys-lstat path
@end defun

@defun sys-fstat fd
[POSIX]
@end defun

@defun sys-stat->mode stat
@defunx sys-stat->ino stat
@defunx sys-stat->dev stat
@defunx sys-stat->rdev stat
@defunx sys-stat->nlink stat
@defunx sys-stat->uid stat
@defunx sys-stat->gid stat
@defunx sys-stat->atime stat
@defunx sys-stat->mtime stat
@defunx sys-stat->ctime stat
Accessors of @code{<sys-stat>} objects.  @code{sys-stat->mode} through
@code{sys-stat->gid} returns an exact integer.  @code{sys-stat->atime}
to @code{sys-stat->ctime} returns a @code{<sys-time>} object.
@end defun

@defun sys-access pathname amode
[POSIX]
An interface to @code{access(2)}.
Returns a boolean value of indicating whether @var{pathname} is allowed
in @var{amode}.  @var{amode} can be a combinations (logical or) of
following predefined flags.
@table @code
@item r_ok
Checks whether @var{pathname} is readable by the current user.
@item w_ok
Checks whether @var{pathname} is writable by the current user.
@item x_ok
Checks whether @var{pathname} is executable (or searchable in case
@var{pathname} is a directory) by the current user.
@item f_ok
Checks whether @var{pathname} exists or not, regardless of
the access permissions of @var{pathname}.  (But you need to have
access permissions of the directories containing @var{pathname}).
@end table
An error is signalled if @var{pathname} does not exist, or the permissions
of directories containing @var{pathname} prevents you from cheking
@var{pathname} itself.
@end defun

@node Other file operations
@subsubsection Other file operations

@defun sys-chdir dir
[POSIX]
An interface to @code{chdir(2)}.  Change the process's current
working directory to @var{dir}.   An error is signalled if
@var{dir} doesn't exist, or you don't have enough permission to
access @var{dir}.
@end defun

@defun sys-pipe &keyword name buffered?
[POSIX]
@end defun

@defun sys-isatty port-or-fd
[POSIX]
@end defun

@defun sys-ttyname port-or-fd
[POSIX]
@end defun

@node Unix groups and passwords
@subsection Unix groups and passwords

@node Unix Group
@subsubsection Unix Group

@deftp {Builtin Class} <sys-group>
@clindex sys-group
@end deftp

@defun sys-getgrid gid
@defunx sys-getgrnam name
[POSIX]
@end defun

@defun sys-gid->group->name gid
@defunx sys-group-name->gid name
@end defun

@node Unix Password
@subsubsection Unix Password

@deftp {Builtin Class} <sys-passwd>
@clindex sys-passwd
@end deftp

@defun sys-getpwuid uid
@defunx sys-getpwnam name
[POSIX]
@end defun

@defun sys-uid->user-name uid
@defunx sys-user-name->uid
@end defun


@node Password encryption
@subsubsection Password encryption

@defun sys-crypt key salt
This is the interface to @code{crypt(3)}.   @var{Key} and @var{salt}
must be a string, and an encrypted string is returned.

On systems where @code{crypt(3)} is not available, call to this
function signals an error.
@end defun

@node Locale
@subsection Locale

@defun sys-setlocate category locale
[POSIX]
@end defun


@node Signal
@subsection Signal

@defvar SIGABRT
@defvarx SIGALRM
@defvarx SIGCHLD
@defvarx SIGCONT
@defvarx SIGFPE
@defvarx SIGHUP
@defvarx SIGILL
@defvarx SIGINT
@defvarx SIGKILL
@defvarx SIGPIPE
@defvarx SIGQUIT
@defvarx SIGSEGV
@defvarx SIGSTOP
@defvarx SIGTSTP
@defvarx SIGTTIN
@defvarx SIGTTOU
@defvarx SIGUSR1
@defvarx SIGUSR2

@end defvar

@defun sys-kill pid sig
[POSIX]
@end defun


@node System Inquiry
@subsection System Inquiry

@defun sys-uname
[POSIX]
@end defun

@defun sys-getcwd
[POSIX] Returns the current working directory by a string.
If the current working directory couldn't be obtained from the system,
an error is signalled.
@end defun

@defun sys-getgid
@defunx sys-getegid
[POSIX] Returns integer value of real and effective group id of the
current process, respectively.
@end defun

@defun sys-getuid
@defunx sys-geteuid
[POSIX] Returns integer value of real and effective user id of the
current process, respectively.
@end defun

@defun sys-getgroups
[POSIX] Returns a list of integer ids of supplementary groups.
@end defun

@defun sys-getlogin
[POSIX] Returns a string of the name of the user logged in on the
controlling terminal of the current process.
If the system can't determine the information, @code{#f} is returned.
@end defun

@defun sys-getpgrp
[POSIX]
@end defun

@defun sys-getpid
@defunx sys-getppid
[POSIX]
@end defun

@defun sys-times
[POSIX]
@end defun

@node Time
@subsection Time

@deftp {Builtin Class} <sys-tm>
@clindex sys-tm
Represents @code{struct tm}.
@end deftp

@defun sys-time
[POSIX] Returns the time since Epoch (00:00:00 UTC, January 1, 1970),
measured in seconds.  It may be a non-integral number, depending on
the architecture.

Note that POSIX's definition of ``seconds since the Epoch'' doesn't
take leap seconds into acount.
@end defun

@defun sys-gmtime time
[POSIX] @var{time} is a number of seconds since Epoch.
This function converts it to @code{<sys-tm>} object, represented in GMT.
@end defun

@defun sys-localtime time
[POSIX] @var{time} is a number of seconds since Epoch.
This function converts it to @code{<sys-tm>} object, represented in the
local time.
@end defun

@defun sys-ctime time
[POSIX]
@end defun

@defun sys-difftime time1 time0
[POSIX]
@end defun

@defun sys-asctime tm
[POSIX]
@end defun

@defun sys-strftime format tm
[POSIX]
@end defun

@defun sys-mktime tm
[POSIX]
@end defun

@defun sys-tm->alist tm
@end defun

@node Unix process management
@subsection Unix process management

@node Fork and exec
@subsubsection Fork and exec

@defun sys-system command
[POSIX]
Runs @var{command} in a subprocess.

This function returns an integer value @code{system()} returned.
Since POSIX doesn't define what @code{system()} returns, you can't
interpret the returned value in a portable way.
@end defun

@defun sys-fork
Fork the current process.  Returns 0 if you're in the child process,
and a child process' pid if you're in the parent process.
All the opened file descriptors are shared between the parent and
the child.
@end defun

@defun sys-exec command args &optional iomap
Execute @var{command} with @var{args}, a list of arguments.
The current process image is replaced by @var{command},
so this function never returns.

All elements of @var{args} must be strings.  The first element of
@var{args} is used as @code{argv[0]}, i.e. the program name.

The optional @var{iomap} argument, when provided, specifies how the
open file descriptors are treated.  It must be the following format:
@example
((@i{to-fd} . @i{from-port-or-fd}) @dots{})
@end example
@i{To-fd} must be an integer,
and @i{from-port-or-fd} must be an integer file descriptor or a port.
Each element of the list makes the file descriptor of @i{from-port-or-fd}
of the current process be mapped to the file descriptr @i{to-fd}
in the executed process.

If @var{iomap} is provided,
any file descriptors other than specified in the iomap list will be closed
before @code{exec()}.  Otherwise, all file descriptors in the current
process remain open.

@example
(sys-exec "ls" '("ls" "-l")) @result{} ;; ls is executed.

(sys-exec "ls" '("ls" "-l") '((1 . 2) (1 . 1)))
   @result{} ;; ls is executed, with its stderr and stdout are mapped to the
              current process's stdout.
@end example

When it encounters an error, most of the time it raises an error condition.
Once the file descriptors are permuted, however, it would be impractical
to handle errors in reasonable way (you don't even know stderr is still
available!), so Gauche simply exits on the error.
@end defun

See also @ref{High Level Process Interface}, which provides
more convenient process handling on top of above primitives.

@node Wait
@subsubsection Wait

@defun sys-wait
@end defun

@defun sys-waitpid pid &keyword nohang untraced
@end defun

@defun sys-wait-exited? status
@defunx sys-wait-exit-status status
@end defun

@defun sys-wait-signaled? status
@defunx sys-wait-termsig status
@end defun

@defun sys-wait-stopped? status
@defunx sys-wait-stopsig status
@end defun


@node Miscellaneous
@subsection Miscellaneous

@defun sys-pause
@end defun

@defun sys-sleep seconds
@end defun

@c ======================================================================
@node Object System
@chapter Object System

@c ----------------------------------------------------------------------
@node General Inquiry
@section  General Inquiry

@defun class-of obj
Returns a class metaobject of @var{obj}.
@end defun

@defun is-a? obj class
Returns true if @var{obj} is an instance of @var{class} or an instance
of descendants of @var{class}.
@end defun

@c ----------------------------------------------------------------------
@node Defining class
@section Defining class

@defmac define-class name supers (slot-spec @dots{}) option @dots{}
@end defmac


@c ----------------------------------------------------------------------
@node Defining methods
@section Defining methods

@defmac define-generic name
@end defmac

@defmac define-method name specs body
@end defmac

@c ----------------------------------------------------------------------
@node Creating Instance
@section Creating Instance

@deffn {Generic Function} make class arg @dots{}
@end deffn

@deffn {Method} make (class <class>) arg @dots{}
@end deffn

@deffn {Method} make (class <method>)  arg @dots{}
@deffnx {Method} make (class <generic>)  arg @dots{}
@end deffn

@deffn {Method} initialize (class <class>) initargs
@end deffn

@c ----------------------------------------------------------------------
@node Accessing Instance
@section Accessing Instance

@defun slot-ref obj slot
@end defun

@defun slot-set! obj slot
@end defun

@defun slot-bound? obj slot
@end defun

@defun slot-exists? slot
@end defun

@deffn {Generic Function} slot-unbound
@end deffn

@deffn {Method} slot-unbound (class <class>) obj slot
@end deffn

@deffn {Generic Function} slot-missing
@end deffn

@deffn {Method} slot-missing (class <class>) obj slot &optional value
@end deffn


@defun class-slot-ref class slot-name
@defunx class-slot-set! class slot-name obj
@end defun

@c ----------------------------------------------------------------------
@node Metaobject protocol
@section Metaobject procotol

@node System metaclasses
@subsection System metaclasses

@deftp {Class} <class>
@clindex class
@end deftp

@deftp {Class} <generic>
@clindex generic
@end deftp

@deftp {Class} <method>
@clindex method
@end deftp

@deftp {Class} <object>
@clindex object
@end deftp


@node Class introspection
@subsection Class introspection

@node Class metaobject
@subsubsection Class metaobject

@defun class-name class
@end defun

@defun class-precedence-list class
@end defun

@defun class-direct-supers class
@end defun

@defun class-direct-slots class
@end defun

@defun class-slots
@end defun

@node Slot definition
@subsubsection Slot definition

@defun class-slot-definition class slot-name
@end defun

@defun class-slot-accessor class slot-name
@end defun

@defun slot-definition-name slot-def
@end defun
@defun slot-definition-allocation slot
@end defun

@defun slot-definition-getter slot
@defunx slot-defininion-setter slot
@defunx slot-definition-accessor slot
@end defun

@defun slot-definition-options slot-def
@defunx slot-definition-option slot-def key &optional default
@end defun

@node Class instantiation
@subsection Class instantiation

@node Customizing slot access
@subsection Customizing slot access

@node Method instantiation
@subsection Method instantiation

@node Customizing method application
@subsection Customizing method application



@c ======================================================================
@node Libarary Modules
@chapter Library Modules

@c ----------------------------------------------------------------------
@node Character code conversion
@section @code{gauche.charconv} - Character Code Conversion

@deftp {Module} gauche.charconv
@mdindex gauche.charconv
@emph{--- NOT IMPLEMENTED ---}
@end deftp

@defun open-input-conversion-port from-port from-code &optional to-code
@end defun

@defun open-output-conversion-port to-port to-code &optional from-code
@end defun

@c ----------------------------------------------------------------------
@node Networking
@section @code{gauche.net} - Networking

@deftp {Module} gauche.net
@mdindex gauche.net
@emph{--- NOT IMPLEMENTED ---}
@end deftp

@node High-level functions
@subsection High-level functions

@defun make-client-socket address &optional port
@end defun

@defun make-server-socket address &optional port reuse-addr?
@end defun

@node Low-level socket interface
@subsection Low-level socket interface

@deftp {Builtin Class} <socket-address>
@clindex socket-address
@end deftp

@defun make-socket-address-unix pathname
@end defun

@defun make-socket-address-inet host port
@end defun

@defun make-socket domain family protocol
@end defun

@defun socket-bind socket address
@end defun

@defun socket-listen
@end defun

@defun socket-accept
@end defun

@defun socket-connect
@end defun

@defun socket-sendto
@end defun

@defun socket-recvfrom
@end defun

@node Netdb interface
@subsection Socket interface

@deftp {Builtin Class} <sys-hostent>
@clindex sys-hostent
@end deftp

@deftp {Builtin Class} <sys-servent>
@clindex sys-servent
@end deftp

@deftp {Builtin Class} <sys-protoent>
@clindex sys-protoent
@end deftp

@c ----------------------------------------------------------------------
@node High Level Process Interface
@section @code{gauche.process} - High Level Process Interface

@deftp {Module} gauche.process
@mdindex gauche.process
This module provides a higher-level API of Unix process control,
implemented on top of low-level system calls such as @code{sys-fork}
and @code{sys-exec}.  The interface is mostly compatible with
STk's process library.

To use this module, say @code{(use gauche.process)}.
@end deftp

@deftp {Class} <process>
@clindex process
An object to keep the status of a child process.
@end deftp

@defun run-process command arg @dots{}
@end defun

@defun process? obj
@end defun

@deffn {Method} process-pid (process <process>)
@end deffn

@deffn {Method} process-command (process <process>)
@end deffn

@deffn {Method} process-status (process <process>)
@end deffn

@deffn {Method} process-input (process <process>)
@deffnx {Method} process-output (process <process>)
@deffnx {Method} process-error (process <process>)
@end deffn

@defun process-alive? process
@end defun

@defun process-list
@end defun

@defun process-wait process
@end defun

@defun process-send-signal process signal
@end defun

@defun process-kill process
@defunx process-stop process
@defunx process-continue process
@end defun

@c ----------------------------------------------------------------------
@node Regular expression utilities
@section @code{gauche.regexp} - Regular expression utilities

@deftp {Module} gauche.regexp
@mdindex gauche.regexp
This module defines some macros useful in regexp match.

The interface is borrowed from scsh, but I changed the name of
macros since scsh's @code{match-cond} can be confusing
(e.g. Bigloo has @code{match-lambda} and @code{match-case} in
pattern match library, that sounds too similar).
@end deftp

In the following macros, @var{match-expr} is an expression
which produces a match object or @code{#f}. Typically
it is a call of @code{rxmatch}, but it can be any expression.

@defmac rxmatch-let match-expr (var @dots{}) form @dots{}

Evaluates @var{match-expr}, and if matched, binds @var{var @dots{}}
to the matched strings, then evaluates @var{form}s.
The first @var{var} receives the entire match, and subsequent
variables receive submatches.  If the number of submatches are
smaller than the number of variables to receive them, the rest
of variables will get @code{#f}.

It is possible to put @code{#f} in variable position, which says
you don't care that match.

@example
(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (time hh mm ss)
  (list time hh mm ss))
 @result{} ("23:59:58" "23" "59" "58")

(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (#f hh mm)
  (list hh mm))
 @result{} ("23" "59")
@end example

This macro corresponds to scsh's @code{let-match}.
@end defmac

@defmac rxmatch-if match-expr (var @dots{}) then-form else-form
Evaluates @var{match-expr}, and if matched, binds @var{var} @dots{}
to the matched strings and evaluate @var{then-form}.
Otherwise evaluates @var{else-form}.
The rule of binding @var{var}s is the same as @code{rxmatch-let}.

@example
(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11:22:33")
    (time)
  (format #f "time is ~a" time)
  "unknown time)
 @result{} "time is 11:22"

(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11-22-33")
    (time)
  (format #f "time is ~a" time)
  "unknown time)
 @result{} "unknown time"
@end example

This macro corresponds to scsh's @code{if-match}.
@end defmac

@defmac rxmatch-cond clause @dots{}
Evaluate condition in @var{clause}s one by one.
If a condition of a clause satisfies, rest portion of the clause
is evaluated and becomes the result of @code{rxmatch-cond}.
@var{Clause} may be one of the following pattern.

@table @code
@item (@var{match-expr} (@var{var} @dots{}) @var{form} @dots{})
Evaluate @var{match-expr}, which may return a regexp match
object or @code{#f}.  If it returns a match object, the matches
are bound to @var{var}s, like @var{rxmatch-let}, and @var{form}s
are evaluated.

@item (test @var{expr} @var{form} @dots{})
Evaluates @var{expr}.  If it yields true, evaluates @var{form}s.

@item (test @var{expr} => @var{proc})
Evaluates @var{expr} and if it is true,
calls @var{proc} with the result of @var{expr} as the only argument.

@item (else @var{form} @dots{})
If this clause exists, it must be the last clause.
If other clauses fail, @var{form}s are evaluated.
@end table

If no @code{else} clause exists, and no other clause matched the
@var{string-expr}, an undefined value is returned.

@example
;; @r{parses several possible date format}
(define (parse-date str)
  (rxmatch-cond
    ((rxmatch #/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ str)
        (#f mm dd yyyy)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ str)
        (#f yyyy mm dd)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^\d+\/\d+\/\d+$/ str)
        (#f)
     (error "ambiguous: ~s" str))
    (else (error "bogus: ~s" str))))

(parse-date "2001/2/3") @result{} (2001 2 3)
(parse-date "12/25/1999") @result{} (1999 12 25)
@end example

This macro corresponds to scsh's @code{match-cond}.
@end defmac

@defmac rxmatch-case string-expr clause @dots{}
@var{String-expr} is evaluated, and @var{clause}s are interpreted
one by one.  A @var{clause} may be one of the following pattern.

@table @code
@item (@var{re} (@var{var} @dots{}) @var{form} @dots{})
@var{Re} must be either a literal string describing a
regexp, or a regexp object.  If it matches with the result
of @var{string-expr}, the match result is bound to @var{var}s
and @var{form}s are evaluated, and @code{rxmatch-case} returns
the result of the last @var{form}.

If @var{re} doesn't match the result of @var{string-expr},
@var{string-expr} yields non-string value, the interpretation proceeds
to the next clause.

@item (test @var{proc} @var{form} @dots{})
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{form}s are evaluated, and
@code{rxmatch-case} returns the result of the last @var{form}.

If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.

@item (test @var{proc} => @var{proc2})
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{proc2} is applied on the result,
and its result is returned as the result of @code{rxmatch-case}.

If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.

@item (else @var{form} @dots{})
This form must appear at the end of @var{clause}s, if any.
If other clauses fail, @var{form}s are evaluated,
and the result of the last @var{form} becomes the result of
@code{rxmatch-case}.
@end table

If no @code{else} clause exists, and no other clause matched the
@var{string-expr}, an undefined value is returned.

@end defmac


@c ----------------------------------------------------------------------
@node Serializer
@section @code{gauche.serializer} - Serializer

@deftp {Module} gauche.serializer
@mdindex gauche.serializer
@end deftp


@c ----------------------------------------------------------------------
@node Unit Testing
@section @code{gauche.test} - Unit Testing

@deftp {Module} gauche.test
@mdindex gauche.test
Defines a set of functions to write test scripts.
A test script will look like this:
@lisp
(use gauche.test)
(test-start "my feature")
(load "my-feature")         ; @r{load your program}
(select-module my-feature)  ; @r{if your program defines a module.}

(test-section "feature group 1")
(test "feature 1-1" EXPECT (lambda () TEST-BODY))
(test "feature 1-2" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-section "feature group 2")
(define test-data ...)
(test "feature 2-1" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-end)
@end lisp

With this convention, you can run test both interactively or
in batch.   To run a test interactively, just load the file
and it reports a result of each test, as well as the summary
of failed test at the end.  To run a test in batch, it is
convenient to redirect the stdout to some file
If stdout is redirected to other than tty, all the verbose logs will go
there, and only a small amount of messages go to stderr.

It is recommended to have a "test" target always in Makefile
of your module/program, so that the user of your program can run a
test easily.  The rule may look like this:

@example
test :
        gosh my-feature-test.scm > test.log
@end example

@end deftp

@defun test name expected thunk &optional =
Calls @var{thunk}, and compares its result with @var{expected}.
The comparison predicate is @var{equal?} by default, but you can
specify your own predicate by the argument @var{=}.
@var{Name} is a name of the test, for logging purpose.
@end defun

@defun test-start module-name
Initializes internal state and prints a log header.
This should be called before any tests.
@var{Module-name} is used only for logging purpose.
@end defun

@defun test-section section-name
Marks beginning of the group of tests.  This is just for logging.
@end defun

@defun test-end
Prints out list of failed tests.
@end defun

@c ----------------------------------------------------------------------
@node RFC822 Message parsing
@section @code{rfc.822} - RFC822 message parsing

@deftp {Module} rfc.822
@mdindex rfc.822
Defines a set of functions that parses and constructs the ``Internet
Message Format'', a text format used to exchange e-mails.
The most recent specification can be found in
@uref{http://www.rfc-editor.org/rfc/rfc2822.txt, RFC2822}.
The format was originally defined in RFC 822, and people still 
call it ``RFC822 format'', hence I named this module.
In the following document, I also refer to the format as ``RFC822 format''.

Say @code{(use rfc.822)} to use this module.
@end deftp

@defun rfc822-header->list iport &optional strict?
Reads RFC822 format message from an input port @var{iport},
until it reaches the end of the message header.
The header fields are unfolded, and broken into a list of the following
format:
@example
((name body) @dots{})
@end example
@var{Name} @dots{} are the field names, and @var{body} @dots{} are
the corresponding field body, both as strings.
Field names are converted to lower-case characters.
Field bodies are not modified, except the folded line is concatenated,
CRLFs removed.
The order of fields are preserved.
@end defun


@c ----------------------------------------------------------------------
@node Base64 encoding/decoding
@section @code{rfc.base64} - Base64 encoding/decoding

@deftp {Module} rfc.base64
@mdindex rfc.base64
This module defines a few functions to encode/decode Base64 format,
defined in @uref{http://www.rfc-editor.org/rfc/rfc2045.txt, RFC 2045},
section 6.3.
@end deftp


@defun base64-encode
@end defun

@defun base64-encode-string string
@end defun

@defun base64-decode
@end defun

@defun base64-decode-string string
@end defun


@c ----------------------------------------------------------------------
@node SLIB
@section @code{slib} - SLIB interface

@deftp {Module} slib
@mdindex slib
This module is the interface to the Aubrey Jaffer's SLIB.
To use SLIB, say @code{(use slib)}.   SLIB itself is not included
in Gauche distribution.   If you don't have it on your system,
get it from @uref{http://www-swiss.ai.mit.edu/~jaffer/SLIB.html}.

This module defines @code{require}, shadowing the Gauche's original
@code{require}.  If it gets a symbol as an argument, it works as
SLIB's @code{require}, while if it gets a string, it works as
Gauche's @code{require}.   The same applies to @code{provide} and
@code{provided?}.

All SLIB symbol bindings, loaded by @code{require}, stay in the
module @code{slib}.
@end deftp

@c ----------------------------------------------------------------------
@node Feature Conditional
@section @code{srfi-0} - Feature Conditional

@deftp {Module} srfi-0
@mdindex srfi-0
@end deftp

@defmac cond-expand (feature-requirement command-or-definition @dots{}) @dots{}
[SRFI-0]
@end defmac

@c ----------------------------------------------------------------------
@node List library
@section @code{srfi-1} - List library

@deftp {Module} srfi-1
@mdindex srfi-1
SRFI-1 is a rich collection of list manipulation library.
It is available by saying @code{(use srfi-1)}.
The implementation is based on Olin Shivers's reference implementation.
I splitted it into number of subfiles that will be autoloaded on demand.

Detailed specificaion of SRFI-1 is available at
@uref{http://srfi.schemers.org/srfi-1/srfi-1.html}.
@end deftp

@node SRFI-1 List constructors
@subsection List constructors

@defun xcons cd ca
[SRFI-1] Equivalent to @code{(cons ca cd)}.  Useful to pass to
higher-order procedures.
@end defun

@defun cons* elt1 elt2 @dots{}
[SRFI-1] Like @code{list}, but the last argument provides the tail of
the constructed list.  This is just a synonym of Gauche built-in procedure
@code{list*}.
@example
(cons* 1 2 3 4) @result{} (1 2 3 . 4)
(cons* 1) @result{} 1
@end example
@end defun

@defun list-tabulate n init-proc
[SRFI-1] Returns an @var{n}-element list.  Element @i{i} of the
list, where 0 <= @i{i} < @i{n}, is produced by @code{(@var{init-proc} @i{i})}.
No guarantee is made about the dynamic order in which init-proc is
applied to these indices.
@example
(list-tabulate 4 values) @result{} (0 1 2 3)
@end example
@end defun

@defun circular-list elt1 elt2 @dots{}
[SRFI-1] Constructs a circular list of the elements.
@example
(circular-list 'z 'q) @result{} (z q z q z q @dots{})
@end example
@end defun

@defun iota count &optional start step
[SRFI-1] Returns a list containing the elements
@example
(@var{start} @var{start}+@var{step} @dots{} @var{start}+(@var{count}-1)*@var{step})
@end example

The @var{start} and @var{step} parameters default to 0 and 1, respectively.
This procedure takes its name from the APL primitive.

@example
(iota 5) @result{} (0 1 2 3 4)
(iota 5 0 -0.1) @result{} (0 -0.1 -0.2 -0.3 -0.4)
@end example
@end defun

@node SRFI-1 List predicates
@subsection List predicates

@defun proper-list? x
[SRFI-1] Returns true iff x is a proper list -- a finite, nil-terminated list.
@end defun

@defun cicular-list? x
[SRFI-1] True if x is a circular list.
@end defun

@defun dotted-list? x
[SRFI-1] True if x is a finite, non-nil-terminated list.
This includes non-pair, non-() values (e.g. symbols, numbers),
which are considered to be dotted lists of length 0.
@end defun

@defun null-list? list
[SRFI-1] @var{List} is a proper or circular list.
This procedure returns true if the argument is the empty list @code{()},
and false otherwise.
It is an error to pass this procedure a value which is not a proper or
circular list. This procedure is recommended as
the termination condition for list-processing procedures that are
not defined on dotted lists. 
@end defun

@defun not-pair? x
[SRFI-1] @code{(lambda (x) (not (pair? x)))}.
Provided as a procedure as it can be useful as the termination condition
for list-processing procedures that wish to
handle all finite lists, both proper and dotted. 
@end defun

@defun list= elt= list @dots{}
[SRFI-1] Determines list equality, given an element-equality procedure.
Proper list A equals proper list B if they are of the
same length, and their corresponding elements are equal, as determined
by @var{elt=}.

It is an error to apply @code{list=} to anything except proper lists.

The equality procedure must be consistent with @code{eq?}. That is,
it must be the case that
@example
(eq? x y) @result{} (elt= x y).
@end example
@end defun

@node SRFI-1 List selectors
@subsection List selectors

@defun  first pair
@defunx second pair
@defunx third pair
@defunx fourth pair
@defunx fifth pair
@defunx sixth pair
@defunx seventh pair
@defunx eighth pair
@defunx ninth pair
@defunx tenth pair
[SRFI-1] Returns n-th element of the (maybe improper) list.
@end defun

@defun car+cdr pair
[SRFI-1] Returns two values, @code{(car pair)} and @code{(cdr pair)}.
@end defun

@defun take x i
@defunx drop x i
[SRFI-1] @code{take} returns the first i elements of list x.
@code{drop} returns all but the first i elements of list x. 
@example
(take '(a b c d e)  2) => (a b)
(drop '(a b c d e)  2) => (c d e)
@end example
@var{x} may be any value -- a proper, circular, or dotted list: 
@example
(take '(1 2 3 . d) 2) => (1 2)
(drop '(1 2 3 . d) 2) => (3 . d)
(drop '(1 2 3 . d) 3) => d
@end example
@code{drop} is exactly equivalent to performing @var{i} cdr operations
on @var{x}; the returned value shares a common tail with @var{x}. If the
argument is a list of non-zero length, take is guaranteed to return a
freshly-allocated list, even in the case where the
entire list is taken.
@end defun

@defun take-right flist i
@defunx drop-right flist i
[SRFI-1] @code{take-right} returns the last @var{i} elements of @var{flist}.
@code{drop-right} returns all but the last @var{i} elements of @var{flist}. 
@example
(take-right '(a b c d e) 2) => (d e)
(drop-right '(a b c d e) 2) => (a b c)
@end example
@var{flist} may be any finite list, either proper or dotted: 
@example
(take-right '(1 2 3 . d) 2) => (2 3 . d)
(drop-right '(1 2 3 . d) 2) => (1)
(take-right '(1 2 3 . d) 0) => d
(drop-right '(1 2 3 . d) 0) => (1 2 3)
@end example
@code{take-right}'s return value is guaranteed to share a common
tail with @var{flist}. If the argument is a list of non-zero
length, @code{drop-right} is guaranteed to return a freshly-allocated
list, even in the case where nothing is dropped.
@end defun

@defun take! x i
@defunx drop-right! x i
@code{take!} and @code{drop-right!} are "linear-update" variants of
[SRFI-1] take and drop-right: the procedure is allowed, but not
required, to alter the argument list to produce the result. 

If @var{x} is circular, @code{take!} may return a shorter-than-expected list.
@end defun

@defun split-at x i
@defunx split-at! x i
[SRFI-1] @code{split-at} splits the list @var{x} at index @var{i},
returning a list of the first @var{i} elements, and the remaining tail.
@example
(split-at '(a b c d e) 2) @result{} (a b) @r{and} (c d e)
@end example
@code{split-at!} is the linear-update variant. It is allowed,
but not required, to alter the argument list to produce the result. 
@end defun

@defun last pair
[SRFI-1] Returns the last element of the non-empty, finite list @var{pair}.
It is equivalent to @code{(car (last-pair pair))}.
Note that @code{last-pair} is Gauche built-in procedure.
@end defun

@node SRFI-1 List miscellaneous routines
@subsection List miscellaneous routines

@defun length+ x
[SRFI-1] If @var{x} is a finite, proper list, returns its length.
Otherwise, returns @code{#f}.
@end defun

@defun concatenate list-of-lists
@defunx concatenate! list-of-lists!
[SRFI-1] Equivalent to @code{(apply append @var{list-of-lists})} and
@code{(apply append! @var{list-of-lists})}, respectively.
@end defun

@defun append-reverse rev-head tail
@defunx append-reverse! rev-head tail
[SRFI-1] @code{append-reverse} returns @code{(append (reverse rev-head) tail)}.
@code{append-reverse!} is just the linear-update variant.
@end defun

@defun zip clist1 clist2 @dots{}
[SRFI-1] Equivalent to @code{(map list clist1 clist2 @dots{})}.
If @code{zip} is passed @var{n} lists, it returns a list as long as
the shortest of these lists, each element of which is an @var{n}-element list
comprised of the corresponding elements from the parameter lists. 
@example
(zip '(one two three) 
     '(1 2 3)
     '(odd even odd even odd even odd even))
     @result{} ((one 1 odd) (two 2 even) (three 3 odd))

(zip '(1 2 3)) @result{} ((1) (2) (3))
@end example
At least one of the argument lists must be finite: 
@example
(zip '(3 1 4 1) (circular-list #f #t)) 
     @result{} ((3 #f) (1 #t) (4 #f) (1 #t))
@end example
@end defun

@defun unzip1 list
@defunx unzip2 list
@defunx unzip3 list
@defunx unzip4 list
@defunx unzip5 list
[SRFI-1] @code{unzip1} takes a list of lists, where every list must
contain at least one element, and returns a list containing the
initial element of each such list. That is, it returns
@code{(map car lists)}. @code{unzip2} takes a list of lists, where every list
must contain at least two elements, and returns two values:
a list of the first elements, and a list of the second
elements. @code{unzip3} does the same for the first
three elements of the lists, and so forth. 
@example
(unzip2 '((1 one) (2 two) (3 three))) @result{}
   (1 2 3) @r{and}
   (one two three)
@end example
@end defun

@defun count pred clist1 clist2 @dots{}
[SRFI-1] @var{pred} is a procedure taking as many arguments as
there are lists and returning a single value. It is applied element-wise
to the elements of the lists, and a count is tallied of the number
of elements that produce a true value. This count is
returned. count is "iterative" in that it is guaranteed to
apply pred to the list elements in a left-to-right order. The
counting stops when the shortest list expires.
@example
(count even? '(3 1 4 1 5 9 2 5 6)) @result{} 3
(count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)) @result{} 3
@end example
At least one of the argument lists must be finite: 
@example
(count < '(3 1 4 1) (circular-list 1 10)) @result{} 2
@end example
@end defun

@node SRFI-1 Fold, unfold & map
@subsection List fold, unfold & map

@defun fold kons knil clist1 clist2 @dots{}
[SRFI-1] The fundamental list iterator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@example
(@var{kons} @var{en} @dots{} (@var{kons} @var{e2} (@var{kons} @var{e1} @var{knil})) @dots{} ) 
@end example

If @var{n} list arguments are provided, then the @var{kons}
function must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples:
@example
(fold + 0 '(3 1 4 1 5 9)) @result{} 23 ;@r{sum up the elements}
(fold cons '() '(a b c d e)) @result{} (e d c b a) ;@r{reverse}
(fold cons* '() '(a b c) '(1 2 3 4 5))
    @result{} (c 3 b 2 a 1) ;@r{n-ary case}
@end example
@end defun

@defun fold-right kons knil clist1 clist2 @dots{}
[SRFI-1] The fundamental list recursion operator.
When it is given a single list
@var{clist1} = (@var{e1} @var{e2} @dots{} @var{en}),
then this procedure returns
@example
(@var{kons} @var{e1} (@var{kons} @var{e2} @dots{} (@var{kons} @var{en} @var{knil})))
@end example

If @var{n} list arguments are provided, then the @var{kons} function
must take @var{n}+1 parameters: one element from each list, and
the "seed" or fold state, which is initially @var{knil}.
The fold operation terminates when the shortest list runs out of values.
At least one of the list arguments must be finite. 

Examples: 
@example
(fold-right cons '() '(a b c d e))
   @result{} (a b c d e) ;@r{copy list}
(fold-right cons* '() '(a b c) '(1 2 3 4 5))
   @result{} (a 1 b 2 c 3) ;@r{n-ary case}
@end example
@end defun

@defun pair-fold kons knil clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun pair-fold-right kons knil clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun reduce f ridentity list
[SRFI-1]
@end defun

@defun reduce-right f ridentity list
[SRFI-1]
@end defun

@defun unfold p f g seed &optional tail-gen
[SRFI-1]
@end defun

@defun unfold-right p f g seed &optional tail
[SRFI-1]
@end defun

@defun append-map f clist1 clist2 @dots{}
@defunx append-map! f clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun map! f list1 clist2 @dots{}
[SRFI-1]
@end defun

@defun map-in-order f clist1 clist2 @dots{}
[SRFI-1] A variant of @code{map}, but it guarantees to apply @var{f}
on each elements of arguments in a left-to-right order.
Since Gauche's @code{map} implementation follows the same order,
this function is just a synonym of @code{map}.
@end defun

@defun pair-for-each f clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun filter-map  f clist1 clist2 @dots{}
[SRIF-1]
@end defun

@node SRFI-1 Filterling & partitioning
@subsection List filtering & partitioning

@defun filter pred list
[SRFI-1]
@end defun

@defun partition pred list
[SRFI-1]
@end defun

@defun remove pred list
[SRFI-1]
@end defun

@defun filter! pred list
@defunx partition! pred list
@defunx remove! pred list
[SRFI-1]
@end defun

@node SRFI-1 Searching
@subsection List searching

@defun find pred clist
[SRFI-1]
@end defun

@defun find-tail pred clist
[SRFI-1]
@end defun

@defun take-while pred clist
@defunx take-while! pred list
[SRFI-1]
@end defun

@defun drop-while pred clist
[SRFI-1]
@end defun

@defun span pred clist
@defunx span! pred list
@defunx break pred clist
@defunx break! pred list
[SRFI-1]
@end defun

@defun any pred clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun every pred clist1 clist2 @dots{}
[SRFI-1]
@end defun

@defun list-index pred clist1 clist2 @dots{}
[SRFI-1]
@end defun

@node SRFI-1 Deletion
@subsection List deletion

@defun delete x list &optional elt=
@defunx delete! x list &optional elt=
[SRFI-1]
@end defun

@defun delete-duplicates list &optional elt=
@defunx delete-duplicates! list &optional elt=
[SRFI-1]
@end defun

@node SRFI-1 Association lists
@subsection Association lists

@defun alist-cons key datum alist
[SRFI-1] Returns @code{(cons (cons @var{obj1} @var{obj2}) @var{obj3})}.
This is an alias of the Gauche builtin procedure @code{acons}.
@end defun

@defun alist-copy alist
[SRFI-1] Returns a fresh copy of @var{alist}.
@end defun

@defun alist-delete key alist &optional =
@defunx alist-delete! key alist &optional =
[SRFI-1]
@end defun

@node SRFI-1 set operations
@subsection Lists as sets

@defun lset@code{<=} elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset= elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-adjoin elt= list elt @dots{}
[SRFI-1]
@end defun

@defun lset-union elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset-intersection elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-difference elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-xor elt= list1 @dots{}
[SRFI-1]
@end defun

@defun lset-diff+intersection elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@defun lset-union! elt= list @dots{}
@defunx lset-intersection! elt= list1 list2 @dots{}
@defunx lset-difference! elt= list1 list2 @dots{}
@defunx lset-xor! elt= list1 @dots{}
@defunx lset-diff+intersection! elt= list1 list2 @dots{}
[SRFI-1]
@end defun

@c ----------------------------------------------------------------------
@node And-let*
@section @code{srfi-2} - And-let*

@deftp {Module} srfi-2
@mdindex srfi-2
@end deftp

@defmac and-let* (bindings @dots{}) body @dots{}
@end defmac

@c ----------------------------------------------------------------------
@node Homogeneous Vectors
@section @code{srfi-4} - Homogeneous Vectors

@deftp {Module} srfi-4
@mdindex srfi-4
@end deftp

@deftp {Builtin Class} <s8vector>
@deftpx {Builtin Class} <u8vector>
@deftpx {Builtin Class} <s16vector>
@deftpx {Builtin Class} <u16vector>
@deftpx {Builtin Class} <s32vector>
@deftpx {Builtin Class} <u32vector>
@deftpx {Builtin Class} <s64vector>
@deftpx {Builtin Class} <u64vector>
@deftpx {Builtin Class} <f32vector>
@deftpx {Builtin Class} <f64vector>
@clindex s8vector
@clindex u8vector
@clindex s16vector
@clindex u16vector
@clindex s32vector
@clindex u32vector
@clindex s64vector
@clindex u64vector
@clindex f32vector
@clindex f64vector
[SRFI-4]
@end deftp

@defun s8vector? obj
@defunx u8vector? obj
@defunx s16vector? obj
@defunx u16vector? obj
@defunx s32vector? obj
@defunx u32vector? obj
@defunx s64vector? obj
@defunx u64vector? obj
@defunx f32vector? obj
@defunx f64vector? obj
[SRFI-4]
@end defun

@defun s8vector n @dots{}
@defunx u8vector n @dots{}
@defunx s16vector n @dots{}
@defunx u16vector n @dots{}
@defunx s32vector n @dots{}
@defunx u32vector n @dots{}
@defunx s64vector n @dots{}
@defunx u64vector n @dots{}
@defunx f32vector x @dots{}
@defunx f64vector x @dots{}
[SRFI-4]
@end defun

@defun  make-s8vector len &optional fill
@defunx make-u8vector len &optional fill
@defunx make-s16vector len &optional fill
@defunx make-u16vector len &optional fill
@defunx make-s32vector len &optional fill
@defunx make-u32vector len &optional fill
@defunx make-s64vector len &optional fill
@defunx make-u64vector len &optional fill
@defunx make-f32vector len &optional fill
@defunx make-f64vector len &optional fill
[SRFI-4]
@end defun

@defun  s8vector-ref vec k
@defunx u8vector-ref vec k
@defunx s16vector-ref vec k
@defunx u16vector-ref vec k
@defunx s32vector-ref vec k
@defunx u32vector-ref vec k
@defunx s64vector-ref vec k
@defunx u64vector-ref vec k
@defunx f32vector-ref vec k
@defunx f64vector-ref vec k
[SRFI-4]
@end defun

@defun  s8vector-set! vec k n
@defunx u8vector-set! vec k n
@defunx s16vector-set! vec k n
@defunx u16vector-set! vec k n
@defunx s32vector-set! vec k n
@defunx u32vector-set! vec k n
@defunx s64vector-set! vec k n
@defunx u64vector-set! vec k n
@defunx f32vector-set! vec k x
@defunx f64vector-set! vec k x
[SRFI-4]
@end defun

@defun  s8vector-copy vec
@defunx u8vector-copy vec
@defunx s16vector-copy vec
@defunx u16vector-copy vec
@defunx s32vector-copy vec
@defunx u32vector-copy vec
@defunx s64vector-copy vec
@defunx u64vector-copy vec
@defunx f32vector-copy vec
@defunx f64vector-copy vec
[SRFI-4]
@end defun

@defun  s8vector-copy! dstvec srcvec
@defunx u8vector-copy! dstvec srcvec
@defunx s16vector-copy! dstvec srcvec
@defunx u16vector-copy! dstvec srcvec
@defunx s32vector-copy! dstvec srcvec
@defunx u32vector-copy! dstvec srcvec
@defunx s64vector-copy! dstvec srcvec
@defunx u64vector-copy! dstvec srcvec
@defunx f32vector-copy! dstvec srcvec
@defunx f64vector-copy! dstvec srcvec
[SRFI-4]
@end defun

@defun  s8vector->list vec
@defunx u8vector->list vec
@defunx s16vector->list vec
@defunx u16vector->list vec
@defunx s32vector->list vec
@defunx u32vector->list vec
@defunx s64vector->list vec
@defunx u64vector->list vec
@defunx f32vector->list vec
@defunx f64vector->list vec
[SRFI-4]
@end defun

@defun  s8vector->vector vec
@defunx u8vector->vector vec
@defunx s16vector->vector vec
@defunx u16vector->vector vec
@defunx s32vector->vector vec
@defunx u32vector->vector vec
@defunx s64vector->vector vec
@defunx u64vector->vector vec
@defunx f32vector->vector vec
@defunx f64vector->vector vec
@end defun

@defun  list->s8vector list
@defunx list->u8vector list
@defunx list->s16vector list
@defunx list->u16vector list
@defunx list->s32vector list
@defunx list->u32vector list
@defunx list->s64vector list
@defunx list->u64vector list
@defunx list->f32vector list
@defunx list->f64vector list
[SRFI-4]
@end defun

@defun  vector->s8vector vec
@defunx vector->u8vector vec
@defunx vector->s16vector vec
@defunx vector->u16vector vec
@defunx vector->s32vector vec
@defunx vector->u32vector vec
@defunx vector->s64vector vec
@defunx vector->u64vector vec
@defunx vector->f32vector vec
@defunx vector->f64vector vec
@end defun

@c ----------------------------------------------------------------------
@node SRFI String ports
@section @code{srfi-6} - String ports

@deftp {Module} srfi-6
@mdindex srfi-6
String ports, defined in SRFI-6, are builtin feature of Gauche.
The form @code{(use srfi-6)} doesn't do anything.
@end deftp

@c ----------------------------------------------------------------------
@node Syntax to receive multiple values
@section @code{srfi-8} - Syntax to receive multiple values

@deftp {Module} srfi-8
@mdindex srfi-8
Syntax @code{receive}, defined in SRFI-8, is builtin feature of Gauche.
The form @code{(use srfi-8)} doesn't do anything.
@end deftp


@c ----------------------------------------------------------------------
@node Let-values
@section @code{srfi-11} - Let-values

@deftp {Module} srfi-11
@mdindex srfi-11
@end deftp


@c ----------------------------------------------------------------------
@node String library
@section @code{srfi-13} - String library

@deftp {Module} srfi-13
@mdindex srfi-13
@end deftp

@node SRFI-13 String predicates
@subsection String predicates

@defun string-null? s
[SRFI-13]
@end defun

@defun string-every char/char-set/pred s &optional start end
[SRFI-13]
@end defun

@defun string-any char/char-set/pred s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String Constructors
@subsection String Constructors

@defun string-tabulate proc len
[SRFI-13]
@end defun

@defun reverse-list->string char-list
[SRFI-13]
@end defun

@node SRFI-13 String Selection
@subsection String selection

@defun substring/shared s start &optional end
[SRFI-13]
@end defun

@defun string-copy! target tstart s &optional start end
[SRFI-13]
@end defun

@defun string-take s nchars
@defunx string-drop s nchars
@defunx string-take-right s nchars
@defunx string-drop-right s nchars
[SRFI-13]
@end defun

@defun string-pad s len &optional char start end
@defunx string-pad-right s len &optional char start end
[SRFI-13]
@end defun

@defun string-trim s &optional char/char-set/pred start end
@defunx string-trim-right s &optional char/char-set/pred start end
@defunx string-trim-both s &optional char/char-set/pred start end
[SRFI-13]
@end defun

@node SRFI-13 String Comparison
@subsection String comparison

@defun string-compare s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
@defunx string-compare-ci s1 s2 proc< proc= proc> &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string= s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-ci@code{=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{<=} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>} s1 s2 &optional start1 end1 start2 end2
@defunx string-ci@code{>=} s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-hash s &optional bound start end 
@defunx string-hash-ci s &optional bound start end 
[SRFI-13]
@end defun

@node SRFI-13 String Prefixes & Suffixes
@subsection String Prefixes & Suffixes

@defun string-prefix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-length-ci s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-length-ci s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@defun string-prefix? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix? s1 s2 &optional start1 end1 start2 end2
@defunx string-prefix-ci? s1 s2 &optional start1 end1 start2 end2
@defunx string-suffix-ci? s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@node SRFI-13 String searching
@subsection String searching

@defun string-index s char/char-set/pred &optional start end
@defunx string-index-right s char/char-set/pred &optional start end
@defunx string-skip s char/char-set/pred &optional start end
@defunx string-skip-right s char/char-set/pred &optional start end
[SRFI-13]
@end defun

@defun string-count s char/char-set/pred &optional start end
[SRFI-13]
@end defun

@defun string-contains s1 s2 &optional start1 end1 start2 end2
@defunx string-contains-ci s1 s2 &optional start1 end1 start2 end2
[SRFI-13]
@end defun

@node SRFI-13 String case mapping
@subsection String case mapping

@defun string-titlecase s &optional start end
@defunx string-titlecase! s &optional start end
[SRFI-13]
@end defun

@defun string-upcase s &optional start end
@defunx string-upcase! s &optional start end
[SRFI-13]
@end defun

@defun string-downcase s &optional start end
@defunx string-downcase! s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String reverse & append
@subsection String reverse & append

@defun string-reverse s &optional start end
@defunx string-reverse! s &optional start end
[SRFI-13]
@end defun

@defun string-concatenate string-list
[SRFI-13]
@end defun

@defun string-concatenate/shared string-list
@defunx string-append/shared s @dots{}
[SRFI-13]
@end defun

@defun string-concatenate-reverse string-list
@defunx string-concatenate-reverse/shared string-list
[SRFI-13]
@end defun

@node SRFI-13 String mapping
@subsection String mapping

@defun string-map proc s &optional start end
@defunx string-map! proc s &optional start end
[SRFI-13]
@end defun

@defun string-fold kons knil s &optional start end
@defunx string-fold-right kons knil s &optional start end
[SRFI-13]
@end defun

@defun string-unfold p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-unfold-right p f g seed &optional base make-final
[SRFI-13]
@end defun

@defun string-for-each proc s &optional start end
[SRFI-13]
@end defun

@defun string-for-each-index proc s &optional start end
[SRFI-13]
@end defun

@node SRFI-13 String rotation
@subsection String rotation

@defun xsubstring s from &optional to start end
[SRFI-13]
@end defun

@defun string-xcopy! target tstart s sfrom &optional sto start end
[SRFI-13]
@end defun

@node SRFI-13 other string operations
@subsection Other string operations

@defun string-replace s1 s2 start1 end2 &optional start2 end2
[SRFI-13]
@end defun

@defun string-tokenize s &optional token-set start end
[SRFI-13]
@end defun

@node SRFI-13 String filtering
@subsection String filtering

@defun string-filter s char/char-set/pred &optional start end
@defunx string-delete s char/char-set/pred &optional start end
[SRFI-13]
@end defun

@node SRFI-13 Low-level string procedures
@subsection Low-level string procedures

@defun string-parse-start+end proc s args
@defunx string-parse-final-start+end proc s args
[SRFI-13]
@end defun

@defmac let-string-start+end (start end [rest]) proc-exp s-exp args-exp body @dots{}
[SRFI-13]
@end defmac

@defun check-substring-spec proc s start end
@defunx substring-spec-ok? s start end
[SRFI-13]
@end defun

@defun make-kmp-restart-vector s &optional c= start end
[SRFI-13]
@end defun

@defun kmp-step pat rv c i c= p-start
[SRFI-13]
@end defun

@defun string-kmp-partial-search pat rv s i &optional c= p-start s-start s-end
[SRFI-13]
@end defun

@c ----------------------------------------------------------------------
@node Character-set library
@section @code{srfi-14} - Character-set library

@deftp {Module} srfi-14
@mdindex srfi-14
@end deftp

@node SRFI-14 Character-set constructors
@subsection Character-set constructors

@defun list->char-set char-list &optional base-cs
@defunx list->char-set! char-list base-cs
[SRFI-14]
@end defun

@defun string->char-set char-list &optional base-cs
@defunx string->char-set! char-list base-cs
[SRFI-14]
@end defun

@defun char-set-filter pred char-set &optional base-cs
@defunx char-set-filter! pred char-set base-cs
[SRFI-14]
@end defun

@defun ucs-range->char-set lower upper &optional error? base-cs
@defunx ucs-range->char-set! lower upper error? base-cs
[SRFI-14]
@end defun

@defun integer-range->char-set lower upper &optional error? base-cs
@defunx integer-range->char-set! lower upper error? base-cs
@end defun

@defun ->char-set x
[SRFI-14]
@end defun

@node SRFI-14 Character-set Comparison
@subsection Character-set comparison

@defun char-set= char-set1 @dots{}
[SRFI-14]
@end defun

@defun char-set@code{<=} char-set1 @dots{}
[SRFI-14]
@end defun

@defun char-set-hash char-set &optional bound
[SRFI-14]
@end defun

@node SRFI-14 Character-set iteration
@subsection Character-set iteration

@defun char-set-cursor char-set
[SRFI-14]
@end defun

@defun char-set-ref char-set cursor
[SRFI-14]
@end defun

@defun char-set-cursor-next char-set cursor
[SRFI-14]
@end defun

@defun end-of-char-set? ccursor
[SRFI-14]
@end defun

@defun char-set-fold kons knil char-set
[SRFI-14]
@end defun

@defun char-set-unfold pred fun gen seed &optional base-char-set
@defunx char-set-unfold! pred fun gen seed base-char-set
[SRFI-14]
@end defun

@defun char-set-for-each proc char-set
[SRFI-14]
@end defun

@defun char-set-map proc char-set
[SRFI-14]
@end defun

@node SRFI-14 Character-set query
@subsection Character-set query

@defun char-set-size char-set
[SRFI-14]
@end defun

@defun char-set-count pred char-set
[SRFI-14]
@end defun

@defun char-set->list char-set
[SRFI-14]
@end defun

@defun char-set->string char-set
[SRFI-14]
@end defun

@defun char-set-every pred char-set
[SRFI-14]
@end defun

@defun char-set-any pred char-set
[SRFI-14]
@end defun

@node SRFI-14 Character-set algebra
@subsection Character-set algebra

@defun char-set-adjoin char-set char1 @dots{}
@defunx char-set-adjoin! char-set char1 @dots{}
[SRFI-14]
@end defun

@defun char-set-delete char-set char1 @dots{}
@defunx char-set-delete! char-set char1 @dots{}
[SRFI-14]
@end defun

@defun char-set-complement char-set
@defunx char-set-complement! char-set
[SRFI-14]
@end defun

@defun char-set-union char-set @dots{}
@defunx char-set-union! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-intersection char-set @dots{}
@defunx char-set-intersection! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-difference char-set1 char-set2 @dots{}
@defunx char-set-difference! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-xor char-set @dots{}
@defunx char-set-xor! char-set1 char-set2 @dots{}
[SRFI-14]
@end defun

@defun char-set-diff+intersection char-set1 char-set2 @dots{}
@defunx char-set-diff+intersection! char-set1 char-set2 char-set3 @dots{}
[SRFI-14]
@end defun



@node SRFI-14 Predefined character-set
@subsection Predefined character-set

@defvar char-set:letter
[SRFI-14]
@end defvar

@defvar char-set:blank
[SRFI-14]
@end defvar

@defvar char-set:iso-control
[SRFI-14]
@end defvar

@defvar char-set:digit
@defvarx char-set:hex-digit
[SRFI-14]
@end defvar

@defvar char-set:graphic
[SRFI-14]
@end defvar

@defvar char-set:lower-case
@defvarx char-set:upper-case
@defvarx char-set:title-case
[SRFI-14]
@end defvar

@defvar char-set:printing
[SRFI-14]
@end defvar

@defvar char-set:punctuation
[SRFI-14]
@end defvar

@defvar char-set:whitespace
[SRFI-14]
@end defvar

@defvar char-set:symbol
[SRFI-14]
@end defvar

@defvar char-set:ascii
[SRFI-14]
@end defvar

@defvar char-set:empty
[SRFI-14]
@end defvar

@defvar char-set:full
[SRFI-14]
@end defvar


@c ======================================================================
@node References
@unnumbered References




@c ======================================================================
@node Function and Syntax Index
@unnumbered Function and Syntax Index
@printindex fn

@node Module Index
@unnumbered Module Index
@printindex md


@node Class Index
@unnumbered Class Index

For readability, the surrounding @code{<} and @code{>} are stripped off.

@printindex cl

@node Variable Index
@unnumbered Variable Index
@printindex vr


@contents
@bye
