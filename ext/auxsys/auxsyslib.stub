;;;
;;; auxsyslib.stub - auxiliary system interface
;;;  
;;;   Copyright (c) 2000-2005 Shiro Kawai, All rights reserved.
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: auxsyslib.stub,v 1.25 2005-08-07 23:42:23 shirok Exp $
;;;

"
#include \"auxsysconf.h\"
#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#ifdef HAVE_SYS_LOADAVG_H
#  include <sys/loadavg.h>
#endif /*HAVE_SYS_LOADAVG_H*/

#include <stdlib.h>
#include <math.h>
#include <locale.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <utime.h>
#ifndef __MINGW32__
#  include <sys/times.h>
#  include <sys/utsname.h>
#endif  /*!__MINGW32__ */
"

;; stdlib.h
(define-cproc sys-abort ()  (call <void> "abort"))

(if "defined HAVE_REALPATH"
  (define-cproc %sys-realpath (path::<const-cstring>)
    (body <const-cstring>
          "#define REALPATH_PATH_MAX 1024  /* TODO: needs to be configured */"
          "char buf[REALPATH_PATH_MAX];"
          "if (realpath(path, buf) == NULL) {"
          "  Scm_SysError(\"realpath failed\");"
          "}"
          "SCM_RESULT = buf;"))
  )

;; math.h
(define-cproc fmod (x::<real> y::<real>)
  (call <double> "fmod"))

(define-cproc frexp (d::<real>)
  (body (<double> <int>) "SCM_RESULT0 = frexp(d, &SCM_RESULT1);"))

(define-cproc modf (x::<real>)
  (body (<double> <double>) "SCM_RESULT0 = modf(x, &SCM_RESULT1);"))

(define-cproc ldexp (x::<real> exp::<int>)
  (call <real> "ldexp"))

(define-cproc log10 (x::<real>)
  (call <real> "log10"))

;; sys/loadavg.h
(if "defined HAVE_GETLOADAVG"
  (define-cproc %sys-getloadavg (&optional (nsamples::<int> 3))
    "#define MAX_LOAD_SAMPLES  3
     double samples[MAX_LOAD_SAMPLES];
     int count, i;
     ScmObj h = SCM_NIL, t = SCM_NIL;
     if (nsamples <= 0 || nsamples > MAX_LOAD_SAMPLES) {
       Scm_Error(\"sys-getloadavg: argument out of range: %d\", samples);
     }
     count = getloadavg(samples, nsamples);
     if (count < 0) SCM_RETURN(SCM_FALSE);
     for (i=0; i<count; i++) {
       ScmObj n = Scm_MakeFlonum(samples[i]);
       SCM_APPEND1(h, t, n);
     }
     SCM_RETURN(h);"))

;; sys/time.h
(if "defined HAVE_GETTIMEOFDAY"
  (define-cproc %sys-gettimeofday ()
    (body (<int> <int>)
          "struct timeval tv;"
          "int r; SCM_SYSCALL(r, gettimeofday(&tv, NULL));"
          "if (r < 0) Scm_SysError(\"gettimeofday failed\");"
          "SCM_RESULT0 = tv.tv_sec;"
          "SCM_RESULT1 = tv.tv_usec;"))
)

;; sys/stat.h
(if "!defined(__MINGW32__)"
(define-cproc sys-mkfifo (path::<const-cstring> mode::<int>)
  (body <int>
        "SCM_SYSCALL(SCM_RESULT, mkfifo(path, mode));"
        "if (SCM_RESULT < 0) Scm_SysError(\"mkfifo failed on %s\", path);"))
) ;; !defined(__MINGW32__)

;; utime.h

(define-cproc sys-utime (path::<const-cstring>
                         &optional (atime #f) (mtime #f))
  (body <void>
        "struct utimbuf tim; int r;"
        "if (SCM_FALSEP(atime)&&SCM_FALSEP(mtime)) {"
        "  SCM_SYSCALL(r, utime(path, NULL));"
        "} else {"
        "  tim.actime  = SCM_FALSEP(atime)?time(NULL):Scm_GetUInteger(atime);"
        "  tim.modtime = SCM_FALSEP(mtime)?time(NULL):Scm_GetUInteger(mtime);"
        "  SCM_SYSCALL(r, utime(path, &tim));"
        "}"
        "if (r < 0) Scm_SysError(\"utime failed on %s\", path);"))

;; set*

(if "!defined(__MINGW32__)" (begin

(define-cproc sys-setgid (gid::<int>)
  (body <int>
        "SCM_SYSCALL(SCM_RESULT, setgid(gid));"
        "if (SCM_RESULT < 0) Scm_SysError(\"setgid failed\");"))

(define-cproc sys-setpgid (pid::<int> pgid::<int>)
  (body <int>
        "SCM_SYSCALL(SCM_RESULT, setpgid(pid, pgid));"
        "if (SCM_RESULT < 0) Scm_SysError(\"setpgid failed\");"))

;; The prototype of setpgrp() differs between platforms.   Since it is
;; redundant anyway, Gauche doesn't support it.
;(if (defined? "HAVE_SETPGRP")
;    (define-cproc %sys-setpgrp ()
;      "  int r = Scm_SysCall(setpgrp());
;      if (r < 0) Scm_SysError(\"setpgrp failed\");
;      SCM_RETURN(Scm_MakeInteger(r));"))

(if "defined HAVE_GETPGID"
(define-cproc %sys-getpgid (pid::<int>)
  (body <int>
        "SCM_SYSCALL(SCM_RESULT, (int)getpgid(pid));"
        "if (SCM_RESULT < 0) Scm_SysError(\"getpgid failed\");"))
)

(define-cproc sys-getpgrp ()
  (body <int>
        "SCM_SYSCALL(SCM_RESULT, (int)getpgrp());"
        "if (SCM_RESULT < 0) Scm_SysError(\"getpgrp failed\");"))

(define-cproc sys-setsid ()
  (body <int>
        "SCM_SYSCALL(SCM_RESULT, setsid());"
        "if (SCM_RESULT < 0) Scm_SysError(\"setsid failed\");"))

(define-cproc sys-setuid (uid::<int>)
  (body <int>
        "SCM_SYSCALL(SCM_RESULT, setuid(uid));"
        "if (SCM_RESULT < 0) Scm_SysError(\"setuid failed\");"))

;; some less-frequently used get-*

(define-cproc sys-getgroups ()
  "
#ifndef NGROUPS
#define NGROUPS 32
#endif
  gid_t glist[NGROUPS], *pglist = glist;
  int size = NGROUPS;
  for (;;) {
    int i, n = getgroups(size, pglist);
    if (n >= 0) {
      ScmObj head = SCM_NIL, tail = SCM_NIL;
      for (i=0; i<n; i++) SCM_APPEND1(head, tail, Scm_MakeInteger(pglist[i]));
      SCM_RETURN(head);
    }
    if (errno == EINVAL) {
      size += NGROUPS;
      pglist = (gid_t *)SCM_MALLOC(size * sizeof(gid_t));
    } else {
      Scm_SysError(\"getgroups failed\");
    }
  }
  /* NOTREACHED */")

)) ;; !defined(__MINGW32__)

(define-cproc sys-getlogin ()
  (call maybe:<const-cstring> "getlogin"))

;; sys/times.h
(if "!defined(__MINGW32__)"
(define-cproc sys-times ()
  "  struct tms info;
  ScmObj h = SCM_NIL, t;
  clock_t r = times(&info);
  if (r == (clock_t)-1) Scm_SysError(\"times failed\");
  SCM_APPEND1(h, t, Scm_MakeInteger(info.tms_utime));
  SCM_APPEND1(h, t, Scm_MakeInteger(info.tms_stime));
  SCM_APPEND1(h, t, Scm_MakeInteger(info.tms_cutime));
  SCM_APPEND1(h, t, Scm_MakeInteger(info.tms_cstime));
#ifdef _SC_CLK_TCK
  SCM_APPEND1(h, t, Scm_MakeInteger(sysconf(_SC_CLK_TCK)));
#else
#ifdef CLK_TCK
  SCM_APPEND1(h, t, Scm_MakeInteger(CLK_TCK)); /* older name */
#else
  SCM_APPEND1(h, t, Scm_MakeInteger(1));  /* or maybe 100, we don't know ...*/
#endif
#endif
  SCM_RETURN(h);")
) ;; !defined(__MINGW32__)

;; sys/utsname.h
;; returns list of (sysname nodename release version machine)
(if "!defined(__MINGW32__)"
(define-cproc sys-uname ()
  "  struct utsname info;
  ScmObj head = SCM_NIL, tail;
  if (uname(&info) < 0) Scm_SysError(\"uname failed\");
  SCM_APPEND1(head, tail, SCM_MAKE_STR_COPYING(info.sysname));
  SCM_APPEND1(head, tail, SCM_MAKE_STR_COPYING(info.nodename));
  SCM_APPEND1(head, tail, SCM_MAKE_STR_COPYING(info.release));
  SCM_APPEND1(head, tail, SCM_MAKE_STR_COPYING(info.version));
  SCM_APPEND1(head, tail, SCM_MAKE_STR_COPYING(info.machine));
  return head;")
) ;; !defined(__MINGW32__)

"#ifndef HOSTNAMELEN
#define HOSTNAMELEN 1024
#endif"

(if "defined HAVE_GETHOSTNAME"
  (define-cproc %sys-gethostname ()
    (body <const-cstring>
          "char buf[HOSTNAMELEN]; int r;"
          "SCM_SYSCALL(r, gethostname(buf, HOSTNAMELEN));"
          "if (r < 0) Scm_SysError(\"gethostname failed\");"
          "SCM_RESULT = buf;"))
)    

(if "defined HAVE_GETDOMAINNAME"
  (define-cproc %sys-getdomainname ()
    (body <const-cstring>
          "char buf[HOSTNAMELEN]; int r;"
          "SCM_SYSCALL(r, getdomainname(buf, HOSTNAMELEN));"
          "if (r < 0) Scm_SysError(\"getdomainname failed\");"
          "SCM_RESULT = buf;"))
)

;; putenv
;;  Assume name and value doesn't contain NUL character.
;;  We need to call system malloc to prevent the passed string from
;;  being GCed.  That memory might be leaked when putenv is called
;;  again for the same variable, but it's the same case as in C programs.
(if "defined HAVE_PUTENV"
  (define-cproc %sys-putenv (name::<string> value::<string>)
    (body <void>
          "char *buf; int namelen, valuelen, len;"
          "namelen = SCM_STRING_SIZE(name);"
          "valuelen = SCM_STRING_SIZE(value);"
          "len = namelen + valuelen + 2;"
          "buf = (char*)malloc(len);"
          "memcpy(buf, SCM_STRING_START(name), namelen);"
          "buf[namelen] = '=';"
          "memcpy(buf+namelen+1, SCM_STRING_START(value), valuelen);"
          "buf[len-1] = '\\0';"
          "putenv(buf);"))
)

(if "defined HAVE_SETENV"
  (define-cproc %sys-setenv (name::<const-cstring>
                             value::<const-cstring>
                             overwrite::<boolean>)
    (call <void> "setenv"))
)

(if "defined HAVE_UNSETENV"
  (define-cproc %sys-unsetenv (name::<const-cstring>)
    (call <void> "unsetenv"))
)

;; ctermid
(if "!defined(__MINGW32__)"
(define-cproc sys-ctermid ()
  (body <const-cstring>
        "char buf[L_ctermid+1]; SCM_RESULT = ctermid(buf);"))
) ;; !defined(__MINGW32__)

;; chown
(if "!defined(__MINGW32__)"
(define-cproc sys-chown (path::<const-cstring> owner::<int> group::<int>)
  (body <int>
        "SCM_SYSCALL(SCM_RESULT, chown(path, owner, group));"
        "if (SCM_RESULT < 0) Scm_SysError(\"chown failed on %s\", path);"))
) ;; !defined(__MINGW32__)

;; lchown
(if "defined HAVE_LCHOWN"
(define-cproc %sys-lchown (path::<const-cstring> owner::<int> group::<int>)
  (body <int>
        "SCM_SYSCALL(SCM_RESULT, lchown(path, owner, group));"
        "if (SCM_RESULT < 0) Scm_SysError(\"lchown failed on %S\", path);"))
)

;; localeconv

; struct lconv
(define-symbol decimal_point "sym_decimal_point")
(define-symbol thousands_sep "sym_thousands_sep")
(define-symbol grouping "sym_grouping")
(define-symbol int_curr_symbol "sym_int_curr_symbol")
(define-symbol currency_symbol "sym_currency_symbol")
(define-symbol mon_decimal_point "sym_mon_decimal_point")
(define-symbol mon_thousands_sep "sym_mon_thousands_sep")
(define-symbol mon_grouping "sym_mon_grouping")
(define-symbol positive_sign "sym_positive_sign")
(define-symbol negative_sign "sym_negative_sign")
(define-symbol int_frac_digits "sym_int_frac_digits")
(define-symbol frac_digits "sym_frac_digits")
(define-symbol p_cs_precedes "sym_p_cs_precedes")
(define-symbol p_sep_by_space "sym_p_sep_by_space")
(define-symbol n_cs_precedes "sym_n_cs_precedes")
(define-symbol n_sep_by_space "sym_n_sep_by_space")
(define-symbol p_sign_posn "sym_p_sign_posn")
(define-symbol n_sign_posn "sym_n_sign_posn")

(define-cproc sys-localeconv ()
  "  struct lconv *lc = localeconv();
  ScmObj h = SCM_NIL, t = SCM_NIL;

#define APPCONS(a, b) SCM_APPEND1(h, t, Scm_Cons(a, b))

  APPCONS(sym_decimal_point, SCM_MAKE_STR_COPYING(lc->decimal_point));
  APPCONS(sym_thousands_sep, SCM_MAKE_STR_COPYING(lc->thousands_sep));
  APPCONS(sym_grouping, SCM_MAKE_STR_COPYING(lc->grouping));
  APPCONS(sym_int_curr_symbol, SCM_MAKE_STR_COPYING(lc->int_curr_symbol));
  APPCONS(sym_currency_symbol, SCM_MAKE_STR_COPYING(lc->currency_symbol));
  APPCONS(sym_mon_decimal_point, SCM_MAKE_STR_COPYING(lc->mon_decimal_point));
  APPCONS(sym_mon_thousands_sep, SCM_MAKE_STR_COPYING(lc->mon_thousands_sep));
  APPCONS(sym_mon_grouping, SCM_MAKE_STR_COPYING(lc->mon_grouping));
  APPCONS(sym_positive_sign, SCM_MAKE_STR_COPYING(lc->positive_sign));
  APPCONS(sym_negative_sign, SCM_MAKE_STR_COPYING(lc->negative_sign));
  APPCONS(sym_int_frac_digits, SCM_MAKE_INT(lc->int_frac_digits));
  APPCONS(sym_frac_digits, SCM_MAKE_INT(lc->frac_digits));
  APPCONS(sym_p_cs_precedes, SCM_MAKE_BOOL(lc->p_cs_precedes));
  APPCONS(sym_p_sep_by_space, SCM_MAKE_BOOL(lc->p_sep_by_space));
  APPCONS(sym_n_cs_precedes, SCM_MAKE_BOOL(lc->n_cs_precedes));
  APPCONS(sym_n_sep_by_space, SCM_MAKE_BOOL(lc->n_sep_by_space));
  APPCONS(sym_p_sign_posn, SCM_MAKE_INT(lc->p_sign_posn));
  APPCONS(sym_n_sign_posn, SCM_MAKE_INT(lc->n_sign_posn));
#undef APPCONS
  return h;")

;; Local variables:
;; mode: scheme
;; end:
