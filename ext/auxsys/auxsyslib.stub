;;;
;;; auxsyslib.stub - auxiliary system interface
;;;  
;;;   Copyright (c) 2000-2003 Shiro Kawai, All rights reserved.
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: auxsyslib.stub,v 1.16 2003-10-06 12:18:50 shirok Exp $
;;;

"
#include \"auxsysconf.h\"
#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif
#include <stdlib.h>
#include <math.h>
#include <locale.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/times.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <utime.h>
"

;; stdlib.h
(define-cproc sys-abort ()  (return <void> "abort"))

;; math.h
(define-cproc fmod (x::<real> y::<real>)
  "if (y == 0.0) Scm_Error(\"Attempted to divide by zero\");
  SCM_RETURN(Scm_MakeFlonum(fmod(x, y)));")

(define-cproc frexp (d::<real>)
  "  double fr; int exp;
  fr = frexp(d, &exp);
  SCM_RETURN(Scm_Values2(Scm_MakeFlonum(fr), Scm_MakeInteger(exp)));")

(define-cproc modf (x::<real>)
  "  double fr, inte;
  fr = modf(x, &inte);
  SCM_RETURN(Scm_Values2(Scm_MakeFlonum(fr), Scm_MakeFlonum(inte)));")

(define-cproc ldexp (x::<real> exp::<int>)
  (return <real> "ldexp"))

(define-cproc log10 (x::<real>)
  (return <real> "log10"))

;; sys/time.h
(if "defined HAVE_GETTIMEOFDAY"
    (define-cproc %sys-gettimeofday ()
      "struct timeval tv;
       int r = Scm_SysCall(gettimeofday(&tv, NULL));
       if (r < 0) Scm_SysError(\"gettimeofday failed\");
       SCM_RETURN(Scm_Values2(Scm_MakeInteger(tv.tv_sec), Scm_MakeInteger(tv.tv_usec)));"))

;; sys/stat.h
(define-cproc sys-mkfifo (path::<string> mode::<int>)
  "  int r = Scm_SysCall(mkfifo(Scm_GetStringConst(path), mode));
  if (r < 0) Scm_SysError(\"mkfifo failed on %S\", path);
  SCM_RETURN(Scm_MakeInteger(r));")

;; utime.h

(define-cproc sys-utime (path::<string> &optional (atime #f) (mtime #f))
  "  struct utimbuf tim; int r;
  if (SCM_FALSEP(atime)&&SCM_FALSEP(mtime)) {
    r = Scm_SysCall(utime(Scm_GetStringConst(path), NULL));
  } else {
    tim.actime  = SCM_FALSEP(atime)? time(NULL) : Scm_GetUInteger(atime);
    tim.modtime = SCM_FALSEP(mtime)? time(NULL) : Scm_GetUInteger(mtime);
    r = Scm_SysCall(utime(Scm_GetStringConst(path), &tim));
  }
  if (r < 0) Scm_SysError(\"utime failed on %S\", path);
  SCM_RETURN(SCM_UNDEFINED);")

;; set*

(define-cproc sys-setgid (gid::<int>)
  "  int r = Scm_SysCall(setgid(gid));
  if (r < 0) Scm_SysError(\"setgid failed\");
  SCM_RETURN(Scm_MakeInteger(r));")

(define-cproc sys-setpgid (pid::<int> pgid::<int>)
  "  int r = Scm_SysCall(setpgid(pid, pgid));
  if (r < 0) Scm_SysError(\"setpgid failed\");
  SCM_RETURN(Scm_MakeInteger(r));")

;; The prototype of setpgrp() differs between platforms.   Since it is
;; redundant anyway, Gauche doesn't support it.
;(if (defined? "HAVE_SETPGRP")
;    (define-cproc %sys-setpgrp ()
;      "  int r = Scm_SysCall(setpgrp());
;      if (r < 0) Scm_SysError(\"setpgrp failed\");
;      SCM_RETURN(Scm_MakeInteger(r));"))

(if "defined HAVE_GETPGID"
    (define-cproc %sys-getpgid (pid::<int>)
      "  int r = (int)Scm_SysCall(getpgid(pid));
      if (r < 0) Scm_SysError(\"getpgid failed\");
      SCM_RETURN(Scm_MakeInteger(r));"))

(define-cproc sys-getpgrp ()
  "int r = (int)Scm_SysCall(getpgrp());
  if (r < 0) Scm_SysError(\"getpgrp failed\");
  SCM_RETURN(Scm_MakeInteger(r));")

(define-cproc sys-setsid ()
  "  int r = Scm_SysCall(setsid());
  if (r < 0) Scm_SysError(\"setsid failed\");
  SCM_RETURN(Scm_MakeInteger(r));")

(define-cproc sys-setuid (uid::<int>)
  "  int r = Scm_SysCall(setuid(uid));
  if (r < 0) Scm_SysError(\"setuid failed\");
  SCM_RETURN(Scm_MakeInteger(r));")

;; some less-frequently used get-*

(define-cproc sys-getgroups ()
  "
#ifndef NGROUPS
#define NGROUPS 32
#endif
  gid_t glist[NGROUPS], *pglist = glist;
  int size = NGROUPS;
  for (;;) {
    int i, n = getgroups(size, pglist);
    if (n >= 0) {
      ScmObj head = SCM_NIL, tail = SCM_NIL;
      for (i=0; i<n; i++) SCM_APPEND1(head, tail, Scm_MakeInteger(pglist[i]));
      SCM_RETURN(head);
    }
    if (errno == EINVAL) {
      size += NGROUPS;
      pglist = (gid_t *)SCM_MALLOC(size * sizeof(gid_t));
    } else {
      Scm_SysError(\"getgroups failed\");
    }
  }
  /* NOTREACHED */")

(define-cproc sys-getlogin ()
  "  const char *p = getlogin();
  if (p) SCM_RETURN(SCM_MAKE_STR_COPYING(p));
  else SCM_RETURN(SCM_FALSE);")

;; sys/times.h
(define-cproc sys-times ()
  "  struct tms info;
  ScmObj h = SCM_NIL, t;
  clock_t r = times(&info);
  if (r == (clock_t)-1) Scm_SysError(\"times failed\");
  SCM_APPEND1(h, t, Scm_MakeInteger(info.tms_utime));
  SCM_APPEND1(h, t, Scm_MakeInteger(info.tms_stime));
  SCM_APPEND1(h, t, Scm_MakeInteger(info.tms_cutime));
  SCM_APPEND1(h, t, Scm_MakeInteger(info.tms_cstime));
#ifdef _SC_CLK_TCK
  SCM_APPEND1(h, t, Scm_MakeInteger(sysconf(_SC_CLK_TCK)));
#else
#ifdef CLK_TCK
  SCM_APPEND1(h, t, Scm_MakeInteger(CLK_TCK)); /* older name */
#else
  SCM_APPEND1(h, t, Scm_MakeInteger(1));  /* or maybe 100, we don't know ...*/
#endif
#endif
  SCM_RETURN(h);")

;; sys/utsname.h
;; returns list of (sysname nodename release version machine)
(define-cproc sys-uname ()
  "  struct utsname info;
  ScmObj head = SCM_NIL, tail;
  if (uname(&info) < 0) Scm_SysError(\"uname failed\");
  SCM_APPEND1(head, tail, SCM_MAKE_STR_COPYING(info.sysname));
  SCM_APPEND1(head, tail, SCM_MAKE_STR_COPYING(info.nodename));
  SCM_APPEND1(head, tail, SCM_MAKE_STR_COPYING(info.release));
  SCM_APPEND1(head, tail, SCM_MAKE_STR_COPYING(info.version));
  SCM_APPEND1(head, tail, SCM_MAKE_STR_COPYING(info.machine));
  return head;")

"#ifndef HOSTNAMELEN
#define HOSTNAMELEN 1024
#endif"

(if "defined HAVE_GETHOSTNAME"
    (define-cproc %sys-gethostname ()
      "  char buf[HOSTNAMELEN]; int r;
         r = Scm_SysCall(gethostname(buf, HOSTNAMELEN));
         if (r < 0) Scm_SysError(\"gethostname failed\");
         SCM_RETURN(SCM_MAKE_STR_COPYING(buf));"))

(if "defined HAVE_GETDOMAINNAME"
    (define-cproc %sys-getdomainname ()
      "  char buf[HOSTNAMELEN]; int r;
         r = Scm_SysCall(getdomainname(buf, HOSTNAMELEN));
         if (r < 0) Scm_SysError(\"getdomainname failed\");
         SCM_RETURN(SCM_MAKE_STR_COPYING(buf));"))

;; putenv
;;  Assume name and value doesn't contain NUL character.
;;  We need to call system malloc to prevent the passed string from
;;  being GCed.  That memory might be leaked when putenv is called
;;  again for the same variable, but it's the same case as in C programs.
(if "defined HAVE_PUTENV"
    (define-cproc %sys-putenv (name::<string> value::<string>)
      "  ScmObj s; char *buf; int namelen, valuelen, len;
 namelen = SCM_STRING_SIZE(name);
 valuelen = SCM_STRING_SIZE(value);
 len = namelen + valuelen + 2;
 buf = (char*)malloc(len);
 memcpy(buf, SCM_STRING_START(name), namelen);
 buf[namelen] = '=';
 memcpy(buf+namelen+1, SCM_STRING_START(value), valuelen);
 buf[len-1] = '\\0';
 putenv(buf);
 SCM_RETURN(SCM_UNDEFINED);")
)

(if "defined HAVE_SETENV"
  (define-cproc %sys-setenv (name::<string> value::<string> overwrite::<boolean>)
    "  setenv(Scm_GetStringConst(name), Scm_GetStringConst(value), overwrite);
       SCM_RETURN(SCM_UNDEFINED);"))

(if "defined HAVE_UNSETENV"
  (define-cproc %sys-unsetenv (name::<string>)
    "  unsetenv(Scm_GetStringConst(name));
       SCM_RETURN(SCM_UNDEFINED);"))

;; ctermid
(define-cproc sys-ctermid ()
  "  char buf[L_ctermid+1];
  char *r = ctermid(buf);
  SCM_RETURN(SCM_MAKE_STR_COPYING(r));")

;; chown
(define-cproc sys-chown (path::<string> owner::<int> group::<int>)
  "int r = Scm_SysCall(chown(Scm_GetStringConst(path), owner, group));
  if (r < 0) Scm_SysError(\"chown failed on %S\", path);
  SCM_RETURN(SCM_TRUE);")

;; localeconv

; struct lconv
(define-symbol decimal_point "sym_decimal_point")
(define-symbol thousands_sep "sym_thousands_sep")
(define-symbol grouping "sym_grouping")
(define-symbol int_curr_symbol "sym_int_curr_symbol")
(define-symbol currency_symbol "sym_currency_symbol")
(define-symbol mon_decimal_point "sym_mon_decimal_point")
(define-symbol mon_thousands_sep "sym_mon_thousands_sep")
(define-symbol mon_grouping "sym_mon_grouping")
(define-symbol positive_sign "sym_positive_sign")
(define-symbol negative_sign "sym_negative_sign")
(define-symbol int_frac_digits "sym_int_frac_digits")
(define-symbol frac_digits "sym_frac_digits")
(define-symbol p_cs_precedes "sym_p_cs_precedes")
(define-symbol p_sep_by_space "sym_p_sep_by_space")
(define-symbol n_cs_precedes "sym_n_cs_precedes")
(define-symbol n_sep_by_space "sym_n_sep_by_space")
(define-symbol p_sign_posn "sym_p_sign_posn")
(define-symbol n_sign_posn "sym_n_sign_posn")

(define-cproc sys-localeconv ()
  "  struct lconv *lc = localeconv();
  ScmObj h = SCM_NIL, t = SCM_NIL;

#define APPCONS(a, b) SCM_APPEND1(h, t, Scm_Cons(a, b))

  APPCONS(sym_decimal_point, SCM_MAKE_STR_COPYING(lc->decimal_point));
  APPCONS(sym_thousands_sep, SCM_MAKE_STR_COPYING(lc->thousands_sep));
  APPCONS(sym_grouping, SCM_MAKE_STR_COPYING(lc->grouping));
  APPCONS(sym_int_curr_symbol, SCM_MAKE_STR_COPYING(lc->int_curr_symbol));
  APPCONS(sym_currency_symbol, SCM_MAKE_STR_COPYING(lc->currency_symbol));
  APPCONS(sym_mon_decimal_point, SCM_MAKE_STR_COPYING(lc->mon_decimal_point));
  APPCONS(sym_mon_thousands_sep, SCM_MAKE_STR_COPYING(lc->mon_thousands_sep));
  APPCONS(sym_mon_grouping, SCM_MAKE_STR_COPYING(lc->mon_grouping));
  APPCONS(sym_positive_sign, SCM_MAKE_STR_COPYING(lc->positive_sign));
  APPCONS(sym_negative_sign, SCM_MAKE_STR_COPYING(lc->negative_sign));
  APPCONS(sym_int_frac_digits, SCM_MAKE_INT(lc->int_frac_digits));
  APPCONS(sym_frac_digits, SCM_MAKE_INT(lc->frac_digits));
  APPCONS(sym_p_cs_precedes, SCM_MAKE_BOOL(lc->p_cs_precedes));
  APPCONS(sym_p_sep_by_space, SCM_MAKE_BOOL(lc->p_sep_by_space));
  APPCONS(sym_n_cs_precedes, SCM_MAKE_BOOL(lc->n_cs_precedes));
  APPCONS(sym_n_sep_by_space, SCM_MAKE_BOOL(lc->n_sep_by_space));
  APPCONS(sym_p_sign_posn, SCM_MAKE_INT(lc->p_sign_posn));
  APPCONS(sym_n_sign_posn, SCM_MAKE_INT(lc->n_sign_posn));
#undef APPCONS
  return h;")

;; Local variables:
;; mode: scheme
;; end:
