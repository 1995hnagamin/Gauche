;;;
;;; netlib.stub - network interface
;;;  
;;;   Copyright (c) 2000-2004 Shiro Kawai, All rights reserved.
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;;  $Id: netlib.stub,v 1.28 2004-08-02 12:20:54 shirok Exp $
;;;

"#include \"gauche/net.h\"
#include <gauche/class.h>
"

(define-type <socket-address> "ScmSockAddr*" "socket address"
  "Scm_SockAddrP" "SCM_SOCKADDR")

(define-type <socket> "ScmSocket*")

;;----------------------------------------------------------
;; Socket address methods

(define-cgeneric sockaddr-name "Scm_GenericSockAddrName" (extern))
(define-cgeneric sockaddr-family "Scm_GenericSockAddrFamily" (extern))
(define-cgeneric sockaddr-addr "Scm_GenericSockAddrAddr" (extern))
(define-cgeneric sockaddr-port "Scm_GenericSockAddrPort" (extern))

(define-symbol unix "sym_unix")
(define-symbol inet "sym_inet")
(define-symbol unknown "sym_unknown")

(define-cmethod sockaddr-name ((addr "Scm_SockAddrClass"))
  "  SCM_RETURN(SCM_MAKE_STR(\"unknown\"));")

(define-cmethod sockaddr-family ((addr "Scm_SockAddrClass"))
  "  SCM_RETURN(sym_unknown);")

(define-cmethod sockaddr-name ((addr "Scm_SockAddrUnClass"))
  "  SCM_RETURN(SCM_MAKE_STR(((ScmSockAddrUn*)addr)->addr.sun_path));")

(define-cmethod sockaddr-family ((addr "Scm_SockAddrUnClass"))
  "  SCM_RETURN(sym_unix);")

(define-cmethod sockaddr-name ((addr "Scm_SockAddrInClass"))
  "  ScmSockAddrIn *a = (ScmSockAddrIn*)addr;
    ScmPort *out = SCM_PORT(Scm_MakeOutputStringPort(TRUE));
    unsigned long inaddr = htonl(a->addr.sin_addr.s_addr);

    /* NB: avoid using inet_ntoa(), which uses static buffer */
    Scm_Printf(out, \"%d.%d.%d.%d:%d\",
               ((inaddr>>24)&0xff),
               ((inaddr>>16)&0xff),
               ((inaddr>>8)&0xff),
               ((inaddr>>0)&0xff),
               ntohs(a->addr.sin_port));
    SCM_RETURN(Scm_GetOutputStringUnsafe(out));")

(define-cmethod sockaddr-family ((addr "Scm_SockAddrInClass"))
  "  SCM_RETURN(sym_inet);")

(define-cmethod sockaddr-addr ((addr "Scm_SockAddrInClass"))
  "  ScmSockAddrIn *a = (ScmSockAddrIn*)addr;
  SCM_RETURN(Scm_MakeIntegerFromUI(ntohl(a->addr.sin_addr.s_addr)));")

(define-cmethod sockaddr-port ((addr "Scm_SockAddrInClass"))
  "  ScmSockAddrIn *a = (ScmSockAddrIn*)addr;
  SCM_RETURN(Scm_MakeInteger(ntohs(a->addr.sin_port)));")

(if "defined HAVE_IPV6"
    (begin
      (define-symbol inet6 "sym_inet6")

      (define-cmethod sockaddr-name ((addr "Scm_SockAddrIn6Class"))
        "  ScmSockAddrIn6 *a = (ScmSockAddrIn6*)addr;
  ScmPort *out = SCM_PORT(Scm_MakeOutputStringPort(TRUE));
  char buf[INET6_ADDRSTRLEN];
  const char *r = inet_ntop(AF_INET6, &a->addr.sin6_addr, buf, sizeof(buf));
  if (r == NULL) Scm_SysError(\"inet_ntop\");
  Scm_Printf(out, \"[%s]:%d\", buf, ntohs(a->addr.sin6_port));
  SCM_RETURN(Scm_GetOutputStringUnsafe(out));")

      (define-cmethod sockaddr-family ((addr "Scm_SockAddrIn6Class"))
        "  SCM_RETURN(sym_inet6);")

      (define-cmethod sockaddr-addr ((addr "Scm_SockAddrIn6Class"))
        "#define BN_SIZE (16 / SIZEOF_LONG)
  ScmSockAddrIn6 *a = (ScmSockAddrIn6*)addr;
  u_long values[BN_SIZE];
  u_long *p = (u_long*)a->addr.sin6_addr.s6_addr;
  int i;
  ScmObj bn;

  for (i = 0; i < BN_SIZE; i++) values[BN_SIZE-i-1] = ntohl(*p++);
  bn = Scm_MakeBignumFromUIArray(1, values, BN_SIZE);
  SCM_RETURN(Scm_NormalizeBignum(SCM_BIGNUM(bn)));")

      (define-cmethod sockaddr-port ((addr "Scm_SockAddrIn6Class"))
        "  ScmSockAddrIn6 *a = (ScmSockAddrIn6*)addr;
  SCM_RETURN(Scm_MakeInteger(ntohs(a->addr.sin6_port)));")
      ))

;;----------------------------------------------------------
;; low-level socket routines

(define-cproc make-socket (domain::<fixnum> type::<fixnum>
                                            &optional (protocol::<fixnum> 0))
  (return "Scm_MakeSocket"))

(define-enum PF_UNSPEC)
(define-enum PF_UNIX)
(define-enum PF_INET)

(define-enum AF_UNSPEC)
(define-enum AF_UNIX)
(define-enum AF_INET)

(define-enum SOCK_STREAM)
(define-enum SOCK_DGRAM)
(define-enum SOCK_RAW)

(if "defined MSG_CTRUNC"    (define-enum MSG_CTRUNC))
(if "defined MSG_DONTROUTE" (define-enum MSG_DONTROUTE))
(if "defined MSG_EOR"       (define-enum MSG_EOR))
(if "defined MSG_OOB"       (define-enum MSG_OOB))
(if "defined MSG_PEEK"      (define-enum MSG_PEEK))
(if "defined MSG_TRUNC"     (define-enum MSG_TRUNC))
(if "defined MSG_WAITALL"   (define-enum MSG_WAITALL))

(if "defined IPPROTO_IP"   (define-enum IPPROTO_IP))
(if "defined IPPROTO_ICMP" (define-enum IPPROTO_ICMP))
(if "defined IPPROTO_TCP"  (define-enum IPPROTO_TCP))
(if "defined IPPROTO_UDP"  (define-enum IPPROTO_UDP))

(define-cproc socket-address (sock::<socket>)
  "  if (sock->address) { SCM_RETURN(SCM_OBJ(sock->address)); }
  else { SCM_RETURN(SCM_FALSE); }")

(define-symbol NONE      "sym_none")
(define-symbol BOUND     "sym_bound")
(define-symbol LISTENING "sym_listening")
(define-symbol CONNECTED "sym_connected")
(define-symbol SHUTDOWN  "sym_shutdown")
(define-symbol CLOSED    "sym_closed")

(define-cproc socket-status (sock::<socket>)
  "  switch (sock->status) {
  case SCM_SOCKET_STATUS_NONE:      SCM_RETURN(sym_none);
  case SCM_SOCKET_STATUS_BOUND:     SCM_RETURN(sym_bound);
  case SCM_SOCKET_STATUS_LISTENING: SCM_RETURN(sym_listening);
  case SCM_SOCKET_STATUS_CONNECTED: SCM_RETURN(sym_connected);
  case SCM_SOCKET_STATUS_SHUTDOWN:  SCM_RETURN(sym_shutdown);
  case SCM_SOCKET_STATUS_CLOSED:    SCM_RETURN(sym_closed);
  default: Scm_Error(\"invalid state of socket %S: implementation bugs?\",
                     sock);
           SCM_RETURN(SCM_UNDEFINED); /* dummy */
  }")

(define-cproc socket-fd (sock::<socket>)
  "  SCM_RETURN(Scm_MakeInteger(sock->fd));")

;; NB: buffered? keyword args in the following two procedures are
;; deprecated; use buffering arg.
(define-cproc socket-input-port (sock::<socket>
                                 &keyword (buffering #f) (buffered? #f))
  " int bufmode;
  if (!SCM_FALSEP(bufferedP)) { /*for backward compatibility */
    bufmode = SCM_PORT_BUFFER_FULL;
  } else {
    bufmode = Scm_BufferingMode(buffering, SCM_PORT_INPUT, SCM_PORT_BUFFER_LINE);
  }
  SCM_RETURN(Scm_SocketInputPort(sock, bufmode));")

(define-cproc socket-output-port (sock::<socket>
                                  &keyword (buffering #f) (buffered? #f))
  " int bufmode;
  if (!SCM_FALSEP(bufferedP)) { /* for backward compatibility */
    bufmode = SCM_PORT_BUFFER_FULL;
  } else {
    bufmode = Scm_BufferingMode(buffering, SCM_PORT_OUTPUT, SCM_PORT_BUFFER_LINE);
  }
  SCM_RETURN(Scm_SocketOutputPort(sock, bufmode));")

(define-cproc socket-shutdown (sock::<socket> &optional (how::<fixnum> 2))
  (return "Scm_SocketShutdown"))
  
(define-cproc socket-close (sock::<socket>)
  (return "Scm_SocketClose"))

(define-cproc socket-bind (sock::<socket> addr::<socket-address>)
  (return "Scm_SocketBind"))

(define-cproc socket-listen (sock::<socket> backlog::<fixnum>)
  (return "Scm_SocketListen"))

(define-cproc socket-accept (sock::<socket>)
  (return "Scm_SocketAccept"))

(define-cproc socket-connect (sock::<socket> addr::<socket-address>)
  (return "Scm_SocketConnect"))

(define-cproc socket-getsockname (sock::<socket>)
  (return "Scm_SocketGetSockName"))

(define-cproc socket-getpeername (sock::<socket>)
  (return "Scm_SocketGetPeerName"))

(define-cproc socket-send (sock::<socket> msg::<string>
                           &optional (flags::<fixnum> 0))
  (return "Scm_SocketSend"))

(define-cproc socket-sendto (sock::<socket> msg::<string> to::<socket-address>
                             &optional (flags::<fixnum> 0))
  (return "Scm_SocketSendTo"))

(define-cproc socket-recv (sock::<socket> bytes::<fixnum>
                           &optional (flags::<fixnum> 0))
  (return "Scm_SocketRecv"))

(define-cproc socket-recvfrom (sock::<socket> bytes::<fixnum>
                               &optional (flags::<fixnum> 0))
  (return "Scm_SocketRecvFrom"))

;; socket option interface

(define-cproc socket-setsockopt (sock::<socket>
                                 level::<fixnum> option::<fixnum> value)
  (return "Scm_SocketSetOpt"))

(define-cproc socket-getsockopt (sock::<socket>
                                 level::<fixnum> option::<fixnum>
                                 rsize::<fixnum>)
  (return "Scm_SocketGetOpt"))

;;----------------------------------------------------------
;; netdb routines

(define-cproc sys-gethostbyname (name::<string>)
  "  SCM_RETURN(Scm_GetHostByName(Scm_GetStringConst(name)));")

(define-cproc sys-gethostbyaddr (addr::<string> type::<fixnum>)
  "  SCM_RETURN(Scm_GetHostByAddr(Scm_GetStringConst(addr), type));")

(define-cproc sys-getprotobyname (name::<string>)
  "  SCM_RETURN(Scm_GetProtoByName(Scm_GetStringConst(name)));")

(define-cproc sys-getprotobynumber (number::<fixnum>)
  "  SCM_RETURN(Scm_GetProtoByNumber(number));")

(define-cproc sys-getservbyname (name::<string> proto::<string>)
  "  SCM_RETURN(Scm_GetServByName(Scm_GetStringConst(name), Scm_GetStringConst(proto)));")

(define-cproc sys-getservbyport (port::<fixnum> proto::<string>)
  "  SCM_RETURN(Scm_GetServByPort(port, Scm_GetStringConst(proto)));")

;;----------------------------------------------------------
;; IPv6 routines

"extern ScmObj addrinfo_allocate(ScmClass *klass, ScmObj initargs);"

(if "defined HAVE_IPV6"
    (begin
      (define-type <sys-addrinfo> "ScmSysAddrinfo*" #f
        "SCM_SYS_ADDRINFO_P" "SCM_SYS_ADDRINFO")

      (define-cclass <sys-addrinfo>
        "ScmSysAddrinfo*" "Scm_SysAddrinfoClass"
        ()
        ((flags :type <int>)
         (family :type <int>)
         (socktype :type <int>)
         (protocol :type <int>)
         (addrlen :type <uint32>)
         (canonname :type <string>)
         (addr :setter "  if (!SCM_SOCKADDRP(value)) Scm_Error(\"ScmSockAddr* required, but got %S\", value);
  obj->addr = SCM_SOCKADDR(value);"))
        (allocator (c "addrinfo_allocate")))

      (define-cproc sys-getaddrinfo (nodename servname hints)
        "  struct addrinfo ai;
  if (!SCM_STRINGP(nodename) && !SCM_FALSEP(nodename))
    Scm_Error(\"string or #f required, but got %S\", nodename);
  if (!SCM_STRINGP(servname) && !SCM_FALSEP(servname))
    Scm_Error(\"string or #f required, but got %S\", servname);
  if (!SCM_SYS_ADDRINFO_P(hints) && !SCM_FALSEP(hints))
    Scm_Error(\"<sys-addrinfo> or #f required, but got %S\", hints);
  if (!SCM_FALSEP(hints)) {
    memset(&ai, 0, sizeof(ai));
    ai.ai_flags = SCM_SYS_ADDRINFO(hints)->flags;
    ai.ai_family = SCM_SYS_ADDRINFO(hints)->family;
    ai.ai_socktype = SCM_SYS_ADDRINFO(hints)->socktype;
    ai.ai_protocol = SCM_SYS_ADDRINFO(hints)->protocol;
  }
  SCM_RETURN(Scm_GetAddrinfo(SCM_FALSEP(nodename) ? NULL : Scm_GetStringConst(SCM_STRING(nodename)),
                             SCM_FALSEP(servname) ? NULL : Scm_GetStringConst(SCM_STRING(servname)),
                             SCM_FALSEP(hints) ? NULL : &ai));")

      (define-cproc sys-getnameinfo (addr::<socket-address> &optional flags::<fixnum>)
        "  SCM_RETURN(Scm_GetNameinfo(addr, flags));")
      ))

(if "defined AF_INET6" (define-enum AF_INET6))
(if "defined PF_INET6" (define-enum PF_INET6))

(if "defined IPPROTO_IPV6" (define-enum IPPROTO_IPV6))
(if "defined IPV6_UNICAST_HOPS" (define-enum IPV6_UNICAST_HOPS))
(if "defined IPV6_MULTICAST_IF" (define-enum IPV6_MULTICAST_IF))
(if "defined IPV6_MULTICAST_HOPS" (define-enum IPV6_MULTICAST_HOPS))
(if "defined IPV6_MULTICAST_LOOP" (define-enum IPV6_MULTICAST_LOOP))
(if "defined IPV6_JOIN_GROUP" (define-enum IPV6_JOIN_GROUP))
(if "defined IPV6_LEAVE_GROUP" (define-enum IPV6_LEAVE_GROUP))
(if "defined IPV6_V6ONLY" (define-enum IPV6_V6ONLY))

(if "defined AI_PASSIVE" (define-enum AI_PASSIVE))
(if "defined AI_CANONNAME" (define-enum AI_CANONNAME))
(if "defined AI_NUMERICHOST" (define-enum AI_NUMERICHOST))
(if "defined AI_NUMERICSERV" (define-enum AI_NUMERICSERV))
(if "defined AI_V4MAPPED" (define-enum AI_V4MAPPED))
(if "defined AI_ALL" (define-enum AI_ALL))
(if "defined AI_ADDRCONFIG" (define-enum AI_ADDRCONFIG))

(if "defined NI_NOFQDN" (define-enum NI_NOFQDN))
(if "defined NI_NUMERICHOST" (define-enum NI_NUMERICHOST))
(if "defined NI_NAMEREQD" (define-enum NI_NAMEREQD))
(if "defined NI_NUMERICSERV" (define-enum NI_NUMERICSERV))
(if "defined NI_DGRAM" (define-enum NI_DGRAM))

;; Local variables:
;; mode: scheme
;; end:
