/*
 * uvectorP.h - internal macros for the uniform vector module
 *
 *  Copyright(C) 2001 by Shiro Kawai (shiro@acm.org)
 *
 *  Permission to use, copy, modify, distribute this software and
 *  accompanying documentation for any purpose is hereby granted,
 *  provided that existing copyright notices are retained in all
 *  copies and that this notice is included verbatim in all
 *  distributions.
 *  This software is provided as is, without express or implied
 *  warranty.  In no circumstances the author(s) shall be liable
 *  for any damages arising out of the use of this software.
 *
 *  This file is automatically generated.  DO NOT EDIT.
 *  $Id: uvectorP.h,v 1.4 2002-02-11 10:06:15 shirok Exp $
 */

#ifndef GAUCHE_UVECTOR_P_H
#define GAUCHE_UVECTOR_P_H

#define SCM_S8VECTOR_BOX(obj, elt)    (obj) = SCM_MAKE_INT(elt)
#define SCM_S8VECTOR_UNBOX(elt, obj)                                       \
    do {                                                                   \
        int v;                                                             \
        if (!SCM_INTP(obj)) Scm_Error("argument out of domain: %S", obj);  \
        v = SCM_INT_VALUE(obj);                                            \
        if (v < -128 || v > 127)                                           \
            Scm_Error("argument out of bound: %d", v);                     \
        elt = (signed char)v;                                              \
    } while (0)
#define SCM_S8VECTOR_PRINT_ELT(out, elt)    Scm_Printf(out, "%d", elt)
#define SCM_S8VECTOR_EQUAL_ELT(x, y)      ((x)==(y))

#define SCM_U8VECTOR_BOX(obj, elt)    (obj) = SCM_MAKE_INT(elt)
#define SCM_U8VECTOR_UNBOX(elt, obj)                                       \
    do {                                                                   \
        int v;                                                             \
        if (!SCM_INTP(obj)) Scm_Error("argument out of domain: %S", obj);  \
        v = SCM_INT_VALUE(obj);                                            \
        if (v < 0 || v > 255)                                              \
            Scm_Error("argument out of bound: %d", v);                     \
        elt = (unsigned char)v;                                            \
    } while (0)
#define SCM_U8VECTOR_PRINT_ELT(out, elt)    Scm_Printf(out, "%u", elt)
#define SCM_U8VECTOR_EQUAL_ELT(x, y)      ((x)==(y))

#define SCM_S16VECTOR_BOX(obj, elt)    (obj) = SCM_MAKE_INT(elt)
#define SCM_S16VECTOR_UNBOX(elt, obj)                                      \
    do {                                                                   \
        int v;                                                             \
        if (!SCM_INTP(obj)) Scm_Error("argument out of domain: %S", obj);  \
        v = SCM_INT_VALUE(obj);                                            \
        if (v < -32768 || v > 32767)                                       \
            Scm_Error("argument out of bound: %d", v);                     \
        elt = (short)v;                                                    \
    } while (0)
#define SCM_S16VECTOR_PRINT_ELT(out, elt)   Scm_Printf(out, "%d", elt)
#define SCM_S16VECTOR_EQUAL_ELT(x, y)      ((x)==(y))

#define SCM_U16VECTOR_BOX(obj, elt)    (obj) = SCM_MAKE_INT(elt)
#define SCM_U16VECTOR_UNBOX(elt, obj)                                      \
    do {                                                                   \
        int v;                                                             \
        if (!SCM_INTP(obj)) Scm_Error("argument out of domain: %S", obj);  \
        v = SCM_INT_VALUE(obj);                                            \
        if (v < 0 || v > 65536)                                            \
            Scm_Error("argument out of bound: %d", v);                     \
        elt = (unsigned short)v;                                           \
    } while (0)
#define SCM_U16VECTOR_PRINT_ELT(out, elt)   Scm_Printf(out, "%u", elt)
#define SCM_U16VECTOR_EQUAL_ELT(x, y)      ((x)==(y))


#define SCM_BIGNUM_BETWEEN(obj1, obj2, obj3)                            \
    ((Scm_BignumCmp(SCM_BIGNUM(obj1), SCM_BIGNUM(obj2)) <= 0) &&        \
     (Scm_BignumCmp(SCM_BIGNUM(obj2), SCM_BIGNUM(obj3)) <= 0))

#define SCM_S32VECTOR_BOX(obj, elt)    (obj) = Scm_MakeInteger(elt)

static inline SCM_UVECTOR_INT32 scm_s32vector_unbox(ScmObj obj)
{
    static ScmObj s32_min = SCM_NIL;
    static ScmObj s32_max = SCM_NIL;

    if (SCM_NULLP(s32_min) || SCM_NULLP(s32_max)) {
        ScmBignum *one = SCM_BIGNUM(Scm_MakeBignumFromSI(1));
        ScmBignum *exp = SCM_BIGNUM(Scm_BignumAsh(one, 31));

        s32_min = Scm_BignumNegate(exp);
        s32_max = Scm_BignumSubSI(exp, 1);
    }

    if (SCM_INTP(obj)) {
        return SCM_INT_VALUE(obj);
    } else if(SCM_BIGNUMP(obj) && SCM_BIGNUM_BETWEEN(s32_min, obj, s32_max)) {
        return (SCM_UVECTOR_INT32)Scm_BignumToSI(SCM_BIGNUM(obj));
    } else {
        Scm_Error("argument out of domain: %S", obj);
    }
}
#define SCM_S32VECTOR_UNBOX(elt, obj) (elt) = scm_s32vector_unbox(obj)
#define SCM_S32VECTOR_PRINT_ELT(out, elt)  Scm_Printf(out, "%d", elt)
#define SCM_S32VECTOR_EQUAL_ELT(x, y)      ((x)==(y))


#define SCM_U32VECTOR_BOX(obj, elt)             \
    do {                                        \
       if (elt <= SCM_SMALL_INT_MAX) {          \
           (obj) = Scm_MakeInteger(elt);        \
       } else {                                 \
           (obj) = Scm_MakeBignumFromUI(elt);   \
       }                                        \
    } while (0)

static inline SCM_UVECTOR_UINT32 scm_u32vector_unbox(ScmObj obj)
{
    static ScmObj u32_min = SCM_NIL;
    static ScmObj u32_max = SCM_NIL;

    if (SCM_NULLP(u32_min) || SCM_NULLP(u32_max)) {
        ScmBignum *one = SCM_BIGNUM(Scm_MakeBignumFromSI(1));
        ScmBignum *exp = SCM_BIGNUM(Scm_BignumAsh(one, 32));

        u32_min = Scm_MakeBignumFromSI(0);
        u32_max = Scm_BignumSubSI(exp, 1);
    }

    if (SCM_INTP(obj) && SCM_INT_VALUE(obj) >= 0) {
        return SCM_INT_VALUE(obj);
    } else if(SCM_BIGNUMP(obj) && SCM_BIGNUM_BETWEEN(u32_min, obj, u32_max)) {
        return (SCM_UVECTOR_UINT32)Scm_BignumToUI(SCM_BIGNUM(obj));
    } else {
        Scm_Error("argument out of domain: %S", obj);
    }
}
#define SCM_U32VECTOR_UNBOX(elt, obj) (elt) = scm_u32vector_unbox(obj)
#define SCM_U32VECTOR_PRINT_ELT(out, elt)   Scm_Printf(out, "%u", elt)
#define SCM_U32VECTOR_EQUAL_ELT(x, y)      ((x)==(y))

#if SIZEOF_LONG >= 8
#define SCM_S64VECTOR_BOX(obj, elt)    (obj) = Scm_MakeInteger(elt)

static inline SCM_UVECTOR_INT64 scm_s64vector_unbox(ScmObj obj)
{
    ScmObj s64_min = SCM_NIL;
    ScmObj s64_max = SCM_NIL;

    if (SCM_NULLP(s64_min) || SCM_NULLP(s64_max)) {
        ScmBignum *one = SCM_BIGNUM(Scm_MakeBignumFromSI(1));
        ScmBignum *exp = SCM_BIGNUM(Scm_BignumAsh(one, 63));
        s64_min = Scm_BignumNegate(exp);
        s64_max = Scm_BignumSubSI(exp, 1);
    }

    if (SCM_INTP(obj)) {
        return SCM_INT_VALUE(obj);
    } else if (SCM_BIGNUMP(obj) && SCM_BIGNUM_BETWEEN(s64_min, obj, s64_max)) {
        return (SCM_UVECTOR_INT64)Scm_BignumToSI(SCM_BIGNUM(obj));
    } else {
        Scm_Error("argument out of domain: %S", obj);
    }
}
#define SCM_S64VECTOR_UNBOX(elt, obj) (elt) = scm_s64vector_unbox(obj)
#define SCM_S64VECTOR_PRINT_ELT(out, elt)  Scm_Printf(out, "%ld", elt)
#define SCM_S64VECTOR_EQUAL_ELT(x, y)      ((x)==(y))
#else /* assuming SIZEOF_LONG == 4 */

static inline int valid_int64(ScmObj obj)
{
    if (SCM_BIGNUMP(obj)) {
        if (!((SCM_BIGNUM(obj)->size <= 8/SIZEOF_LONG)
               || (SCM_BIGNUM(obj)->sign < 0
                   && SCM_BIGNUM(obj)->size == 8/SIZEOF_LONG + 1
                   && SCM_BIGNUM(obj)->values[8/SIZEOF_LONG + 1] == 1)))
            return FALSE;
        else
            return TRUE;
    } else if (SCM_INTP(obj)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

#define SCM_S64VECTOR_BOX(obj, elt)    (obj) = (elt)
#define SCM_S64VECTOR_UNBOX(elt, obj)                                   \
    do {                                                                \
        if (!valid_int64(obj))                                          \
            Scm_Error("argument out of domain: %S", obj);               \
        elt = obj;                                                      \
    } while (0)
#define SCM_S64VECTOR_PRINT_ELT(out, elt)  Scm_Printf(out, "%S", elt)
#define SCM_S64VECTOR_EQUAL_ELT(x, y)      Scm_NumEq(x, y)
#endif


#if SIZEOF_LONG >= 8
#define SCM_U64VECTOR_BOX(obj, elt)    (obj) = Scm_MakeIntegerFromUI(elt)

static inline SCM_UVECTOR_UINT64 scm_u64vector_unbox(ScmObj obj)
{
    ScmObj u64_min = SCM_NIL;
    ScmObj u64_max = SCM_NIL;

    if (SCM_NULLP(u64_min) || SCM_NULLP(u64_max)) {
        ScmBignum *one = SCM_BIGNUM(Scm_MakeBignumFromSI(1));
        ScmBignum *exp = SCM_BIGNUM(Scm_BignumAsh(one, 64));
        u64_min = Scm_MakeBignumFromSI(0);
        u64_max = Scm_BignumSubSI(exp, 1);
    }

    if (SCM_INTP(obj) && SCM_INT_VALUE(obj) >= 0) {
        return SCM_INT_VALUE(obj);
    } else if (SCM_BIGNUMP(obj) && SCM_BIGNUM_BETWEEN(u64_min, obj, u64_max)) {
        return (SCM_UVECTOR_UINT64)Scm_BignumToUI(SCM_BIGNUM(obj));
    } else {
        Scm_Error("argument out of domain: %S", obj);
    }
}
#define SCM_U64VECTOR_UNBOX(elt, obj) (elt) = scm_u64vector_unbox(obj)
#define SCM_U64VECTOR_PRINT_ELT(out, elt)  Scm_Printf(out, "%lu", elt)
#define SCM_U64VECTOR_EQUAL_ELT(x, y)      ((x)==(y))
#else /* assuming SIZEOF_LONG == 4 */

static inline int valid_uint64(ScmObj obj)
{
    if (SCM_BIGNUMP(obj)) {
        if (SCM_BIGNUM(obj)->sign < 0) return FALSE;
        if (SCM_BIGNUM(obj)->size > 8/SIZEOF_LONG) return FALSE;
        return TRUE;
    } else if (SCM_INTP(obj)) {
        if (SCM_INT_VALUE(obj) < 0) return FALSE;
        return TRUE;
    } else {
        return FALSE;
    }
}

#define SCM_U64VECTOR_BOX(obj, elt)    (obj) = (elt)
#define SCM_U64VECTOR_UNBOX(elt, obj)                                   \
    do {                                                                \
        if (!valid_uint64(obj))                                         \
            Scm_Error("argument out of domain: %S", obj);               \
        elt = obj;                                                      \
    } while (0)
#define SCM_U64VECTOR_PRINT_ELT(out, elt)  Scm_Printf(out, "%S", elt)
#define SCM_U64VECTOR_EQUAL_ELT(x, y)      Scm_NumEq(x, y)
#endif


#define SCM_F32VECTOR_BOX(obj, elt)  (obj) = Scm_MakeFlonum((double)elt)
#define SCM_F32VECTOR_UNBOX(elt, obj)                                   \
    do {                                                                \
        float v;                                                        \
        if (SCM_FLONUMP(obj)) v = (float)SCM_FLONUM_VALUE(obj);         \
        else if (SCM_INTP(obj)) v = (float)SCM_INT_VALUE(obj);          \
        else if (SCM_BIGNUMP(obj)) v = Scm_BignumToDouble(SCM_BIGNUM(obj)); \
        else Scm_Error("argument out of domain: %S", obj);              \
        elt = v;                                                        \
    } while (0)
#define SCM_F32VECTOR_PRINT_ELT(out, elt)   Scm_Printf(out, "%f", elt)
#define SCM_F32VECTOR_EQUAL_ELT(x, y)      ((x)==(y))


#define SCM_F64VECTOR_BOX(obj, elt)  (obj) = Scm_MakeFlonum(elt)
#define SCM_F64VECTOR_UNBOX(elt, obj)                                   \
    do {                                                                \
        double v;                                                       \
        if (SCM_FLONUMP(obj)) v = SCM_FLONUM_VALUE(obj);                \
        else if (SCM_INTP(obj)) v = (double)SCM_INT_VALUE(obj);         \
        else if (SCM_BIGNUMP(obj)) v = Scm_BignumToDouble(SCM_BIGNUM(obj)); \
        else Scm_Error("argument out of domain: %S", obj);              \
        elt = v;                                                        \
    } while (0)
#define SCM_F64VECTOR_PRINT_ELT(out, elt)   Scm_Printf(out, "%lf", elt)
#define SCM_F64VECTOR_EQUAL_ELT(x, y)      ((x)==(y))

#endif /* GAUCHE_UVECTOR_P_H */
