;;
;;  Generate uvutil.c
;;  $Id: uvutil.c.scm,v 1.1 2002-06-18 09:20:05 shirok Exp $

(use srfi-13)
(define (pr . args)
  (for-each print args))

;;==========================================================
;; prologue
;;

(pr
 "/*"
 " * uvutil - additional uniform vector utilities"
 " *"
 " *  Copyright(C) 2002 by Shiro Kawai (shiro@acm.org)"
 " *"
 " *  Permission to use, copy, modify, distribute this software and"
 " *  accompanying documentation for any purpose is hereby granted,"
 " *  provided that existing copyright notices are retained in all"
 " *  copies and that this notice is included verbatim in all"
 " *  distributions."
 " *  This software is provided as is, without express or implied"
 " *  warranty.  In no circumstances the author(s) shall be liable"
 " *  for any damages arising out of the use of this software."
 " *"
 " * This file is automatically generated from uvutil.c.scm"
 " * $Id: uvutil.c.scm,v 1.1 2002-06-18 09:20:05 shirok Exp $"
 " */"
 ""
 "#include <stdlib.h>"
 "#include <math.h>"
 "#include <limits.h>"
 "#include <string.h>  /* for memcpy() */"
 "#include <gauche.h>"
 "#include <gauche/extend.h>"
 "#include \"gauche/uvector.h\""
 "#include \"gauche/arith.h\""
 "#include \"uvectorP.h\""
 ""
 "#define SIZECHK(d, a, b)                                        \\"
 "  do {                                                          \\"
 "    if ((a)->size != (b)->size) {                               \\"
 "      Scm_Error(\"Vector size doesn't match: %S and %S\", a, b);  \\"
 "    }                                                           \\"
 "  SCM_ASSERT((a)->size == (d)->size);                         \\"
 "  } while (0)"
 ""
 ;; Common overflow handler
 "static void uvoverflow(void)"
 "{"
 "  Scm_Error(\"uniform vector operation overflow\");"
 "}"
 ""
 ;; u_long multiplier
 "static u_long umul(u_long x, u_long y, int clamp)"
 "{"
 "  u_long r;"
 "  if (x==0 || y==0) return 0;"
 "  r = x*y;"
 "  if (r<x || r<y) {"
 "    if (clamp) return SCM_ULONG_MAX;"
 "    else uvoverflow();"
 "  }"
 "  return r;"
 "}"
 ""
 )

;;=================================================================
;; Template for binary operation
;;

(define (emit-binop vecttype itemtype opname calctype)
  (let* ((|VECTTYPE| (string-upcase vecttype)))
    (pr
     #`"ScmObj Scm_,|vecttype|,|opname|(Scm,|vecttype| *dst,"
     #`"                                Scm,|vecttype| *v0,"
     #`"                                ScmObj operand,"
     #`"                                int clamp)"
     #`"{"
     #`"    int i, size = v0->size;"
     #`"    ,|calctype| k;"
     #`"    if (SCM_,|VECTTYPE|P(operand)) {"
     #`"        Scm,|vecttype| *v1 = SCM_,|VECTTYPE|(operand);"
     #`"        SIZECHK(dst, v0, v1);"
     #`"        for (i=0; i<size; i++) {"
     #`"            OPERATE(k, v0->elements[i], v1->elements[i]);"
     #`"            dst->elements[i] = (,|itemtype|)k;"
     #`"        }"
     #`"    } else {"
     #`"        ,|itemtype| e1;"
     #`"        SCM_ASSERT(dst->size == v0->size);"
     #`"        SCM_,|VECTTYPE|_UNBOX(e1, operand);"
     #`"        for (i=0; i<size; i++) {"
     #`"             OPERATE(k, v0->elements[i], e1);"
     #`"             dst->elements[i] = (,|itemtype|)k;"
     #`"        }"
     #`"    }"
     #`"    return SCM_OBJ(dst);"
     #`"}")))

;; handle overflow or underflow
(define (overflow maxval)
  #`"do { if (!(clamp&SCM_UVECTOR_CLAMP_HI)) uvoverflow(); (k)=,|maxval|; } while (0)")

(define (underflow minval)
  #`"do { if (!(clamp&SCM_UVECTOR_CLAMP_LO)) uvoverflow(); (k)=,|minval|; } while (0)")

;; Common part for s8, u8, s16, u16vector.
;; Can be used for s32 and u32 vector on 64bit architecture.
(define (emit-small-binop vecttype itemtype opname calctype op minval maxval)
  (pr
   #`"#define OPERATE(k, e0, e1)                         \\"
   #`"    (k) = (e0) ,|op| (e1);                         \\"
   #`"    if ((k) < ,|minval|)      ,(underflow minval); \\"
   #`"    else if ((k) > ,|maxval|) ,(overflow maxval);"
   )
  (emit-binop vecttype itemtype opname calctype)
  (pr "#undef OPERATE"))

(define (emit-noclamp-binop vecttype itemtype opname calctype op)
  (pr
   #`"#define OPERATE(k, e0, e1) (k) = (e0) ,|op| (e1)")
  (emit-binop vecttype itemtype opname calctype)
  (pr "#undef OPERATE"))

(define (emit-small-ops vecttype itemtype minval maxval)
  (emit-small-binop vecttype itemtype "Add" "int" "+" minval maxval)
  (emit-small-binop vecttype itemtype "Sub" "int" "-" minval maxval)
  (emit-small-binop vecttype itemtype "Mul" "int" "*" minval maxval)
  (emit-small-binop vecttype itemtype "Div" "int" "/" minval maxval)
  (emit-noclamp-binop vecttype itemtype "Mod" "int" "%")
  (emit-noclamp-binop vecttype itemtype "And" "int" "&")
  (emit-noclamp-binop vecttype itemtype "Ior" "int" "|")
  (emit-noclamp-binop vecttype itemtype "Xor" "int" "^")
  )

(emit-small-ops "S8Vector" "signed char"       -128    127)
(emit-small-ops "U8Vector" "unsigned char"        0    255)
(emit-small-ops "S16Vector" "signed short"   -32768  32767)
(emit-small-ops "U16Vector" "unsigned short"      0  65535)

;; Operation on the machine-word-size value.
;; Special treatment is required to detect overflow and underflow.
;; These are so terrible.
(define (add-signed-words)
  (define (over)  (overflow "LONG_MAX"))
  (define (under) (underflow "LONG_MIN"))

  (pr
   "#define OPERATE(k, e0, e1)                     \\"
   "  do { long V0 = (e0), V1= (e1);               \\"
   "    (k) = V0 + V1;                             \\"
   "    if (V0 >= 0) {                             \\"
   "       if (V1 >= 0) {                          \\"
   #`"       if ((k) < V0) ,(over);                \\"
   "       }                                       \\"
   "    } else {                                   \\"
   "       if (V1 < 0) {                           \\"
   #`"       if ((k) >= V0) ,(under);              \\"
   "       }                                       \\"
   "    }                                          \\"
   "  } while (0)"))

(define (sub-signed-words)
  (define (over)  (overflow "LONG_MAX"))
  (define (under) (underflow "LONG_MIN"))

  (pr
   "#define OPERATE(k, e0, e1)                     \\"
   "  do { long V0 = (e0), V1 = (e1);              \\"
   "    (k) = V0 - V1;                             \\"
   "    if (V0 >= 0) {                             \\"
   "       if (V1 < 0) {                           \\"
   #`"       if ((k) < V0) ,(over);                \\"
   "       }                                       \\"
   "    } else {                                   \\"
   "       if (V1 > 0) {                           \\"
   #`"       if ((k) >= V0) ,(under);              \\"
   "       }                                       \\"
   "    }                                          \\"
   "  } while (0)"))

(define (mul-signed-words)
  (define (over)  (overflow "LONG_MAX"))
  (define (under) (underflow "LONG_MIN"))

  (pr
   "#define OPERATE(k, e0, e1)                     \\"
   "  do { long V0 = (e0), V1 = (e1);              \\"
   "    u_long kr;                                 \\"
   "    if (V0 >= 0) {                             \\"
   "      if (V1 >= 0) {                           \\"
   "        kr = umul(V0, V1, (clamp&SCM_UVECTOR_CLAMP_HI));\\"
   #`"      if (kr > LONG_MAX) ,(over);            \\"
   "        else (k) = kr;                         \\"
   "      } else {                                 \\"
   "        kr = umul(V0, -V1, (clamp&SCM_UVECTOR_CLAMP_LO));\\"
   #`"      if (kr > LONG_MAX+1UL) ,(under);       \\"
   "        else (k) = -kr;                        \\"
   "      }                                        \\"
   "    } else {                                   \\"
   "      if (V1 >= 0) {                           \\"
   "        kr = umul(-V0, V1, (clamp&SCM_UVECTOR_CLAMP_LO));\\"
   #`"      if (kr > LONG_MAX+1UL) ,(under);       \\"
   "        else (k) = -kr;                        \\"
   "      } else {                                 \\"
   "        kr = umul(-V0, -V1, (clamp&SCM_UVECTOR_CLAMP_HI));\\"
   #`"      if (kr > LONG_MAX) ,(over);            \\"
   "        else (k) = kr;                         \\"
   "      }                                        \\"
   "    }                                          \\"
   "  } while (0)"))

(define (div-signed-words)
  (pr
   "#define OPERATE(k, e0, e1)                     \\"
   "  do { long V0 = (e0), V1 = (e1);              \\"
   "    if ((V0 == LONG_MIN && V1 == -1)           \\"
   "        || (V1 == LONG_MIN && V0 == -1)) {     \\"
   #`"    ,(overflow 'LONG_MAX);                   \\"
   "    }                                          \\"
   "    (k) = V0/V1;                               \\"
   "  } while (0)"))

;; s32 vector.  
(define (emit-s32-ops)
  (define int32min -2147483648)
  (define int32max 2147483647)
  ;; on 64bit architecture, overflow detection is simple.
  (print "#if SIZEOF_LONG >= 8")
  (letrec ((emit-op
            (lambda (name op)
              (emit-small-binop "S32Vector" "int" name "long" op
                                int32min int32max)))
           (emit-op-noclamp
            (lambda (name op)
              (emit-noclamp-binop "S32Vector" "int" name "long" op))))
              
    (emit-op "Add" "+")
    (emit-op "Sub" "-")
    (emit-op "Mul" "*")
    (emit-op "Div" "/")
    (emit-op-noclamp "Mod" "%")
    (emit-op-noclamp "And" "&")
    (emit-op-noclamp "Ior" "|")
    (emit-op-noclamp "Xor" "^"))
  (print "#else /*SIZEOF_LONG == 4*/")
  ;; on 32bit architecture, needs some hack to detect overflow.
  (add-signed-words)
  (emit-binop "S32Vector" "long" "Add" "long")
  (pr "#undef OPERATE")

  (sub-signed-words)
  (emit-binop "S32Vector" "long" "Sub" "long")
  (pr "#undef OPERATE")

  (mul-signed-words)
  (emit-binop "S32Vector" "long" "Mul" "long")
  (pr "#undef OPERATE")

  (div-signed-words)
  (emit-binop "S32Vector" "long" "Div" "long")
  (pr "#undef OPERATE")

  (emit-noclamp-binop "S32Vector" "long" "Mod" "long" "%")
  (emit-noclamp-binop "S32Vector" "long" "And" "long" "&")
  (emit-noclamp-binop "S32Vector" "long" "Ior" "long" "|")
  (emit-noclamp-binop "S32Vector" "long" "Xor" "long" "^")

  (print "#endif /*SIZEOF_LONG == 4 */")
  )

;; u32 vector
(define (emit-u32-ops)
  (define uint32max "4294967295UL")
  ;; on 64bit architecture, overflow detection is simple.
  (print "#if SIZEOF_LONG >= 8")
  (letrec ((emit-op
            (lambda (name op)
              (emit-small-binop "U32Vector" "int" name "long" op
                                0 uint32max)))
           (emit-op-noclamp
            (lambda (name op)
              (emit-noclamp-binop "U32Vector" "int" name "long" op))))
              
    (emit-op "Add" "+")
    (emit-op "Sub" "-")
    (emit-op "Mul" "*")
    (emit-op "Div" "/")
    (emit-op-noclamp "Mod" "%")
    (emit-op-noclamp "And" "&")
    (emit-op-noclamp "Ior" "|")
    (emit-op-noclamp "Xor" "^"))
  (print "#else /*SIZEOF_LONG == 4*/")
  ;; on 32bit architecture, needs some hack to detect overflow.
  (pr "#define OPERATE(k, e0, e1)                \\"
      "  do { u_long V0 = (e0), V1 = (e1), C = 0;\\"
      "    UADD(k, C, V0, V1);                   \\"
      #`"  if (C) ,(overflow uint32max);         \\"
      "  } while (0)")
  (emit-binop "U32Vector" "long" "Add" "u_long")
  (pr "#undef OPERATE")

  (pr "#define OPERATE(k, e0, e1)                \\"
      "  do { u_long V0 = (e0), V1 = (e1), C = 0;\\"
      "    USUB(k, C, V0, V1);                   \\"
      #`"  if (C) ,(overflow uint32max);         \\"
      "  } while (0)")
  (emit-binop "U32Vector" "long" "Sub" "u_long")
  (pr "#undef OPERATE")

  (pr "#define OPERATE(k, e0, e1)                \\"
      "  do { u_long V0 = (e0), V1 = (e1), hi, lo; \\"
      "    UMUL(hi, lo, V0, V1);                 \\"
      #`"  if (hi) ,(overflow uint32max);        \\"
      "    else (k) = lo;                        \\"
      "  } while (0)")
  (emit-binop "U32Vector" "long" "Mul" "u_long")
  (pr "#undef OPERATE")

  (emit-noclamp-binop "U32Vector" "long" "Div" "u_long" "/")
  (emit-noclamp-binop "U32Vector" "long" "Mod" "u_long" "%")
  (emit-noclamp-binop "U32Vector" "long" "And" "u_long" "&")
  (emit-noclamp-binop "U32Vector" "long" "Ior" "u_long" "|")
  (emit-noclamp-binop "U32Vector" "long" "Xor" "u_long" "^")

  (print "#endif /*SIZEOF_LONG == 4 */")
  )


(emit-s32-ops)
(emit-u32-ops)
