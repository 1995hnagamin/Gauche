;;;
;;; intlib.stub - internal built-ins
;;;  
;;;   Copyright (c) 2000-2005 Shiro Kawai, All rights reserved.
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: intlib.stub,v 1.6 2005-05-22 11:00:22 shirok Exp $
;;;

;; This file defines subrs that are used by Gauche internal routines
;; (such as the compiler).  They are interned in gauche.internal module.
;; The API in this module is still fluid.  Do not count on them.


"
#include <gauche/class.h>
#include <gauche/code.h>
#include <gauche/vminsn.h>
#include <gauche/macro.h>
#include <gauche/prof.h>
#include <gauche/builtin-syms.h>
"

;;
;; Pair attributes
;;
;;  Pair attributes are almost exclusively used to attach source-code
;;  information to s-exprs.

(define-cproc pair-attributes (pair::<pair>)
  (return "Scm_PairAttr"))

(define-cproc pair-attribute-get (pair::<pair> key &optional fallback)
  "  SCM_RETURN(Scm_PairAttrGet(SCM_PAIR(pair), key, fallback));")

(define-cproc pair-attribute-set! (pair::<pair> key value)
  "  SCM_RETURN(Scm_PairAttrSet(SCM_PAIR(pair), key, value));")

(define-cproc extended-pair? (obj)
  (return <boolean> "SCM_EXTENDED_PAIR_P"))

(define-cproc extended-cons (car cdr)
  (return "Scm_ExtendedCons"))

(define-cproc extended-list (elt &rest more)
  "SCM_RETURN(Scm_ExtendedCons(elt, more));")

;;
;; Syntactic closure
;;

(define-cproc make-syntactic-closure (env literals expr)
  (return "Scm_MakeSyntacticClosure"))

;;
;; Identifiers
;;
;;   Identifiers shouldn't be seen by programmers except they are
;;   really aware of working with Gauche internals.  However, for
;;   historical reasons, identifiers leak out to the Scheme world
;;   in the expanded form of the macro.  Hence we leave identifer?
;;   and identifier->symbol in extlib.stub.

(define-cproc make-identifier-old (name::<symbol> env::<list>)
  (return "Scm_MakeIdentifier"))

(define-cproc make-identifier (name::<symbol> env::<list> mod::<module>)
  (return "Scm_MakeIdentifierWithModule"))

;;
;; Symbol table
;;

;; Returns GLOC object or #f
(define-cproc find-binding (mod::<module> name::<symbol>
                            stay-in-module::<boolean>)
  "ScmGloc *g = Scm_FindBinding(mod, name, stay_in_module);
   if (g) SCM_RETURN(SCM_OBJ(g));
   else   SCM_RETURN(SCM_FALSE);")

;; This small piece of code encapsulates the common procedure in
;; pass1/variable to find whether the variable reference is a constant
;; or not.
(define-cproc find-const-binding (id::<identifier>)
  "ScmGloc *g = Scm_FindBinding(id->module, id->name, FALSE);
  if (!g || !SCM_GLOC_CONST_P(g)
      || SCM_VM_COMPILER_FLAG_IS_SET(Scm_VM(), SCM_COMPILE_NOINLINE_CONSTS)) {
    SCM_RETURN(SCM_FALSE);
  }
  SCM_RETURN(SCM_GLOC_GET(g));")

(define-cproc %insert-binding (mod::<module> name::<symbol> value)
  (return "Scm_Define"))

(define-cproc %export-symbols (mod::<module> names)
  (return "Scm_ExportSymbols"))

(define-cproc %import-modules (mod::<module> mods)
  (return "Scm_ImportModules"))

(define-cproc gloc-ref (gloc)
  "if (!SCM_GLOCP(gloc)) Scm_Error(\"GLOC required, but got %S\", gloc);
   SCM_RETURN(SCM_GLOC_GET(SCM_GLOC(gloc)));")

(define-cproc gloc-set! (gloc value)
  "if (!SCM_GLOCP(gloc)) Scm_Error(\"GLOC required, but got %S\", gloc);
   SCM_RETURN(SCM_GLOC_SET(SCM_GLOC(gloc), value));")

(define-cproc gloc-const? (gloc)
  "if (!SCM_GLOCP(gloc)) Scm_Error(\"GLOC required, but got %S\", gloc);
   SCM_RETURN(SCM_MAKE_BOOL(SCM_GLOC_CONST_P(SCM_GLOC(gloc))));")

;;
;; Compiler interface (Temporary)
;;

;; Lookup variable reference in the compiler environment in Pass 1.
;; This is a performance critical function, thus it is implemented in C.
(define-cproc cenv-lookup (cenv name lookup-as)
  (return "Scm_CompilerEnvLookup"))

;; Lookup local variable from runtime environment in Pass 3.
;; Also moved to C for efficiency.
(define-cproc renv-lookup (renv lvar)
  (return "Scm_RuntimeEnvLookup"))

;; This is an aux call to dispatch the function call with global variable
;; reference in its first position (in pass1/glbobal-call).  It checks
;; up the binding of global identifier, and returns two values.
;; The first value is #f if this global call would be a simple call.
;; Otherwise, the first value is a bound value of the global variable,
;; and the second value is one of the symbols 'macro, 'syntax or 'inline.

(define-cproc global-call-type (id)
  "ScmGloc *gloc = Scm_FindBinding(SCM_IDENTIFIER(id)->module,
                                   SCM_IDENTIFIER(id)->name, FALSE);
  ScmObj gval;
  if (!gloc) SCM_RETURN(Scm_Values2(SCM_FALSE, SCM_FALSE));
  gval = SCM_GLOC_GET(gloc);
  if (SCM_MACROP(gval)) {
    SCM_RETURN(Scm_Values2(gval, SCM_SYM_MACRO));
  } else if (SCM_SYNTAXP(gval)) {
    SCM_RETURN(Scm_Values2(gval, SCM_SYM_SYNTAX));
  } else if (SCM_PROCEDUREP(gval)
             && SCM_PROCEDURE_INLINER(gval)
             && !SCM_FALSEP(SCM_PROCEDURE_INLINER(gval))
             && !SCM_VM_COMPILER_FLAG_IS_SET(Scm_VM(), 
                                             SCM_COMPILE_NOINLINE_GLOBALS)) {
    SCM_RETURN(Scm_Values2(gval, SCM_SYM_INLINE));
  } else {
    SCM_RETURN(Scm_Values2(SCM_FALSE, SCM_FALSE));
  }")

(define-cproc macro? (obj)
  (return <boolean> "SCM_MACROP"))

(define-cproc make-toplevel-closure (code::<compiled-code>)
  "SCM_RETURN(Scm_MakeClosure(SCM_OBJ(code), NULL));")

(define-cproc make-macro-transformer (name::<symbol> proc::<procedure>)
  (return "Scm_MakeMacroTransformerOld"))

(define-cproc compile-syntax-rules (name literals rules env)
  (return "Scm_CompileSyntaxRules"))

(define-cproc call-macro-expander (mac expr env)
  "if (!SCM_MACROP(mac)) Scm_Error(\"macro required, but got %S\", mac);
  SCM_RETURN(Scm_CallMacroExpander(SCM_MACRO(mac), expr, env));")

(define-cproc make-syntax (name::<symbol> proc)
  "SCM_RETURN(Scm_MakeSyntax(name, proc));")

(define-cproc call-syntax-handler (syn program cenv)
  "SCM_ASSERT(SCM_SYNTAXP(syn));
   SCM_RETURN(Scm_VMApply2(SCM_SYNTAX(syn)->handler, program, cenv));")

(define-cproc syntax-handler (syn)
  "SCM_ASSERT(SCM_SYNTAXP(syn));
   SCM_RETURN(SCM_SYNTAX(syn)->handler);")

(define-cproc %internal-macro-expand (form env once::<boolean>)
  (return "Scm_VMMacroExpand"))

(define-cproc make-promise (thunk)
  (return "Scm_MakePromise"))

(define-cproc %procedure-inliner (proc::<procedure>)
  (setter (proc::<procedure> inliner)
    "  proc->inliner = inliner; SCM_RETURN(SCM_UNDEFINED);")
  "if (proc->inliner) SCM_RETURN(proc->inliner);
   else SCM_RETURN(SCM_FALSE);")

;;
;; Compiled code builder interface
;;

(define-cproc make-compiled-code-builder (reqargs::<uint16> optargs::<uint16>
                                          name parent intform)
  (return "Scm_MakeCompiledCodeBuilder"))

;; CompiledCodeEmit is performance critical.  To reduce the overhead of
;;  argument passing, we prepare variations for specific code patterns.
(define-cproc compiled-code-emit0! (cc::<compiled-code>
                                    code::<int>)
  "Scm_CompiledCodeEmit(cc, code, 0, 0, SCM_FALSE, SCM_FALSE);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc compiled-code-emit0o! (cc::<compiled-code>
                                     code::<int> operand)
  "Scm_CompiledCodeEmit(cc, code, 0, 0, operand, SCM_FALSE);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc compiled-code-emit0i! (cc::<compiled-code>
                                     code::<int> info)
  "Scm_CompiledCodeEmit(cc, code, 0, 0, SCM_FALSE, info);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc compiled-code-emit0oi! (cc::<compiled-code>
                                      code::<int> operand info)
  "Scm_CompiledCodeEmit(cc, code, 0, 0, operand, info);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc compiled-code-emit1! (cc::<compiled-code>
                                    code::<int> arg0::<int>)
  "Scm_CompiledCodeEmit(cc, code, arg0, 0, SCM_FALSE, SCM_FALSE);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc compiled-code-emit1o! (cc::<compiled-code>
                                     code::<int> arg0::<int> operand)
  "Scm_CompiledCodeEmit(cc, code, arg0, 0, operand, SCM_FALSE);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc compiled-code-emit1i! (cc::<compiled-code>
                                     code::<int> arg0::<int> info)
  "Scm_CompiledCodeEmit(cc, code, arg0, 0, SCM_FALSE, info);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc compiled-code-emit1oi! (cc::<compiled-code>
                                      code::<int> arg0::<int> operand info)
  "Scm_CompiledCodeEmit(cc, code, arg0, 0, operand, info);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc compiled-code-emit2! (cc::<compiled-code>
                                    code::<int> arg0::<int> arg1::<int>)
  "Scm_CompiledCodeEmit(cc, code, arg0, arg1, SCM_FALSE, SCM_FALSE);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc compiled-code-emit2o! (cc::<compiled-code>
                                     code::<int> arg0::<int> arg1::<int>
                                     operand)
  "Scm_CompiledCodeEmit(cc, code, arg0, arg1, operand, SCM_FALSE);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc compiled-code-emit2i! (cc::<compiled-code>
                                     code::<int> arg0::<int> arg1::<int>
                                     info)
  "Scm_CompiledCodeEmit(cc, code, arg0, arg1, SCM_FALSE, info);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc compiled-code-emit2oi! (cc::<compiled-code>
                                      code::<int> arg0::<int> arg1::<int>
                                      operand info)
  "Scm_CompiledCodeEmit(cc, code, arg0, arg1, operand, info);
   SCM_RETURN(SCM_UNDEFINED);")


(define-cproc compiled-code-new-label (cc::<compiled-code>)
  (return "Scm_CompiledCodeNewLabel"))

(define-cproc compiled-code-set-label! (cc::<compiled-code> label)
  (return <void> "Scm_CompiledCodeSetLabel"))

(define-cproc compiled-code-finish-builder (cc::<compiled-code>
                                            maxstack::<int>)
  (return <void> "Scm_CompiledCodeFinishBuilder"))

;; standard
(define-constant ENV_HEADER_SIZE  (c "SCM_MAKE_INT(ENV_SIZE(0))"))
(define-constant CONT_FRAME_SIZE (c "SCM_MAKE_INT(CONT_FRAME_SIZE)"))

;;
;; VM inspection and interface
;;

(define-cproc vm-dump-code (code::<compiled-code>)
  (return <void> "Scm_CompiledCodeDump"))
(define-cproc vm-code->list (code::<compiled-code>)
  (return "Scm_CompiledCodeToList"))
(define-cproc vm-insn-build (insn)
  (return <ulong> "Scm_VMInsnBuild"))

;; Eval situation flag (for eval-when constrcut)
(define-cproc vm-eval-situation (&optional val)
  "int prev;
   if (SCM_UNBOUNDP(val)) {
     SCM_RETURN(SCM_MAKE_INT(Scm_VM()->evalSituation));
   } else {
     if (!SCM_INTP(val)) Scm_Error(\"integer required, but got %S\", val);
     prev = Scm_VM()->evalSituation;
     Scm_VM()->evalSituation = SCM_INT_VALUE(val);
     SCM_RETURN(SCM_MAKE_INT(prev));
   }")

(define-enum SCM_VM_EXECUTING)
(define-enum SCM_VM_LOADING)
(define-enum SCM_VM_COMPILING)

;; Compiler flags
(define-cproc vm-compiler-flag-is-set? (flag::<uint>)
  "SCM_RETURN(SCM_MAKE_BOOL(SCM_VM_COMPILER_FLAG_IS_SET(Scm_VM(), flag)));")
(define-cproc vm-compiler-flag-set! (flag::<uint>)
  "SCM_VM_COMPILER_FLAG_SET(Scm_VM(), flag); SCM_RETURN(SCM_UNDEFINED);")
(define-cproc vm-compiler-flag-clear! (flag::<uint>)
  "SCM_VM_COMPILER_FLAG_CLEAR(Scm_VM(), flag); SCM_RETURN(SCM_UNDEFINED);")

(define-enum SCM_COMPILE_NOINLINE_GLOBALS)
(define-enum SCM_COMPILE_NOINLINE_LOCALS)
(define-enum SCM_COMPILE_NOINLINE_CONSTS)
(define-enum SCM_COMPILE_NOSOURCE)
(define-enum SCM_COMPILE_SHOWRESULT)

;; Set/get VM's current module info. (temporary)
(define-cproc vm-current-module ()
  "  SCM_RETURN(SCM_OBJ(Scm_VM()->module));")
(define-cproc vm-set-current-module (mod::<module>)
  "Scm_VM()->module = mod; SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gc-print-static-roots ()
  (return <void> "GC_print_static_roots"))

;;
;; Profiler internal API
;;
(define-cproc profiler-raw-result () (return "Scm_ProfilerRawResult"))

;;
;; Some aux hacks
;;

;; (%map1c proc lis c) = (map (cut proc <> c) lis)
"static ScmObj map1c_cc(ScmObj result, void *data[])
 {
   ScmObj proc = SCM_OBJ(data[0]);
   ScmObj r = SCM_OBJ(data[1]);
   ScmObj lis = SCM_OBJ(data[2]);
   ScmObj c = SCM_OBJ(data[3]);
   if (SCM_NULLP(lis)) {
     SCM_RETURN(Scm_ReverseX(Scm_Cons(result, r)));
   } else {
     data[1] = Scm_Cons(result, r);
     data[2] = SCM_CDR(lis);
     Scm_VMPushCC(map1c_cc, data, 4);
     SCM_RETURN(Scm_VMApply2(proc, SCM_CAR(lis), c));
   }
 }"

(define-cproc %map1c (proc lis c)
  "void *data[4];
  if (SCM_NULLP(lis)) SCM_RETURN(SCM_NIL);
  data[0] = proc;
  data[1] = SCM_NIL;
  data[2] = SCM_CDR(lis);
  data[3] = c;
  Scm_VMPushCC(map1c_cc, data, 4);
  SCM_RETURN(Scm_VMApply2(proc, SCM_CAR(lis), c));")

;; (%map1cc proc lis c1 c2) = (map (cut proc <> c1 c2) lis)
"static ScmObj map1cc_cc(ScmObj result, void *data[])
 {
   ScmObj proc = SCM_OBJ(data[0]);
   ScmObj r = SCM_OBJ(data[1]);
   ScmObj lis = SCM_OBJ(data[2]);
   ScmObj c1 = SCM_OBJ(data[3]);
   ScmObj c2 = SCM_OBJ(data[4]);
   if (SCM_NULLP(lis)) {
     SCM_RETURN(Scm_ReverseX(Scm_Cons(result, r)));
   } else {
     data[1] = Scm_Cons(result, r);
     data[2] = SCM_CDR(lis);
     Scm_VMPushCC(map1cc_cc, data, 5);
     SCM_RETURN(Scm_VMApply3(proc, SCM_CAR(lis), c1, c2));
   }
 }"

(define-cproc %map1cc (proc lis c1 c2)
  "void *data[5];
  if (SCM_NULLP(lis)) SCM_RETURN(SCM_NIL);
  data[0] = proc;
  data[1] = SCM_NIL;
  data[2] = SCM_CDR(lis);
  data[3] = c1;
  data[4] = c2;
  Scm_VMPushCC(map1cc_cc, data, 5);
  SCM_RETURN(Scm_VMApply3(proc, SCM_CAR(lis), c1, c2));")

;; (%map-cons lis1 lis2) = (map cons lis1 lis2)
(define-cproc %map-cons (lis1 lis2)
  "ScmObj h = SCM_NIL, t = SCM_NIL;
  while (SCM_PAIRP(lis1) && SCM_PAIRP(lis2)) {
    SCM_APPEND1(h, t, Scm_Cons(SCM_CAR(lis1), SCM_CAR(lis2)));
    lis1 = SCM_CDR(lis1);
    lis2 = SCM_CDR(lis2);
  }
  SCM_RETURN(h);")

;; Local variables:
;; mode: scheme
;; end:
