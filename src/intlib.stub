;;;
;;; intlib.stub - internal built-ins
;;;  
;;;   Copyright (c) 2000-2005 Shiro Kawai, All rights reserved.
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: intlib.stub,v 1.14 2005-08-01 12:23:34 shirok Exp $
;;;

;; This file defines subrs that are used by Gauche internal routines
;; (such as the compiler).  They are interned in gauche.internal module.
;; The API in this module is still fluid.  Do not count on them.


"
#include <gauche/class.h>
#include <gauche/code.h>
#include <gauche/vminsn.h>
#include <gauche/macro.h>
#include <gauche/prof.h>
#include <gauche/builtin-syms.h>
"

;;
;; Pair attributes
;;
;;  Pair attributes are almost exclusively used to attach source-code
;;  information to s-exprs.

(define-cproc pair-attributes (pair::<pair>)
  (call "Scm_PairAttr"))

(define-cproc pair-attribute-get (pair::<pair> key &optional fallback)
  (expr "Scm_PairAttrGet(SCM_PAIR(pair), key, fallback)"))

(define-cproc pair-attribute-set! (pair::<pair> key value)
  (expr "Scm_PairAttrSet(SCM_PAIR(pair), key, value)"))

(define-cproc extended-pair? (obj)
  (call <boolean> "SCM_EXTENDED_PAIR_P"))

(define-cproc extended-cons (car cdr)
  (call "Scm_ExtendedCons"))

(define-cproc extended-list (elt &rest more)
  (call "Scm_ExtendedCons"))

;;
;; Syntactic closure
;;

(define-cproc make-syntactic-closure (env literals expr)
  (call "Scm_MakeSyntacticClosure"))

;;
;; Identifiers
;;
;;   Identifiers shouldn't be seen by programmers except they are
;;   really aware of working with Gauche internals.  However, for
;;   historical reasons, identifiers leak out to the Scheme world
;;   in the expanded form of the macro.  Hence we leave identifer?
;;   and identifier->symbol in extlib.stub.

(define-cproc make-identifier (name::<symbol> mod::<module> env::<list>)
  (call "Scm_MakeIdentifier"))

;;
;; Symbol table
;;

;; Returns GLOC object or #f
(define-cproc find-binding (mod::<module> name::<symbol>
                            stay-in-module::<boolean>)
  "ScmGloc *g = Scm_FindBinding(mod, name, stay_in_module);
   if (g) SCM_RETURN(SCM_OBJ(g));
   else   SCM_RETURN(SCM_FALSE);")

;; This small piece of code encapsulates the common procedure in
;; pass1/variable to find whether the variable reference is a constant
;; or not.
(define-cproc find-const-binding (id::<identifier>)
  "ScmGloc *g = Scm_FindBinding(id->module, id->name, FALSE);
  if (!g || !SCM_GLOC_CONST_P(g)
      || SCM_VM_COMPILER_FLAG_IS_SET(Scm_VM(), SCM_COMPILE_NOINLINE_CONSTS)) {
    SCM_RETURN(SCM_FALSE);
  }
  SCM_RETURN(SCM_GLOC_GET(g));")

(define-cproc %insert-binding (mod::<module> name::<symbol> value)
  (call "Scm_Define"))

(define-cproc %export-symbols (mod::<module> names)
  (call "Scm_ExportSymbols"))

(define-cproc %import-modules (mod::<module> mods)
  (call "Scm_ImportModules"))

(define-type <gloc> "ScmGloc*" "GLOC"
  "SCM_GLOCP" "SCM_GLOC" "SCM_OBJ")

(define-cproc gloc-ref (gloc::<gloc>)
  (call "SCM_GLOC_GET"))

(define-cproc gloc-set! (gloc::<gloc> value)
  (call "SCM_GLOC_SET"))

(define-cproc gloc-const? (gloc::<gloc>)
  (call <boolean> "SCM_GLOC_CONST_P"))

;;
;; Compiler interface
;;

;; This is an aux call to dispatch the function call with global variable
;; reference in its first position (in pass1/glbobal-call).  It checks
;; up the binding of global identifier, and returns two values.
;; The first value is #f if this global call would be a simple call.
;; Otherwise, the first value is a bound value of the global variable,
;; and the second value is one of the symbols 'macro, 'syntax or 'inline.

(define-cproc global-call-type (id)
  "ScmGloc *gloc = Scm_FindBinding(SCM_IDENTIFIER(id)->module,
                                   SCM_IDENTIFIER(id)->name, FALSE);
  ScmObj gval;
  if (!gloc) SCM_RETURN(Scm_Values2(SCM_FALSE, SCM_FALSE));
  gval = SCM_GLOC_GET(gloc);
  if (SCM_MACROP(gval)) {
    SCM_RETURN(Scm_Values2(gval, SCM_SYM_MACRO));
  } else if (SCM_SYNTAXP(gval)) {
    SCM_RETURN(Scm_Values2(gval, SCM_SYM_SYNTAX));
  } else if (SCM_PROCEDUREP(gval)
             && SCM_PROCEDURE_INLINER(gval)
             && !SCM_FALSEP(SCM_PROCEDURE_INLINER(gval))
             && !SCM_VM_COMPILER_FLAG_IS_SET(Scm_VM(), 
                                             SCM_COMPILE_NOINLINE_GLOBALS)) {
    SCM_RETURN(Scm_Values2(gval, SCM_SYM_INLINE));
  } else {
    SCM_RETURN(Scm_Values2(SCM_FALSE, SCM_FALSE));
  }")

(define-cproc macro? (obj)
  (call <boolean> "SCM_MACROP"))

(define-cproc make-toplevel-closure (code::<compiled-code>)
  (expr "Scm_MakeClosure(SCM_OBJ(code), NULL)"))

(define-cproc make-macro-transformer (name::<symbol> proc::<procedure>)
  (call "Scm_MakeMacroTransformerOld"))

(define-cproc compile-syntax-rules (name literals rules mod env)
  (call "Scm_CompileSyntaxRules"))

(define-type <macro> "ScmMacro*" "macro"
  "SCM_MACROP" "SCM_MACRO" "SCM_OBJ")

(define-cproc call-macro-expander (mac::<macro> expr env)
  (call "Scm_CallMacroExpander"))

(define-cproc make-syntax (name::<symbol> proc)
  (call "Scm_MakeSyntax"))

(define-cproc call-syntax-handler (syn program cenv)
  "SCM_ASSERT(SCM_SYNTAXP(syn));
   SCM_RETURN(Scm_VMApply2(SCM_SYNTAX(syn)->handler, program, cenv));")

(define-cproc syntax-handler (syn)
  "SCM_ASSERT(SCM_SYNTAXP(syn));
   SCM_RETURN(SCM_SYNTAX(syn)->handler);")

(define-cproc %internal-macro-expand (form env once::<boolean>)
  (call "Scm_VMMacroExpand"))

(define-cproc %procedure-inliner (proc::<procedure>)
  (setter (proc::<procedure> inliner)
    "  proc->inliner = inliner; SCM_RETURN(SCM_UNDEFINED);")
  "if (proc->inliner) SCM_RETURN(proc->inliner);
   else SCM_RETURN(SCM_FALSE);")

;;
;; Compiled code builder interface
;;

(define-cproc make-compiled-code-builder (reqargs::<uint16> optargs::<uint16>
                                          name parent intform)
  (call "Scm_MakeCompiledCodeBuilder"))

;; CompiledCodeEmit is performance critical.  To reduce the overhead of
;;  argument passing, we prepare variations for specific code patterns.
(define-cproc compiled-code-emit0! (cc::<compiled-code>
                                    code::<int>)
  (body <void> "Scm_CompiledCodeEmit(cc, code, 0, 0, SCM_FALSE, SCM_FALSE);"))

(define-cproc compiled-code-emit0o! (cc::<compiled-code>
                                     code::<int> operand)
  (body <void> "Scm_CompiledCodeEmit(cc, code, 0, 0, operand, SCM_FALSE);"))

(define-cproc compiled-code-emit0i! (cc::<compiled-code>
                                     code::<int> info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, 0, 0, SCM_FALSE, info);"))

(define-cproc compiled-code-emit0oi! (cc::<compiled-code>
                                      code::<int> operand info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, 0, 0, operand, info);"))

(define-cproc compiled-code-emit1! (cc::<compiled-code>
                                    code::<int> arg0::<int>)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, 0, SCM_FALSE, SCM_FALSE);"))

(define-cproc compiled-code-emit1o! (cc::<compiled-code>
                                     code::<int> arg0::<int> operand)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, 0, operand, SCM_FALSE);"))

(define-cproc compiled-code-emit1i! (cc::<compiled-code>
                                     code::<int> arg0::<int> info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, 0, SCM_FALSE, info);"))

(define-cproc compiled-code-emit1oi! (cc::<compiled-code>
                                      code::<int> arg0::<int> operand info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, 0, operand, info);"))

(define-cproc compiled-code-emit2! (cc::<compiled-code>
                                    code::<int> arg0::<int> arg1::<int>)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, arg1, SCM_FALSE, SCM_FALSE);"))

(define-cproc compiled-code-emit2o! (cc::<compiled-code>
                                     code::<int> arg0::<int> arg1::<int>
                                     operand)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, arg1, operand, SCM_FALSE);"))

(define-cproc compiled-code-emit2i! (cc::<compiled-code>
                                     code::<int> arg0::<int> arg1::<int>
                                     info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, arg1, SCM_FALSE, info);"))

(define-cproc compiled-code-emit2oi! (cc::<compiled-code>
                                      code::<int> arg0::<int> arg1::<int>
                                      operand info)
  (body <void> "Scm_CompiledCodeEmit(cc, code, arg0, arg1, operand, info);"))


(define-cproc compiled-code-new-label (cc::<compiled-code>)
  (call "Scm_CompiledCodeNewLabel"))

(define-cproc compiled-code-set-label! (cc::<compiled-code> label)
  (call <void> "Scm_CompiledCodeSetLabel"))

(define-cproc compiled-code-finish-builder (cc::<compiled-code>
                                            maxstack::<int>)
  (call <void> "Scm_CompiledCodeFinishBuilder"))

;; standard
(define-constant ENV_HEADER_SIZE  (c "SCM_MAKE_INT(ENV_SIZE(0))"))
(define-constant CONT_FRAME_SIZE (c "SCM_MAKE_INT(CONT_FRAME_SIZE)"))

;;
;; VM inspection and interface
;;

(define-cproc vm-dump-code (code::<compiled-code>)
  (call <void> "Scm_CompiledCodeDump"))
(define-cproc vm-code->list (code::<compiled-code>)
  (call "Scm_CompiledCodeToList"))
(define-cproc vm-insn-build (insn)
  (call <ulong> "Scm_VMInsnBuild"))

;; Eval situation flag (for eval-when constrcut)
(define-cproc vm-eval-situation (&optional val)
  "int prev;
   if (SCM_UNBOUNDP(val)) {
     SCM_RETURN(SCM_MAKE_INT(Scm_VM()->evalSituation));
   } else {
     if (!SCM_INTP(val)) Scm_Error(\"integer required, but got %S\", val);
     prev = Scm_VM()->evalSituation;
     Scm_VM()->evalSituation = SCM_INT_VALUE(val);
     SCM_RETURN(SCM_MAKE_INT(prev));
   }")

(define-enum SCM_VM_EXECUTING)
(define-enum SCM_VM_LOADING)
(define-enum SCM_VM_COMPILING)

;; Compiler flags
(define-cproc vm-compiler-flag-is-set? (flag::<uint>)
  (expr <boolean> "SCM_VM_COMPILER_FLAG_IS_SET(Scm_VM(), flag)"))
(define-cproc vm-compiler-flag-set! (flag::<uint>)
  (body <void> "SCM_VM_COMPILER_FLAG_SET(Scm_VM(), flag);"))
(define-cproc vm-compiler-flag-clear! (flag::<uint>)
  (body <void> "SCM_VM_COMPILER_FLAG_CLEAR(Scm_VM(), flag);"))

(define-cproc vm-compiler-flag-noinline-locals? ()
  (expr <boolean> "SCM_VM_COMPILER_FLAG_IS_SET(Scm_VM(), SCM_COMPILE_NOINLINE_LOCALS)"))

(define-enum SCM_COMPILE_NOINLINE_GLOBALS)
(define-enum SCM_COMPILE_NOINLINE_LOCALS)
(define-enum SCM_COMPILE_NOINLINE_CONSTS)
(define-enum SCM_COMPILE_NOSOURCE)
(define-enum SCM_COMPILE_SHOWRESULT)

;; Set/get VM's current module info. (temporary)
(define-cproc vm-current-module ()
  (expr "SCM_OBJ(Scm_VM()->module)"))
(define-cproc vm-set-current-module (mod::<module>)
  (body <void> "Scm_VM()->module = mod;"))

(define-cproc gc-print-static-roots ()
  (call <void> "GC_print_static_roots"))

;;
;; Profiler internal API
;;
(define-cproc profiler-raw-result () (call "Scm_ProfilerRawResult"))

;;
;; Compiler internal procedures
;;
;; These procedures are originally implemented in Scheme, but moved
;; here for efficiency.
;; Some procedures depend on the structure defined in compile.scm,
;; and need to be adjusted if the structure is changed.
;; In future, gencomp should be extended so that these routines can
;; be written in compile.scm as "inlined C" code.

;; Lookup variable reference in the compiler environment in Pass 1.
;; This depends on the Cenv structure.
;;
;;   cenv-lookup :: Cenv, Name, LookupAs -> Var
;;        where Var = Lvar | Identifier | Macro
;;
;;   LookupAs ::
;;      LEXICAL(0) - lookup only lexical bindings
;;    | SYNTAX(1)  - lookup lexical and syntactic bindings
;;    | PATTERN(2) - lookup lexical, syntactic and pattern bindings
;;
;;   PERFORMANCE KLUDGE:
;;     - We assume the frame structure is well-formed, so skip some tests.
;;     - We assume 'lookupAs' and the car of each frame are small non-negative
;;       integers, so we directly compare them without unboxing them.
;;
(define-cproc cenv-lookup (cenv name lookup-as)
  " ScmObj frames, fp, vp;
    int name_identifier = SCM_IDENTIFIERP(name);
    SCM_ASSERT(SCM_VECTORP(cenv));
    frames = SCM_VECTOR_ELEMENT(cenv, 1);
    SCM_FOR_EACH(fp, frames) {
        if (name_identifier && SCM_IDENTIFIER(name)->env == fp) {
            /* strip identifier if we're in the same env (kludge). */
            name = SCM_OBJ(SCM_IDENTIFIER(name)->name);
        }
        if (SCM_CAAR(fp) > lookup_as) continue; /* see PERFORMANCE KLUDGE above */
        /* We inline assq here to squeeze performance. */
        SCM_FOR_EACH(vp, SCM_CDAR(fp)) {
            if (SCM_EQ(name, SCM_CAAR(vp))) return SCM_CDAR(vp);
        }
    }
    if (SCM_SYMBOLP(name)) {
        ScmObj mod = SCM_VECTOR_ELEMENT(cenv, 0);
        SCM_ASSERT(SCM_MODULEP(mod));
        return Scm_MakeIdentifier(SCM_SYMBOL(name), SCM_MODULE(mod), SCM_NIL);
    } else {
        SCM_ASSERT(SCM_IDENTIFIERP(name));
        return name;
    }
  ")

;; Check if Cenv is toplevel or not.  Depends on the structure of Cenv.
;;
;; (define (cenv-toplevel? cenv)
;;   (not (any (lambda (frame) (eqv? (car frame) LEXICAL))
;;             (cenv-frames cenv))))
;;
(define-cproc cenv-toplevel? (cenv)
  "ScmObj fp;
  SCM_ASSERT(SCM_VECTORP(cenv));
  SCM_FOR_EACH(fp, SCM_VECTOR_ELEMENT(cenv, 1)) {
    if (SCM_CAAR(fp) == SCM_MAKE_INT(0)) return SCM_FALSE;
  }
  return SCM_TRUE;")

;; Lookup local variable from the runtime envirnoment Renv.
;; Called in Pass3.
;;
;;   renv-lookup : [[Lvar]], Lvar -> Int, Int
;;
;; Returns depth and offset of local variable frame.
;;  Note that this routine is agnostic about the structure of Lvar.

(define-cproc renv-lookup (renv lvar)
  " ScmObj fp, lp;
    int depth = 0;
    SCM_FOR_EACH(fp, renv) {
        int count = 1;
        SCM_FOR_EACH(lp, SCM_CAR(fp)) {
            if (SCM_EQ(SCM_CAR(lp), lvar)) {
                return Scm_Values2(SCM_MAKE_INT(depth),
                                   SCM_MAKE_INT(Scm_Length(SCM_CAR(fp))-count));
            }
            count++;
        }
        depth++;
    }
    Scm_Error(\"[internal error] stray local variable:\", lvar);
    SCM_RETURN(SCM_UNDEFINED); /* dummy */
  ")

;; Specialized routines handling Lvar structure.
(define-symbol lvar "sym_lvar")

"#define LVAR_OFFSET_TAG        0
#define LVAR_OFFSET_NAME        1
#define LVAR_OFFSET_INITVAL     2
#define LVAR_OFFSET_REF_COUNT   3
#define LVAR_OFFSET_SET_COUNT   4
#define LVAR_SIZE               5
"

;; Specialized routine for (map (lambda (name) (make-lvar name)) objs)
(define-cproc %map-make-lvar (names)
  "ScmObj h = SCM_NIL, t = SCM_NIL;
   SCM_FOR_EACH(names, names) {
     ScmObj v = Scm_MakeVector(LVAR_SIZE, SCM_MAKE_INT(0));
     SCM_VECTOR_ELEMENT(v, LVAR_OFFSET_TAG) = sym_lvar;
     SCM_VECTOR_ELEMENT(v, LVAR_OFFSET_NAME) = SCM_CAR(names);
     SCM_VECTOR_ELEMENT(v, LVAR_OFFSET_INITVAL) = SCM_UNDEFINED;
     SCM_APPEND1(h, t, v);
   }
   SCM_RETURN(h);")

(define-cproc lvar-ref++! (lvar)
  "int i;
  SCM_ASSERT(SCM_VECTORP(lvar));
  i = SCM_INT_VALUE(SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_REF_COUNT));
  SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_REF_COUNT) = SCM_MAKE_INT(i+1);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc lvar-ref--! (lvar)
  "int i;
  SCM_ASSERT(SCM_VECTORP(lvar));
  i = SCM_INT_VALUE(SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_REF_COUNT));
  SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_REF_COUNT) = SCM_MAKE_INT(i-1);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc lvar-set++! (lvar)
  "int i;
  SCM_ASSERT(SCM_VECTORP(lvar));
  i = SCM_INT_VALUE(SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_SET_COUNT));
  SCM_VECTOR_ELEMENT(lvar, LVAR_OFFSET_SET_COUNT) = SCM_MAKE_INT(i+1);
  SCM_RETURN(SCM_UNDEFINED);")

;; %imax - max for unsigned integer only, unsafe.
(define-cproc %imax (x y)
  "if (SCM_WORD(x) > SCM_WORD(y)) SCM_RETURN(x);
   else SCM_RETURN(y);")

;; (%map1c proc lis c) = (map (cut proc <> c) lis)
"static ScmObj map1c_cc(ScmObj result, void *data[])
 {
   ScmObj proc = SCM_OBJ(data[0]);
   ScmObj r = SCM_OBJ(data[1]);
   ScmObj lis = SCM_OBJ(data[2]);
   ScmObj c = SCM_OBJ(data[3]);
   if (SCM_NULLP(lis)) {
     SCM_RETURN(Scm_ReverseX(Scm_Cons(result, r)));
   } else {
     data[1] = Scm_Cons(result, r);
     data[2] = SCM_CDR(lis);
     Scm_VMPushCC(map1c_cc, data, 4);
     SCM_RETURN(Scm_VMApply2(proc, SCM_CAR(lis), c));
   }
 }"

(define-cproc %map1c (proc lis c)
  "void *data[4];
  if (SCM_NULLP(lis)) SCM_RETURN(SCM_NIL);
  data[0] = proc;
  data[1] = SCM_NIL;
  data[2] = SCM_CDR(lis);
  data[3] = c;
  Scm_VMPushCC(map1c_cc, data, 4);
  SCM_RETURN(Scm_VMApply2(proc, SCM_CAR(lis), c));")

;; (%map1cc proc lis c1 c2) = (map (cut proc <> c1 c2) lis)
"static ScmObj map1cc_cc(ScmObj result, void *data[])
 {
   ScmObj proc = SCM_OBJ(data[0]);
   ScmObj r = SCM_OBJ(data[1]);
   ScmObj lis = SCM_OBJ(data[2]);
   ScmObj c1 = SCM_OBJ(data[3]);
   ScmObj c2 = SCM_OBJ(data[4]);
   if (SCM_NULLP(lis)) {
     SCM_RETURN(Scm_ReverseX(Scm_Cons(result, r)));
   } else {
     data[1] = Scm_Cons(result, r);
     data[2] = SCM_CDR(lis);
     Scm_VMPushCC(map1cc_cc, data, 5);
     SCM_RETURN(Scm_VMApply3(proc, SCM_CAR(lis), c1, c2));
   }
 }"

(define-cproc %map1cc (proc lis c1 c2)
  "void *data[5];
  if (SCM_NULLP(lis)) SCM_RETURN(SCM_NIL);
  data[0] = proc;
  data[1] = SCM_NIL;
  data[2] = SCM_CDR(lis);
  data[3] = c1;
  data[4] = c2;
  Scm_VMPushCC(map1cc_cc, data, 5);
  SCM_RETURN(Scm_VMApply3(proc, SCM_CAR(lis), c1, c2));")

;; (%map-cons lis1 lis2) = (map cons lis1 lis2)
(define-cproc %map-cons (lis1 lis2)
  "ScmObj h = SCM_NIL, t = SCM_NIL;
  while (SCM_PAIRP(lis1) && SCM_PAIRP(lis2)) {
    SCM_APPEND1(h, t, Scm_Cons(SCM_CAR(lis1), SCM_CAR(lis2)));
    lis1 = SCM_CDR(lis1);
    lis2 = SCM_CDR(lis2);
  }
  SCM_RETURN(h);")

;; Local variables:
;; mode: scheme
;; end:
