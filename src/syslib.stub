;;;
;;; syslib.stub - system interface functions
;;;
;;;   Copyright (c) 2000-2002 Shiro Kawai (shiro@acm.org)
;;;
;;;   Permission to use, copy, modify, distribute this software and
;;;   accompanying documentation for any purpose is hereby granted,
;;;   provided that existing copyright notices are retained in all
;;;   copies and that this notice is included verbatim in all
;;;   distributions.
;;;   This software is provided as is, without express or implied
;;;   warranty.  In no circumstances the author(s) shall be liable
;;;   for any damages arising out of the use of this software.
;;;
;;; $Id: syslib.stub,v 1.84 2002-08-29 08:13:29 shirok Exp $
;;;

;; System interface functions.   Mostly I followed POSIX.1, but included
;; some non-posix functions which are important for programming on Unix.

"#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <locale.h>
#include <grp.h>
#include <pwd.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/wait.h>
#include <signal.h>
#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif
"

;;---------------------------------------------------------------------
;; dirent.h - read directory
;;   we don't have correspoinding functions, but provide these:

(define-cproc sys-readdir (pathname::<string>)
  (return "Scm_ReadDirectory"))

(define-cproc sys-glob (pattern::<string>)
  (return "Scm_GlobDirectory"))

;; Bonus

(define-cproc sys-normalize-pathname (pathname::<string>
                                      &keyword (absolute #f)
                                               (expand #f)
                                               (canonicalize #f))
  "  int flags = 0;
  if (!SCM_FALSEP(absolute)) flags |= SCM_PATH_ABSOLUTE;
  if (!SCM_FALSEP(expand))   flags |= SCM_PATH_EXPAND;
  if (!SCM_FALSEP(canonicalize)) flags |= SCM_PATH_CANONICALIZE;
  SCM_RETURN(Scm_NormalizePathname(pathname, flags));")

(define-cproc sys-basename (pathname::<string>)
  (return "Scm_BaseName"))

(define-cproc sys-dirname (pathname::<string>)
  (return "Scm_DirName"))

;;---------------------------------------------------------------------
;; grp.h - groups

(define-type <sys-group> "ScmSysGroup*")

(define-cproc sys-getgrgid (gid::<int>)
  (return "Scm_GetGroupById"))
(define-cproc sys-getgrnam (name::<string>)
  (return "Scm_GetGroupByName"))

;; faster functions; bypassing creation of group object
(define-cproc sys-gid->group-name (gid::<int>)
  "  struct group *g = getgrgid(gid);
  if (g == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(SCM_MAKE_STR_COPYING(g->gr_name));")
(define-cproc sys-group-name->gid (name::<string>)
  "  struct group *g = getgrnam(Scm_GetStringConst(name));
  if (g == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(Scm_MakeInteger(g->gr_gid));")

;;---------------------------------------------------------------------
;; locale.h

(define-enum LC_ALL)
(define-enum LC_COLLATE)
(define-enum LC_CTYPE)
(define-enum LC_MONETARY)
(define-enum LC_NUMERIC)
(define-enum LC_TIME)

(define-cproc sys-setlocale (category::<fixnum> locale::<string>)
  "  char *result = setlocale(category, Scm_GetStringConst(locale));
  if (result) SCM_RETURN(SCM_MAKE_STR_COPYING(result));
  else SCM_RETURN(SCM_FALSE);")

; struct lconv
(define-symbol decimal_point "sym_decimal_point")
(define-symbol thousands_sep "sym_thousands_sep")
(define-symbol grouping "sym_grouping")
(define-symbol int_curr_symbol "sym_int_curr_symbol")
(define-symbol currency_symbol "sym_currency_symbol")
(define-symbol mon_decimal_point "sym_mon_decimal_point")
(define-symbol mon_thousands_sep "sym_mon_thousands_sep")
(define-symbol mon_grouping "sym_mon_grouping")
(define-symbol positive_sign "sym_positive_sign")
(define-symbol negative_sign "sym_negative_sign")
(define-symbol int_frac_digits "sym_int_frac_digits")
(define-symbol frac_digits "sym_frac_digits")
(define-symbol p_cs_precedes "sym_p_cs_precedes")
(define-symbol p_sep_by_space "sym_p_sep_by_space")
(define-symbol n_cs_precedes "sym_n_cs_precedes")
(define-symbol n_sep_by_space "sym_n_sep_by_space")
(define-symbol p_sign_posn "sym_p_sign_posn")
(define-symbol n_sign_posn "sym_n_sign_posn")

(define-cproc sys-localeconv ()
  "  struct lconv *lc = localeconv();
  ScmObj h = SCM_NIL, t = SCM_NIL;

#define APPCONS(a, b) SCM_APPEND1(h, t, Scm_Cons(a, b))

  APPCONS(sym_decimal_point, SCM_MAKE_STR_COPYING(lc->decimal_point));
  APPCONS(sym_thousands_sep, SCM_MAKE_STR_COPYING(lc->thousands_sep));
  APPCONS(sym_grouping, SCM_MAKE_STR_COPYING(lc->grouping));
  APPCONS(sym_int_curr_symbol, SCM_MAKE_STR_COPYING(lc->int_curr_symbol));
  APPCONS(sym_currency_symbol, SCM_MAKE_STR_COPYING(lc->currency_symbol));
  APPCONS(sym_mon_decimal_point, SCM_MAKE_STR_COPYING(lc->mon_decimal_point));
  APPCONS(sym_mon_thousands_sep, SCM_MAKE_STR_COPYING(lc->mon_thousands_sep));
  APPCONS(sym_mon_grouping, SCM_MAKE_STR_COPYING(lc->mon_grouping));
  APPCONS(sym_positive_sign, SCM_MAKE_STR_COPYING(lc->positive_sign));
  APPCONS(sym_negative_sign, SCM_MAKE_STR_COPYING(lc->negative_sign));
  APPCONS(sym_int_frac_digits, SCM_MAKE_INT(lc->int_frac_digits));
  APPCONS(sym_frac_digits, SCM_MAKE_INT(lc->frac_digits));
  APPCONS(sym_p_cs_precedes, SCM_MAKE_BOOL(lc->p_cs_precedes));
  APPCONS(sym_p_sep_by_space, SCM_MAKE_BOOL(lc->p_sep_by_space));
  APPCONS(sym_n_cs_precedes, SCM_MAKE_BOOL(lc->n_cs_precedes));
  APPCONS(sym_n_sep_by_space, SCM_MAKE_BOOL(lc->n_sep_by_space));
  APPCONS(sym_p_sign_posn, SCM_MAKE_INT(lc->p_sign_posn));
  APPCONS(sym_n_sign_posn, SCM_MAKE_INT(lc->n_sign_posn));
#undef APPCONS
  return h;")

;;---------------------------------------------------------------------
;; math.h

;;---------------------------------------------------------------------
;; pwd.h - passwords

(define-type <sys-passwd> "ScmSysPasswd*")

(define-cproc sys-getpwuid (uid::<int>)
  (return "Scm_GetPasswdById"))
(define-cproc sys-getpwnam (name::<string>)
  (return "Scm_GetPasswdByName"))

;; faster functions; bypassing creation of passwd object
(define-cproc sys-uid->user-name (uid::<int>)
  "  struct passwd *p = getpwuid(uid);
  if (p == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(SCM_MAKE_STR_COPYING(p->pw_name));")
(define-cproc sys-user-name->uid (name::<string>)
  "  struct passwd *p = getpwnam(Scm_GetStringConst(name));
  if (p == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(Scm_MakeInteger(p->pw_uid));")

;;---------------------------------------------------------------------
;; setjmp.h

;;  No equivalent functions --- use call/cc

;;---------------------------------------------------------------------
;; signal.h

(define-type <sys-sigset> "ScmSysSigset*")

(define-cproc sys-sigset-add! (set::<sys-sigset> &rest sigs)
  "SCM_RETURN(Scm_SysSigsetOp(set, sigs, FALSE));")

(define-cproc sys-sigset-delete! (set::<sys-sigset> &rest sigs)
  "SCM_RETURN(Scm_SysSigsetOp(set, sigs, TRUE));")

(define-cproc sys-sigset-fill! (set::<sys-sigset>)
  "SCM_RETURN(Scm_SysSigsetFill(set, FALSE));")

(define-cproc sys-sigset-empty! (set::<sys-sigset>)
  "SCM_RETURN(Scm_SysSigsetFill(set, TRUE));")

(define-cproc sys-signal-name (sig::<fixnum>)
  (return "Scm_SignalName"))

(define-cproc sys-kill (pid::<int> sig::<fixnum>)
  "  int r = Scm_SysCall(kill(pid, sig));
  if (r < 0) Scm_SysError(\"kill failed\");
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc set-signal-handler! (sig proc)
  (return "Scm_SetSignalHandler"))

(define-cproc get-signal-handler (sig::<fixnum>)
  (return "Scm_GetSignalHandler"))

(define-cproc get-signal-handlers ()
  (return "Scm_GetSignalHandlers"))

(define-enum SIG_SETMASK)
(define-enum SIG_BLOCK)
(define-enum SIG_UNBLOCK)

(define-cproc sys-sigmask (how::<fixnum> mask::<sys-sigset>)
  (return "Scm_SysSigmask"))

(define-cproc sys-sigsuspend (mask::<sys-sigset>)
  (return "Scm_SigSuspend"))

;(define-cproc %with-signal-handlers (handlers thunk)
;  (assert (procedure? thunk))
;  "SCM_RETURN(Scm_VMWithSignalHandlers(handlers, thunk));")

;; raise should be handled by sys-kill

;;---------------------------------------------------------------------
;; stdio.h

(define-cproc sys-remove (filename::<string>)
  "  if (Scm_SysCall(remove(Scm_GetStringConst(filename))) < 0)
       Scm_SysError(\"removing %S failed\", filename);
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-rename (old::<string> new::<string>)
  "  if (Scm_SysCall(rename(Scm_GetStringConst(old), Scm_GetStringConst(new))) < 0)
       Scm_SysError(\"renaming %S to %S failed\", old, new);
  SCM_RETURN(SCM_TRUE);")

;; NB: Alghough tmpnam() is in POSIX, its use is discouraged because of
;; potential security risk.  We mimic it's behavior by mkstemp() if possible.
(define-cproc sys-tmpnam ()
  "
#ifdef HAVE_MKSTEMP
  char nam[] = \"/tmp/fileXXXXXX\";
  int fd = Scm_SysCall(mkstemp(nam));
  if (fd < 0) Scm_SysError(\"mkstemp failed\");
  close(fd);
  unlink(nam);
  SCM_RETURN(SCM_MAKE_STR_COPYING(nam));
#else
  char *s = tmpnam(NULL);
  SCM_RETURN(SCM_MAKE_STRNIG_COPYING(s));
#endif")

(define-cproc sys-mkstemp (template::<string>)
  "
#ifdef HAVE_MKSTEMP
#define MKSTEMP_PATH_MAX 1025  /* Gee, remove me */
  char name[MKSTEMP_PATH_MAX];
  ScmObj sname;
  int siz = SCM_STRING_SIZE(template), fd;
  if (siz >= MKSTEMP_PATH_MAX-6) { 
    Scm_Error(\"pathname too long: %S\", template);
  }
  memcpy(name, SCM_STRING_START(template), siz);
  memcpy(name + siz, \"XXXXXX\", 6);
  name[siz+6] = '\\0';
  fd = Scm_SysCall(mkstemp(name));
  if (fd < 0) Scm_SysError(\"mkstemp failed\");
  sname = SCM_MAKE_STR_COPYING(name);
  SCM_RETURN(Scm_Values2(Scm_MakePortWithFd(sname, SCM_PORT_OUTPUT, fd, SCM_PORT_BUFFER_FULL, TRUE), sname));
#else
  /* TODO: provide alternative */
  Scm_Error(\"mkstemp() is not supported on this platform (yet)\");
  SCM_RETURN(SCM_UNDEFINED);
#endif")

;; tmpfile

;;---------------------------------------------------------------------
;; stdlib.h

(define-cproc sys-exit (code::<fixnum>)
  (return void "_exit"))

(define-cproc sys-getenv (name::<string>)
  "  const char *p = getenv(Scm_GetStringConst(name));
  if (p == NULL) {
    SCM_RETURN(SCM_FALSE);
  } else {
    SCM_RETURN(SCM_MAKE_STR_COPYING(p));
  }")

;; Note: the return value of system() is not portable.
(define-cproc sys-system (command::<string>)
  "  int r = Scm_SysCall(system(Scm_GetStringConst(command)));
  SCM_RETURN(Scm_MakeInteger(r));")

(define-cproc sys-random ()
  "#if defined(HAVE_RANDOM) && defined(HAVE_SRANDOM)
  SCM_RETURN(Scm_MakeInteger(random()));
#elif defined(LRAND48) && defined(SRAND48)
  SCM_RETURN(Scm_MakeInteger(lrand48()));
#else
  Scm_Error(\"system doesn't have either random() or lrand48()\");
  SCM_RETURN(SCM_UNDEFINED);
#endif")

(define-cproc sys-srandom (seed)
  "  if (!SCM_EXACTP(seed)) Scm_Error(\"exact integer required: %S\", seed);
#if defined(HAVE_RANDOM) && defined(HAVE_SRANDOM)
  srandom(Scm_GetUInteger(seed));
#elif defined(LRAND48) && defined(SRAND48)
  srand48(Scm_GetUInteger(seed));
#else
  Scm_Error(\"system doesn't have either srandom() or srand48()\");
#endif
  SCM_RETURN(SCM_UNDEFINED);")

(define-constant RAND_MAX (c "Scm_MakeIntegerFromUI(RAND_MAX)"))

;;---------------------------------------------------------------------
;; string.h

;;  use Scheme functions

;;---------------------------------------------------------------------
;; sys/stat.h

(define-type <sys-stat> "ScmSysStat*")

(define-cproc sys-stat (path::<string>)
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int r = Scm_SysCall(stat(Scm_GetStringConst(path), &s->statrec));
  if (r < 0) Scm_SysError(\"stat failed for %S\", path);
  SCM_RETURN(SCM_OBJ(s));")

(define-cproc sys-lstat (path::<string>)
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int r = Scm_SysCall(lstat(Scm_GetStringConst(path), &s->statrec));
  if (r < 0) Scm_SysError(\"lstat failed for %S\", path);
  SCM_RETURN(SCM_OBJ(s));")

(define-cproc sys-fstat (port-or-fd)
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int fd = Scm_GetPortFd(port_or_fd, FALSE), r;
  if (fd < 0) SCM_RETURN(SCM_FALSE);
  r = Scm_SysCall(fstat(fd, &s->statrec));
  if (r < 0) Scm_SysError(\"fstat failed for %d\", fd);
  SCM_RETURN(SCM_OBJ(s));")

;;---------------------------------------------------------------------
;; sys/wait.h

;; returns pid and status 
(define-cproc sys-wait ()
  "  int status;
  pid_t r = wait(&status);
  if (r < 0) {
    if (errno == EINTR) Scm_SigCheck(Scm_VM());
    Scm_SysError(\"wait() failed\");
  }
  SCM_RETURN(Scm_Values2(Scm_MakeInteger(r), Scm_MakeInteger(status)));")

(define-cproc sys-waitpid (pid::<int> &keyword (nohang #f) (untraced #f))
  "  int status, options = 0;  pid_t r;
  if (!SCM_FALSEP(nohang))   options |= WNOHANG;
  if (!SCM_FALSEP(untraced)) options |= WUNTRACED;
  r = waitpid(pid, &status, options);
  if (r < 0) {
    if (errno == EINTR) Scm_SigCheck(Scm_VM());
    Scm_SysError(\"waitpid() failed\");
  }
  SCM_RETURN(Scm_Values2(Scm_MakeInteger(r), Scm_MakeInteger(status)));")

;; status interpretation
(define-cproc sys-wait-exited? (status::<int>)
  (return <boolean> "WIFEXITED"))

(define-cproc sys-wait-exit-status (status::<int>)
  (return <int> "WEXITSTATUS"))

(define-cproc sys-wait-signaled? (status::<int>)
  (return <boolean> "WIFSIGNALED"))

(define-cproc sys-wait-termsig (status::<int>)
  (return <int> "WTERMSIG"))

(define-cproc sys-wait-stopped? (status::<int>)
  (return <boolean> "WIFSTOPPED"))

(define-cproc sys-wait-stopsig (status::<int>)
  (return <int> "WSTOPSIG"))

;;---------------------------------------------------------------------
;; time.h

(define-type <time> "ScmTime*")

(define-type <sys-tm> "ScmSysTm*")

(define-cproc sys-time ()
  "SCM_RETURN(Scm_MakeSysTime(time(NULL)));")

(define-cproc current-time ()           ;SRFI-18, SRFI-19, SRFI-21
  (return "Scm_CurrentTime"))

(define-cproc time? (obj)               ;SRFI-18, SRFI-19, SRFI-21
  (return <boolean> "SCM_TIMEP"))

(define-cproc time->seconds (t::<time>) ;SRFI-18
  (return "Scm_TimeToSeconds"))

(define-cproc seconds->time (t::<real>) ;SRFI-18
  (return "Scm_RealSecondsToTime"))

(define-cproc sys-asctime (tm::<sys-tm>)
  "  SCM_RETURN(SCM_MAKE_STR_COPYING(asctime(&SCM_SYS_TM_TM(tm))));")

(define-cproc sys-ctime (time)
  "time_t tim = Scm_GetSysTime(time);
  SCM_RETURN(SCM_MAKE_STR_COPYING(ctime(&tim)));")

(define-cproc sys-difftime (time1 time0)
  "SCM_RETURN(Scm_MakeFlonum(difftime(Scm_GetSysTime(time1),
                                      Scm_GetSysTime(time0))));")

(define-cproc sys-strftime (format::<string> tm::<sys-tm>)
  "  char tmpbuf[256];
  strftime(tmpbuf, sizeof(tmpbuf),
           Scm_GetStringConst(format), &SCM_SYS_TM_TM(tm));
  SCM_RETURN(SCM_MAKE_STR_COPYING(tmpbuf));")

(define-cproc sys-gmtime (time)
  "time_t tim = Scm_GetSysTime(time);
  SCM_RETURN(Scm_MakeSysTm(gmtime(&tim)));")

(define-cproc sys-localtime (time)
  "time_t tim = Scm_GetSysTime(time);
  SCM_RETURN(Scm_MakeSysTm(localtime(&tim)));")

(define-cproc sys-mktime (tm::<sys-tm>)
  "  SCM_RETURN(Scm_MakeSysTime(mktime(&SCM_SYS_TM_TM(tm))));")

;;---------------------------------------------------------------------
;; unistd.h - miscellaneous functions

(define-enum R_OK)
(define-enum W_OK)
(define-enum X_OK)
(define-enum F_OK)

;; FREEBSD's and Darwin's access(2) implementation is not quite reliable.
(define-cproc sys-access (pathname::<string> amode::<int>)
  "
#if defined(__FreeBSD__) || (defined(__APPLE__) && defined(__MACH__) && defined(__ppc__))
  struct stat statbuf;
  int r = Scm_SysCall(stat(Scm_GetStringConst(pathname), &statbuf));
  if (r < 0) SCM_RETURN(SCM_FALSE);
  if ((amode & R_OK) && !(statbuf.st_mode & S_IRUSR)) SCM_RETURN(SCM_FALSE);
  if ((amode & W_OK) && !(statbuf.st_mode & S_IWUSR)) SCM_RETURN(SCM_FALSE);
  if ((amode & X_OK) && !(statbuf.st_mode & S_IXUSR)) SCM_RETURN(SCM_FALSE);
  SCM_RETURN(SCM_TRUE);
#else
  int r = Scm_SysCall(access(Scm_GetStringConst(pathname), amode));
  SCM_RETURN((r == 0)? SCM_TRUE : SCM_FALSE);
#endif")

(define-cproc sys-chdir (pathname::<string>)
  "  if (Scm_SysCall(chdir(Scm_GetStringConst(pathname))) < 0)
    Scm_SysError(\"chdir failed\");
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-chmod (pathname::<string> mode::<int>)
  "  if (Scm_SysCall(chmod(Scm_GetStringConst(pathname), mode)) < 0)
    Scm_SysError(\"chmod failed\");
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-fork ()
  "  int pid = Scm_SysCall(fork());
  SCM_RETURN(Scm_MakeInteger(pid));")

(define-cproc sys-exec (command::<string> args::<list> &optional iomap)
  "  Scm_SysExec(command, args, iomap);
  SCM_RETURN(SCM_UNDEFINED); /* dummy */")

(define-cproc sys-getcwd ()
  "#define GETCWD_PATH_MAX 1024  /* TODO: needs to be configured */
  char p[GETCWD_PATH_MAX]; ScmObj s;
  if (getcwd(p, GETCWD_PATH_MAX-1) == NULL) Scm_SysError(\"getcwd failed\");
  s = SCM_MAKE_STR_COPYING(p);
  SCM_RETURN(s);")

(define-cproc sys-getegid () (return <int> "getegid"))
(define-cproc sys-getgid ()  (return <int> "getgid"))
(define-cproc sys-geteuid () (return <int> "geteuid"))
(define-cproc sys-getuid ()  (return <int> "getuid"))

(define-cproc sys-getgroups ()
  "
#ifndef NGROUPS
#define NGROUPS 32
#endif
  gid_t glist[NGROUPS], *pglist = glist;
  int size = NGROUPS;
  for (;;) {
    int i, n = getgroups(size, pglist);
    if (n >= 0) {
      ScmObj head = SCM_NIL, tail = SCM_NIL;
      for (i=0; i<n; i++) SCM_APPEND1(head, tail, Scm_MakeInteger(pglist[i]));
      SCM_RETURN(head);
    }
    if (errno == EINVAL) {
      size += NGROUPS;
      pglist = (gid_t *)SCM_MALLOC(size * sizeof(gid_t));
    } else {
      Scm_SysError(\"getgroups failed\");
    }
  }
  /* NOTREACHED */")

(define-cproc sys-getlogin ()
  "  const char *p = getlogin();
  if (p) SCM_RETURN(SCM_MAKE_STR_COPYING(p));
  else SCM_RETURN(SCM_FALSE);")

(define-cproc sys-getpid ()  (return <int> "getpid"))
(define-cproc sys-getppid () (return <int> "getppid"))

(define-cproc sys-link (existing::<string> new::<string>)
  "  if (Scm_SysCall(link(Scm_GetStringConst(existing), Scm_GetStringConst(new))) < 0)
        Scm_SysError(\"link failed\");
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-pause ()
  ;; We can't simply use pause().  If a signal is delivered after the last
  ;; Scm_SigCheck and before the call of pause(), the signal will just sit
  ;; in a queue and pause() may not return.
  (return "Scm_Pause"))

(define-cproc sys-alarm (seconds::<fixnum>)
  "  int r = Scm_SysCall(alarm(seconds));
  SCM_RETURN(Scm_MakeInteger(r));")

;; returns a list of two ports
(define-cproc sys-pipe (&keyword (name "(pipe)") (buffering #f) (buffered? #f))
  "  int fds[2], r, bufmode; ScmObj rend, wend;
  r = Scm_SysCall(pipe(fds));
  if (r < 0) Scm_SysError(\"pipe failed\");
  if (SCM_TRUEP(bufferedP)) {
    bufmode = SCM_PORT_BUFFER_FULL; /* for backward compatibility */
  } else {
    bufmode = Scm_BufferingMode(buffering, -1, SCM_PORT_BUFFER_LINE);
  }
  rend = Scm_MakePortWithFd(name, SCM_PORT_INPUT, fds[0], bufmode, TRUE);
  wend = Scm_MakePortWithFd(name, SCM_PORT_OUTPUT, fds[1], bufmode, TRUE);
  SCM_RETURN(Scm_Values2(rend, wend));")  

(define-cproc sys-mkdir (pathname::<string> mode::<int>)
  "  if (Scm_SysCall(mkdir(Scm_GetStringConst(pathname), mode)) < 0)
    Scm_SysError(\"mkdir failed\");
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-rmdir (pathname::<string>)
  "  if (Scm_SysCall(rmdir(Scm_GetStringConst(pathname))) < 0)
    Scm_SysError(\"rmdir failed\");
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-umask (mode::<fixnum>)
  (return <int> "umask"))

(define-cproc sys-sleep (seconds::<fixnum>)
  (return <int> "sleep"))

(if "defined(HAVE_USLEEP)"
    (define-cproc sys-usleep (microseconds::<uint32>)
      "int r = Scm_SysCall(usleep(microseconds));
    if (r < 0 && errno == EINVAL) {
      Scm_Error(\"invalid value for usleep: %d\", microseconds);
    }
    return SCM_MAKE_INT(r);"))

(define-cproc sys-unlink (pathname::<string>)
  "  if (Scm_SysCall(unlink(Scm_GetStringConst(pathname))) < 0) {
     if (errno == ENOENT) { SCM_RETURN(SCM_FALSE); }
     else Scm_SysError(\"unlink failed\");
  }
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-isatty (port_or_fd)
  "  int fd = Scm_GetPortFd(port_or_fd, FALSE);
  SCM_RETURN(SCM_MAKE_BOOL(fd >= 0 && isatty(fd)));")
  
(define-cproc sys-ttyname (port_or_fd)
  "  int fd = Scm_GetPortFd(port_or_fd, FALSE); const char *name;
  if (fd < 0) SCM_RETURN(SCM_FALSE);
  name = ttyname(fd);
  if (name) SCM_RETURN(SCM_MAKE_STR_COPYING(name));
  else SCM_RETURN(SCM_FALSE);")

;; NB. Linux needs _XOPEN_SOURCE defined before unistd.h to get crypt()
;; prototype.  However, it screws up something else.  Just for now I
;; cast the return value of crypt() to avoid it...such a kludge...
(if "defined(HAVE_CRYPT)"
(define-cproc sys-crypt (key::<string> salt::<string>)
  "
  SCM_RETURN(SCM_MAKE_STR_COPYING((const char *)crypt(Scm_GetStringConst(key),
                                                      Scm_GetStringConst(salt))));")
)

;; not supported yet:
;;  fpathconf lseek pathconf read sysconf write

;;---------------------------------------------------------------------
;; symbolic link

(if "defined(HAVE_SYMLINK)"
(define-cproc sys-symlink (existing::<string> new::<string>)
  "
#ifdef HAVE_SYMLINK
  int r = Scm_SysCall(symlink(Scm_GetStringConst(existing), Scm_GetStringConst(new)));
  if (r < 0) Scm_SysError(\"link failed\");
  SCM_RETURN(SCM_TRUE);
#else
  Scm_Error(\"the system doesn't support symbolic links\");
  SCM_RETURN(SCM_FALSE);
#endif
")
)

(if "defined(HAVE_READLINK)"
(define-cproc sys-readlink (path::<string>)
  "#define READLINK_PATH_MAX 1024  /* TODO: needs to be configured */
  char buf[READLINK_PATH_MAX];
  int n = Scm_SysCall(readlink(Scm_GetStringConst(path), buf, READLINK_PATH_MAX));
  if (n < 0) Scm_SysError(\"readlink failed\");
  if (n == READLINK_PATH_MAX) Scm_Error(\"readlink result too long\");
  return Scm_MakeString(buf, n, -1, SCM_MAKSTR_COPYING);")
)

;;---------------------------------------------------------------------
;; select

(define-type <sys-fdset> "ScmSysFdset*")

(define-cproc sys-fdset-ref (fdset::<sys-fdset> pf)
  "#ifdef HAVE_SELECT
  int fd = Scm_GetPortFd(pf, FALSE);
  if (fd < 0) SCM_RETURN(SCM_TRUE);
  else SCM_RETURN(SCM_MAKE_BOOL(FD_ISSET(fd, &fdset->fdset)));
#else
  SCM_RETURN(SCM_UNDEFINED); /* can't be here */
#endif"
  (setter sys-fdset-set!))
  
(define-cproc sys-fdset-set! (fdset::<sys-fdset> pf flag::<boolean>)
  "#ifdef HAVE_SELECT
  int fd = Scm_GetPortFd(pf, FALSE);
  if (fd >= 0) {
    if (flag) {
      FD_SET(fd, &fdset->fdset);
      if (fdset->maxfd < fd) fdset->maxfd = fd;
    } else {
      FD_CLR(fd, &fdset->fdset);
      if (fdset->maxfd == fd) {
        int i;
        for (i=fdset->maxfd-1; i>=0; i--) {
          if (FD_ISSET(i, &fdset->fdset)) break;
        }
        fdset->maxfd = i;
      }
    }
  }
#endif
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc sys-fdset-max-fd (fdset::<sys-fdset>)
  "  SCM_RETURN(Scm_MakeInteger(fdset->maxfd));")

(define-cproc sys-select (rfds wfds efds &optional (timeout #f))
  (return "Scm_SysSelect"))

(define-cproc sys-select! (rfds wfds efds &optional (timeout #f))
  (return "Scm_SysSelectX"))


;; Local variables:
;; mode: scheme
;; end:
