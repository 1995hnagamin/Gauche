;;;
;;; syslib.stub - system interface functions
;;;
;;;   Copyright (c) 2000-2002 Shiro Kawai (shiro@acm.org)
;;;
;;;   Permission to use, copy, modify, distribute this software and
;;;   accompanying documentation for any purpose is hereby granted,
;;;   provided that existing copyright notices are retained in all
;;;   copies and that this notice is included verbatim in all
;;;   distributions.
;;;   This software is provided as is, without express or implied
;;;   warranty.  In no circumstances the author(s) shall be liable
;;;   for any damages arising out of the use of this software.
;;;
;;; $Id: syslib.stub,v 1.78 2002-07-17 07:17:55 shirok Exp $
;;;

;; System interface functions.   Mostly I followed POSIX.1, but included
;; some non-posix functions which are important for programming on Unix.

"#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <locale.h>
#include <grp.h>
#include <pwd.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/wait.h>
#include <signal.h>
#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif
"

;;---------------------------------------------------------------------
;; dirent.h - read directory
;;   we don't have correspoinding functions, but provide these:

(define-cproc sys-readdir (pathname)
  (assert (string? pathname))
  "  SCM_RETURN(Scm_ReadDirectory(pathname));")

(define-cproc sys-glob (pattern)
  (assert (string? pattern))
  "  SCM_RETURN(Scm_GlobDirectory(pattern));")

;; Bonus

(define-cproc sys-normalize-pathname (pathname
                                      &keyword (absolute #f)
                                               (expand #f)
                                               (canonicalize #f))
  (assert (string? pathname))
  "  int flags = 0;
  if (!SCM_FALSEP(absolute)) flags |= SCM_PATH_ABSOLUTE;
  if (!SCM_FALSEP(expand))   flags |= SCM_PATH_EXPAND;
  if (!SCM_FALSEP(canonicalize)) flags |= SCM_PATH_CANONICALIZE;
  SCM_RETURN(Scm_NormalizePathname(pathname, flags));")

(define-cproc sys-basename (pathname)
  (assert (string? pathname))
  "  SCM_RETURN(Scm_BaseName(pathname));")

(define-cproc sys-dirname (pathname)
  (assert (string? pathname))
  "  SCM_RETURN(Scm_DirName(pathname));")

;;---------------------------------------------------------------------
;; grp.h - groups

(define-type "sys-group" sys-group?
  "ScmSysGroup*"  "SCM_SYS_GROUP_P" "SCM_SYS_GROUP")

(define-cproc sys-getgrgid (gid)
  (assert (small-integer? gid))         ;TODO: make sure it covers all gids
  "  SCM_RETURN(Scm_GetGroupById(gid));")
(define-cproc sys-getgrnam (name)
  (assert (string? name))
  "  SCM_RETURN(Scm_GetGroupByName(name));")

;; faster functions; bypassing creation of group object
(define-cproc sys-gid->group-name (gid)
  (assert (small-integer? gid))         ;TODO: make sure it covers all gids
  "  struct group *g = getgrgid(gid);
  if (g == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(SCM_MAKE_STR_COPYING(g->gr_name));")
(define-cproc sys-group-name->gid (name)
  (assert (string? name))
  "  struct group *g = getgrnam(Scm_GetStringConst(name));
  if (g == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(Scm_MakeInteger(g->gr_gid));")

;;---------------------------------------------------------------------
;; locale.h

(define-symbol |LC_ALL| "lc_all" "Scm_MakeInteger(LC_ALL)")
(define-symbol |LC_COLLATE| "lc_collate" "Scm_MakeInteger(LC_COLLATE)")
(define-symbol |LC_CTYPE| "lc_ctype" "Scm_MakeInteger(LC_CTYPE)")
(define-symbol |LC_MONETARY| "lc_monetary" "Scm_MakeInteger(LC_MONETARY)")
(define-symbol |LC_NUMERIC| "lc_numeric" "Scm_MakeInteger(LC_NUMERIC)")
(define-symbol |LC_TIME| "lc_time" "Scm_MakeInteger(LC_TIME)")

(define-cproc sys-setlocale (category locale)
  (assert (small-integer? category))
  (assert (string? locale))
  "  char *result = setlocale(category, Scm_GetStringConst(locale));
  if (result) SCM_RETURN(SCM_MAKE_STR_COPYING(result));
  else SCM_RETURN(SCM_FALSE);")

; struct lconv
(define-symbol decimal_point "sym_decimal_point")
(define-symbol thousands_sep "sym_thousands_sep")
(define-symbol grouping "sym_grouping")
(define-symbol int_curr_symbol "sym_int_curr_symbol")
(define-symbol currency_symbol "sym_currency_symbol")
(define-symbol mon_decimal_point "sym_mon_decimal_point")
(define-symbol mon_thousands_sep "sym_mon_thousands_sep")
(define-symbol mon_grouping "sym_mon_grouping")
(define-symbol positive_sign "sym_positive_sign")
(define-symbol negative_sign "sym_negative_sign")
(define-symbol int_frac_digits "sym_int_frac_digits")
(define-symbol frac_digits "sym_frac_digits")
(define-symbol p_cs_precedes "sym_p_cs_precedes")
(define-symbol p_sep_by_space "sym_p_sep_by_space")
(define-symbol n_cs_precedes "sym_n_cs_precedes")
(define-symbol n_sep_by_space "sym_n_sep_by_space")
(define-symbol p_sign_posn "sym_p_sign_posn")
(define-symbol n_sign_posn "sym_n_sign_posn")

(define-cproc sys-localeconv ()
  "  struct lconv *lc = localeconv();
  ScmObj h = SCM_NIL, t = SCM_NIL;

#define APPCONS(a, b) SCM_APPEND1(h, t, Scm_Cons(a, b))

  APPCONS(sym_decimal_point, SCM_MAKE_STR_COPYING(lc->decimal_point));
  APPCONS(sym_thousands_sep, SCM_MAKE_STR_COPYING(lc->thousands_sep));
  APPCONS(sym_grouping, SCM_MAKE_STR_COPYING(lc->grouping));
  APPCONS(sym_int_curr_symbol, SCM_MAKE_STR_COPYING(lc->int_curr_symbol));
  APPCONS(sym_currency_symbol, SCM_MAKE_STR_COPYING(lc->currency_symbol));
  APPCONS(sym_mon_decimal_point, SCM_MAKE_STR_COPYING(lc->mon_decimal_point));
  APPCONS(sym_mon_thousands_sep, SCM_MAKE_STR_COPYING(lc->mon_thousands_sep));
  APPCONS(sym_mon_grouping, SCM_MAKE_STR_COPYING(lc->mon_grouping));
  APPCONS(sym_positive_sign, SCM_MAKE_STR_COPYING(lc->positive_sign));
  APPCONS(sym_negative_sign, SCM_MAKE_STR_COPYING(lc->negative_sign));
  APPCONS(sym_int_frac_digits, SCM_MAKE_INT(lc->int_frac_digits));
  APPCONS(sym_frac_digits, SCM_MAKE_INT(lc->frac_digits));
  APPCONS(sym_p_cs_precedes, SCM_MAKE_BOOL(lc->p_cs_precedes));
  APPCONS(sym_p_sep_by_space, SCM_MAKE_BOOL(lc->p_sep_by_space));
  APPCONS(sym_n_cs_precedes, SCM_MAKE_BOOL(lc->n_cs_precedes));
  APPCONS(sym_n_sep_by_space, SCM_MAKE_BOOL(lc->n_sep_by_space));
  APPCONS(sym_p_sign_posn, SCM_MAKE_INT(lc->p_sign_posn));
  APPCONS(sym_n_sign_posn, SCM_MAKE_INT(lc->n_sign_posn));
#undef APPCONS
  return h;")

;;---------------------------------------------------------------------
;; math.h

;;---------------------------------------------------------------------
;; pwd.h - passwords

(define-type "sys-passwd" sys-passwd?
  "ScmSysPasswd*"  "SCM_SYS_PASSWD_P" "SCM_SYS_PASSWD")

(define-cproc sys-getpwuid (uid)
  (assert (small-integer? uid))         ;TODO: make sure it covers all gids
  "  SCM_RETURN(Scm_GetPasswdById(uid));")
(define-cproc sys-getpwnam (name)
  (assert (string? name))
  "  SCM_RETURN(Scm_GetPasswdByName(name));")

;; faster functions; bypassing creation of passwd object
(define-cproc sys-uid->user-name (uid)
  (assert (small-integer? uid))         ;TODO: make sure it covers all uids
  "  struct passwd *p = getpwuid(uid);
  if (p == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(SCM_MAKE_STR_COPYING(p->pw_name));")
(define-cproc sys-user-name->uid (name)
  (assert (string? name))
  "  struct passwd *p = getpwnam(Scm_GetStringConst(name));
  if (p == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(Scm_MakeInteger(p->pw_uid));")

;;---------------------------------------------------------------------
;; setjmp.h

;;  No equivalent functions --- use call/cc

;;---------------------------------------------------------------------
;; signal.h

(define-type "sys-sigset" sys-sigset?
  "ScmSysSigset*"  "SCM_SYS_SIGSET_P" "SCM_SYS_SIGSET")

(define-cproc sys-sigset-add! (set &rest sigs)
  (assert (sys-sigset? set))
  "SCM_RETURN(Scm_SysSigsetOp(set, sigs, FALSE));")

(define-cproc sys-sigset-delete! (set &rest sigs)
  (assert (sys-sigset? set))
  "SCM_RETURN(Scm_SysSigsetOp(set, sigs, TRUE));")

(define-cproc sys-sigset-fill! (set)
  (assert (sys-sigset? set))
  "SCM_RETURN(Scm_SysSigsetFill(set, FALSE));")

(define-cproc sys-sigset-empty! (set)
  (assert (sys-sigset? set))
  "SCM_RETURN(Scm_SysSigsetFill(set, TRUE));")

(define-cproc sys-signal-name (sig)
  (assert (small-integer? sig))
  "SCM_RETURN(Scm_SignalName(sig));")

(define-cproc sys-kill (pid sig)
  (assert (exact? pid))
  (assert (exact? sig))
  "  int r = Scm_SysCall(kill(pid, sig));
  if (r < 0) Scm_SysError(\"kill failed\");
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc set-signal-handler! (sig proc)
  "SCM_RETURN(Scm_SetSignalHandler(sig, proc));")

(define-cproc get-signal-handler (sig)
  (assert (exact? sig))
  "SCM_RETURN(Scm_GetSignalHandler(sig));")

(define-cproc get-signal-handlers ()
  "SCM_RETURN(Scm_GetSignalHandlers());")

(define-symbol SIG_SETMASK "sym_sig_setmask" "Scm_MakeInteger(SIG_SETMASK)")
(define-symbol SIG_BLOCK   "sym_sig_block"   "Scm_MakeInteger(SIG_BLOCK)")
(define-symbol SIG_UNBLOCK "sym_sig_unblock" "Scm_MakeInteger(SIG_UNBLOCK)")

(define-cproc sys-sigmask (how mask)
  (assert (small-integer? how))
  (assert (sys-sigset? mask))
  "SCM_RETURN(Scm_SysSigmask(how, mask));")

(define-cproc sys-sigsuspend (mask)
  (assert (sys-sigset? mask))
  "SCM_RETURN(Scm_SigSuspend(mask));")

;(define-cproc %with-signal-handlers (handlers thunk)
;  (assert (procedure? thunk))
;  "SCM_RETURN(Scm_VMWithSignalHandlers(handlers, thunk));")

;; raise should be handled by sys-kill

;;---------------------------------------------------------------------
;; stdio.h

(define-cproc sys-remove (filename)
  (assert (string? filename))
  "  if (Scm_SysCall(remove(Scm_GetStringConst(filename))) < 0)
       Scm_SysError(\"removing %S failed\", filename);
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-rename (old new)
  (assert (string? old))
  (assert (string? new))
  "  if (Scm_SysCall(rename(Scm_GetStringConst(old), Scm_GetStringConst(new))) < 0)
       Scm_SysError(\"renaming %S to %S failed\", old, new);
  SCM_RETURN(SCM_TRUE);")

;; NB: Alghough tmpnam() is in POSIX, its use is discouraged because of
;; potential security risk.  We mimic it's behavior by mkstemp() if possible.
(define-cproc sys-tmpnam ()
  "
#ifdef HAVE_MKSTEMP
  char nam[] = \"/tmp/fileXXXXXX\";
  int fd = Scm_SysCall(mkstemp(nam));
  if (fd < 0) Scm_SysError(\"mkstemp failed\");
  close(fd);
  unlink(nam);
  SCM_RETURN(SCM_MAKE_STR_COPYING(nam));
#else
  char *s = tmpnam(NULL);
  SCM_RETURN(SCM_MAKE_STRNIG_COPYING(s));
#endif")

(define-cproc sys-mkstemp (template)
  (assert (string? template))
  "
#ifdef HAVE_MKSTEMP
#define MKSTEMP_PATH_MAX 1025  /* Gee, remove me */
  char name[MKSTEMP_PATH_MAX];
  ScmObj sname;
  int siz = SCM_STRING_SIZE(template), fd;
  if (siz >= MKSTEMP_PATH_MAX-6) { 
    Scm_Error(\"pathname too long: %S\", template);
  }
  memcpy(name, SCM_STRING_START(template), siz);
  memcpy(name + siz, \"XXXXXX\", 6);
  name[siz+6] = '\\0';
  fd = Scm_SysCall(mkstemp(name));
  if (fd < 0) Scm_SysError(\"mkstemp failed\");
  sname = SCM_MAKE_STR_COPYING(name);
  SCM_RETURN(Scm_Values2(Scm_MakePortWithFd(sname, SCM_PORT_OUTPUT, fd, SCM_PORT_BUFFER_FULL, TRUE), sname));
#else
  /* TODO: provide alternative */
  Scm_Error(\"mkstemp() is not supported on this platform (yet)\");
  SCM_RETURN(SCM_UNDEFINED);
#endif")

;; tmpfile

;;---------------------------------------------------------------------
;; stdlib.h

(define-cproc sys-exit (code)
  (assert (small-integer? code))
  "  _exit(code); SCM_RETURN(SCM_FALSE);")

(define-cproc sys-getenv (name)
  (assert (string? name))
  "  const char *p = getenv(Scm_GetStringConst(name));
  if (p == NULL) {
    SCM_RETURN(SCM_FALSE);
  } else {
    SCM_RETURN(SCM_MAKE_STR_COPYING(p));
  }")

;; Note: the return value of system() is not portable.
(define-cproc sys-system (command)
  (assert (string? command))
  "  int r = Scm_SysCall(system(Scm_GetStringConst(command)));
  SCM_RETURN(Scm_MakeInteger(r));")

(define-cproc sys-random ()
  "#if defined(HAVE_RANDOM) && defined(HAVE_SRANDOM)
  SCM_RETURN(Scm_MakeInteger(random()));
#elif defined(LRAND48) && defined(SRAND48)
  SCM_RETURN(Scm_MakeInteger(lrand48()));
#else
  Scm_Error(\"system doesn't have either random() or lrand48()\");
  SCM_RETURN(SCM_UNDEFINED);
#endif")

(define-cproc sys-srandom (seed)
  "  if (!SCM_EXACTP(seed)) Scm_Error(\"exact integer required: %S\", seed);
#if defined(HAVE_RANDOM) && defined(HAVE_SRANDOM)
  srandom(Scm_GetUInteger(seed));
#elif defined(LRAND48) && defined(SRAND48)
  srand48(Scm_GetUInteger(seed));
#else
  Scm_Error(\"system doesn't have either srandom() or srand48()\");
#endif
  SCM_RETURN(SCM_UNDEFINED);")

(define-symbol |RAND_MAX| "sym_rand_max"
  "Scm_MakeInteger(LONG_MAX)")

;;---------------------------------------------------------------------
;; string.h

;;  use Scheme functions

;;---------------------------------------------------------------------
;; sys/stat.h

(define-type "sys-stat" sys-stat?
  "ScmSysStat*"  "SCM_SYS_STAT_P" "SCM_SYS_STAT")

(define-cproc sys-stat (path)
  (assert (string? path))
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int r = Scm_SysCall(stat(Scm_GetStringConst(path), &s->statrec));
  if (r < 0) Scm_SysError(\"stat failed for %S\", path);
  SCM_RETURN(SCM_OBJ(s));")

(define-cproc sys-lstat (path)
  (assert (string? path))
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int r = Scm_SysCall(lstat(Scm_GetStringConst(path), &s->statrec));
  if (r < 0) Scm_SysError(\"lstat failed for %S\", path);
  SCM_RETURN(SCM_OBJ(s));")

(define-cproc sys-fstat (port-or-fd)
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int fd = Scm_GetPortFd(port_or_fd, FALSE), r;
  if (fd < 0) SCM_RETURN(SCM_FALSE);
  r = Scm_SysCall(fstat(fd, &s->statrec));
  if (r < 0) Scm_SysError(\"fstat failed for %d\", fd);
  SCM_RETURN(SCM_OBJ(s));")

;;---------------------------------------------------------------------
;; sys/wait.h

;; returns pid and status 
(define-cproc sys-wait ()
  "  int status;
  pid_t r = wait(&status);
  if (r < 0) {
    if (errno == EINTR) Scm_SigCheck(Scm_VM());
    Scm_SysError(\"wait() failed\");
  }
  SCM_RETURN(Scm_Values2(Scm_MakeInteger(r), Scm_MakeInteger(status)));")

(define-cproc sys-waitpid (pid &keyword (nohang #f) (untraced #f))
  (assert (small-integer? pid))         ;TODO: small-int is enough?
  "  int status, options = 0;  pid_t r;
  if (!SCM_FALSEP(nohang))   options |= WNOHANG;
  if (!SCM_FALSEP(untraced)) options |= WUNTRACED;
  r = waitpid(pid, &status, options);
  if (r < 0) {
    if (errno == EINTR) Scm_SigCheck(Scm_VM());
    Scm_SysError(\"waitpid() failed\");
  }
  SCM_RETURN(Scm_Values2(Scm_MakeInteger(r), Scm_MakeInteger(status)));")

;; status interpretation
(define-cproc sys-wait-exited? (status)
  (assert (small-integer? status))      ;TODO: small-int is enough?
  "  SCM_RETURN(SCM_MAKE_BOOL(WIFEXITED(status)));")

(define-cproc sys-wait-exit-status (status)
  (assert (small-integer? status))      ;TODO: small-int is enough?
  "  SCM_RETURN(Scm_MakeInteger(WEXITSTATUS(status)));")

(define-cproc sys-wait-signaled? (status)
  (assert (small-integer? status))      ;TODO: small-int is enough?
  "  SCM_RETURN(SCM_MAKE_BOOL(WIFSIGNALED(status)));")

(define-cproc sys-wait-termsig (status)
  (assert (small-integer? status))      ;TODO: small-int is enough?
  "  SCM_RETURN(Scm_MakeInteger(WTERMSIG(status)));")

(define-cproc sys-wait-stopped? (status)
  (assert (small-integer? status))      ;TODO: small-int is enough?
  "  SCM_RETURN(SCM_MAKE_BOOL(WIFSTOPPED(status)));")

(define-cproc sys-wait-stopsig (status)
  (assert (small-integer? status))      ;TODO: small-int is enough?
  "  SCM_RETURN(Scm_MakeInteger(WSTOPSIG(status)));")

;;---------------------------------------------------------------------
;; time.h

(define-type "time" time?
  "ScmTime*"      "SCM_TIMEP"    "SCM_TIME")

(define-type "sys-tm" sys-tm?
  "ScmSysTm*"     "SCM_SYS_TM_P" "SCM_SYS_TM")

(define-cproc sys-time ()
  "SCM_RETURN(Scm_MakeSysTime(time(NULL)));")

(define-cproc current-time ()           ;SRFI-18, SRFI-19, SRFI-21
  "SCM_RETURN(Scm_CurrentTime());")

(define-cproc time? (obj)               ;SRFI-18, SRFI-19, SRFI-21
  "SCM_RETURN(SCM_MAKE_BOOL(SCM_TIMEP(obj)));")

(define-cproc time->seconds (t)         ;SRFI-18
  (assert (time? t))
  "SCM_RETURN(Scm_TimeToSeconds(t));")

(define-cproc seconds->time (t)         ;SRFI-18
  (assert (real? t))
  "SCM_RETURN(Scm_RealSecondsToTime(t));")

(define-cproc sys-asctime (tm)
  (assert (sys-tm? tm))
  "  SCM_RETURN(SCM_MAKE_STR_COPYING(asctime(&SCM_SYS_TM_TM(tm))));")

(define-cproc sys-ctime (time)
  "time_t tim = Scm_GetSysTime(time);
  SCM_RETURN(SCM_MAKE_STR_COPYING(ctime(&tim)));")

(define-cproc sys-difftime (time1 time0)
  "SCM_RETURN(Scm_MakeFlonum(difftime(Scm_GetSysTime(time1),
                                      Scm_GetSysTime(time0))));")

(define-cproc sys-strftime (format tm)
  (assert (string? format))
  (assert (sys-tm? tm))
  "  char tmpbuf[256];
  strftime(tmpbuf, sizeof(tmpbuf),
           Scm_GetStringConst(format), &SCM_SYS_TM_TM(tm));
  SCM_RETURN(SCM_MAKE_STR_COPYING(tmpbuf));")

(define-cproc sys-gmtime (time)
  "time_t tim = Scm_GetSysTime(time);
  SCM_RETURN(Scm_MakeSysTm(gmtime(&tim)));")

(define-cproc sys-localtime (time)
  "time_t tim = Scm_GetSysTime(time);
  SCM_RETURN(Scm_MakeSysTm(localtime(&tim)));")

(define-cproc sys-mktime (tm)
  (assert (sys-tm? tm))
  "  SCM_RETURN(Scm_MakeSysTime(mktime(&SCM_SYS_TM_TM(tm))));")

;;---------------------------------------------------------------------
;; unistd.h - miscellaneous functions

(define-symbol |R_OK| "sym_r_ok" "Scm_MakeInteger(R_OK)")
(define-symbol |W_OK| "sym_w_ok" "Scm_MakeInteger(W_OK)")
(define-symbol |X_OK| "sym_x_ok" "Scm_MakeInteger(X_OK)")
(define-symbol |F_OK| "sym_f_ok" "Scm_MakeInteger(F_OK)")

;; FREEBSD's and Darwin's access(2) implementation is not quite reliable.
(define-cproc sys-access (pathname amode)
  (assert (string? pathname))
  (assert (exact? amode))
  "
#if defined(__FreeBSD__) || (defined(__APPLE__) && defined(__MACH__) && defined(__ppc__))
  struct stat statbuf;
  int r = Scm_SysCall(stat(Scm_GetStringConst(pathname), &statbuf));
  if (r < 0) SCM_RETURN(SCM_FALSE);
  if ((amode & R_OK) && !(statbuf.st_mode & S_IRUSR)) SCM_RETURN(SCM_FALSE);
  if ((amode & W_OK) && !(statbuf.st_mode & S_IWUSR)) SCM_RETURN(SCM_FALSE);
  if ((amode & X_OK) && !(statbuf.st_mode & S_IXUSR)) SCM_RETURN(SCM_FALSE);
  SCM_RETURN(SCM_TRUE);
#else
  int r = Scm_SysCall(access(Scm_GetStringConst(pathname), amode));
  SCM_RETURN((r == 0)? SCM_TRUE : SCM_FALSE);
#endif")

(define-cproc sys-chdir (pathname)
  (assert (string? pathname))
  "  if (Scm_SysCall(chdir(Scm_GetStringConst(pathname))) < 0)
    Scm_SysError(\"chdir failed\");
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-chmod (pathname mode)
  (assert (string? pathname))
  (assert (small-integer? mode))
  "  if (Scm_SysCall(chmod(Scm_GetStringConst(pathname), mode)) < 0)
    Scm_SysError(\"chmod failed\");
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-fork ()
  "  int pid = Scm_SysCall(fork());
  SCM_RETURN(Scm_MakeInteger(pid));")

(define-cproc sys-exec (command args &optional iomap)
  (assert (string? command))
  (assert (list? args))
  "  Scm_SysExec(command, args, iomap);
  SCM_RETURN(SCM_UNDEFINED); /* dummy */")

(define-cproc sys-getcwd ()
  "#define GETCWD_PATH_MAX 1024  /* TODO: needs to be configured */
  char p[GETCWD_PATH_MAX]; ScmObj s;
  if (getcwd(p, GETCWD_PATH_MAX-1) == NULL) Scm_SysError(\"getcwd failed\");
  s = SCM_MAKE_STR_COPYING(p);
  SCM_RETURN(s);")

(define-cproc sys-getegid ()
  "  SCM_RETURN(Scm_MakeInteger(getegid()));")

(define-cproc sys-getgid ()
  "  SCM_RETURN(Scm_MakeInteger(getgid()));")

(define-cproc sys-geteuid ()
  "  SCM_RETURN(Scm_MakeInteger(geteuid()));")

(define-cproc sys-getuid ()
  "  SCM_RETURN(Scm_MakeInteger(getuid()));")

(define-cproc sys-getgroups ()
  "
#ifndef NGROUPS
#define NGROUPS 32
#endif
  gid_t glist[NGROUPS], *pglist = glist;
  int size = NGROUPS;
  for (;;) {
    int i, n = getgroups(size, pglist);
    if (n >= 0) {
      ScmObj head = SCM_NIL, tail = SCM_NIL;
      for (i=0; i<n; i++) SCM_APPEND1(head, tail, Scm_MakeInteger(pglist[i]));
      SCM_RETURN(head);
    }
    if (errno == EINVAL) {
      size += NGROUPS;
      pglist = (gid_t *)SCM_MALLOC(size * sizeof(gid_t));
    } else {
      Scm_SysError(\"getgroups failed\");
    }
  }
  /* NOTREACHED */")

(define-cproc sys-getlogin ()
  "  const char *p = getlogin();
  if (p) SCM_RETURN(SCM_MAKE_STR_COPYING(p));
  else SCM_RETURN(SCM_FALSE);")

(define-cproc sys-getpid ()
  "  SCM_RETURN(Scm_MakeInteger(getpid()));")

(define-cproc sys-getppid ()
  "  SCM_RETURN(Scm_MakeInteger(getppid()));")


(define-cproc sys-link (existing new)
  (assert (string? existing))
  (assert (string? new))
  "  if (Scm_SysCall(link(Scm_GetStringConst(existing), Scm_GetStringConst(new))) < 0)
        Scm_SysError(\"link failed\");
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-pause ()
  ;; We can't simply use pause().  If a signal is delivered after the last
  ;; Scm_SigCheck and before the call of pause(), the signal will just sit
  ;; in a queue and pause() may not return.
  "SCM_RETURN(Scm_Pause());")

(define-cproc sys-alarm (seconds)
  (assert (small-integer? seconds))
  "  int r = Scm_SysCall(alarm(seconds));
  SCM_RETURN(Scm_MakeInteger(r));")

;; returns a list of two ports
(define-cproc sys-pipe (&keyword (name "(pipe)") (buffering #f) (buffered? #f))
  "  int fds[2], r, bufmode; ScmObj rend, wend;
  r = Scm_SysCall(pipe(fds));
  if (r < 0) Scm_SysError(\"pipe failed\");
  if (SCM_TRUEP(bufferedP)) {
    bufmode = SCM_PORT_BUFFER_FULL; /* for backward compatibility */
  } else {
    bufmode = Scm_BufferingMode(buffering, -1, SCM_PORT_BUFFER_LINE);
  }
  rend = Scm_MakePortWithFd(name, SCM_PORT_INPUT, fds[0], bufmode, TRUE);
  wend = Scm_MakePortWithFd(name, SCM_PORT_OUTPUT, fds[1], bufmode, TRUE);
  SCM_RETURN(Scm_Values2(rend, wend));")  

(define-cproc sys-mkdir (pathname mode)
  (assert (string? pathname))
  (assert (small-integer? mode))
  "  if (Scm_SysCall(mkdir(Scm_GetStringConst(pathname), mode)) < 0)
    Scm_SysError(\"mkdir failed\");
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-rmdir (pathname)
  (assert (string? pathname))
  "  if (Scm_SysCall(rmdir(Scm_GetStringConst(pathname))) < 0)
    Scm_SysError(\"rmdir failed\");
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-umask (mode)
  (assert (small-integer? mode))
  "  SCM_RETURN(Scm_MakeInteger(umask(mode)));")

(define-cproc sys-sleep (seconds)
  (assert (exact? seconds))
  "  SCM_RETURN(Scm_MakeInteger(sleep(seconds)));")

(define-cproc sys-unlink (pathname)
  (assert (string? pathname))
  "  if (Scm_SysCall(unlink(Scm_GetStringConst(pathname))) < 0) {
     if (errno == ENOENT) { SCM_RETURN(SCM_FALSE); }
     else Scm_SysError(\"unlink failed\");
  }
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-isatty (port_or_fd)
  "  int fd = Scm_GetPortFd(port_or_fd, FALSE);
  SCM_RETURN(SCM_MAKE_BOOL(fd >= 0 && isatty(fd)));")
  
(define-cproc sys-ttyname (port_or_fd)
  "  int fd = Scm_GetPortFd(port_or_fd, FALSE); const char *name;
  if (fd < 0) SCM_RETURN(SCM_FALSE);
  name = ttyname(fd);
  if (name) SCM_RETURN(SCM_MAKE_STR_COPYING(name));
  else SCM_RETURN(SCM_FALSE);")

;; NB. Linux needs _XOPEN_SOURCE defined before unistd.h to get crypt()
;; prototype.  However, it screws up something else.  Just for now I
;; cast the return value of crypt() to avoid it...such a kludge...
(if "defined(HAVE_CRYPT)"
(define-cproc sys-crypt (key salt)
  (assert (string? key))
  (assert (string? salt))
  "
  SCM_RETURN(SCM_MAKE_STR_COPYING((const char *)crypt(Scm_GetStringConst(key),
                                                      Scm_GetStringConst(salt))));")
)

;; not supported yet:
;;  fpathconf lseek pathconf read sysconf write

;;---------------------------------------------------------------------
;; symbolic link

(if "defined(HAVE_SYMLINK)"
(define-cproc sys-symlink (existing new)
  (assert (string? existing))
  (assert (string? new))
  "
#ifdef HAVE_SYMLINK
  int r = Scm_SysCall(symlink(Scm_GetStringConst(existing), Scm_GetStringConst(new)));
  if (r < 0) Scm_SysError(\"link failed\");
  SCM_RETURN(SCM_TRUE);
#else
  Scm_Error(\"the system doesn't support symbolic links\");
  SCM_RETURN(SCM_FALSE);
#endif
")
)

(if "defined(HAVE_READLINK)"
(define-cproc sys-readlink (path)
  (assert (string? path))
  "#define READLINK_PATH_MAX 1024  /* TODO: needs to be configured */
  char buf[READLINK_PATH_MAX];
  int n = Scm_SysCall(readlink(Scm_GetStringConst(path), buf, READLINK_PATH_MAX));
  if (n < 0) Scm_SysError(\"readlink failed\");
  if (n == READLINK_PATH_MAX) Scm_Error(\"readlink result too long\");
  return Scm_MakeString(buf, n, -1, SCM_MAKSTR_COPYING);")
)

;;---------------------------------------------------------------------
;; select

(define-type "sys-fdset" sys-fdset?
  "ScmSysFdset*"  "SCM_SYS_FDSET_P" "SCM_SYS_FDSET")

(define-cproc sys-fdset-ref (fdset pf)
  (assert (sys-fdset? fdset))
  "#ifdef HAVE_SELECT
  int fd = Scm_GetPortFd(pf, FALSE);
  if (fd < 0) SCM_RETURN(SCM_TRUE);
  else SCM_RETURN(SCM_MAKE_BOOL(FD_ISSET(fd, &fdset->fdset)));
#else
  SCM_RETURN(SCM_UNDEFINED); /* can't be here */
#endif"
  (setter sys-fdset-set!))
  
(define-cproc sys-fdset-set! (fdset pf flag)
  (assert (sys-fdset? fdset))
  (assert (boolean? flag))
  "#ifdef HAVE_SELECT
  int fd = Scm_GetPortFd(pf, FALSE);
  if (fd >= 0) {
    if (flag) {
      FD_SET(fd, &fdset->fdset);
      if (fdset->maxfd < fd) fdset->maxfd = fd;
    } else {
      FD_CLR(fd, &fdset->fdset);
      if (fdset->maxfd == fd) {
        int i;
        for (i=fdset->maxfd-1; i>=0; i--) {
          if (FD_ISSET(i, &fdset->fdset)) break;
        }
        fdset->maxfd = i;
      }
    }
  }
#endif
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc sys-fdset-max-fd (fdset)
  (assert (sys-fdset? fdset))
  "  SCM_RETURN(Scm_MakeInteger(fdset->maxfd));")

(define-cproc sys-select (rfds wfds efds &optional (timeout #f))
  "  SCM_RETURN(Scm_SysSelect(rfds, wfds, efds, timeout));")

(define-cproc sys-select! (rfds wfds efds &optional (timeout #f))
  "  SCM_RETURN(Scm_SysSelectX(rfds, wfds, efds, timeout));")


;; Local variables:
;; mode: scheme
;; end:
