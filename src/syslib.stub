;;;
;;; syslib.stub - system interface functions
;;;  
;;;   Copyright (c) 2000-2005 Shiro Kawai, All rights reserved.
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: syslib.stub,v 1.104 2005-08-07 23:42:23 shirok Exp $
;;;

;; System interface functions.   Mostly I followed POSIX.1, but included
;; some non-posix functions which are important for programming on Unix.

"#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <locale.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <math.h>
#ifndef __MINGW32__
#include <sys/wait.h>
#include <grp.h>
#include <pwd.h>
#endif /*!__MINGW32__*/
#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif
"

;;---------------------------------------------------------------------
;; dirent.h - read directory
;;   we don't have correspoinding functions, but provide these:

(define-cproc sys-readdir (pathname::<string>)
  (call "Scm_ReadDirectory"))

(define-cproc sys-glob (pattern::<string>)
  (call "Scm_GlobDirectory"))

;; Bonus

(define-cproc sys-normalize-pathname (pathname::<string>
                                      &keyword (absolute #f)
                                               (expand #f)
                                               (canonicalize #f))
  "  int flags = 0;
  if (!SCM_FALSEP(absolute)) flags |= SCM_PATH_ABSOLUTE;
  if (!SCM_FALSEP(expand))   flags |= SCM_PATH_EXPAND;
  if (!SCM_FALSEP(canonicalize)) flags |= SCM_PATH_CANONICALIZE;
  SCM_RETURN(Scm_NormalizePathname(pathname, flags));")

(define-cproc sys-basename (pathname::<string>)
  (call "Scm_BaseName"))

(define-cproc sys-dirname (pathname::<string>)
  (call "Scm_DirName"))

;;---------------------------------------------------------------------
;; grp.h - groups

(define-type <sys-group> "ScmSysGroup*")

(define-cproc sys-getgrgid (gid::<int>)
  (call "Scm_GetGroupById"))
(define-cproc sys-getgrnam (name::<string>)
  (call "Scm_GetGroupByName"))

;; faster functions; bypassing creation of group object
(define-cproc sys-gid->group-name (gid::<int>)
  "  struct group *g = getgrgid(gid);
  if (g == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(SCM_MAKE_STR_COPYING(g->gr_name));")
(define-cproc sys-group-name->gid (name::<string>)
  "  struct group *g = getgrnam(Scm_GetStringConst(name));
  if (g == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(Scm_MakeInteger(g->gr_gid));")

;;---------------------------------------------------------------------
;; locale.h

(define-enum LC_ALL)
(define-enum LC_COLLATE)
(define-enum LC_CTYPE)
(define-enum LC_MONETARY)
(define-enum LC_NUMERIC)
(define-enum LC_TIME)

(define-cproc sys-setlocale (category::<fixnum> locale::<const-cstring>)
  (call maybe:<const-cstring> "setlocale"))

;;---------------------------------------------------------------------
;; math.h

;;---------------------------------------------------------------------
;; pwd.h - passwords

(define-type <sys-passwd> "ScmSysPasswd*")

(define-cproc sys-getpwuid (uid::<int>)
  (call "Scm_GetPasswdById"))
(define-cproc sys-getpwnam (name::<string>)
  (call "Scm_GetPasswdByName"))

;; faster functions; bypassing creation of passwd object
(define-cproc sys-uid->user-name (uid::<int>)
  "  struct passwd *p = getpwuid(uid);
  if (p == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(SCM_MAKE_STR_COPYING(p->pw_name));")
(define-cproc sys-user-name->uid (name::<string>)
  "  struct passwd *p = getpwnam(Scm_GetStringConst(name));
  if (p == NULL) { Scm_SigCheck(Scm_VM()); SCM_RETURN(SCM_FALSE); }
  else SCM_RETURN(Scm_MakeInteger(p->pw_uid));")

;;---------------------------------------------------------------------
;; setjmp.h

;;  No equivalent functions --- use call/cc

;;---------------------------------------------------------------------
;; signal.h

(define-type <sys-sigset> "ScmSysSigset*")

(define-cproc sys-sigset-add! (set::<sys-sigset> &rest sigs)
  (expr "Scm_SysSigsetOp(set, sigs, FALSE)"))

(define-cproc sys-sigset-delete! (set::<sys-sigset> &rest sigs)
  (expr "Scm_SysSigsetOp(set, sigs, TRUE)"))

(define-cproc sys-sigset-fill! (set::<sys-sigset>)
  (expr "Scm_SysSigsetFill(set, FALSE)"))

(define-cproc sys-sigset-empty! (set::<sys-sigset>)
  (expr "Scm_SysSigsetFill(set, TRUE)"))

(define-cproc sys-signal-name (sig::<fixnum>)
  (call "Scm_SignalName"))

(define-cproc sys-kill (pid::<int> sig::<fixnum>)
  (body <void>
        "int r; SCM_SYSCALL(r, kill(pid, sig));"
        "if (r < 0) Scm_SysError(\"kill failed\");"))

(define-cproc set-signal-handler! (sig proc)
  (call "Scm_SetSignalHandler"))

(define-cproc get-signal-handler (sig::<fixnum>)
  (call "Scm_GetSignalHandler"))

(define-cproc get-signal-handlers ()
  (call "Scm_GetSignalHandlers"))

(define-enum SIG_SETMASK)
(define-enum SIG_BLOCK)
(define-enum SIG_UNBLOCK)

(define-cproc sys-sigmask (how::<fixnum> mask::<sys-sigset>)
  (call "Scm_SysSigmask"))

(define-cproc sys-sigsuspend (mask::<sys-sigset>)
  (call "Scm_SigSuspend"))

;(define-cproc %with-signal-handlers (handlers thunk)
;  (assert (procedure? thunk))
;  "SCM_RETURN(Scm_VMWithSignalHandlers(handlers, thunk));")

;; raise should be handled by sys-kill

;;---------------------------------------------------------------------
;; stdio.h

(define-cproc sys-remove (filename::<const-cstring>)
  "  int r;
  SCM_SYSCALL(r, remove(filename));
  if (r < 0) Scm_SysError(\"removing %s failed\", filename);
  SCM_RETURN(SCM_TRUE);")

(define-cproc sys-rename (oldname::<const-cstring> newname::<const-cstring>)
  "  int r;
#if defined(__MINGW32__)
  /* Windows doesn't allow renaming to the existing file, so we unlink
     it first.  This breaks the atomicity of rename operation.
     We don't check and raise an error here, since the error will be
     caught by rename() call. */
  chmod(newname, 0666);
  unlink(newname);
#endif /* __MINGW32__ */
  SCM_SYSCALL(r, rename(oldname, newname));
  if (r < 0) Scm_SysError(\"renaming %s to %s failed\", oldname, newname);
  SCM_RETURN(SCM_TRUE);")

;; NB: Alghough tmpnam() is in POSIX, its use is discouraged because of
;; potential security risk.  We mimic it's behavior by mkstemp() if possible.
(define-cproc sys-tmpnam ()
  "
#ifdef HAVE_MKSTEMP
  char nam[] = \"/tmp/fileXXXXXX\";
  int fd;
  SCM_SYSCALL(fd, mkstemp(nam));
  if (fd < 0) Scm_SysError(\"mkstemp failed\");
  close(fd);
  unlink(nam);
  SCM_RETURN(SCM_MAKE_STR_COPYING(nam));
#else
  char *s = tmpnam(NULL);
  SCM_RETURN(SCM_MAKE_STR_COPYING(s));
#endif")

(define-cproc sys-mkstemp (template::<string>)
  (call "Scm_SysMkstemp"))

;; tmpfile

;;---------------------------------------------------------------------
;; stdlib.h

(define-cproc sys-exit (code::<fixnum>)
  (call <void> "_exit"))

(define-cproc sys-getenv (name::<const-cstring>)
  (call maybe:<const-cstring> "getenv"))

;; Note: the return value of system() is not portable.
(define-cproc sys-system (command::<const-cstring>)
  (body <int>
        "SCM_SYSCALL(SCM_RESULT, system(command));"))

(define-cproc sys-random ()
  "#if defined(HAVE_RANDOM) && defined(HAVE_SRANDOM)
  SCM_RETURN(Scm_MakeInteger(random()));
#elif defined(LRAND48) && defined(SRAND48)
  SCM_RETURN(Scm_MakeInteger(lrand48()));
#else
  /* fallback - we don't want to use rand(), for it is not very good RNG.
     replace it when we have time. */
  SCM_RETURN(Scm_MakeInteger(rand()));
#endif")

(define-cproc sys-srandom (seed)
  "  if (!SCM_EXACTP(seed)) Scm_Error(\"exact integer required: %S\", seed);
#if defined(HAVE_RANDOM) && defined(HAVE_SRANDOM)
  srandom(Scm_GetUInteger(seed));
#elif defined(LRAND48) && defined(SRAND48)
  srand48(Scm_GetUInteger(seed));
#else
  /* fallback - we don't want to use rand(), for it is not very good RNG.
     replace it when we have time. */
  srand(Scm_GetUInteger(seed));
#endif
  SCM_RETURN(SCM_UNDEFINED);")

(define-constant RAND_MAX (c "Scm_MakeIntegerFromUI(RAND_MAX)"))

;;---------------------------------------------------------------------
;; string.h

;; TODO: for thread safety, we should use strerror_r when available.
;; unfortunately there are conflicting versions of strerror_r among
;; various systems.
(define-cproc sys-strerror (errno::<int>)
  (call <const-cstring> "strerror"))

;;---------------------------------------------------------------------
;; sys/stat.h

(define-type <sys-stat> "ScmSysStat*")

(define-cproc sys-stat (path::<const-cstring>)
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int r;
  SCM_SYSCALL(r, stat(path, &s->statrec));
  if (r < 0) Scm_SysError(\"stat failed for %s\", path);
  SCM_RETURN(SCM_OBJ(s));")

(if "!defined(__MINGW32__)"
(define-cproc sys-lstat (path::<const-cstring>)
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int r;
  SCM_SYSCALL(r, lstat(path, &s->statrec));
  if (r < 0) Scm_SysError(\"lstat failed for %s\", path);
  SCM_RETURN(SCM_OBJ(s));")
)

(define-cproc sys-fstat (port-or-fd)
  "  ScmSysStat *s = SCM_SYS_STAT(Scm_MakeSysStat());
  int fd = Scm_GetPortFd(port_or_fd, FALSE), r;
  if (fd < 0) SCM_RETURN(SCM_FALSE);
  SCM_SYSCALL(r, fstat(fd, &s->statrec));
  if (r < 0) Scm_SysError(\"fstat failed for %d\", fd);
  SCM_RETURN(SCM_OBJ(s));")

;;---------------------------------------------------------------------
;; sys/wait.h

(if "!defined(__MINGW32__)" (begin

;; returns pid and status 
(define-cproc sys-wait ()
  (body (<int> <int>)
        "int status;  pid_t r = wait(&status);"
        "if (r < 0) {"
        "  if (errno == EINTR) Scm_SigCheck(Scm_VM());"
        "  Scm_SysError(\"wait() failed\");"
        "}"
        "SCM_RESULT0 = r; SCM_RESULT1 = status;"))

(define-cproc sys-waitpid (pid::<int> &keyword (nohang #f) (untraced #f))
  (body (<int> <int>)
        "  int status, options = 0;  pid_t r;"
        "if (!SCM_FALSEP(nohang))   options |= WNOHANG;"
        "if (!SCM_FALSEP(untraced)) options |= WUNTRACED;"
        "r = waitpid(pid, &status, options);"
        "if (r < 0) {"
        "  if (errno == EINTR) Scm_SigCheck(Scm_VM());"
        "  Scm_SysError(\"waitpid() failed\");"
        "}"
        "SCM_RESULT0 = r; SCM_RESULT1 = status;"))

;; status interpretation
(define-cproc sys-wait-exited? (status::<int>)
  (call <boolean> "WIFEXITED"))

(define-cproc sys-wait-exit-status (status::<int>)
  (call <int> "WEXITSTATUS"))

(define-cproc sys-wait-signaled? (status::<int>)
  (call <boolean> "WIFSIGNALED"))

(define-cproc sys-wait-termsig (status::<int>)
  (call <int> "WTERMSIG"))

(define-cproc sys-wait-stopped? (status::<int>)
  (call <boolean> "WIFSTOPPED"))

(define-cproc sys-wait-stopsig (status::<int>)
  (call <int> "WSTOPSIG"))

)) ;; !defined(__MINGW32__)

;;---------------------------------------------------------------------
;; time.h

(define-type <time> "ScmTime*")

(define-type <sys-tm> "ScmSysTm*")

(define-cproc sys-time ()
  (expr "Scm_MakeSysTime(time(NULL))"))

(define-cproc current-time ()           ;SRFI-18, SRFI-19, SRFI-21
  (call "Scm_CurrentTime"))

(define-cproc time? (obj)               ;SRFI-18, SRFI-19, SRFI-21
  (call <boolean> "SCM_TIMEP"))

(define-cproc time->seconds (t::<time>) ;SRFI-18
  (call "Scm_TimeToSeconds"))

(define-cproc seconds->time (t::<real>) ;SRFI-18
  (call "Scm_RealSecondsToTime"))

(define-cproc sys-asctime (tm::<sys-tm>)
  (expr "SCM_MAKE_STR_COPYING(asctime(&SCM_SYS_TM_TM(tm)))"))

(define-cproc sys-ctime (time)
  (body <const-cstring>
        "time_t tim = Scm_GetSysTime(time);"
        "SCM_RESULT = ctime(&tim);"))

(define-cproc sys-difftime (time1 time0)
  (expr <double> "difftime(Scm_GetSysTime(time1), Scm_GetSysTime(time0))"))

(define-cproc sys-strftime (format::<const-cstring> tm::<sys-tm>)
  (body <const-cstring>
        "char tmpbuf[256];"
        "strftime(tmpbuf, sizeof(tmpbuf), format, &SCM_SYS_TM_TM(tm));"
        "SCM_RESULT = tmpbuf;"))

(define-cproc sys-gmtime (time)
  (body "time_t tim = Scm_GetSysTime(time);"
        "SCM_RESULT = Scm_MakeSysTm(gmtime(&tim));"))

(define-cproc sys-localtime (time)
  (body "time_t tim = Scm_GetSysTime(time);"
        "SCM_RESULT = Scm_MakeSysTm(localtime(&tim));"))

(define-cproc sys-mktime (tm::<sys-tm>)
  (expr "Scm_MakeSysTime(mktime(&SCM_SYS_TM_TM(tm)))"))

;;---------------------------------------------------------------------
;; unistd.h - miscellaneous functions

(define-enum R_OK)
(define-enum W_OK)
(define-enum X_OK)
(define-enum F_OK)

(define-cproc sys-access (pathname::<const-cstring> amode::<int>)
  (body <boolean>
        "int r;"
        "if (Scm_IsSugid()) {
           Scm_Error(\"cannot use sys-access in suid/sgid program.\");"
        "}"
        "SCM_SYSCALL(r, access(pathname, amode));"
        "SCM_RESULT = (r == 0);"))

(define-cproc sys-chdir (pathname::<const-cstring>)
  (body "int r; SCM_SYSCALL(r, chdir(pathname));"
        "if (r < 0) Scm_SysError(\"chdir failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-chmod (pathname::<const-cstring> mode::<int>)
  (body "int r; SCM_SYSCALL(r, chmod(pathname, mode));"
        "if (r < 0) Scm_SysError(\"chmod failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-fork ()
  (body <int>
        "pid_t pid; SCM_SYSCALL(pid, fork());"
        "if (pid < 0) Scm_SysError(\"fork failed\");"
        "SCM_RESULT = pid;"))

(define-cproc sys-exec (command::<string> args::<list> &optional iomap)
  (body <void> "Scm_SysExec(command, args, iomap, FALSE);"))

(define-cproc sys-fork-and-exec (command::<string> args::<list>
                                                   &optional iomap)
  (expr "Scm_SysExec(command, args, iomap, TRUE)"))

(define-cproc sys-getcwd ()
  (body <const-cstring>
        "#define GETCWD_PATH_MAX 1024  /* TODO: needs to be configured */"
        "char p[GETCWD_PATH_MAX];"
        "if (getcwd(p, GETCWD_PATH_MAX-1) == NULL) {"
        "  Scm_SysError(\"getcwd failed\");"
        "}"
        "SCM_RESULT = p;"))

(define-cproc sys-getegid () (call <int> "getegid"))
(define-cproc sys-getgid ()  (call <int> "getgid"))
(define-cproc sys-geteuid () (call <int> "geteuid"))
(define-cproc sys-getuid ()  (call <int> "getuid"))

(define-cproc sys-getpid ()  (call <int> "getpid"))
(define-cproc sys-getppid () (call <int> "getppid"))

(define-cproc sys-link (existing::<const-cstring> newpath::<const-cstring>)
  (body "int r; SCM_SYSCALL(r, link(existing, newpath));"
        "if (r < 0) Scm_SysError(\"link failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-pause ()
  ;; We can't simply use pause().  If a signal is delivered after the last
  ;; Scm_SigCheck and before the call of pause(), the signal will just sit
  ;; in a queue and pause() may not return.
  (call "Scm_Pause"))

(define-cproc sys-alarm (seconds::<fixnum>)
  (body <int> "SCM_SYSCALL(SCM_RESULT, alarm(seconds));"))

;; returns a list of two ports
(define-cproc sys-pipe (&keyword (name "(pipe)") (buffering #f) (buffered? #f))
  (body (<top> <top>)
        "int fds[2], r, bufmode;"
        "SCM_SYSCALL(r, pipe(fds));"
        "if (r < 0) Scm_SysError(\"pipe failed\");"
        "if (SCM_TRUEP(bufferedP)) {"
        "  bufmode = SCM_PORT_BUFFER_FULL; /* for backward compatibility */"
        "} else {"
        "  bufmode = Scm_BufferingMode(buffering, -1, SCM_PORT_BUFFER_LINE);"
        "}"
        "SCM_RESULT0 = Scm_MakePortWithFd(name, SCM_PORT_INPUT, fds[0], bufmode, TRUE);"
        "SCM_RESULT1 = Scm_MakePortWithFd(name, SCM_PORT_OUTPUT, fds[1], bufmode, TRUE);"))
        

(define-cproc sys-mkdir (pathname::<const-cstring> mode::<int>)
  (body "int r;"
        "#ifndef __MINGW32__"
        "SCM_SYSCALL(r, mkdir(pathname, mode));"
        "#else"
        "SCM_SYSCALL(r, mkdir(pathname));"
        "#endif /*__MINGW32__*/"
        "if (r < 0) Scm_SysError(\"mkdir failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-rmdir (pathname::<const-cstring>)
  (body "int r; SCM_SYSCALL(r, rmdir(pathname));"
        "if (r < 0) Scm_SysError(\"rmdir failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-umask (mode::<fixnum>)
  (call <int> "umask"))

(define-cproc sys-sleep (seconds::<fixnum>)
  (call <int> "sleep"))

(if "defined(HAVE_NANOSLEEP)"
    (define-cproc sys-nanosleep (nanoseconds)
      "struct timespec spec, rem;
       if (SCM_TIMEP(nanoseconds)) {
           spec.tv_sec = SCM_TIME(nanoseconds)->sec;
           spec.tv_nsec = SCM_TIME(nanoseconds)->nsec;
       } else if (!SCM_REALP(nanoseconds)) {
           Scm_Error(\"bad timeout spec: <time> object or real number is required, but got %S\", nanoseconds);
       } else {
           double v = Scm_GetDouble(nanoseconds);
           if (v < 0) Scm_Error(\"bad timeout spec: positive number required, but got %S\", nanoseconds);
           spec.tv_sec = (unsigned long)floor(v/1.0e9);
           spec.tv_nsec = (unsigned long)fmod(v, 1.0e9);
           while (spec.tv_nsec >= 1000000000) {
               spec.tv_nsec -= 1000000000;
               spec.tv_sec += 1;
           }
       }
       rem.tv_sec = rem.tv_nsec = 0;
       nanosleep(&spec, &rem);
       if (rem.tv_sec == 0 && rem.tv_nsec == 0) SCM_RETURN(SCM_FALSE);
       else SCM_RETURN(Scm_MakeTime(SCM_FALSE, rem.tv_sec, rem.tv_nsec));"))

(define-cproc sys-unlink (pathname::<const-cstring>)
  (body "int r; SCM_SYSCALL(r, unlink(pathname));"
        "if (r < 0) {"
        "  if (errno == ENOENT) { SCM_RETURN(SCM_FALSE); }"
        "  else Scm_SysError(\"unlink failed\");"
        "}"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-isatty (port_or_fd)
  (body <boolean>
        "int fd = Scm_GetPortFd(port_or_fd, FALSE);"
        "SCM_RESULT = (fd >= 0 && isatty(fd));"))
  
(define-cproc sys-ttyname (port_or_fd)
  (body maybe:<const-cstring>
        "int fd = Scm_GetPortFd(port_or_fd, FALSE);"
        "if (fd < 0) SCM_RESULT = NULL;"
        "else SCM_RESULT = ttyname(fd);"))

(define-cproc sys-truncate (path::<const-cstring> length::<integer>)
  (body "int r; SCM_SYSCALL(r, truncate(path, Scm_IntegerToOffset(length)));"
        "if (r < 0) Scm_SysError(\"truncate failed\");"
        "SCM_RESULT = SCM_TRUE;"))

(define-cproc sys-ftruncate (port_or_fd length::<integer>)
  (body "int r; int fd = Scm_GetPortFd(port_or_fd, TRUE);"
        "SCM_SYSCALL(r, ftruncate(fd, Scm_IntegerToOffset(length)));"
        "if (r < 0) Scm_SysError(\"ftruncate failed\");"
        "SCM_RESULT = SCM_TRUE;"))

;; NB. Linux needs _XOPEN_SOURCE defined before unistd.h to get crypt()
;; prototype.  However, it screws up something else.  Just for now I
;; cast the return value of crypt() to avoid it...such a kludge...
(if "defined(HAVE_CRYPT)"
(define-cproc sys-crypt (key::<const-cstring> salt::<const-cstring>)
  (expr <const-cstring> "(const char *)crypt(key, salt)"))
)

;; not supported yet:
;;  fpathconf lseek pathconf read sysconf write

;;---------------------------------------------------------------------
;; symbolic link

(if "defined(HAVE_SYMLINK)"
(define-cproc sys-symlink (existing::<const-cstring> newpath::<const-cstring>)
  "
#ifdef HAVE_SYMLINK
  int r;
  SCM_SYSCALL(r, symlink(existing, newpath));
  if (r < 0) Scm_SysError(\"link failed\");
  SCM_RETURN(SCM_TRUE);
#else
  Scm_Error(\"the system doesn't support symbolic links\");
  SCM_RETURN(SCM_FALSE);
#endif
")
)

(if "defined(HAVE_READLINK)"
(define-cproc sys-readlink (path::<const-cstring>)
  "#define READLINK_PATH_MAX 1024  /* TODO: needs to be configured */
  char buf[READLINK_PATH_MAX];
  int n;
  SCM_SYSCALL(n, readlink(path, buf, READLINK_PATH_MAX));
  if (n < 0) Scm_SysError(\"readlink failed\");
  if (n == READLINK_PATH_MAX) Scm_Error(\"readlink result too long\");
  return Scm_MakeString(buf, n, -1, SCM_MAKSTR_COPYING);")
)

;;---------------------------------------------------------------------
;; select

(define-type <sys-fdset> "ScmSysFdset*")

(if "defined(HAVE_SELECT)" (begin
(define-cproc sys-fdset-ref (fdset::<sys-fdset> pf)
  (body <boolean>
        "int fd = Scm_GetPortFd(pf, FALSE);"
        "if (fd < 0) SCM_RESULT = TRUE;"
        "else SCM_RESULT = FD_ISSET(fd, &fdset->fdset);")
  (setter sys-fdset-set!))
  
(define-cproc sys-fdset-set! (fdset::<sys-fdset> pf flag::<boolean>)
  "int fd = Scm_GetPortFd(pf, FALSE);
  if (fd >= 0) {
    if (flag) {
      FD_SET(fd, &fdset->fdset);
      if (fdset->maxfd < fd) fdset->maxfd = fd;
    } else {
      FD_CLR(fd, &fdset->fdset);
      if (fdset->maxfd == fd) {
        int i;
        for (i=fdset->maxfd-1; i>=0; i--) {
          if (FD_ISSET(i, &fdset->fdset)) break;
        }
        fdset->maxfd = i;
      }
    }
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc sys-fdset-max-fd (fdset::<sys-fdset>)
  (expr <int> "fdset->maxfd"))

(define-cproc sys-select (rfds wfds efds &optional (timeout #f))
  (call "Scm_SysSelect"))

(define-cproc sys-select! (rfds wfds efds &optional (timeout #f))
  (call "Scm_SysSelectX"))

)) ;; if defined(HAVE_SELECT)

;; Local variables:
;; mode: scheme
;; end:
