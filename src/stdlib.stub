;;;
;;; stdlib.stub - r5rs scheme procedures
;;;  
;;;   Copyright (c) 2000-2007  Shiro Kawai  <shiro@acm.org>
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: stdlib.stub,v 1.131 2007-08-10 01:19:36 shirok Exp $
;;;

"
#include <gauche/vminsn.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>

#ifndef M_PI
#define M_PI 3.1415926535897932384
#endif
"

;;
;; 6.1  Equivalence predicates
;;

(define-cproc eqv? (obj1 obj2)
  (inliner EQV)
  (call <boolean> "Scm_EqvP"))

(define-cproc eq? (obj1 obj2)
  (inliner EQ)
  (call <boolean> "SCM_EQ"))

(define-cproc equal? (obj1 obj2)
  (call <boolean> "Scm_EqualP"))

;;
;; 6.2  Numbers
;;

(define-cproc number? (obj)   (call <boolean> "SCM_NUMBERP"))
(define-cproc complex? (obj)  (call <boolean> "SCM_NUMBERP"))
(define-cproc real? (obj)     (call <boolean> "SCM_REALP"))
(define-cproc rational? (obj) (call <boolean> "SCM_REALP"))
(define-cproc integer? (obj)
  (expr <boolean> (and (SCM_NUMBERP obj) (Scm_IntegerP obj))))

(define-cproc exact? (obj)    (call <boolean> "SCM_EXACTP"))
(define-cproc inexact? (obj)  (call <boolean> "SCM_INEXACTP"))

(define-cproc = (arg0 arg1 &rest args)
  (body <boolean>
        (loop (cond 
               ((not (Scm_NumEq arg0 arg1)) (result FALSE) (break))
               ((SCM_NULLP args) (result TRUE) (break))
               (else (set! arg1 (SCM_CAR args)
                           args (SCM_CDR args)))))))

(eval*
 (use gauche.cgen.cise)
 (use util.match)
 (define-cise-macro (numcmp form env)
   (match form
     ((_ op)
      `(loop (cond
              ((not (,op (Scm_NumCmp arg0 arg1) 0)) (result FALSE) (break))
              ((SCM_NULLP args) (result TRUE) (break))
              (else (set! arg0 arg1
                          arg1 (SCM_CAR args)
                          args (SCM_CDR args))))))))
 )

(define-cproc < (arg0 arg1 &rest args)  (body <boolean> (numcmp <)))
(define-cproc <= (arg0 arg1 &rest args) (body <boolean> (numcmp <=)))
(define-cproc > (arg0 arg1 &rest args)  (body <boolean> (numcmp >)))
(define-cproc >= (arg0 arg1 &rest args) (body <boolean> (numcmp >=)))

(define-cproc zero? (obj::<number>)
  (expr <boolean> (and (SCM_REALP obj) (== (Scm_Sign obj) 0))))

(define-cproc positive? (obj) (expr <boolean> (> (Scm_Sign obj) 0)))
(define-cproc negative? (obj) (expr <boolean> (< (Scm_Sign obj) 0)))
(define-cproc odd? (obj)      (call <boolean> "Scm_OddP"))
(define-cproc even? (obj)     (call <boolean> "!Scm_OddP"))

(define-cproc max (arg0 &rest args)
  (body <number> (Scm_MinMax arg0 args NULL (& SCM_RESULT))))
(define-cproc min (arg0 &rest args)
  (body <number> (Scm_MinMax arg0 args (& SCM_RESULT) NULL)))

(define-cproc + (&rest args)
  (body <number>
        (cond
         ((not (SCM_PAIRP args)) (result (SCM_MAKE_INT 0)))
         ((not (SCM_NUMBERP (SCM_CAR args)))
          (Scm_Error "number required, but got %S" (SCM_CAR args))
          (result SCM_UNDEFINED))       ;dummy
         (else
          (let* ((r :: ScmObj (SCM_CAR args)))
            (for-each (lambda (v) (set! r (Scm_Add r v))) (SCM_CDR args))
            (result r))))))

(define-cproc * (&rest args)
  (body <number>
        (cond
         ((not (SCM_PAIRP args)) (result (SCM_MAKE_INT 1)))
         ((not (SCM_NUMBERP (SCM_CAR args)))
          (Scm_Error "number required, but got %S" (SCM_CAR args))
          (result SCM_UNDEFINED))       ;dummy
         (else
          (let* ((r :: ScmObj (SCM_CAR args)))
            (for-each (lambda (v) (set! r (Scm_Mul r v))) (SCM_CDR args))
            (result r))))))

(define-cproc - (arg1 &rest args)
  (body <number>
        (if (SCM_NULLP args)
          (result (Scm_Negate arg1))
          (begin
            (for-each (lambda (v) (set! arg1 (Scm_Sub arg1 v))) args)
            (result arg1)))))

(define-cproc / (arg1 &rest args)
  (body <number>
        (if (SCM_NULLP args)
          (result (Scm_Reciprocal arg1))
          (begin
            (for-each (lambda (v) (set! arg1 (Scm_Div arg1 v))) args)
            (result arg1)))))

(define-cproc abs (obj) (call "Scm_Abs"))

(define-cproc quotient (n1 n2)  (expr "Scm_Quotient(n1, n2, NULL)"))
(define-cproc remainder (n1 n2) (expr "Scm_Modulo(n1, n2, TRUE)"))
(define-cproc modulo (n1 n2)    (expr "Scm_Modulo(n1, n2, FALSE)"))

(define-cproc %gcd (n1 n2)    (call "Scm_Gcd"))
(define-cproc numerator (n)   (call "Scm_Numerator"))
(define-cproc denominator (n) (call "Scm_Denominator"))
;; gcd, lcd - in gauche/numerical.scm

(define-cproc floor (v)    (expr <number> (Scm_Round v SCM_ROUND_FLOOR)))
(define-cproc ceiling (v)  (expr <number> (Scm_Round v SCM_ROUND_CEIL)))
(define-cproc truncate (v) (expr <number> (Scm_Round v SCM_ROUND_TRUNC)))
(define-cproc round (v)    (expr <number> (Scm_Round v SCM_ROUND_ROUND)))

;; rationalize - not implemented


;; Transcedental functions.  Complex numbers are handled in Scheme.

(define-cproc %exp (x::<real>) (call <real> "exp"))

(define-cproc %log (x)
  (body <number>
        (unless (SCM_REALP x)
          (Scm_Error "real number required, but got %S" x))
        (if (< (Scm_Sign x) 0)
          (result (Scm_MakeComplex (log (- (Scm_GetDouble x))) M_PI))
          ;; NB: I intentionally delegate handling of the case x==0.0 to the
          ;; system log() function.  Most systems should yield NaN or Inf.
          (result (Scm_MakeFlonum (log (Scm_GetDouble x)))))))

(define-cproc %sin (x::<real>) (call <real> "sin"))
(define-cproc %cos (x::<real>) (call <real> "cos"))
(define-cproc %tan (x::<real>) (call <real> "tan"))
(define-cproc %asin (x::<real>)
  (body <number>
        (cond
         ((> x 1.0)
          (result (Scm_MakeComplex (/ M_PI 2.0)
                                   (- (log (+ x (sqrt (- (* x x) 1.0))))))))
         ((< x -1.0)
          (result (Scm_MakeComplex (/ (- M_PI) 2.0)
                                   (- (log (- (- x) (sqrt (- (* x x) 1.0))))))))
         (else
          (result (Scm_MakeFlonum (asin x)))))))
(define-cproc %acos (x::<real>)
  (body <number>
        (cond
         ((> x 1.0)
          (result (Scm_MakeComplex 0 (log (+ x (sqrt (- (* x x) 1.0)))))))
         ((< x -1.0)
          (result (Scm_MakeComplex 0 (log (+ x (sqrt (- (* x x) 1.0)))))))
         (else
          (result (Scm_MakeFlonum (acos x)))))))

(define-cproc %atan (z::<real> &optional x)
  (body <double>
        (if (SCM_UNBOUNDP x)
          (result (atan z))
          (begin
            (unless (SCM_REALP x)
              (Scm_Error "real number required for x, but got %S" x))
            (result (atan2 z (Scm_GetDouble x)))))))

(define-cproc %sinh (x::<real>) (call <real> "sinh"))
(define-cproc %cosh (x::<real>) (call <real> "cosh"))
(define-cproc %tanh (x::<real>) (call <real> "tanh"))
;; NB: asinh and acosh are not in POSIX.

(define-cproc %sqrt (x::<real>)
  (body <top>
        (if (< x 0)
          (result (Scm_MakeComplex 0.0 (sqrt (- x))))
          (result (Scm_MakeFlonum (sqrt x))))))

(define-cproc %expt (x y) (call "Scm_Expt"))

(define-cproc make-rectangular (a::<real> b::<real>)
  (call "Scm_MakeComplex"))

(define-cproc make-polar (r::<real> t::<real>)
  (call "Scm_MakeComplexPolar"))

(define-cproc %complex->real/imag (z)
  "if (SCM_EXACTP(z)) { SCM_RETURN(Scm_Values2(z, SCM_MAKE_INT(0))); }
  else if (SCM_FLONUMP(z)) { SCM_RETURN(Scm_Values2(z, Scm_MakeFlonum(0.0))); }
  else if (!SCM_COMPNUMP(z)) {
    Scm_Error(\"number required, but got %S\", z);
    SCM_RETURN(SCM_UNDEFINED);
  } else { SCM_RETURN(Scm_Values2(Scm_MakeFlonum(SCM_COMPNUM_REAL(z)), Scm_MakeFlonum(SCM_COMPNUM_IMAG(z))));}")

;; we don't use Scm_RealPart and Scm_ImagPart, for preserving exactness
;; and avoiding extra allocation.
(define-cproc real-part (z::<number>)
  (body <top>
        (if (SCM_REALP z)
          (result z)
          (result (Scm_MakeFlonum (SCM_COMPNUM_REAL z))))))

(define-cproc imag-part (z::<number>)
  (body <top>
        (cond
         ((SCM_EXACTP z) (result (SCM_MAKE_INT 0)))
         ((SCM_REALP z)  (result (Scm_MakeFlonum 0.0)))
         (else (result (Scm_MakeFlonum (SCM_COMPNUM_IMAG z)))))))

(define-cproc magnitude (z)  (call <double> "Scm_Magnitude"))
(define-cproc angle (z)      (call <double> "Scm_Angle"))

(define-cproc exact->inexact (obj) (call "Scm_ExactToInexact"))
(define-cproc inexact->exact (obj) (call "Scm_InexactToExact"))

(define-cproc number->string (obj
                              &optional (radix::<fixnum> 10) (use-upper? #f))
  (expr <top> (Scm_NumberToString obj radix (not (SCM_FALSEP use_upperP)))))

(define-cproc string->number (obj::<string> &optional (radix::<fixnum> 10))
  (expr <top> (Scm_StringToNumber obj radix FALSE)))

;;
;; 6.3.1  Booleans
;;

(define-cproc not (obj)
  (inliner NOT)
  (call <boolean> "SCM_FALSEP"))

(define-cproc boolean? (obj)
  (call <boolean> "SCM_BOOLP"))

;;
;; 6.3.2  Pairs and lists
;;

(define-cproc pair? (obj)
  (inliner PAIRP)
  (call <boolean> "SCM_PAIRP"))

(define-cproc cons (obj1 obj2)
  (inliner CONS)
  (call "Scm_Cons"))

(define-cproc car (obj::<pair>)
  (inliner CAR)
  (call "SCM_CAR")
  (setter set-car!))

(define-cproc cdr (obj::<pair>)
  (inliner CDR)
  (call "SCM_CDR")
  (setter set-cdr!))

(define-cproc set-car! (obj::<pair> value)
  (call <void> "SCM_SET_CAR"))

(define-cproc set-cdr! (obj::<pair> value)
  (call <void> "SCM_SET_CDR"))

"#define CXR_SETTER(PRE, pre, tail) \\
  ScmObj cell = Scm_C##tail##r(obj); \\
  if (!SCM_PAIRP(cell)) Scm_Error(\"can't set c\" #pre #tail \"r of %S\", obj); \\
  SCM_SET_C##PRE##R(cell, value); SCM_RETURN(SCM_UNDEFINED);
"

(define-cproc caar (obj)
  (inliner CAAR)
  (call "Scm_Caar")
  (setter (obj value) "CXR_SETTER(A, a, a);"))
(define-cproc cadr (obj)
  (inliner CADR)
  (call "Scm_Cadr")
  (setter (obj value) "CXR_SETTER(A, a, d);"))
(define-cproc cdar (obj)
  (inliner CDAR)
  (call "Scm_Cdar")
  (setter (obj value) "CXR_SETTER(D, d, a);"))
(define-cproc cddr (obj)
  (inliner CDDR)
  (call "Scm_Cddr")
  (setter (obj value) "CXR_SETTER(D, d, d);"))
;; NB: caaar ... cddddr are in autoloaded Scheme file now.

(define-cproc null? (obj)
  (inliner NULLP)
  (call <boolean> "SCM_NULLP"))

(define-cproc list? (obj)
  (call <boolean> "SCM_PROPER_LIST_P"))

(define-cproc list (&rest args)
  (inliner LIST)
  (expr "args"))

(define-cproc length (list)
  (inliner LENGTH)
  (body <long>
        (let* ((len :: long (Scm_Length list)))
          (if (< len 0) (Scm_Error "bad list: %S" list))
          (result len))))

(define-cproc length+ (list) ;; srfi-1
  (body <top>
        (let* ((i :: int (Scm_Length list)))
          (if (< i 0) (result SCM_FALSE) (result (Scm_MakeInteger i))))))

(define-cproc append (&rest lists)
  (inliner APPEND)
  (call "Scm_Append"))

(define-cproc reverse (list::<list>)
  (inliner REVERSE)
  (call "Scm_Reverse"))

(define-cproc list-tail (list k::<fixnum> &optional fallback)
  (call "Scm_ListTail"))

(define-cproc list-ref (list k::<fixnum> &optional fallback)
  (call "Scm_ListRef"))

(define-cproc memq (obj list::<list>)
  (inliner MEMQ)
  (call "Scm_Memq"))

(define-cproc memv (obj list::<list>)
  (inliner MEMV)
  (call "Scm_Memv"))

(define-cproc member (obj list::<list>)
  (expr <top> (Scm_Member obj list SCM_CMP_EQUAL)))

(define-cproc assq (obj alist::<list>)
  (inliner ASSQ)
  (call "Scm_Assq"))

(define-cproc assv (obj alist::<list>)
  (inliner ASSV)
  (call "Scm_Assv"))

(define-cproc assoc (obj alist::<list>)
  (expr <top> (Scm_Assoc obj alist SCM_CMP_EQUAL)))

;;
;; 6.3.3  Symbols
;;

(define-cproc symbol? (obj)
  (inliner SYMBOLP)
  (call <boolean> "SCM_SYMBOLP"))

(define-cproc symbol->string (obj::<symbol>)
  (expr <top> (SCM_OBJ (SCM_SYMBOL_NAME obj))))

(define-cproc string->symbol (obj::<string>)
  (call "Scm_Intern"))

;;
;; 6.3.4  Characters
;;

(define-cproc char? (obj)
  (inliner CHARP)
  (call <boolean> "SCM_CHARP"))

(define-cproc char=? (c1::<char> c2::<char>)  (expr <boolean> "c1 == c2"))
(define-cproc char<? (c1::<char> c2::<char>)  (expr <boolean> "c1 < c2"))
(define-cproc char>? (c1::<char> c2::<char>)  (expr <boolean> "c1 > c2"))
(define-cproc char<=? (c1::<char> c2::<char>) (expr <boolean> "c1 <= c2"))
(define-cproc char>=? (c1::<char> c2::<char>) (expr <boolean> "c1 >= c2"))

(eval*
 (define-cise-macro (char-ci-cmp form env)
   (match form
     ((_ op) `(,op (SCM_CHAR_UPCASE c1) (SCM_CHAR_UPCASE c2)))))
 )

(define-cproc char-ci=? (c1::<char> c2::<char>)
  (expr <boolean> (char-ci-cmp ==)))
(define-cproc char-ci<? (c1::<char> c2::<char>)
  (expr <boolean> (char-ci-cmp <)))
(define-cproc char-ci<=? (c1::<char> c2::<char>)
  (expr <boolean> (char-ci-cmp <=)))
(define-cproc char-ci>? (c1::<char> c2::<char>)
  (expr <boolean> (char-ci-cmp >)))
(define-cproc char-ci>=? (c1::<char> c2::<char>)
  (expr <boolean> (char-ci-cmp >=)))

(define-cproc char-alphabetic? (c::<char>)
  (expr <boolean> (and (SCM_CHAR_ASCII_P c) (isalpha c))))
(define-cproc char-numeric? (c::<char>)
  (expr <boolean> (and (SCM_CHAR_ASCII_P c) (isdigit c))))
(define-cproc char-whitespace? (c::<char>)
  (expr <boolean> (and (SCM_CHAR_ASCII_P c) (isspace c))))
(define-cproc char-upper-case? (c::<char>)
  (call <boolean> "SCM_CHAR_UPPER_P"))
(define-cproc char-lower-case? (c::<char>)
  (call <boolean> "SCM_CHAR_LOWER_P"))

(define-cproc char->integer (c::<char>) (expr <long> "(signed long)c"))
(define-cproc integer->char (c::<int>)  (expr <char> "(ScmChar)c"))

(define-cproc char-upcase (c::<char>)   (call <char> "SCM_CHAR_UPCASE"))
(define-cproc char-downcase (c::<char>) (call <char> "SCM_CHAR_DOWNCASE")) 

;;
;; 6.3.5 Strings
;;

(define-cproc string? (obj)
  (inliner STRINGP)
  (call <boolean> "SCM_STRINGP"))

(define-cproc make-string (len::<fixnum> &optional (c::<char> #\ ))
  (call "Scm_MakeFillString"))

(define-cproc string (&rest chars)
  (call "Scm_ListToString"))

(define-cproc string-length (str::<string>)
  (expr <fixnum> (SCM_STRING_BODY_LENGTH (SCM_STRING_BODY str))))

;; NB: string-set! is moved to scmlib.scm, so we can't declare setter here.
;; It is set in scmlib.scm.
(define-cproc string-ref (str::<string> k::<fixnum> &optional fallback)
  (body <top>
        (let* ((r :: ScmChar (Scm_StringRef str k (SCM_UNBOUNDP fallback))))
          (result (?: (== r SCM_CHAR_INVALID) fallback (SCM_MAKE_CHAR r))))))

(eval*
 (define-cise-macro (strcmp form env)
   (match form
     [(_ op) `(,op (Scm_StringCmp s1 s2) 0)]))
 (define-cise-macro (strcmp-ci form env)
   (match form
     [(_ op) `(,op (Scm_StringCiCmp s1 s2) 0)]))
 )
        
(define-cproc string=? (s1::<string> s2::<string>)
  (call <boolean> "Scm_StringEqual"))
(define-cproc string<? (s1::<string> s2::<string>)
  (expr <boolean> (strcmp <)))
(define-cproc string<=? (s1::<string> s2::<string>)
  (expr <boolean> (strcmp <=)))
(define-cproc string>? (s1::<string> s2::<string>)
  (expr <boolean> (strcmp >)))
(define-cproc string>=? (s1::<string> s2::<string>)
  (expr <boolean> (strcmp >=)))

(define-cproc string-ci=? (s1::<string> s2::<string>)
  (expr <boolean> (strcmp-ci ==)))
(define-cproc string-ci<? (s1::<string> s2::<string>)
  (expr <boolean> (strcmp-ci <)))
(define-cproc string-ci<=? (s1::<string> s2::<string>)
  (expr <boolean> (strcmp-ci <=)))
(define-cproc string-ci>? (s1::<string> s2::<string>)
  (expr <boolean> (strcmp-ci >)))
(define-cproc string-ci>=? (s1::<string> s2::<string>)
  (expr <boolean> (strcmp-ci >=)))

(define-cproc substring (str::<string> start::<fixnum> end::<fixnum>)
  (expr <top> (Scm_Substring str start end FALSE)))

(define-cproc string-append (&rest args)
  (call "Scm_StringAppend"))

(define-cproc string->list (str::<string> &optional start end)
  (expr <top>
        (Scm_StringToList (SCM_STRING (Scm_MaybeSubstring str start end)))))

(define-cproc list->string (list::<list>)
  (call "Scm_ListToString"))

(define-cproc string-copy (str::<string> &optional start end)
  (expr <top>
        (Scm_CopyString (SCM_STRING (Scm_MaybeSubstring str start end)))))

;;
;; 6.3.6  Vectors
;;

(define-cproc vector? (obj)
  (inliner VECTORP)
  (call <boolean> "SCM_VECTORP"))

(define-cproc make-vector (k::<fixnum> &optional fill)
  (call "Scm_MakeVector"))

(define-cproc vector (&rest args)
  (inliner VEC)
  (expr <top> (Scm_ListToVector args 0 -1)))

(define-cproc vector-length (vec::<vector>)
  (inliner VEC-LEN)
  (call <fixnum> "SCM_VECTOR_SIZE"))

(define-cproc vector-ref (vec::<vector> k::<integer> &optional fallback)
  (setter vector-set!)
  (body <top>
        (cond ((or (SCM_BIGNUMP k)
                   (< (SCM_INT_VALUE k) 0)
                   (>= (SCM_INT_VALUE k) (SCM_VECTOR_SIZE vec)))
               (when (SCM_UNBOUNDP fallback)
                 (Scm_Error "vector-ref index out of range: %S" k))
               (result fallback))
              (else
               (result (SCM_VECTOR_ELEMENT vec (SCM_INT_VALUE k)))))))

(define-cproc vector-set! (vec::<vector> k::<integer> obj)
  (body <void>
        (if (or (SCM_BIGNUMP k)
                (< (SCM_INT_VALUE k) 0)
                (>= (SCM_INT_VALUE k) (SCM_VECTOR_SIZE vec)))
          (Scm_Error "vector-set! index out of range: %S" k)
          (set! (SCM_VECTOR_ELEMENT vec (SCM_INT_VALUE k)) obj))))

(define-cproc vector->list (vec::<vector>
                            &optional (start::<fixnum> 0) (end::<fixnum> -1))
  (call "Scm_VectorToList"))

(define-cproc list->vector (list::<list>
                            &optional (start::<fixnum> 0) (end::<fixnum> -1))
  (call "Scm_ListToVector"))

(define-cproc vector-fill! (vec::<vector> fill
                            &optional (start::<fixnum> 0) (end::<fixnum> -1))
  (call <void> "Scm_VectorFill"))

;;
;; 6.4  Control Features
;;

(define-cproc procedure? (obj) (call <boolean> "SCM_PROCEDUREP"))

(define-cproc apply (proc arg1 &rest args)
  (inliner APPLY)
  (body <top>
        (let* ((head :: ScmObj)
               (tail :: ScmObj))
          (cond ((SCM_NULLP args) (result (Scm_VMApply proc arg1)))
                (else
                 (set! head (Scm_Cons arg1 SCM_NIL)
                       tail head)
                 (pair-for-each (lambda (cp)
                                  (when (SCM_NULLP (SCM_CDR cp))
                                    (SCM_APPEND head tail (SCM_CAR cp))
                                    (break))
                                  (unless (SCM_PAIRP (SCM_CDR cp))
                                    (Scm_Error "improper list not allowed: %S"
                                               (SCM_CDR cp)))
                                  (SCM_APPEND1 head tail (SCM_CAR cp)))
                                args)
                 (result (Scm_VMApply proc head))))
          )))

(define-cproc map (proc args::<list> &rest moreargs)
  (call "Scm_Map"))

(define-cproc for-each (proc args::<list> &rest moreargs)
  (call "Scm_ForEach"))
          
(define-cproc force (p)
  (call "Scm_Force"))

(define-cproc call-with-current-continuation (proc)
  (call "Scm_VMCallCC"))

(define-cproc values (&rest args)
  (inliner VALUES)
  (call "Scm_Values"))

;; call-with-values - defined in scmlib.scm

(define-cproc dynamic-wind (pre body post)
  (call "Scm_VMDynamicWind"))

(define-cproc eval (expr env)
  (call "Scm_VMEval"))

;; for now, just return a module.
(define-cproc null-environment (version::<fixnum>)
  (body <top>
        (when (!= version 5)
          (Scm_Error "unknown rNrs version: %d" version))
        (result (SCM_OBJ (Scm_NullModule)))))
(define-cproc scheme-report-environment (version::<fixnum>)
  (body <top>
        (when (!= version 5)
          (Scm_Error "unknown rNrs version: %d" version))
        (result (SCM_OBJ (Scm_SchemeModule)))))
(define-cproc interaction-environment ()
  (expr <top> (SCM_OBJ (Scm_UserModule))))

;;
;; 6.6.1  Ports
;;
  
;; open-input-file, open-output-file, and various call-with-* and
;; with-* are defined in scmlib.scm.

(define-cproc input-port? (obj)  (call <boolean> "SCM_IPORTP"))
(define-cproc output-port? (obj) (call <boolean> "SCM_OPORTP"))
(define-cproc port? (obj)        (call <boolean> "SCM_PORTP"))

(define-cproc current-input-port (&optional newport)
  (body <top>
        (cond
         ((SCM_IPORTP newport)
          (result (Scm_SetCurrentInputPort (SCM_PORT newport))))
         ((not (SCM_UNBOUNDP newport))
          (Scm_TypeError "current-input-port" "input port" newport)
          (result SCM_UNDEFINED))
         (else
          (result (SCM_OBJ SCM_CURIN))))
       ))

(define-cproc current-output-port (&optional newport)
  (body <top>
        (cond
         ((SCM_OPORTP newport)
          (result (Scm_SetCurrentOutputPort (SCM_PORT newport))))
         ((not (SCM_UNBOUNDP newport))
          (Scm_TypeError "current-output-port" "output port" newport)
          (result SCM_UNDEFINED))
         (else
          (result (SCM_OBJ SCM_CUROUT))))))

(define-cproc close-input-port (port::<port>)
  (call <void> "Scm_ClosePort"))

(define-cproc close-output-port (port::<port>)
  (call <void> "Scm_ClosePort"))

;;
;; 6.6.2  Input
;;

(define-cproc read (&optional (port::<input-port> (current-input-port)))
  (expr <top> (Scm_Read (SCM_OBJ port))))

(define-cproc read-char (&optional (port::<input-port> (current-input-port)))
  (inliner READ-CHAR)
  (body <top>
         (let* ((ch :: int))
           (SCM_GETC ch port)
           (result (?: (== ch EOF) SCM_EOF (SCM_MAKE_CHAR ch))))))

(define-cproc peek-char (&optional (port::<input-port> (current-input-port)))
  (inliner PEEK-CHAR)
  (body <top>
        (let* ((ch :: ScmChar (Scm_Peekc port)))
          (result (?: (== ch SCM_CHAR_INVALID) SCM_EOF (SCM_MAKE_CHAR ch))))))

(define-cproc eof-object? (obj)
  (inliner EOFP)
  (call <boolean> "SCM_EOFP"))

(define-cproc char-ready? (&optional (port::<input-port> (current-input-port)))
  (call <boolean> "Scm_CharReady"))

;;
;; 6.6.3  Output
;;

(define-cproc write (obj &optional (port::<output-port> (current-output-port)))
  (body <void> (Scm_Write obj (SCM_OBJ port) SCM_WRITE_WRITE)))

(define-cproc display (obj &optional (port::<output-port> (current-output-port)))
  (body <void> (Scm_Write obj (SCM_OBJ port) SCM_WRITE_DISPLAY)))

(define-cproc newline (&optional (port::<output-port> (current-output-port)))
  (body <void> (SCM_PUTC #\newline port)))

(define-cproc write-char (ch::<char>
                          &optional
                          (port::<output-port> (current-output-port)))
  (inliner WRITE-CHAR)
  (body <void> (SCM_PUTC ch port)))

;;
;; 6.6.4  System Interface
;;

; load : defined in load.c
; transcript-on
; transcript-off

;; Local variables:
;; mode: scheme
;; end:
