;; -*-Scheme-*-

;;
;; built-in scheme procedures
;;

"#include <math.h>\n"

;;
;; 6.1  Equivalence predicates
;;

(define-cproc eqv? (obj1 obj2)
  "  SCM_RETURN(Scm_EqvP(obj1, obj2));")

(define-cproc eq? (obj1 obj2)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EQ(obj1, obj2)));")

(define-cproc equal? (obj1 obj2)
  "  SCM_RETURN(Scm_EqualP(obj1, obj2));")

;;
;; 6.2  Numbers
;;

(define-cproc number? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_NUMBERP(obj)));")
(define-cproc complex? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_NUMBERP(obj)));")
(define-cproc real? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_REALP(obj)));")
(define-cproc rational? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_INTEGERP(obj)));")
(define-cproc integer? (obj)
  "  SCM_RETURN(Scm_IntegerP(obj));")

(define-cproc exact? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EXACTP(obj)));")
(define-cproc inexact? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_INEXACTP(obj)));")

(define-cproc = (arg0 arg1 &rest args)
  "  SCM_RETURN(Scm_NumEq(arg0, arg1, args));")
(define-cproc < (arg0 arg1 &rest args)
  "  SCM_RETURN(Scm_NumLt(arg0, arg1, args));")
(define-cproc <= (arg0 arg1 &rest args)
  "  SCM_RETURN(Scm_NumLe(arg0, arg1, args));")
(define-cproc > (arg0 arg1 &rest args)
  "  SCM_RETURN(Scm_NumGt(arg0, arg1, args));")
(define-cproc >= (arg0 arg1 &rest args)
  "  SCM_RETURN(Scm_NumGe(arg0, arg1, args));")

(define-cproc zero? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) == 0));")
(define-cproc positive? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) > 0));")
(define-cproc negative? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) < 0));")
(define-cproc odd? (obj)
  (assert (exact? obj))
  ;; TODO: bignum
  "  SCM_RETURN(SCM_MAKE_BOOL(obj&1));")
(define-cproc even? (obj)
  (assert (exact? obj))
  ;; TODO: bignum
  "  SCM_RETURN(SCM_MAKE_BOOL(!(obj&1)));")

(define-cproc max (arg0 &rest args)
  "  SCM_RETURN(Scm_Max(arg0, args));")
(define-cproc min (arg0 &rest args)
  "  SCM_RETURN(Scm_Min(arg0, args));")


(define-cproc + (&rest args)
  "  SCM_RETURN(Scm_Add(args)); ")

(define-cproc * (&rest args)
  "  SCM_RETURN(Scm_Multiply(args));")

(define-cproc - (arg1 &rest args)
  "  ScmObj r;
  if (SCM_NULLP(args)) r = Scm_Negate(arg1);
  else r = Scm_Subtract(arg1, SCM_CAR(args), SCM_CDR(args));
  SCM_RETURN(r);")

(define-cproc / (arg1 &rest args)
  "  ScmObj r;
  if (SCM_NULLP(args)) r = Scm_Reciprocal(arg1);
  else r = Scm_Divide(arg1, SCM_CAR(args), SCM_CDR(args));
  SCM_RETURN(r);")

(define-cproc abs (obj)
  "  SCM_RETURN(Scm_Abs(obj));")

(define-cproc quotient (n1 n2)
  "  SCM_RETURN(Scm_Quotient(n1, n2));")

(define-cproc remainder (n1 n2)
  "  SCM_RETURN(Scm_Modulo(n1, n2, 1));")

(define-cproc modulo (n1 n2)
  "  SCM_RETURN(Scm_Modulo(n1, n2, 0));")


(define-cproc gcd (&rest args)
  ;; TODO: implement me!
  "  SCM_RETURN(SCM_MAKE_INT(1));")

(define-cproc lcm (&rest args)
  ;; TODO: implement me!
  "  SCM_RETURN(SCM_MAKE_INT(1));")

;; in Gauche, rational number is exact integer, i.e. N/1
(define-cproc numerator (q)
  "  if (!SCM_EXACTP(q)) Scm_Error(\"exact integer required: %S\", q_scm);
  SCM_RETURN(q);")
(define-cproc denominator (q)
  (assert (exact? q))
  "  SCM_RETURN(SCM_MAKE_INT(1));")

;; floor
;; ceiling
;; truncate
;; round
;; rationalize
;; exp
;; log
;; sin
;; cos
;; tan
;; asin
;; acos
;; atan
;; sqrt
;; expt
;; make-rectangular
;; make-polar

(define-cproc real-part (z)
  "  ScmObj r;
  if (SCM_INTP(z)) r = z;
  else if (SCM_FLONUMP(z)) r = z;
  else if (SCM_COMPLEXP(z)) r = Scm_MakeFlonum(SCM_COMPLEX_REAL(z));
  else Scm_Error(\"number required, but got %S\", z);
  SCM_RETURN(r);")

(define-cproc imag-part (z)
  "  ScmObj r;
  if (SCM_INTP(z)) r = SCM_MAKE_INT(0);
  else if (SCM_FLONUMP(z)) r = Scm_MakeFlonum(0.0);
  else if (SCM_COMPLEXP(z)) r = Scm_MakeFlonum(SCM_COMPLEX_REAL(z));
  else Scm_Error(\"number required, but got %S\", z);
  SCM_RETURN(r);")

(define-cproc magnitude (z)
  "  ScmObj r;
  if (SCM_INTP(z)) r = Scm_Abs(z); 
  else if (SCM_FLONUMP(z)) r = Scm_Abs(z); 
  else if (SCM_COMPLEXP(z)) {
    double real = SCM_COMPLEX_REAL(z);
    double imag = SCM_COMPLEX_IMAG(z);
    r = Scm_MakeFlonum(sqrt(real*real + imag*imag));
  } 
  else Scm_Error(\"number required, but got %S\", z);
  SCM_RETURN(r);")
  

;; angle

(define-cproc exact->inexact (obj)
  "  SCM_RETURN(Scm_ExactToInexact(obj));")

(define-cproc inexact->exact (obj)
  "  SCM_RETURN(Scm_InexactToExact(obj));")

(define-cproc number->string (obj &optional (radix 10))
  (assert (small-integer? radix))
  "  SCM_RETURN(Scm_NumberToString(obj, radix));")

(define-cproc string->number (obj)
  (assert (string? obj))
  "  SCM_RETURN(Scm_StringToNumber(obj));")

;;
;; 6.3.1  Booleans
;;

(define-cproc not (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_FALSEP(obj)));")

(define-cproc boolean? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_BOOLP(obj)));")

;;
;; 6.3.2  Pairs and lists
;;

(define-cproc pair? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_PAIRP(obj)));")

(define-cproc cons (obj1 obj2)
  (inliner "Scm_inline_cons")
  "  SCM_RETURN(Scm_Cons(obj1, obj2));")

(define-cproc car (obj)
  (assert (pair? obj))
  "  SCM_RETURN(SCM_CAR(obj));")

(define-cproc cdr (obj)
  (assert (pair? obj))
  "  SCM_RETURN(SCM_CDR(obj));")

(define-cproc set-car! (obj value)
  (assert (pair? obj))
  "  SCM_SET_CAR(obj, value);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc set-cdr! (obj value)
  (assert (pair? obj))
  "  SCM_SET_CDR(obj, value);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc caar (obj)    "SCM_RETURN(Scm_Caar(obj));")
(define-cproc cadr (obj)    "SCM_RETURN(Scm_Cadr(obj));")
(define-cproc cdar (obj)    "SCM_RETURN(Scm_Cdar(obj));")
(define-cproc cddr (obj)    "SCM_RETURN(Scm_Cddr(obj));")
(define-cproc caaar (obj)   "SCM_RETURN(Scm_Caaar(obj));")
(define-cproc caadr (obj)   "SCM_RETURN(Scm_Caadr(obj));")
(define-cproc cadar (obj)   "SCM_RETURN(Scm_Cadar(obj));")
(define-cproc caddr (obj)   "SCM_RETURN(Scm_Caddr(obj));")
(define-cproc cdaar (obj)   "SCM_RETURN(Scm_Cdaar(obj));")
(define-cproc cdadr (obj)   "SCM_RETURN(Scm_Cdadr(obj));")
(define-cproc cddar (obj)   "SCM_RETURN(Scm_Cddar(obj));")
(define-cproc cdddr (obj)   "SCM_RETURN(Scm_Cdddr(obj));")
(define-cproc caaaar (obj)  "SCM_RETURN(Scm_Caaaar(obj));")
(define-cproc caaadr (obj)  "SCM_RETURN(Scm_Caaadr(obj));")
(define-cproc caadar (obj)  "SCM_RETURN(Scm_Caadar(obj));")
(define-cproc caaddr (obj)  "SCM_RETURN(Scm_Caaddr(obj));")
(define-cproc cadaar (obj)  "SCM_RETURN(Scm_Cadaar(obj));")
(define-cproc cadadr (obj)  "SCM_RETURN(Scm_Cadadr(obj));")
(define-cproc caddar (obj)  "SCM_RETURN(Scm_Caddar(obj));")
(define-cproc cadddr (obj)  "SCM_RETURN(Scm_Cadddr(obj));")
(define-cproc cdaaar (obj)  "SCM_RETURN(Scm_Cdaaar(obj));")
(define-cproc cdaadr (obj)  "SCM_RETURN(Scm_Cdaadr(obj));")
(define-cproc cdadar (obj)  "SCM_RETURN(Scm_Cdadar(obj));")
(define-cproc cdaddr (obj)  "SCM_RETURN(Scm_Cdaddr(obj));")
(define-cproc cddaar (obj)  "SCM_RETURN(Scm_Cddaar(obj));")
(define-cproc cddadr (obj)  "SCM_RETURN(Scm_Cddadr(obj));")
(define-cproc cdddar (obj)  "SCM_RETURN(Scm_Cdddar(obj));")
(define-cproc cddddr (obj)  "SCM_RETURN(Scm_Cddddr(obj));")

(define-cproc null? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_NULLP(obj)));")

(define-cproc list? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Length(obj) >= 0));")

(define-cproc list (&rest args)
  "  SCM_RETURN(args);")

(define-cproc length (list)
  "  int i = Scm_Length(list);
  if (i < 0) Scm_Error(\"bad list: %S\", list);
  SCM_RETURN(Scm_MakeInteger(i));")

(define-cproc append (&rest lists)
  "  SCM_RETURN(Scm_Append(lists));")

(define-cproc reverse (list)
  (assert (list? list))
  "  SCM_RETURN(Scm_Reverse(list));")

(define-cproc list-tail (list k)
  (assert (small-integer? k))
  "  SCM_RETURN(Scm_ListTail(list, k));")

(define-cproc list-ref (list k)
  (assert (small-integer? k))
  "  SCM_RETURN(Scm_ListRef(list, k));")

(define-cproc memq (obj list)
  (assert (list? list))
  "  SCM_RETURN(Scm_Memq(obj, list));")

(define-cproc memv (obj list)
  (assert (list? list))
  (inliner "Scm_inline_memv")
  "  SCM_RETURN(Scm_Memv(obj, list));")

(define-cproc member (obj list)
  (assert (list? list))
  "  SCM_RETURN(Scm_Member(obj, list));")

(define-cproc assq (obj alist)
  (assert (list? alist))
  "  SCM_RETURN(Scm_Assq(obj, alist));")

(define-cproc assv (obj alist)
  (assert (list? alist))
  "  SCM_RETURN(Scm_Assv(obj, alist));")

(define-cproc assoc (obj alist)
  (assert (list? alist))
  "  SCM_RETURN(Scm_Assoc(obj, alist));")

;;
;; 6.3.3  Symbols
;;

(define-cproc symbol? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_SYMBOLP(obj)));")

(define-cproc symbol->string (obj)
  "  SCM_RETURN(SCM_OBJ(Scm_CopyString(SCM_SYMBOL_NAME(obj))));")

(define-cproc string->symbol (obj)
  (assert (string? obj))
  "  SCM_RETURN(Scm_Intern(obj));")

;;
;; 6.3.4  Characters
;;

(define-cproc char? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHARP(obj)));")

(define-cproc char=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EQ(c1, c2)));")
(define-cproc char<? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 < c2));")
(define-cproc char>? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 > c2));")
(define-cproc char<=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 <= c2));")
(define-cproc char>=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 >= c2));")

(define-cproc char-ci=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EQ(SCM_CHAR_UPCASE(c1),SCM_CHAR_UPCASE(c2))));")
(define-cproc char-ci<? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)<SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci<=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)<=SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci>? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)>SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci>=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)>=SCM_CHAR_UPCASE(c2)));")

(define-cproc char-alphabetic? (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isalpha(c)));")
(define-cproc char-numeric? (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isdigit(c)));")
(define-cproc char-whitespace? (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isspace(c)));")
(define-cproc char-upper-case? (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPPER_P(c)));")
(define-cproc char-lower-case? (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_LOWER_P(c)));")

(define-cproc char->integer (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_INT((signed long)c));")

(define-cproc integer->char (c)
  (assert (small-integer? c))
  "  SCM_RETURN(SCM_MAKE_CHAR((ScmChar)c));")

(define-cproc char-upcase (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_CHAR(SCM_CHAR_UPCASE(c)));")

(define-cproc char-downcase (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_CHAR(SCM_CHAR_DOWNCASE(c)));")

;;
;; 6.3.5 Strings
;;

(define-cproc string? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRINGP(obj)));")

(define-cproc make-string (len &optional (c #\ ))
  (assert (small-integer? len))
  (assert (char? c))
  "  SCM_RETURN(Scm_MakeFillString(len, c));")

(define-cproc string (&rest chars)
  "  SCM_RETURN(Scm_MakeStringFromList(chars));")

(define-cproc string-length (str)
  (assert (string? str))
  "  SCM_RETURN(SCM_MAKE_INT(SCM_STRING_LENGTH(str)));")

(define-cproc string-ref (str k)
  (assert (string? str))
  (assert (small-integer? k))
  "  SCM_RETURN(SCM_MAKE_CHAR(Scm_StringRef(str, k)));")

(define-cproc string-set! (str k c)
  (assert (string? str))
  (assert (small-integer? k))
  (assert (char? c))
  "  ScmObj r = Scm_StringSet(str, k, c);
  if (r == SCM_FALSE) Scm_Error(\"argument out of range: %d\", k);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc string=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  if (SCM_STRING_LENGTH(s1) != SCM_STRING_LENGTH(s2)) SCM_RETURN(SCM_FALSE);
  if (memcmp(SCM_STRING_START(s1), SCM_STRING_START(s2), SCM_STRING_SIZE(s1)) == 0)
     SCM_RETURN(SCM_TRUE);
  else
     SCM_RETURN(SCM_FALSE);")

(define-cproc string<? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(Scm_StringLt(s1, s2));")
(define-cproc string<=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(Scm_StringLe(s1, s2));")
(define-cproc string>? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(Scm_StringGt(s1, s2));")
(define-cproc string>=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(Scm_StringGe(s1, s2));")

(define-cproc string-ci=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(Scm_StringCiEqual(s1, s2));")
(define-cproc string-ci<? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(Scm_StringCiLt(s1, s2));")
(define-cproc string-ci<=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(Scm_StringCiLe(s1, s2));")
(define-cproc string-ci>? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(Scm_StringCiGt(s1, s2));")
(define-cproc string-ci>=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(Scm_StringCiGe(s1, s2));")

(define-cproc substring (str start end)
  (assert (string? str))
  (assert (small-integer? start))
  (assert (small-integer? end))
  "  SCM_RETURN(Scm_Substring(str, start, end));")

(define-cproc string-append (&rest args)
  "  ScmObj str, strs; int size=0, len=0; char *buf, *bufp;
  SCM_FOR_EACH(strs, args) {
    str = SCM_CAR(strs);
    if (!SCM_STRINGP(str)) Scm_Error(\"string required, but got %S\", str);
    size += SCM_STRING_SIZE(str);
    if (len >= 0 && SCM_STRING_LENGTH(str) >= 0) 
      len += SCM_STRING_LENGTH(str);
    else
      len = -1;
  }
  buf = bufp = SCM_NEW_ATOMIC2(char *, size+1);
  SCM_FOR_EACH(strs, args) {
    str = SCM_CAR(strs);
    memcpy(bufp, SCM_STRING_START(str), SCM_STRING_SIZE(str));
    bufp += SCM_STRING_SIZE(str);
  }
  SCM_RETURN(Scm_MakeStringConst(buf, size, len));
")

(define-cproc string->list (str)
  (assert (string? str))
  "  SCM_RETURN(Scm_StringToList(str));")

(define-cproc list->string (list)
  (assert (list? list))
  "  SCM_RETURN(Scm_ListToString(list));")

(define-cproc string-copy (str)
  (assert (string? str))
  "  SCM_RETURN(Scm_CopyString(str));")

(define-cproc string-fill! (str c)
  (assert (string? str))
  (assert (char? c))
  "  SCM_RETURN(Scm_StringFill(str, c));")

;;
;; 6.3.6  Vectors
;;

(define-cproc vector? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_VECTORP(obj)));")

(define-cproc make-vector (k &optional fill)
  (assert (small-integer? k))
  "  SCM_RETURN(Scm_MakeVector(k, fill));")

(define-cproc vector (&rest args)
  (inliner "Scm_inline_vector")
  "  SCM_RETURN(Scm_ListToVector(args));")

(define-cproc vector-length (vec)
  (inliner "Scm_inline_vector_length")
  (assert (vector? vec))
  "  SCM_RETURN(Scm_MakeInteger(SCM_VECTOR_SIZE(vec)));")

(define-cproc vector-ref (vec k)
  (inliner "Scm_inline_vector_ref")
  (assert (vector? vec))
  (assert (small-integer? k))
  "  SCM_RETURN(Scm_VectorRef(vec, k));")

(define-cproc vector-set! (vec k obj)
  (inliner "Scm_inline_vector_set")
  (assert (vector? vec))
  (assert (small-integer? k))
  "  Scm_VectorSet(vec, k, obj);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc vector->list (vec)
  (assert (vector? vec))
  "  SCM_RETURN(Scm_VectorToList(vec));")

(define-cproc list->vector (list)
  (assert (list? list))
  "  SCM_RETURN(Scm_ListToVector(list));")

(define-cproc vector-fill! (vec fill)
  (assert (vector? vec))
  "  Scm_VectorFill(vec, fill);
  SCM_RETURN(SCM_UNDEFINED);")

;;
;; 6.4  Control Features
;;

(define-cproc procedure? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_PROCEDUREP(obj)));")

(define-cproc apply (proc arg1 &rest args)
  "  if (SCM_NULLP(args)) Scm_Apply(proc, arg1);
  else {
    ScmObj head, tail, cp;
    head = tail = Scm_Cons(arg1, SCM_NIL);
    SCM_FOR_EACH(cp, args) {
      if (SCM_NULLP(SCM_CDR(cp))) {
        SCM_GROW_LIST_SPLICING(head, tail, SCM_CAR(cp));
        Scm_Apply(proc, head);
        return;
      }
      if (!SCM_PAIRP(SCM_CDR(cp))) {
        Scm_Error(\"improper list not allowed: %S\", SCM_CDR(cp));
      }
      SCM_GROW_LIST(head, tail, SCM_CAR(cp));
    }
  } /*NOTREACHED*/")

(define-cproc map (proc args &rest moreargs)
  (assert (procedure? proc))
  (assert (list? args))
  "  Scm_Map(proc, args, moreargs);")

(define-cproc for-each (proc args &rest moreargs)
  (assert (procedure? proc))
  (assert (list? args))
  "  Scm_ForEach(proc, args, moreargs);")
          
(define-cproc force (p)
  "  Scm_Force(p);")

(define-proc call-with-current-continuation (proc)
  "  Scm_CallCC(proc);")

; values
; call-with-values

(define-cproc dynamic-wind (pre body post)
  "  Scm_DynamicWind(pre, body, post);")

(define-cproc eval (expr env)
  ;; Result is pushed by evaluation of expr
  "  Scm_Eval(expr, env);")

;; TODO: implement environments!
; scheme-report-environment
; null-environment
; interaction-environment

;;
;; 6.6.1  Ports
;;
  
(define-cproc call-with-input-file (file proc)
  (assert (string? file))
  (assert (procedure? proc))
  "  Scm_CallWithFile(file, proc, 1);")

(define-cproc call-with-output-file (file proc)
  (assert (string? file))
  (assert (procedure? proc))
  "  Scm_CallWithFile(file, proc, 0);")

(define-cproc input-port? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_IPORTP(obj)));")

(define-cproc output-port? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_OPORTP(obj)));")

(define-cproc current-input-port ()
  "  SCM_RETURN(SCM_OBJ(SCM_CURRENT_INPUT_PORT));")

(define-cproc current-output-port ()
  "  SCM_RETURN(SCM_OBJ(SCM_CURRENT_OUTPUT_PORT));")

; with-input-from-file
; with-output-to-file

(define-cproc open-input-file (path)
  (assert (string? path))
  "  ScmObj o = Scm_OpenFilePort(Scm_GetStringConst(path), \"r\");
  if (o == SCM_FALSE) Scm_Error(\"couldn't open input file: %S\", path_scm);
  SCM_RETURN(o);")

(define-cproc open-output-file (path)
  (assert (string? path))
  "  ScmObj o = Scm_OpenFilePort(Scm_GetStringConst(path), \"w\");
  if (o == SCM_FALSE) Scm_Error(\"couldn't open output file: %S\", path_scm);
  SCM_RETURN(o);")

(define-cproc close-input-port (port)
  (assert (input-port? port))
  "  Scm_ClosePort(port); SCM_RETURN(SCM_UNDEFINED);")

(define-cproc close-output-port (port)
  (assert (output-port? port))
  "  Scm_ClosePort(port); SCM_RETURN(SCM_UNDEFINED);")

;;
;; 6.6.2  Input
;;

(define-cproc read (&optional (port (current-input-port)))
  (assert (input-port? port))
  "  SCM_RETURN(Scm_Read(SCM_OBJ(port)));")

(define-cproc read-char (&optional (port (current-input-port)))
  (assert (input-port? port))
  "  int ch;
  SCM_GETC(ch, port);
  if (ch == EOF) SCM_RETURN(SCM_EOF);
  else SCM_RETURN(SCM_MAKE_CHAR(ch));")

(define-cproc peek-char (&optional (port (current-input-port)))
  (assert (input-port? port))
  "  ScmChar ch; ScmObj r;
  if ((ch = SCM_PORT_UNGOTTEN(port)) == SCM_CHAR_INVALID) {
    SCM_GETC(ch, port);
    SCM_PORT_UNGOTTEN(port) = ch;
  }
  r = (ch == SCM_CHAR_INVALID)? SCM_EOF : SCM_MAKE_CHAR(ch);
  SCM_RETURN(r);")

(define-cproc eof-object? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EOFP(obj)));")

; char-ready?

;;
;; 6.6.3  Output
;;

(define-cproc write (obj &optional (port (current-output-port)))
  (assert (output-port? port))
  "  int nc = Scm_Write(obj, SCM_OBJ(port), SCM_PRINT_WRITE);
  SCM_RETURN(Scm_MakeInteger(nc));")

(define-cproc display (obj &optional (port (current-output-port)))
  (assert (output-port? port))
  "  int nc = Scm_Write(obj, SCM_OBJ(port), SCM_PRINT_DISPLAY);
  SCM_RETURN(Scm_MakeInteger(nc));")

(define-cproc newline (&optional (port (current-output-port)))
  (assert (output-port? port))
  "  SCM_PUTC('\\n', port);
  SCM_RETURN(SCM_MAKE_INT(1));")

(define-cproc write-char (ch &optional (port (current-output-port)))
  (assert (char? ch))
  (assert (output-port? port))
  "  SCM_PUTC(ch, port);
  SCM_RETURN(SCM_MAKE_INT(1));")

;;
;; 6.6.4  System Interface
;;

(define-cproc load (file)
  (assert (string? file))
  "  Scm_Load(Scm_GetStringConst(file));")

; transcript-on
; transcript-off

