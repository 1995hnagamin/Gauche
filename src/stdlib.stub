;;;
;;; stdlib.stub - r5rs scheme procedures
;;;
;;;   Copyright (c) 2000-2001 Shiro Kawai (shiro@acm.org)
;;;
;;;   Permission to use, copy, modify, distribute this software and
;;;   accompanying documentation for any purpose is hereby granted,
;;;   provided that existing copyright notices are retained in all
;;;   copies and that this notice is included verbatim in all
;;;   distributions.
;;;   This software is provided as is, without express or implied
;;;   warranty.  In no circumstances the author(s) shall be liable
;;;   for any damages arising out of the use of this software.
;;;
;;; $Id: stdlib.stub,v 1.65 2001-08-30 07:05:09 shirok Exp $
;;;


"
#include <stdlib.h>
#include <ctype.h>
#include <math.h>

#ifndef M_PI
#define M_PI 3.1415926535897932384
#endif
"

;;
;; 6.1  Equivalence predicates
;;

(define-cproc eqv? (obj1 obj2)
  (inliner "SCM_VM_EQV")
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_EqvP(obj1, obj2)));")

(define-cproc eq? (obj1 obj2)
  (inliner "SCM_VM_EQ")
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EQ(obj1, obj2)));")

(define-cproc equal? (obj1 obj2)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_EqualP(obj1, obj2)));")

;;
;; 6.2  Numbers
;;

(define-cproc number? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_NUMBERP(obj)));")
(define-cproc complex? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_NUMBERP(obj)));")
(define-cproc real? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_REALP(obj)));")
(define-cproc rational? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_REALP(obj)));")
(define-cproc integer? (obj)
  "  if (!SCM_NUMBERP(obj)) SCM_RETURN(SCM_FALSE);
  else SCM_RETURN(SCM_MAKE_BOOL(Scm_IntegerP(obj)));")

(define-cproc exact? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EXACTP(obj)));")
(define-cproc inexact? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_INEXACTP(obj)));")

(define-cproc = (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMEQ2") (else #f)))
  "  for (;;) {
  if (!Scm_NumEq(arg0, arg1)) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg1 = SCM_CAR(args); args = SCM_CDR(args);
  }")

(define-cproc < (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMLT2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) >= 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc <= (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMLE2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) > 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc > (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMGT2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) <= 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc >= (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMGE2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) < 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc zero? (obj)
  "  if (SCM_COMPLEXP(obj)) SCM_RETURN(SCM_FALSE);
  SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) == 0));")
(define-cproc positive? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) > 0));")
(define-cproc negative? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) < 0));")
(define-cproc odd? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_OddP(obj)));")
(define-cproc even? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(!Scm_OddP(obj)));")

(define-cproc max (arg0 &rest args)
  "  SCM_RETURN(Scm_Max(arg0, args));")
(define-cproc min (arg0 &rest args)
  "  SCM_RETURN(Scm_Min(arg0, args));")

"/* inliner for `+' */
static inline ScmObj immediate_integer_inliner(long insn, int arg0, ScmObj arg1, ScmObj env)
{
  return Scm_Append2(Scm_Compile(arg1, env, SCM_COMPILE_NORMAL),
                     Scm_Cons(SCM_VM_INSN1(insn, arg0), SCM_NIL));
}

static inline ScmObj num2op_inliner(long insn, ScmObj arg0, ScmObj arg1, ScmObj env)
{
  ScmObj code = SCM_NIL, tail;
  SCM_APPEND(code, tail, Scm_Compile(arg0, env, SCM_COMPILE_NORMAL));
  SCM_APPEND1(code, tail, SCM_VM_INSN(SCM_VM_PUSH));
  SCM_APPEND(code, tail, Scm_Compile(arg1, env, SCM_COMPILE_NORMAL));
  SCM_APPEND1(code, tail, SCM_VM_INSN(insn));
  return code;
}

static ScmObj plus_inliner(ScmSubr *subr, ScmObj form, ScmObj env, int ctx)
{
  ScmObj args = SCM_CDR(form), arg0, arg1;
  int imm;
  if (Scm_Length(form) != 3) return SCM_FALSE;
  arg0 = SCM_CAR(args);
  arg1 = SCM_CADR(args);
  if (SCM_INTP(arg0)) {
    if (SCM_INTP(arg1)) {
      return(SCM_LIST1(Scm_MakeInteger(SCM_INT_VALUE(arg0)+SCM_INT_VALUE(arg1))));
    }
    imm = SCM_INT_VALUE(arg0);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMADDI, imm, arg1, env);
  } else if (SCM_INTP(arg1)) {
    imm = SCM_INT_VALUE(arg1);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMADDI, imm, arg0, env);
  }
  return num2op_inliner(SCM_VM_NUMADD2, arg0, arg1, env);
}

static ScmObj minus_inliner(ScmSubr *subr, ScmObj form, ScmObj env, int ctx)
{
  ScmObj args = SCM_CDR(form), arg0, arg1;
  int imm;
  if (Scm_Length(form) != 3) return SCM_FALSE;
  arg0 = SCM_CAR(args);
  arg1 = SCM_CADR(args);
  if (SCM_INTP(arg0)) {
    if (SCM_INTP(arg1)) {
      return(SCM_LIST1(Scm_MakeInteger(SCM_INT_VALUE(arg0)-SCM_INT_VALUE(arg1))));
    }
    imm = SCM_INT_VALUE(arg0);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMSUBI, imm, arg1, env);
  } else if (SCM_INTP(arg1)) {
    imm = SCM_INT_VALUE(arg1);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMADDI, -imm, arg0, env);
  }
  return num2op_inliner(SCM_VM_NUMSUB2, arg0, arg1, env);
}

"

(define-cproc + (&rest args)
;  (inliner (case-nargs (2 "SCM_VM_NUMADD2") (else #f)))
  (inliner (proc "plus_inliner"))
  "  if (SCM_NULLP(args)) SCM_RETURN(SCM_MAKE_INT(0));
  if (!SCM_PAIRP(SCM_CDR(args))) {
    if (!SCM_NUMBERP(SCM_CAR(args)))
      Scm_Error(\"number required, but got %S\", SCM_CAR(args));
    SCM_RETURN(SCM_CAR(args));
  } else {
    SCM_RETURN(Scm_Add(SCM_CAR(args), SCM_CADR(args), SCM_CDDR(args)));
  }")

(define-cproc * (&rest args)
  "  if (!SCM_PAIRP(args)) return SCM_MAKE_INT(1);
  if (!SCM_PAIRP(SCM_CDR(args))) {
    if (!SCM_NUMBERP(SCM_CAR(args)))
      Scm_Error(\"number required, but got %S\", SCM_CAR(args));
      return SCM_CAR(args);
    }
  SCM_RETURN(Scm_Multiply(SCM_CAR(args), SCM_CADR(args), SCM_CDDR(args)));")

(define-cproc - (arg1 &rest args)
;  (inliner (case-nargs (2 "SCM_VM_NUMSUB2") (else #f)))
  (inliner (proc "minus_inliner"))
  "  ScmObj r;
  if (SCM_NULLP(args)) r = Scm_Negate(arg1);
  else r = Scm_Subtract(arg1, SCM_CAR(args), SCM_CDR(args));
  SCM_RETURN(r);")

(define-cproc / (arg1 &rest args)
  "  ScmObj r;
  if (SCM_NULLP(args)) r = Scm_Reciprocal(arg1);
  else r = Scm_Divide(arg1, SCM_CAR(args), SCM_CDR(args));
  SCM_RETURN(r);")

(define-cproc abs (obj)
  "  SCM_RETURN(Scm_Abs(obj));")

(define-cproc quotient (n1 n2)
  "  SCM_RETURN(Scm_Quotient(n1, n2));")
(define-cproc remainder (n1 n2)
  "  SCM_RETURN(Scm_Modulo(n1, n2, TRUE));")
(define-cproc modulo (n1 n2)
  "  SCM_RETURN(Scm_Modulo(n1, n2, FALSE));")

;; gcd, lcd, numerator, denominator - in gauche/numeric.scm

(define-cproc floor (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_FLOOR));")
(define-cproc ceiling (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_CEIL));")
(define-cproc truncate (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_TRUNC));")
(define-cproc round (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_ROUND));")

;; rationalize - not implemented


;; Transcedental functions.  Complex numbers are handled in Scheme.

(define-cproc %exp (x)
  "  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  SCM_RETURN(Scm_MakeFlonum(exp(Scm_GetDouble(x))));")

(define-cproc %log (x)
  "  int sign;
  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  sign = Scm_Sign(x);
  if (sign < 0)
    SCM_RETURN(Scm_MakeComplex(log(-Scm_GetDouble(x)), M_PI));
  else
    /* NB: I intentionally delegate handling of the case x==0.0 to the
       system log() function.  Most systems should yield NaN or Inf. */
    SCM_RETURN(Scm_MakeFlonum(log(Scm_GetDouble(x))));")

(define-cproc %sin (x)
  "  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  SCM_RETURN(Scm_MakeFlonum(sin(Scm_GetDouble(x))));")
(define-cproc %cos (x)
  "  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  SCM_RETURN(Scm_MakeFlonum(cos(Scm_GetDouble(x))));")
(define-cproc %tan (x)
  "  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  SCM_RETURN(Scm_MakeFlonum(tan(Scm_GetDouble(x))));")
(define-cproc %asin (x)
  "  double v;
  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  v = Scm_GetDouble(x);
  if (v > 1.0) {
    SCM_RETURN(Scm_MakeComplex(M_PI/2.0, -log(v + sqrt(v*v-1.0))));
  } else if (v < -1.0) {
    SCM_RETURN(Scm_MakeComplex(-M_PI/2.0, -log(-v - sqrt(v*v-1.0))));
  } else {
    SCM_RETURN(Scm_MakeFlonum(asin(v)));
  }")
(define-cproc %acos (x)
  "  double v;
  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  v = Scm_GetDouble(x);
  if (v > 1.0) {
    SCM_RETURN(Scm_MakeComplex(0, log(v + sqrt(v*v-1.0))));
  } else if (v < -1.0) {
    SCM_RETURN(Scm_MakeComplex(M_PI, log(-v - sqrt(v*v-1.0))));
  } else {
    SCM_RETURN(Scm_MakeFlonum(acos(v)));
  }")

(define-cproc %atan (z &optional x)
  "  if (!SCM_REALP(z)) Scm_Error(\"real number required, but got %S\", z);
  if (x == SCM_UNBOUND) {
     SCM_RETURN(Scm_MakeFlonum(atan(Scm_GetDouble(z))));
  } else {
     if (!SCM_REALP(z)) Scm_Error(\"real number required, but got %S\", z);
     SCM_RETURN(Scm_MakeFlonum(atan2(Scm_GetDouble(z), Scm_GetDouble(x))));
  }")

(define-cproc %sinh (x)
  "  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  SCM_RETURN(Scm_MakeFlonum(sinh(Scm_GetDouble(x))));")
(define-cproc %cosh (x)
  "  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  SCM_RETURN(Scm_MakeFlonum(cosh(Scm_GetDouble(x))));")
(define-cproc %tanh (x)
  "  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  SCM_RETURN(Scm_MakeFlonum(tanh(Scm_GetDouble(x))));")
;; asinh and acosh are not in POSIX.
;(define-cproc %asinh (x)
;  "  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
;  SCM_RETURN(Scm_MakeFlonum(asinh(Scm_GetDouble(x))));")
;(define-cproc %acosh (x)
;  "  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
;  SCM_RETURN(Scm_MakeFlonum(acosh(Scm_GetDouble(x))));")

(define-cproc %sqrt (x)
  "  double vx;
  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  vx = Scm_GetDouble(x);
  if (vx < 0) SCM_RETURN(Scm_MakeComplex(0.0, sqrt(-vx)));
  else        SCM_RETURN(Scm_MakeFlonum(sqrt(vx)));")

(define-cproc %expt (x y)
  "  SCM_RETURN(Scm_Expt(x, y));")

(define-cproc make-rectangular (a b)
  "  ScmObj z;
  if (!SCM_REALP(a)) Scm_Error(\"real number required, but got %S\", a);
  if (!SCM_REALP(b)) Scm_Error(\"real number required, but got %S\", b);
  if (Scm_Sign(b) == 0) z = Scm_MakeFlonum(Scm_GetDouble(a));
  else z = Scm_MakeComplex(Scm_GetDouble(a), Scm_GetDouble(b));
  SCM_RETURN(z);")

(define-cproc %complex->real/imag (z)
  "  if (SCM_EXACTP(z)) { SCM_RETURN(Scm_Values2(z, SCM_MAKE_INT(0))); }
  else if (SCM_FLONUMP(z)) { SCM_RETURN(Scm_Values2(z, Scm_MakeFlonum(0.0))); }
  else if (!SCM_COMPLEXP(z)) {
    Scm_Error(\"number required, but got %S\", z);
    SCM_RETURN(SCM_UNDEFINED);
  } else { SCM_RETURN(Scm_Values2(Scm_MakeFlonum(SCM_COMPLEX_REAL(z)), Scm_MakeFlonum(SCM_COMPLEX_IMAG(z))));}")
    
;; make-polar, real-part, imag-part - defined in gauche/numeric.scm

(define-cproc magnitude (z)
  "  SCM_RETURN(Scm_Magnitude(z));")
(define-cproc angle (z)
  "  SCM_RETURN(Scm_Angle(z));")

(define-cproc exact->inexact (obj)
  "  SCM_RETURN(Scm_ExactToInexact(obj));")

(define-cproc inexact->exact (obj)
  "  SCM_RETURN(Scm_InexactToExact(obj));")

(define-cproc number->string (obj &optional (radix 10))
  (assert (small-integer? radix))
  "  SCM_RETURN(Scm_NumberToString(obj, radix));")

(define-cproc string->number (obj &optional (radix 10))
  (assert (string? obj))
  (assert (small-integer? radix))
  "  SCM_RETURN(Scm_StringToNumber(obj, radix));")

;;
;; 6.3.1  Booleans
;;

(define-cproc not (obj)
  (inliner "SCM_VM_NOT")
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_FALSEP(obj)));")

(define-cproc boolean? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_BOOLP(obj)));")

;;
;; 6.3.2  Pairs and lists
;;

(define-cproc pair? (obj)
  (inliner "SCM_VM_PAIRP")
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_PAIRP(obj)));")

(define-cproc cons (obj1 obj2)
  (inliner "SCM_VM_CONS")
  "  SCM_RETURN(Scm_Cons(obj1, obj2));")

(define-cproc car (obj)
  (inliner "SCM_VM_CAR")
  (assert (pair? obj))
  "  SCM_RETURN(SCM_CAR(obj));"
  (setter set-car!))

(define-cproc cdr (obj)
  (inliner "SCM_VM_CDR")
  (assert (pair? obj))
  "  SCM_RETURN(SCM_CDR(obj));"
  (setter set-cdr!))

(define-cproc set-car! (obj value)
  (assert (pair? obj))
  "  SCM_SET_CAR(obj, value);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc set-cdr! (obj value)
  (assert (pair? obj))
  "  SCM_SET_CDR(obj, value);
  SCM_RETURN(SCM_UNDEFINED);")

"#define CXR_SETTER(PRE, pre, tail) \\
  ScmObj cell = Scm_C##tail##r(obj); \\
  if (!SCM_PAIRP(cell)) Scm_Error(\"can't set c\" #pre #tail \"r of %S\", obj); \\
  SCM_SET_C##PRE##R(cell, value); SCM_RETURN(SCM_UNDEFINED);
"

(define-cproc caar (obj)    "SCM_RETURN(Scm_Caar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, a);"))
(define-cproc cadr (obj)    "SCM_RETURN(Scm_Cadr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, d);"))
(define-cproc cdar (obj)    "SCM_RETURN(Scm_Cdar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, a);"))
(define-cproc cddr (obj)    "SCM_RETURN(Scm_Cddr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, d);"))
(define-cproc caaar (obj)   "SCM_RETURN(Scm_Caaar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, aa);"))
(define-cproc caadr (obj)   "SCM_RETURN(Scm_Caadr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, ad);"))
(define-cproc cadar (obj)   "SCM_RETURN(Scm_Cadar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, da);"))
(define-cproc caddr (obj)   "SCM_RETURN(Scm_Caddr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, dd);"))
(define-cproc cdaar (obj)   "SCM_RETURN(Scm_Cdaar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, aa);"))
(define-cproc cdadr (obj)   "SCM_RETURN(Scm_Cdadr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, ad);"))
(define-cproc cddar (obj)   "SCM_RETURN(Scm_Cddar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, da);"))
(define-cproc cdddr (obj)   "SCM_RETURN(Scm_Cdddr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, dd);"))
(define-cproc caaaar (obj)  "SCM_RETURN(Scm_Caaaar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, aaa);"))
(define-cproc caaadr (obj)  "SCM_RETURN(Scm_Caaadr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, aad);"))
(define-cproc caadar (obj)  "SCM_RETURN(Scm_Caadar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, ada);"))
(define-cproc caaddr (obj)  "SCM_RETURN(Scm_Caaddr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, add);"))
(define-cproc cadaar (obj)  "SCM_RETURN(Scm_Cadaar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, daa);"))
(define-cproc cadadr (obj)  "SCM_RETURN(Scm_Cadadr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, dad);"))
(define-cproc caddar (obj)  "SCM_RETURN(Scm_Caddar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, dda);"))
(define-cproc cadddr (obj)  "SCM_RETURN(Scm_Cadddr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, ddd);"))
(define-cproc cdaaar (obj)  "SCM_RETURN(Scm_Cdaaar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, aaa);"))
(define-cproc cdaadr (obj)  "SCM_RETURN(Scm_Cdaadr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, aad);"))
(define-cproc cdadar (obj)  "SCM_RETURN(Scm_Cdadar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, ada);"))
(define-cproc cdaddr (obj)  "SCM_RETURN(Scm_Cdaddr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, add);"))
(define-cproc cddaar (obj)  "SCM_RETURN(Scm_Cddaar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, daa);"))
(define-cproc cddadr (obj)  "SCM_RETURN(Scm_Cddadr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, dad);"))
(define-cproc cdddar (obj)  "SCM_RETURN(Scm_Cdddar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, dda);"))
(define-cproc cddddr (obj)  "SCM_RETURN(Scm_Cddddr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, ddd);"))

(define-cproc null? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_NULLP(obj)));")

(define-cproc list? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Length(obj) >= 0));")

(define-cproc list (&rest args)
  (inliner "SCM_VM_LIST")
  ;; TODO: check to see if we don't need to copy args?
  "  SCM_RETURN(args);")

(define-cproc length (list)
  "  int i = Scm_Length(list);
  if (i < 0) Scm_Error(\"bad list: %S\", list);
  SCM_RETURN(Scm_MakeInteger(i));")

(define-cproc append (&rest lists)
  (inliner "SCM_VM_APPEND")
  "  SCM_RETURN(Scm_Append(lists));")

(define-cproc reverse (list)
  (assert (list? list))
  (inliner "SCM_VM_REVERSE")
  "  SCM_RETURN(Scm_Reverse(list));")

(define-cproc list-tail (list k)
  (assert (small-integer? k))
  "  SCM_RETURN(Scm_ListTail(list, k));")

(define-cproc list-ref (list k)
  (assert (small-integer? k))
  "  SCM_RETURN(Scm_ListRef(list, k));")

(define-cproc memq (obj list)
  (assert (list? list))
  (inliner "SCM_VM_MEMQ")
  "  SCM_RETURN(Scm_Memq(obj, list));")

(define-cproc memv (obj list)
  (assert (list? list))
  (inliner "SCM_VM_MEMV")
  "  SCM_RETURN(Scm_Memv(obj, list));")

(define-cproc member (obj list)
  (assert (list? list))
  "  SCM_RETURN(Scm_Member(obj, list, SCM_CMP_EQUAL));")

(define-cproc assq (obj alist)
  (assert (list? alist))
  (inliner "SCM_VM_ASSQ")
  "  SCM_RETURN(Scm_Assq(obj, alist));")

(define-cproc assv (obj alist)
  (assert (list? alist))
  (inliner "SCM_VM_ASSV")
  "  SCM_RETURN(Scm_Assv(obj, alist));")

(define-cproc assoc (obj alist)
  (assert (list? alist))
  "  SCM_RETURN(Scm_Assoc(obj, alist, SCM_CMP_EQUAL));")

;;
;; 6.3.3  Symbols
;;

(define-cproc symbol? (obj)
  (inliner "SCM_VM_SYMBOLP")
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_SYMBOLP(obj)));")

(define-cproc symbol->string (obj)
  (assert (symbol? obj))
  "  SCM_RETURN(SCM_OBJ(SCM_SYMBOL_NAME(obj)));")

(define-cproc string->symbol (obj)
  (assert (string? obj))
  "  SCM_RETURN(Scm_Intern(obj));")

;;
;; 6.3.4  Characters
;;

(define-cproc char? (obj)
  (inliner "SCM_VM_CHARP")
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHARP(obj)));")

(define-cproc char=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EQ(c1, c2)));")
(define-cproc char<? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 < c2));")
(define-cproc char>? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 > c2));")
(define-cproc char<=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 <= c2));")
(define-cproc char>=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 >= c2));")

(define-cproc char-ci=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EQ(SCM_CHAR_UPCASE(c1),SCM_CHAR_UPCASE(c2))));")
(define-cproc char-ci<? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)<SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci<=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)<=SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci>? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)>SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci>=? (c1 c2)
  (assert (char? c1))
  (assert (char? c2))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)>=SCM_CHAR_UPCASE(c2)));")

(define-cproc char-alphabetic? (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isalpha(c)));")
(define-cproc char-numeric? (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isdigit(c)));")
(define-cproc char-whitespace? (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isspace(c)));")
(define-cproc char-upper-case? (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPPER_P(c)));")
(define-cproc char-lower-case? (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_LOWER_P(c)));")

(define-cproc char->integer (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_INT((signed long)c));")

(define-cproc integer->char (c)
  (assert (small-integer? c))
  "  SCM_RETURN(SCM_MAKE_CHAR((ScmChar)c));")

(define-cproc char-upcase (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_CHAR(SCM_CHAR_UPCASE(c)));")

(define-cproc char-downcase (c)
  (assert (char? c))
  "  SCM_RETURN(SCM_MAKE_CHAR(SCM_CHAR_DOWNCASE(c)));")

;;
;; 6.3.5 Strings
;;

(define-cproc string? (obj)
  (inliner "SCM_VM_STRINGP")
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRINGP(obj)));")

(define-cproc make-string (len &optional (c #\ ))
  (assert (small-integer? len))
  (assert (char? c))
  "  SCM_RETURN(Scm_MakeFillString(len, c));")

(define-cproc string (&rest chars)
  "  SCM_RETURN(Scm_ListToString(chars));")

(define-cproc string-length (str)
  (assert (string? str))
  "  SCM_RETURN(SCM_MAKE_INT(SCM_STRING_LENGTH(str)));")

(define-cproc string-ref (str k)
  (assert (string? str))
  (assert (small-integer? k))
  (setter string-set!)
  "  SCM_RETURN(SCM_MAKE_CHAR(Scm_StringRef(str, k)));")

(define-cproc string-set! (str k c)
  (assert (string? str))
  (assert (small-integer? k))
  (assert (char? c))
  "  ScmObj r = Scm_StringSet(str, k, c);
  if (r == SCM_FALSE) Scm_Error(\"argument out of range: %d\", k);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc string=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) == 0));")
(define-cproc string<? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) < 0));")
(define-cproc string<=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) <= 0));")
(define-cproc string>? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) > 0));")
(define-cproc string>=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) >= 0));")

(define-cproc string-ci=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) == 0));")
(define-cproc string-ci<? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) < 0));")
(define-cproc string-ci<=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) <= 0));")
(define-cproc string-ci>? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) > 0));")
(define-cproc string-ci>=? (s1 s2)
  (assert (string? s1))
  (assert (string? s2))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) >= 0));")

(define-cproc substring (str start end)
  (assert (string? str))
  (assert (small-integer? start))
  (assert (small-integer? end))
  "  SCM_RETURN(Scm_Substring(str, start, end));")

(define-cproc string-append (&rest args)
  "  SCM_RETURN(Scm_StringAppend(args));")

(define-cproc string->list (str &optional start end) ;optional arg in SRFI-13
  (assert (string? str))
  "  ScmObj xstr = Scm_MaybeSubstring(str, start, end);
  SCM_RETURN(Scm_StringToList(SCM_STRING(xstr)));")

(define-cproc list->string (list)
  (assert (list? list))
  "  SCM_RETURN(Scm_ListToString(list));")

(define-cproc string-copy (str &optional start end) ;optional arg in SRFI-13
  (assert (string? str))
  "  ScmObj xstr = Scm_MaybeSubstring(str, start, end);
  SCM_RETURN(Scm_CopyString(SCM_STRING(xstr)));")

(define-cproc string-fill! (str c &optional start end) ;optional arg in SRFI-13
  (assert (string? str))
  (assert (char? c))
  "  SCM_RETURN(Scm_StringFill(str, c, start, end));")

;;
;; 6.3.6  Vectors
;;

(define-cproc vector? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_VECTORP(obj)));")

(define-cproc make-vector (k &optional fill)
  (assert (small-integer? k))
  "  SCM_RETURN(Scm_MakeVector(k, fill));")

(define-cproc vector (&rest args)
  (inliner "SCM_VM_VEC")
  "  SCM_RETURN(Scm_ListToVector(args));")

(define-cproc vector-length (vec)
  (inliner "SCM_VM_VEC_LEN")
  (assert (vector? vec))
  "  SCM_RETURN(Scm_MakeInteger(SCM_VECTOR_SIZE(vec)));")

(define-cproc vector-ref (vec k)
  (inliner "SCM_VM_VEC_REF")
  (assert (vector? vec))
  (assert (small-integer? k))
  (setter vector-set!)
  "  SCM_RETURN(Scm_VectorRef(vec, k));")

(define-cproc vector-set! (vec k obj)
  (inliner "SCM_VM_VEC_SET")
  (assert (vector? vec))
  (assert (small-integer? k))
  "  Scm_VectorSet(vec, k, obj);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc vector->list (vec)
  (assert (vector? vec))
  "  SCM_RETURN(Scm_VectorToList(vec));")

(define-cproc list->vector (list)
  (assert (list? list))
  "  SCM_RETURN(Scm_ListToVector(list));")

(define-cproc vector-fill! (vec fill)
  (assert (vector? vec))
  "  Scm_VectorFill(vec, fill);
  SCM_RETURN(SCM_UNDEFINED);")

;;
;; 6.4  Control Features
;;

(define-cproc procedure? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_PROCEDUREP(obj)));")

(define-cproc apply (proc arg1 &rest args)
  "  ScmObj head, tail, cp;
  if (SCM_NULLP(args)) return Scm_VMApply(proc, arg1);
  else {
    head = tail = Scm_Cons(arg1, SCM_NIL);
    SCM_FOR_EACH(cp, args) {
      if (SCM_NULLP(SCM_CDR(cp))) {
        SCM_APPEND(head, tail, SCM_CAR(cp));
        break;
      }
      if (!SCM_PAIRP(SCM_CDR(cp))) {
        Scm_Error(\"improper list not allowed: %S\", SCM_CDR(cp));
      }
      SCM_APPEND1(head, tail, SCM_CAR(cp));
    }
  }
  return Scm_VMApply(proc, head);")

(define-cproc map (proc args &rest moreargs)
  (assert (procedure? proc))
  (assert (list? args))
  "  SCM_RETURN(Scm_Map(proc, args, moreargs));")

(define-cproc for-each (proc args &rest moreargs)
  (assert (procedure? proc))
  (assert (list? args))
  "  SCM_RETURN(Scm_ForEach(proc, args, moreargs));")
          
(define-cproc force (p)
  "  return Scm_Force(p);")

(define-cproc call-with-current-continuation (proc)
  "  Scm_VMCallCC(proc);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc values (&rest args)
  (inliner "SCM_VM_VALUES")
  "  SCM_RETURN(Scm_Values(args));")

;; call-with-values - defined in gauche-init.scm

(define-cproc dynamic-wind (pre body post)
  "  SCM_RETURN(Scm_VMDynamicWind(pre, body, post));")

(define-cproc eval (expr env)
  "  SCM_RETURN(Scm_VMEval(expr, env));")

;; for now, just return a module.
(define-cproc null-environment ()
  "  SCM_RETURN(SCM_OBJ(Scm_NullModule()));")
(define-cproc interaction-environment ()
  "  SCM_RETURN(SCM_OBJ(Scm_UserModule()));")
(define-cproc scheme-report-environment (version)
  (assert (small-integer? version))
  "  if (version != 5) Scm_Error(\"unknown rNrs version: %d\", version);
  SCM_RETURN(SCM_OBJ(Scm_SchemeModule()));")

;;
;; 6.6.1  Ports
;;
  
(define-cproc call-with-input-file (file proc)
  (assert (string? file))
  (assert (procedure? proc))
  "  Scm_CallWithFile(file, proc, 1);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc call-with-output-file (file proc)
  (assert (string? file))
  (assert (procedure? proc))
  "  Scm_CallWithFile(file, proc, 0);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc input-port? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_IPORTP(obj)));")

(define-cproc output-port? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_OPORTP(obj)));")

(define-cproc current-input-port ()
  "  SCM_RETURN(SCM_OBJ(SCM_CURIN));")

(define-cproc current-output-port ()
  "  SCM_RETURN(SCM_OBJ(SCM_CUROUT));")

(define-cproc with-input-from-file (file thunk)
  (assert (string? file))
  (assert (procedure? thunk))
  "  Scm_WithFile(file, thunk, 0);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc with-output-to-file (file thunk)
  (assert (string? file))
  (assert (procedure? thunk))
  "  Scm_WithFile(file, thunk, 1);
  SCM_RETURN(SCM_UNDEFINED);")


(define-cproc open-input-file (path)
  (assert (string? path))
  "  ScmObj o = Scm_OpenFilePort(Scm_GetStringConst(path), \"r\");
  if (o == SCM_FALSE) Scm_Error(\"couldn't open input file: %S\", path_scm);
  SCM_RETURN(o);")

(define-cproc open-output-file (path)
  (assert (string? path))
  "  ScmObj o = Scm_OpenFilePort(Scm_GetStringConst(path), \"w\");
  if (o == SCM_FALSE) Scm_Error(\"couldn't open output file: %S\", path_scm);
  SCM_RETURN(o);")

(define-cproc close-input-port (port)
  (assert (input-port? port))
  "  Scm_ClosePort(port); SCM_RETURN(SCM_UNDEFINED);")

(define-cproc close-output-port (port)
  (assert (output-port? port))
  "  Scm_ClosePort(port); SCM_RETURN(SCM_UNDEFINED);")

;;
;; 6.6.2  Input
;;

(define-cproc read (&optional (port (current-input-port)))
  (assert (input-port? port))
  "  SCM_RETURN(Scm_Read(SCM_OBJ(port)));")

(define-cproc read-char (&optional (port (current-input-port)))
  (assert (input-port? port))
  (inliner "SCM_VM_READ_CHAR")
  "  int ch = EOF;
  SCM_GETC(ch, port);
  if (ch == EOF) SCM_RETURN(SCM_EOF);
  else SCM_RETURN(SCM_MAKE_CHAR(ch));")

(define-cproc peek-char (&optional (port (current-input-port)))
  (assert (input-port? port))
  "  ScmChar ch; ScmObj r;
  if ((ch = SCM_PORT_UNGOTTEN(port)) == SCM_CHAR_INVALID) {
    SCM_GETC(ch, port);
    SCM_PORT_UNGOTTEN(port) = ch;
  }
  r = (ch == SCM_CHAR_INVALID)? SCM_EOF : SCM_MAKE_CHAR(ch);
  SCM_RETURN(r);")

(define-cproc eof-object? (obj)
  (inliner "SCM_VM_EOFP")
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EOFP(obj)));")

(define-cproc char-ready? (port)
  (assert (input-port? port))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_CharReady(port)));")

;;
;; 6.6.3  Output
;;

(define-cproc write (obj &optional (port (current-output-port)))
  (assert (output-port? port))
  "  Scm_Write(obj, SCM_OBJ(port), SCM_WRITE_WRITE);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc display (obj &optional (port (current-output-port)))
  (assert (output-port? port))
  "  Scm_Write(obj, SCM_OBJ(port), SCM_WRITE_DISPLAY);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc newline (&optional (port (current-output-port)))
  (assert (output-port? port))
  "  SCM_PUTC('\\n', port);
  SCM_RETURN(SCM_MAKE_INT(1));")

(define-cproc write-char (ch &optional (port (current-output-port)))
  (assert (char? ch))
  (assert (output-port? port))
  (inliner "SCM_VM_WRITE_CHAR")
  "  SCM_PUTC(ch, port);
  SCM_RETURN(SCM_MAKE_INT(1));")

;;
;; 6.6.4  System Interface
;;

(define-cproc load (file &keyword (error-if-not-found #t))
  (assert (string? file))
  "  SCM_RETURN(Scm_VMLoad(file, !SCM_FALSEP(error_if_not_found)));")

; transcript-on
; transcript-off

;; Local variables:
;; mode: scheme
;; end:
