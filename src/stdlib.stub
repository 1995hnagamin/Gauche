;;;
;;; stdlib.stub - r5rs scheme procedures
;;;
;;;   Copyright (c) 2000-2002 Shiro Kawai (shiro@acm.org)
;;;
;;;   Permission to use, copy, modify, distribute this software and
;;;   accompanying documentation for any purpose is hereby granted,
;;;   provided that existing copyright notices are retained in all
;;;   copies and that this notice is included verbatim in all
;;;   distributions.
;;;   This software is provided as is, without express or implied
;;;   warranty.  In no circumstances the author(s) shall be liable
;;;   for any damages arising out of the use of this software.
;;;
;;; $Id: stdlib.stub,v 1.93 2002-09-10 10:36:41 shirok Exp $
;;;


"
#include <stdlib.h>
#include <ctype.h>
#include <fcntl.h>
#include <math.h>

#ifndef M_PI
#define M_PI 3.1415926535897932384
#endif
"

;;
;; 6.1  Equivalence predicates
;;

(define-cproc eqv? (obj1 obj2)
  (inliner "SCM_VM_EQV")
  (return <boolean> "Scm_EqvP"))

(define-cproc eq? (obj1 obj2)
  (inliner "SCM_VM_EQ")
  (return <boolean> "SCM_EQ"))

(define-cproc equal? (obj1 obj2)
  (return <boolean> "Scm_EqualP"))

;;
;; 6.2  Numbers
;;

(define-cproc number? (obj)   (return <boolean> "SCM_NUMBERP"))
(define-cproc complex? (obj)  (return <boolean> "SCM_NUMBERP"))
(define-cproc real? (obj)     (return <boolean> "SCM_REALP"))
(define-cproc rational? (obj) (return <boolean> "SCM_REALP"))
(define-cproc integer? (obj)
  "  if (!SCM_NUMBERP(obj)) SCM_RETURN(SCM_FALSE);
  else SCM_RETURN(SCM_MAKE_BOOL(Scm_IntegerP(obj)));")

(define-cproc exact? (obj)    (return <boolean> "SCM_EXACTP"))
(define-cproc inexact? (obj)  (return <boolean> "SCM_INEXACTP"))

(define-cproc = (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMEQ2") (else #f)))
  "  for (;;) {
  if (!Scm_NumEq(arg0, arg1)) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg1 = SCM_CAR(args); args = SCM_CDR(args);
  }")

(define-cproc < (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMLT2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) >= 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc <= (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMLE2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) > 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc > (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMGT2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) <= 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc >= (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMGE2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) < 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc zero? (obj)
  "if (SCM_COMPLEXP(obj))
       SCM_RETURN(SCM_MAKE_BOOL(SCM_COMPLEX_IMAG(obj) == 0.0));
  else SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) == 0));")
(define-cproc positive? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) > 0));")
(define-cproc negative? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) < 0));")
(define-cproc odd? (obj)   (return <boolean> "Scm_OddP"))
(define-cproc even? (obj)  (return <boolean> "!Scm_OddP"))

(define-cproc max (arg0 &rest args)
  "ScmObj r; Scm_MinMax(arg0, args, NULL, &r); SCM_RETURN(r);")
(define-cproc min (arg0 &rest args)
  "ScmObj r; Scm_MinMax(arg0, args, &r, NULL); SCM_RETURN(r);")

"/* inliner for `+' */
static inline ScmObj immediate_integer_inliner(long insn, long arg0, ScmObj arg1, ScmObj env)
{
  return Scm_Append2X(Scm_Compile(arg1, env, SCM_COMPILE_NORMAL),
                      Scm_Cons(SCM_VM_INSN1(insn, arg0), SCM_NIL));
}

static inline ScmObj num2op_inliner(long insn, ScmObj arg0, ScmObj arg1, ScmObj env)
{
  ScmObj code = SCM_NIL, tail = SCM_NIL;
  SCM_APPEND(code, tail, Scm_Compile(arg0, env, SCM_COMPILE_NORMAL));
  SCM_APPEND1(code, tail, SCM_VM_INSN(SCM_VM_PUSH));
  SCM_APPEND(code, tail, Scm_Compile(arg1, env, SCM_COMPILE_NORMAL));
  SCM_APPEND1(code, tail, SCM_VM_INSN(insn));
  return code;
}

static ScmObj plus_inliner(ScmSubr *subr, ScmObj form, ScmObj env, int ctx)
{
  ScmObj args = SCM_CDR(form), arg0, arg1;
  long imm;
  if (Scm_Length(form) != 3) return SCM_FALSE;
  arg0 = SCM_CAR(args);
  arg1 = SCM_CADR(args);
  if (SCM_INTP(arg0)) {
    if (SCM_INTP(arg1)) {
      return(SCM_LIST1(Scm_MakeInteger(SCM_INT_VALUE(arg0)+SCM_INT_VALUE(arg1))));
    }
    imm = SCM_INT_VALUE(arg0);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMADDI, imm, arg1, env);
  } else if (SCM_INTP(arg1)) {
    imm = SCM_INT_VALUE(arg1);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMADDI, imm, arg0, env);
  }
  return num2op_inliner(SCM_VM_NUMADD2, arg0, arg1, env);
}

static ScmObj minus_inliner(ScmSubr *subr, ScmObj form, ScmObj env, int ctx)
{
  ScmObj args = SCM_CDR(form), arg0, arg1;
  long imm;
  if (Scm_Length(form) != 3) return SCM_FALSE;
  arg0 = SCM_CAR(args);
  arg1 = SCM_CADR(args);
  if (SCM_INTP(arg0)) {
    if (SCM_INTP(arg1)) {
      return(SCM_LIST1(Scm_MakeInteger(SCM_INT_VALUE(arg0)-SCM_INT_VALUE(arg1))));
    }
    imm = SCM_INT_VALUE(arg0);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMSUBI, imm, arg1, env);
  } else if (SCM_INTP(arg1)) {
    imm = SCM_INT_VALUE(arg1);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMADDI, -imm, arg0, env);
  }
  return num2op_inliner(SCM_VM_NUMSUB2, arg0, arg1, env);
}

"

(define-cproc + (&rest args)
;  (inliner (case-nargs (2 "SCM_VM_NUMADD2") (else #f)))
  (inliner (proc "plus_inliner"))
  "  if (SCM_NULLP(args)) SCM_RETURN(SCM_MAKE_INT(0));
  if (!SCM_PAIRP(SCM_CDR(args))) {
    if (!SCM_NUMBERP(SCM_CAR(args)))
      Scm_Error(\"number required, but got %S\", SCM_CAR(args));
    SCM_RETURN(SCM_CAR(args));
  } else {
    SCM_RETURN(Scm_Add(SCM_CAR(args), SCM_CADR(args), SCM_CDDR(args)));
  }")

(define-cproc * (&rest args)
  "  if (!SCM_PAIRP(args)) return SCM_MAKE_INT(1);
  if (!SCM_PAIRP(SCM_CDR(args))) {
    if (!SCM_NUMBERP(SCM_CAR(args)))
      Scm_Error(\"number required, but got %S\", SCM_CAR(args));
      return SCM_CAR(args);
    }
  SCM_RETURN(Scm_Multiply(SCM_CAR(args), SCM_CADR(args), SCM_CDDR(args)));")

(define-cproc - (arg1 &rest args)
;  (inliner (case-nargs (2 "SCM_VM_NUMSUB2") (else #f)))
  (inliner (proc "minus_inliner"))
  "  ScmObj r;
  if (SCM_NULLP(args)) r = Scm_Negate(arg1);
  else r = Scm_Subtract(arg1, SCM_CAR(args), SCM_CDR(args));
  SCM_RETURN(r);")

(define-cproc / (arg1 &rest args)
  "  ScmObj r;
  if (SCM_NULLP(args)) r = Scm_Reciprocal(arg1);
  else r = Scm_Divide(arg1, SCM_CAR(args), SCM_CDR(args));
  SCM_RETURN(r);")

(define-cproc abs (obj) (return "Scm_Abs"))

(define-cproc quotient (n1 n2)
  "  SCM_RETURN(Scm_Quotient(n1, n2, NULL));")
(define-cproc remainder (n1 n2)
  "  SCM_RETURN(Scm_Modulo(n1, n2, TRUE));")
(define-cproc modulo (n1 n2)
  "  SCM_RETURN(Scm_Modulo(n1, n2, FALSE));")

;; gcd, lcd, numerator, denominator - in gauche/numeric.scm

(define-cproc floor (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_FLOOR));")
(define-cproc ceiling (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_CEIL));")
(define-cproc truncate (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_TRUNC));")
(define-cproc round (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_ROUND));")

;; rationalize - not implemented


;; Transcedental functions.  Complex numbers are handled in Scheme.

(define-cproc %exp (x::<real>) (return <real> "exp"))

(define-cproc %log (x)
  "  int sign;
  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  sign = Scm_Sign(x);
  if (sign < 0)
    SCM_RETURN(Scm_MakeComplex(log(-Scm_GetDouble(x)), M_PI));
  else
    /* NB: I intentionally delegate handling of the case x==0.0 to the
       system log() function.  Most systems should yield NaN or Inf. */
    SCM_RETURN(Scm_MakeFlonum(log(Scm_GetDouble(x))));")

(define-cproc %sin (x::<real>) (return <real> "sin"))
(define-cproc %cos (x::<real>) (return <real> "cos"))
(define-cproc %tan (x::<real>) (return <real> "tan"))
(define-cproc %asin (x::<real>)
  "if (x > 1.0) {
    SCM_RETURN(Scm_MakeComplex(M_PI/2.0, -log(x + sqrt(x*x-1.0))));
  } else if (x < -1.0) {
    SCM_RETURN(Scm_MakeComplex(-M_PI/2.0, -log(-x - sqrt(x*x-1.0))));
  } else {
    SCM_RETURN(Scm_MakeFlonum(asin(x)));
  }")
(define-cproc %acos (x::<real>)
  "if (x > 1.0) {
    SCM_RETURN(Scm_MakeComplex(0, log(x + sqrt(x*x-1.0))));
  } else if (x < -1.0) {
    SCM_RETURN(Scm_MakeComplex(M_PI, log(-x - sqrt(x*x-1.0))));
  } else {
    SCM_RETURN(Scm_MakeFlonum(acos(x)));
  }")

(define-cproc %atan (z::<real> &optional x)
  "if (x == SCM_UNBOUND) {
     SCM_RETURN(Scm_MakeFlonum(atan(z)));
  } else {
     if (!SCM_REALP(x)) Scm_Error(\"real number required for x, but got %S\", x);
     SCM_RETURN(Scm_MakeFlonum(atan2(z, Scm_GetDouble(x))));
  }")

(define-cproc %sinh (x::<real>) (return <real> "sinh"))
(define-cproc %cosh (x::<real>) (return <real> "cosh"))
(define-cproc %tanh (x::<real>) (return <real> "tanh"))
;; NB: asinh and acosh are not in POSIX.

(define-cproc %sqrt (x::<real>)
  "if (x < 0) SCM_RETURN(Scm_MakeComplex(0.0, sqrt(-x)));
  else        SCM_RETURN(Scm_MakeFlonum(sqrt(x)));")

(define-cproc %expt (x y) (return "Scm_Expt"))

(define-cproc make-rectangular (a::<real> b::<real>)
  "if (b == 0.0) SCM_RETURN(Scm_MakeFlonum(a));
  else SCM_RETURN(Scm_MakeComplex(a, b));")

(define-cproc make-polar (r::<real> t::<real>)
  "double real = r * cos(t), imag = r * sin(t);
  if (imag == 0.0) SCM_RETURN(Scm_MakeFlonum(real));
  else SCM_RETURN(Scm_MakeComplex(real, imag));")

(define-cproc %complex->real/imag (z)
  "  if (SCM_EXACTP(z)) { SCM_RETURN(Scm_Values2(z, SCM_MAKE_INT(0))); }
  else if (SCM_FLONUMP(z)) { SCM_RETURN(Scm_Values2(z, Scm_MakeFlonum(0.0))); }
  else if (!SCM_COMPLEXP(z)) {
    Scm_Error(\"number required, but got %S\", z);
    SCM_RETURN(SCM_UNDEFINED);
  } else { SCM_RETURN(Scm_Values2(Scm_MakeFlonum(SCM_COMPLEX_REAL(z)), Scm_MakeFlonum(SCM_COMPLEX_IMAG(z))));}")
    
;; real-part, imag-part - defined in gauche/numeric.scm

(define-cproc magnitude (z)  (return "Scm_Magnitude"))
(define-cproc angle (z)      (return "Scm_Angle"))

(define-cproc exact->inexact (obj) (return "Scm_ExactToInexact"))
(define-cproc inexact->exact (obj) (return "Scm_InexactToExact"))

(define-cproc number->string (obj
                              &optional (radix::<fixnum> 10) (use-upper? #f))
  "  SCM_RETURN(Scm_NumberToString(obj, radix, !SCM_FALSEP(use_upperP)));")

(define-cproc string->number (obj::<string> &optional (radix::<fixnum> 10))
  "  SCM_RETURN(Scm_StringToNumber(obj, radix, FALSE));")

;;
;; 6.3.1  Booleans
;;

(define-cproc not (obj)
  (inliner "SCM_VM_NOT")
  (return <boolean> "SCM_FALSEP"))

(define-cproc boolean? (obj)
  (return <boolean> "SCM_BOOLP"))

;;
;; 6.3.2  Pairs and lists
;;

(define-cproc pair? (obj)
  (inliner "SCM_VM_PAIRP")
  (return <boolean> "SCM_PAIRP"))

(define-cproc cons (obj1 obj2)
  (inliner "SCM_VM_CONS")
  (return "Scm_Cons"))

(define-cproc car (obj::<pair>)
  (inliner "SCM_VM_CAR")
  (return "SCM_CAR")
  (setter set-car!))

(define-cproc cdr (obj::<pair>)
  (inliner "SCM_VM_CDR")
  (return "SCM_CDR")
  (setter set-cdr!))

(define-cproc set-car! (obj::<pair> value)
  (return void "SCM_SET_CAR"))

(define-cproc set-cdr! (obj::<pair> value)
  (return void "SCM_SET_CDR"))

"#define CXR_SETTER(PRE, pre, tail) \\
  ScmObj cell = Scm_C##tail##r(obj); \\
  if (!SCM_PAIRP(cell)) Scm_Error(\"can't set c\" #pre #tail \"r of %S\", obj); \\
  SCM_SET_C##PRE##R(cell, value); SCM_RETURN(SCM_UNDEFINED);
"

(define-cproc caar (obj)    "SCM_RETURN(Scm_Caar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, a);"))
(define-cproc cadr (obj)    "SCM_RETURN(Scm_Cadr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, d);"))
(define-cproc cdar (obj)    "SCM_RETURN(Scm_Cdar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, a);"))
(define-cproc cddr (obj)    "SCM_RETURN(Scm_Cddr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, d);"))
(define-cproc caaar (obj)   "SCM_RETURN(Scm_Caaar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, aa);"))
(define-cproc caadr (obj)   "SCM_RETURN(Scm_Caadr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, ad);"))
(define-cproc cadar (obj)   "SCM_RETURN(Scm_Cadar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, da);"))
(define-cproc caddr (obj)   "SCM_RETURN(Scm_Caddr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, dd);"))
(define-cproc cdaar (obj)   "SCM_RETURN(Scm_Cdaar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, aa);"))
(define-cproc cdadr (obj)   "SCM_RETURN(Scm_Cdadr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, ad);"))
(define-cproc cddar (obj)   "SCM_RETURN(Scm_Cddar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, da);"))
(define-cproc cdddr (obj)   "SCM_RETURN(Scm_Cdddr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, dd);"))
(define-cproc caaaar (obj)  "SCM_RETURN(Scm_Caaaar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, aaa);"))
(define-cproc caaadr (obj)  "SCM_RETURN(Scm_Caaadr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, aad);"))
(define-cproc caadar (obj)  "SCM_RETURN(Scm_Caadar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, ada);"))
(define-cproc caaddr (obj)  "SCM_RETURN(Scm_Caaddr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, add);"))
(define-cproc cadaar (obj)  "SCM_RETURN(Scm_Cadaar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, daa);"))
(define-cproc cadadr (obj)  "SCM_RETURN(Scm_Cadadr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, dad);"))
(define-cproc caddar (obj)  "SCM_RETURN(Scm_Caddar(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, dda);"))
(define-cproc cadddr (obj)  "SCM_RETURN(Scm_Cadddr(obj));"
  (setter (obj value)       "CXR_SETTER(A, a, ddd);"))
(define-cproc cdaaar (obj)  "SCM_RETURN(Scm_Cdaaar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, aaa);"))
(define-cproc cdaadr (obj)  "SCM_RETURN(Scm_Cdaadr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, aad);"))
(define-cproc cdadar (obj)  "SCM_RETURN(Scm_Cdadar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, ada);"))
(define-cproc cdaddr (obj)  "SCM_RETURN(Scm_Cdaddr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, add);"))
(define-cproc cddaar (obj)  "SCM_RETURN(Scm_Cddaar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, daa);"))
(define-cproc cddadr (obj)  "SCM_RETURN(Scm_Cddadr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, dad);"))
(define-cproc cdddar (obj)  "SCM_RETURN(Scm_Cdddar(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, dda);"))
(define-cproc cddddr (obj)  "SCM_RETURN(Scm_Cddddr(obj));"
  (setter (obj value)       "CXR_SETTER(D, d, ddd);"))

(define-cproc null? (obj)
  (inliner "SCM_VM_NULLP")
  (return <boolean> "SCM_NULLP"))

(define-cproc list? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Length(obj) >= 0));")

(define-cproc list (&rest args)
  (inliner "SCM_VM_LIST")
  ;; TODO: check to see if we don't need to copy args?
  "  SCM_RETURN(args);")

(define-cproc length (list)
  "  int i = Scm_Length(list);
  if (i < 0) Scm_Error(\"bad list: %S\", list);
  SCM_RETURN(Scm_MakeInteger(i));")

(define-cproc append (&rest lists)
  (inliner "SCM_VM_APPEND")
  (return "Scm_Append"))

(define-cproc reverse (list::<list>)
  (inliner "SCM_VM_REVERSE")
  (return "Scm_Reverse"))

(define-cproc list-tail (list k::<fixnum>)
  (return "Scm_ListTail"))

(define-cproc list-ref (list k::<fixnum> &optional fallback)
  (return "Scm_ListRef"))

(define-cproc memq (obj list::<list>)
  (inliner "SCM_VM_MEMQ")
  (return "Scm_Memq"))

(define-cproc memv (obj list::<list>)
  (inliner "SCM_VM_MEMV")
  (return "Scm_Memv"))

(define-cproc member (obj list::<list>)
  "  SCM_RETURN(Scm_Member(obj, list, SCM_CMP_EQUAL));")

(define-cproc assq (obj alist::<list>)
  (inliner "SCM_VM_ASSQ")
  (return "Scm_Assq"))

(define-cproc assv (obj alist::<list>)
  (inliner "SCM_VM_ASSV")
  (return "Scm_Assv"))

(define-cproc assoc (obj alist::<list>)
  "  SCM_RETURN(Scm_Assoc(obj, alist, SCM_CMP_EQUAL));")

;;
;; 6.3.3  Symbols
;;

(define-cproc symbol? (obj)
  (inliner "SCM_VM_SYMBOLP")
  (return <boolean> "SCM_SYMBOLP"))

(define-cproc symbol->string (obj::<symbol>)
  "  SCM_RETURN(SCM_OBJ(SCM_SYMBOL_NAME(obj)));")

(define-cproc string->symbol (obj::<string>)
  (return "Scm_Intern"))

;;
;; 6.3.4  Characters
;;

(define-cproc char? (obj)
  (inliner "SCM_VM_CHARP")
  (return <boolean> "SCM_CHARP"))

(define-cproc char=? (c1::<char> c2::<char>) (return <boolean> "SCM_EQ"))
(define-cproc char<? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 < c2));")
(define-cproc char>? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 > c2));")
(define-cproc char<=? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 <= c2));")
(define-cproc char>=? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 >= c2));")

(define-cproc char-ci=? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EQ(SCM_CHAR_UPCASE(c1),SCM_CHAR_UPCASE(c2))));")
(define-cproc char-ci<? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)<SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci<=? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)<=SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci>? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)>SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci>=? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)>=SCM_CHAR_UPCASE(c2)));")

(define-cproc char-alphabetic? (c::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isalpha(c)));")
(define-cproc char-numeric? (c::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isdigit(c)));")
(define-cproc char-whitespace? (c::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isspace(c)));")
(define-cproc char-upper-case? (c::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPPER_P(c)));")
(define-cproc char-lower-case? (c::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_LOWER_P(c)));")

(define-cproc char->integer (c::<char>)
  "  SCM_RETURN(SCM_MAKE_INT((signed long)c));")

(define-cproc integer->char (c::<int>)
  "  SCM_RETURN(SCM_MAKE_CHAR((ScmChar)c));")

(define-cproc char-upcase (c::<char>)
  "  SCM_RETURN(SCM_MAKE_CHAR(SCM_CHAR_UPCASE(c)));")

(define-cproc char-downcase (c::<char>)
  "  SCM_RETURN(SCM_MAKE_CHAR(SCM_CHAR_DOWNCASE(c)));")

;;
;; 6.3.5 Strings
;;

(define-cproc string? (obj)
  (inliner "SCM_VM_STRINGP")
  (return <boolean> "SCM_STRINGP"))

(define-cproc make-string (len::<fixnum> &optional (c::<char> #\ ))
  (return "Scm_MakeFillString"))

(define-cproc string (&rest chars)
  (return "Scm_ListToString"))

(define-cproc string-length (str::<string>)
  (return <fixnum> "SCM_STRING_LENGTH"))

(define-cproc string-ref (str::<string> k::<fixnum> &optional fallback)
  (setter string-set!)
  "if (k < 0 || k >= SCM_STRING_LENGTH(str)) {
    if (SCM_UNBOUNDP(fallback)) {
      Scm_Error(\"index out of bounds: %d\", k);
    } else {
      SCM_RETURN(fallback);
    }
  }
  SCM_RETURN(SCM_MAKE_CHAR(Scm_StringRef(str, k)));")

(define-cproc string-set! (str::<string> k::<fixnum> c::<char>)
  "  ScmObj r = Scm_StringSet(str, k, c);
  if (r == SCM_FALSE) Scm_Error(\"argument out of range: %d\", k);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc string=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) == 0));")
(define-cproc string<? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) < 0));")
(define-cproc string<=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) <= 0));")
(define-cproc string>? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) > 0));")
(define-cproc string>=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) >= 0));")

(define-cproc string-ci=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) == 0));")
(define-cproc string-ci<? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) < 0));")
(define-cproc string-ci<=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) <= 0));")
(define-cproc string-ci>? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) > 0));")
(define-cproc string-ci>=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) >= 0));")

(define-cproc substring (str::<string> start::<fixnum> end::<fixnum>)
  (return "Scm_Substring"))

(define-cproc string-append (&rest args)
  (return "Scm_StringAppend"))

(define-cproc string->list (str::<string> &optional start end)
  "  ScmObj xstr = Scm_MaybeSubstring(str, start, end);
  SCM_RETURN(Scm_StringToList(SCM_STRING(xstr)));")

(define-cproc list->string (list::<list>)
  (return "Scm_ListToString"))

(define-cproc string-copy (str::<string> &optional start end)
  "  ScmObj xstr = Scm_MaybeSubstring(str, start, end);
  SCM_RETURN(Scm_CopyString(SCM_STRING(xstr)));")

(define-cproc string-fill! (str::<string> c::<char> &optional start end)
  (return "Scm_StringFill"))

;;
;; 6.3.6  Vectors
;;

(define-cproc vector? (obj) (return <boolean> "SCM_VECTORP"))

(define-cproc make-vector (k::<fixnum> &optional fill)
  (return "Scm_MakeVector"))

(define-cproc vector (&rest args)
  (inliner "SCM_VM_VEC")
  (return "Scm_ListToVector"))

(define-cproc vector-length (vec::<vector>)
  (inliner "SCM_VM_VEC_LEN")
  (return <fixnum> "SCM_VECTOR_SIZE"))

(define-cproc vector-ref (vec::<vector> k::<fixnum> &optional fallback)
  (inliner (case-nargs (2 "SCM_VM_VEC_REF") (else #f)))
  (return "Scm_VectorRef")
  (setter vector-set!))

(define-cproc vector-set! (vec::<vector> k::<fixnum> obj)
  (inliner "SCM_VM_VEC_SET")
  (return <void> "Scm_VectorSet"))

(define-cproc vector->list (vec::<vector>
                            &optional (start::<fixnum> 0) (end::<fixnum> -1))
  (return "Scm_VectorToList"))

(define-cproc list->vector (list::<list>)
  (return "Scm_ListToVector"))

(define-cproc vector-fill! (vec::<vector> fill
                            &optional (start::<fixnum> 0) (end::<fixnum> -1))
  (return void "Scm_VectorFill"))

;;
;; 6.4  Control Features
;;

(define-cproc procedure? (obj) (return <boolean> "SCM_PROCEDUREP"))

(define-cproc apply (proc arg1 &rest args)
  (inliner "SCM_VM_APPLY")
  "  ScmObj head, tail, cp;
  if (SCM_NULLP(args)) return Scm_VMApply(proc, arg1);
  else {
    head = tail = Scm_Cons(arg1, SCM_NIL);
    SCM_FOR_EACH(cp, args) {
      if (SCM_NULLP(SCM_CDR(cp))) {
        SCM_APPEND(head, tail, SCM_CAR(cp));
        break;
      }
      if (!SCM_PAIRP(SCM_CDR(cp))) {
        Scm_Error(\"improper list not allowed: %S\", SCM_CDR(cp));
      }
      SCM_APPEND1(head, tail, SCM_CAR(cp));
    }
  }
  return Scm_VMApply(proc, head);")

(define-cproc map (proc::<procedure> args::<list> &rest moreargs)
  (return "Scm_Map"))

(define-cproc for-each (proc::<procedure> args::<list> &rest moreargs)
  (return "Scm_ForEach"))
          
(define-cproc force (p)
  (return "Scm_Force"))

(define-cproc call-with-current-continuation (proc)
  (return "Scm_VMCallCC"))

(define-cproc values (&rest args)
  (inliner "SCM_VM_VALUES")
  (return "Scm_Values"))

;; call-with-values - defined in gauche-init.scm

(define-cproc dynamic-wind (pre body post)
  (return "Scm_VMDynamicWind"))

(define-cproc eval (expr env)
  (return "Scm_VMEval"))

;; for now, just return a module.
(define-cproc null-environment (version::<fixnum>)
  "  if (version != 5) Scm_Error(\"unknown rNrs version: %d\", version);
  SCM_RETURN(SCM_OBJ(Scm_NullModule()));")
(define-cproc scheme-report-environment (version::<fixnum>)
  "  if (version != 5) Scm_Error(\"unknown rNrs version: %d\", version);
  SCM_RETURN(SCM_OBJ(Scm_SchemeModule()));")
(define-cproc interaction-environment ()
  "  SCM_RETURN(SCM_OBJ(Scm_UserModule()));")

;;
;; 6.6.1  Ports
;;
  
;; valid keywords for open-*-file options
(define-keyword error "key_error")
(define-keyword create "key_create")
(define-keyword append "key_append")
(define-keyword supersede "key_supersede")
(define-keyword character "key_character")
(define-keyword binary "key_binary")

(define-cproc input-port? (obj)  (return <boolean> "SCM_IPORTP"))
(define-cproc output-port? (obj) (return <boolean> "SCM_OPORTP"))
(define-cproc port? (obj)        (return <boolean> "SCM_PORTP"))

(define-cproc current-input-port ()
  "  SCM_RETURN(SCM_OBJ(SCM_CURIN));")

(define-cproc current-output-port ()
  "  SCM_RETURN(SCM_OBJ(SCM_CUROUT));")

(define-cproc open-input-file (path::<string>
                               &keyword (if-does-not-exist (c "key_error"))
                                        (buffering #f)
                                        (element-type (c "key_character"))
                               )
  "  ScmObj o; int ignerr = FALSE, bufmode;
  if (SCM_FALSEP(if_does_not_exist)) ignerr = TRUE;
  else if (!SCM_EQ(if_does_not_exist, key_error)) {
    Scm_Error(\"argument for :if-does-not-exist must be either :error or #f, but got %S\", if_does_not_exist);
  }
  bufmode = Scm_BufferingMode(buffering, SCM_PORT_INPUT, SCM_PORT_BUFFER_FULL);
  o = Scm_OpenFilePort(Scm_GetStringConst(path), O_RDONLY, bufmode, 0);
  if (o == SCM_FALSE && !ignerr) {
     Scm_Error(\"couldn't open input file: %S\", path_scm);
  }
  SCM_RETURN(o);")

(define-cproc open-output-file (path::<string>
                                &keyword (if-exists (c "key_supersede"))
                                         (if-does-not-exist (c "key_create"))
                                         (mode::<fixnum> #o666)
                                         (buffering #f)
                                         (element-type (c "key_character"))
                                         )
  "  ScmObj o;
  int ignerr = FALSE, bufmode, flags = O_WRONLY;

  if (SCM_EQ(if_exists, key_append)) flags |= O_APPEND;
  else if (SCM_EQ(if_exists, key_error)) {
    flags |= O_EXCL;
    if (SCM_EQ(if_does_not_exist, key_error)) {
      Scm_Error(\"bad flag combination: :if-exists and :if-does-not-exist can't be :error the same time.\");
    }
  }
  else if (SCM_EQ(if_exists, key_supersede)) flags |= O_TRUNC;
  else if (SCM_FALSEP(if_exists)) { flags |= O_EXCL; ignerr = TRUE; }
  else {
    Scm_Error(\"argument for :if-exists must be either :supersede, :append, :error or #f, but got %S\", if_exists);
  }

  if (SCM_EQ(if_does_not_exist, key_create)) flags |= O_CREAT;
  else if (SCM_FALSEP(if_does_not_exist)) ignerr = TRUE;
  else if (!SCM_EQ(if_does_not_exist, key_error)) {
    Scm_Error(\"argument for :if-does-not-exist must be either :error, :create or #f, but got %S\", if_does_not_exist);
  }

  bufmode = Scm_BufferingMode(buffering, SCM_PORT_OUTPUT, SCM_PORT_BUFFER_FULL);
  o = Scm_OpenFilePort(Scm_GetStringConst(path), flags, bufmode, mode);
  if (!ignerr && o == SCM_FALSE) {
     Scm_Error(\"couldn't open output file: %S\", path_scm);
  }
  SCM_RETURN(o);")

(define-cproc close-input-port (port::<port>)
  (return <void> "Scm_ClosePort"))

(define-cproc close-output-port (port::<port>)
  (return <void> "Scm_ClosePort"))

;;
;; 6.6.2  Input
;;

(define-cproc read (&optional (port::<input-port> (current-input-port)))
  "  SCM_RETURN(Scm_Read(SCM_OBJ(port)));")

(define-cproc read-char (&optional (port::<input-port> (current-input-port)))
  (inliner "SCM_VM_READ_CHAR")
  "  int ch = EOF;
  SCM_GETC(ch, port);
  if (ch == EOF) SCM_RETURN(SCM_EOF);
  else SCM_RETURN(SCM_MAKE_CHAR(ch));")

(define-cproc peek-char (&optional (port::<input-port> (current-input-port)))
  "  ScmChar ch; ScmObj r;
  if ((ch = SCM_PORT_UNGOTTEN(port)) == SCM_CHAR_INVALID) {
    SCM_GETC(ch, port);
    SCM_PORT_UNGOTTEN(port) = ch;
  }
  r = (ch == SCM_CHAR_INVALID)? SCM_EOF : SCM_MAKE_CHAR(ch);
  SCM_RETURN(r);")

(define-cproc eof-object? (obj)
  (inliner "SCM_VM_EOFP")
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EOFP(obj)));")

(define-cproc char-ready? (port::<input-port>)
  (return <boolean> "Scm_CharReady"))

;;
;; 6.6.3  Output
;;

(define-cproc write (obj &optional (port::<output-port> (current-output-port)))
  "Scm_Write(obj, SCM_OBJ(port), SCM_WRITE_WRITE);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc display (obj &optional (port::<output-port> (current-output-port)))
  "Scm_Write(obj, SCM_OBJ(port), SCM_WRITE_DISPLAY);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc newline (&optional (port::<output-port> (current-output-port)))
  "  SCM_PUTC('\\n', port); SCM_RETURN(SCM_UNDEFINED);")

(define-cproc write-char (ch::<char>
                          &optional (port::<output-port> (current-output-port)))
  (inliner "SCM_VM_WRITE_CHAR")
  "  SCM_PUTC(ch, port); SCM_RETURN(SCM_UNDEFINED);")

;;
;; 6.6.4  System Interface
;;

; load : defined in load.c
; transcript-on
; transcript-off

;; Local variables:
;; mode: scheme
;; end:
