;;;
;;; extlib.stub - extra built-ins
;;;
;;;   Copyright (c) 2000-2002 Shiro Kawai (shiro@acm.org)
;;;
;;;   Permission to use, copy, modify, distribute this software and
;;;   accompanying documentation for any purpose is hereby granted,
;;;   provided that existing copyright notices are retained in all
;;;   copies and that this notice is included verbatim in all
;;;   distributions.
;;;   This software is provided as is, without express or implied
;;;   warranty.  In no circumstances the author(s) shall be liable
;;;   for any damages arising out of the use of this software.
;;;
;;; $Id: extlib.stub,v 1.160 2002-06-25 06:28:04 shirok Exp $
;;;

"
#include <gauche/arch.h>
"

;;
;; Macros
;;

(define-cproc macroexpand (form)
  "SCM_RETURN(Scm_MacroExpand(form, SCM_NIL, FALSE));")
(define-cproc macroexpand-1 (form)
  "SCM_RETURN(Scm_MacroExpand(form, SCM_NIL, TRUE));")

;;
;; 6.1  Equivalence predicates
;;

;; to pass the cmpmode argument
(define-symbol eq?    "sym_eq")
(define-symbol eqv?   "sym_eqv")
(define-symbol equal? "sym_equal")

(define-symbol string=? "sym_string_eq") ; used for make-hash-table

"static int getcmpmode(ScmObj opt)
 { if (SCM_UNBOUNDP(opt) || opt == sym_equal) return SCM_CMP_EQUAL;
   if (opt == sym_eq) return SCM_CMP_EQ;
   if (opt == sym_eqv) return SCM_CMP_EQV;
   Scm_Error(\"unrecognized compare mode: %S\", opt);
   return 0; /* dummy */ }"

;;
;; 6.2  Numbers
;;

(define-cproc ash (num cnt)
  (assert (small-integer? cnt))
  "  SCM_RETURN(Scm_Ash(num, cnt));")
(define-cproc lognot (x)
  "  SCM_RETURN(Scm_LogNot(x));")
(define-cproc logand (x y &rest args)
  "  ScmObj cp, r = Scm_LogAnd(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogAnd(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")
(define-cproc logior (x y &rest args)
  "  ScmObj cp, r = Scm_LogIor(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogIor(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")
(define-cproc logxor (x y &rest args)
  "  ScmObj cp, r = Scm_LogXor(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogXor(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")

(define-cproc clamp (x &optional (min #f) (max #f))
  " ScmObj r = x;  int maybe_exact = FALSE;
  if (SCM_EXACTP(x)) maybe_exact = TRUE;
  else if (!SCM_FLONUMP(x)) {
    Scm_Error(\"real number required for x, but got %S\", x);
  }
  if (SCM_EXACTP(min)) {
    if (Scm_NumCmp(x, min) < 0) r = min;
  } else if (SCM_FLONUMP(min)) {
    maybe_exact = FALSE;
    if (Scm_NumCmp(x, min) < 0) r = min;
  } else if (!SCM_FALSEP(min)) {
    Scm_Error(\"real number or #f required for min, but got %S\", min);
  }
  if (SCM_EXACTP(max)) {
    if (Scm_NumCmp(x, max) > 0) r = max;
  } else if (SCM_FLONUMP(max)) {
     maybe_exact = FALSE;
    if (Scm_NumCmp(x, max) > 0) r = max;
  } else if (!SCM_FALSEP(max)) {
    Scm_Error(\"real number or #f required for max, but got %S\", max);
  }
  if (!maybe_exact && SCM_EXACTP(r)) SCM_RETURN(Scm_ExactToInexact(r));
  else SCM_RETURN(r);")

(define-cproc decode-float (num)        ;from ChezScheme
  "if (SCM_FLONUMP(num)) {
     int exp, sign;
     ScmObj f = Scm_DecodeFlonum(SCM_FLONUM_VALUE(num), &exp, &sign);
     ScmObj v = Scm_MakeVector(3, SCM_FALSE);
     SCM_VECTOR_ELEMENT(v, 0) = f;
     SCM_VECTOR_ELEMENT(v, 1) = Scm_MakeInteger(exp);
     SCM_VECTOR_ELEMENT(v, 2) = Scm_MakeInteger(sign);
     SCM_RETURN(v);
  } else if (SCM_INTP(num)) {
     ScmObj v = Scm_MakeVector(3, SCM_FALSE);
     SCM_VECTOR_ELEMENT(v, 0) = Scm_Abs(num);
     SCM_VECTOR_ELEMENT(v, 1) = Scm_MakeInteger(0);
     SCM_VECTOR_ELEMENT(v, 2) = Scm_MakeInteger(Scm_Sign(num));
     SCM_RETURN(v);
  } else {
     Scm_Error(\"real number required, but got %S\", num);
     SCM_RETURN(SCM_UNDEFINED);
  }")

;; just for debug...
(if "SCM_DEBUG_HELPER"
(define-cproc %bignum-dump (obj)
  "  if (SCM_BIGNUMP(obj)) Scm_DumpBignum(SCM_BIGNUM(obj), SCM_CUROUT);
  SCM_RETURN(SCM_UNDEFINED);")
)

(define-cproc min&max (arg0 &rest args)
  "ScmObj min, max;
   Scm_MinMax(arg0, args, &min, &max);
   SCM_RETURN(Scm_Values2(min, max));")

(define-cproc quotient&remainder (n1 n2)
  "ScmObj q, r;
   q = Scm_Quotient(n1, n2, &r);
   SCM_RETURN(Scm_Values2(q, r));")

;;
;; 6.3.1  Booleans
;;

;;
;; 6.3.2  Pairs and lists
;;

(define-cproc make-list (len &optional (fill #f)) ; SRFI-1
  (assert (small-integer? len))
  "  SCM_RETURN(Scm_MakeList(len, fill));")

(define-cproc acons (caa cda cd)
  "  SCM_RETURN(Scm_Acons(caa, cda, cd));")

(define-cproc last-pair (list)          ; SRFI-1
  (assert (pair? list))
  "  SCM_RETURN(Scm_LastPair(list));")

(define-cproc list-copy (list)          ; SRFI-1
  "  SCM_RETURN(Scm_CopyList(list));")

(define-cproc list* (&rest args)
  (inliner "SCM_VM_LIST_STAR")
  "  ScmObj head = SCM_NIL, tail = SCM_NIL, cp;
  if (SCM_PAIRP(args)) {
    SCM_FOR_EACH(cp, args) {
      if (!SCM_PAIRP(SCM_CDR(cp))) {
        if (SCM_NULLP(head)) head = SCM_CAR(cp);
        else SCM_SET_CDR(tail, SCM_CAR(cp));
        break;
      }
      SCM_APPEND1(head, tail, SCM_CAR(cp));
    }
  }
  SCM_RETURN(head);")

(define-cproc %delete (obj list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_Delete(obj, list, getcmpmode(cmpmode)));")

(define-cproc %delete! (obj list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_DeleteX(obj, list, getcmpmode(cmpmode)));")

(define-cproc %delete-duplicates (list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_DeleteDuplicates(list, getcmpmode(cmpmode)));")

(define-cproc %delete-duplicates! (list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_DeleteDuplicatesX(list, getcmpmode(cmpmode)));")

(define-cproc %alist-delete (elt list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_AssocDelete(elt, list, getcmpmode(cmpmode)));")

(define-cproc %alist-delete! (elt list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_AssocDeleteX(elt, list, getcmpmode(cmpmode)));")

;; SRFI-1 has this.
;(define-cproc union (&rest args)        ;use eq? to compare.
;  (assert (list? args))
;  "  ScmObj set, ap;
;  if (SCM_NULLP(args)) SCM_RETURN(SCM_NIL);
;  set = SCM_CAR(args);
;  SCM_FOR_EACH(ap, SCM_CDR(args))
;    set = Scm_Union(set, SCM_CAR(ap));
;  SCM_RETURN(set);")

(define-cproc append! (&rest list)
  "  ScmObj cp, h = SCM_NIL, t = SCM_NIL;
  SCM_FOR_EACH(cp, list) SCM_APPEND(h, t, SCM_CAR(cp));
  SCM_RETURN(h);")

(define-cproc reverse! (list)
  "  SCM_RETURN(Scm_ReverseX(list));")

(define-cproc sort (list &optional (fn #f))
  "  SCM_RETURN(Scm_SortList(list, fn));")

(define-cproc sort! (list &optional (fn #f))
  "  SCM_RETURN(Scm_SortListX(list, fn));")

;(define-cproc topological-sort (edges)
;  (assert (list? edges))
;  "  SCM_RETURN(Scm_TopologicalSort(edges));")

;; TODO: this doesn't work properly.  Find the cause.
"
static ScmObj monotonic_merge_cb(ScmObj elt, void *data)
{
    ScmObj proc = SCM_OBJ(data);
    return Scm_Apply(proc, SCM_LIST1(elt));
}
"

(define-cproc monotonic-merge (start sequences get-super)
  (assert (list? sequences))
  (assert (procedure? get-super))
  "  SCM_RETURN(Scm_MonotonicMerge(start, sequences,
                                   monotonic_merge_cb, (void*)get_super));")

(define-cproc pair-attributes (pair)
  (assert (pair? pair))
  "  SCM_RETURN(SCM_PAIR_ATTR(pair));")

(define-cproc pair-attribute-get (pair key &optional fallback)
  (assert (pair? pair))
  "  SCM_RETURN(Scm_PairAttrGet(SCM_PAIR(pair), key, fallback));")

(define-cproc pair-attribute-set! (pair key value)
  (assert (pair? pair))
  "  SCM_RETURN(Scm_PairAttrSet(SCM_PAIR(pair), key, value));")

;;
;; 6.3.3  Symbols
;;

(define-cproc symbol-bound? (symbol &optional module)
  (assert (symbol? symbol))
  "  
  if (module == SCM_UNBOUND) {
     module = SCM_OBJ(SCM_CURRENT_MODULE());
  } else if (!SCM_MODULEP(module)) {
     Scm_Error(\"module required, but got %S\", module);
  }
  if (Scm_SymbolValue(SCM_MODULE(module), symbol) == SCM_UNBOUND)
     SCM_RETURN(SCM_FALSE);
  else
     SCM_RETURN(SCM_TRUE);")

(define-cproc gensym (&optional prefix)
  "  ScmString *p = NULL;
  if (prefix != SCM_UNBOUND) {
    if (!SCM_STRINGP(prefix))
      Scm_Error(\"string expected, but got %S\", prefix);
    p = SCM_STRING(prefix);
  }
  SCM_RETURN(Scm_Gensym(p));")

;; keywords
(define-cproc keyword? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_KEYWORDP(obj)));")

(define-cproc make-keyword (name)
  "   ScmString *sname = NULL;
  if (SCM_STRINGP(name)) sname = SCM_STRING(name);
  else if (SCM_SYMBOLP(name)) sname = SCM_SYMBOL_NAME(name);
  else Scm_Error(\"string or symbol required, but got %S\", name);
  SCM_RETURN(Scm_MakeKeyword(sname));")

(define-cproc get-keyword (key list &optional fallback)
  "  SCM_RETURN(Scm_GetKeyword(key, list, fallback));")

;; identifiers
(define-cproc identifier? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_IDENTIFIERP(obj)));")

(define-cproc identifier->symbol (obj)
  (assert (identifier? obj))
  "  SCM_RETURN(SCM_OBJ(SCM_IDENTIFIER(obj)->name));")

;;
;; 6.3.4  Characters
;;

(define-cproc digit->integer (ch &optional (radix 10))
  (assert (char? ch))
  (assert (small-integer? radix))
  "  int r;
  if (radix < 2 || radix > 36)
     Scm_Error(\"radix must be between 2 and 36, but got %d\", radix);
  r = Scm_DigitToInt(ch, radix);
  return (r >= 0 ? SCM_MAKE_INT(r) : SCM_FALSE);")

(define-cproc integer->digit (n &optional (radix 10))
  (assert (small-integer? radix))
  (assert (small-integer? n))
  "  ScmChar r;
  if (radix < 2 || radix > 36)
     Scm_Error(\"radix must be between 2 and 36, but got %d\", radix);
  r = Scm_IntToDigit(n, radix);
  return (r == SCM_CHAR_INVALID? SCM_FALSE : SCM_MAKE_CHAR(r));")

(define-cproc ucs->char (n)
  (assert (exact? n))
  "ScmChar ch = Scm_UcsToChar(n);
  if (ch == SCM_CHAR_INVALID) SCM_RETURN(SCM_FALSE);
  else SCM_RETURN(SCM_MAKE_CHAR(ch));")

(define-cproc char->ucs (c)
  (assert (char? c))
  "int ucs = Scm_CharToUcs(c);
  if (ucs < 0) SCM_RETURN(SCM_FALSE);
  else SCM_RETURN(Scm_MakeInteger(ucs));")

(define-cproc gauche-character-encoding ()
  "  SCM_RETURN(Scm_CharEncodingName());")

(define-cproc supported-character-encodings ()
  "  SCM_RETURN(Scm_ConstCStringArrayToList(Scm_SupportedCharacterEncodings(), -1));")

(define-cproc supported-character-encoding? (encoding)
  (assert (string? encoding))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_SupportedCharacterEncodingP(Scm_GetStringConst(encoding))));")

;; character sets (SRFI-14)
;;   not all of srfi-14 functions are defined in C.  you need to load
;;   srfi-14.scm to get a full set of functions.

(define-symbol *char-code-max* "char_code_max"
  "Scm_MakeInteger(SCM_CHAR_MAX)")

(define-cproc char-set? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHARSETP(obj)));")

"static void char_set_add(ScmCharSet *cs, ScmObj chars)
 {  ScmObj cp; ScmChar ch;
  SCM_FOR_EACH(cp, chars) {
    if (!SCM_CHARP(SCM_CAR(cp)))
      Scm_Error(\"character required, but got %S\", SCM_CAR(cp));
    ch = SCM_CHAR_VALUE(SCM_CAR(cp));
    Scm_CharSetAddRange(cs, ch, ch);
  }
 }"

(define-cproc %char-set-equal? (x y)
  (assert (char-set? x))
  (assert (char-set? y))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_CharSetEq(x, y)));")

(define-cproc char-set (&rest chars)
  "  ScmCharSet *cs = SCM_CHARSET(Scm_MakeEmptyCharSet());
  char_set_add(cs, chars);
  SCM_RETURN(SCM_OBJ(cs));")

(define-cproc char-set-copy (cs)
  (assert (char-set? cs))
  "  SCM_RETURN(Scm_CopyCharSet(cs));")

(define-cproc %char-set-add-chars! (cs chars)
  (assert (char-set? cs))
  (assert (list? chars))
  "  char_set_add(cs, chars); SCM_RETURN(SCM_OBJ(cs));")

(define-cproc %char-set-add-range! (cs from to)
  (assert (char-set? cs))
  "  long fromc = -1, toc = -1;
  if (SCM_EXACTP(from)) fromc = Scm_GetInteger(from);
  else if (SCM_CHARP(from)) fromc = SCM_CHAR_VALUE(from);
  if (fromc < 0) Scm_Error(\"character or positive integer required, but got %S\", from);
  if (fromc >= SCM_CHAR_MAX) Scm_Error(\"argument out of range: %S\", from);
  if (SCM_EXACTP(to)) toc = Scm_GetInteger(to);
  else if (SCM_CHARP(to)) toc = SCM_CHAR_VALUE(to);
  if (toc < 0) Scm_Error(\"character or positive integer required, but got %S\", to);
  if (toc >= SCM_CHAR_MAX) Scm_Error(\"argument out of range: %S\", to);
  SCM_RETURN(Scm_CharSetAddRange(cs, (ScmChar)fromc, (ScmChar)toc));")

(define-cproc %char-set-add! (dst src)
  (assert (char-set? dst))
  (assert (char-set? src))
  "  SCM_RETURN(Scm_CharSetAdd(dst, src));")

(define-cproc char-set-contains? (cs ch)
  (assert (char-set? cs))
  (assert (char? ch))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_CharSetContains(cs, ch)));")

(define-cproc %char-set-complement! (cs)
  (assert (char-set? cs))
  "  SCM_RETURN(Scm_CharSetComplement(cs));")

(define-cproc %char-set-ranges (cs)
  (assert (char-set? cs))
  "  SCM_RETURN(Scm_CharSetRanges(cs));")

(define-cproc %char-set-predefined (num)
  (assert (small-integer? num))
  "  SCM_RETURN(Scm_GetStandardCharSet(num));")

;; for debug
(if "SCM_DEBUG_HELPER"
(define-cproc %char-set-dump (cs)
  (assert (char-set? cs))
  "  Scm_CharSetDump(cs, SCM_CUROUT); SCM_RETURN(SCM_UNDEFINED);")
)

;;
;; 6.3.5 Strings
;;

(define-cproc string-incomplete? (obj)    ;gauche specific
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRINGP(obj)&&SCM_STRING_INCOMPLETE_P(obj)));")
(define-cproc string-immutable? (obj)   ;gauche specific
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRINGP(obj)&&SCM_STRING_IMMUTABLE_P(obj)));")

(define-cproc string-complete->incomplete! (str) ;gauche specific
  (assert (string? str))
  "  SCM_RETURN(Scm_StringCompleteToIncompleteX(str));")
(define-cproc string-incomplete->complete! (str) ;gauche specific
  (assert (string? str))
  "  SCM_RETURN(Scm_StringIncompleteToCompleteX(str));")
(define-cproc string-complete->incomplete (str) ;gauche specific
  (assert (string? str))
  "  SCM_RETURN(Scm_StringCompleteToIncomplete(str));")
(define-cproc string-incomplete->complete (str) ;gauche specific
  (assert (string? str))
  "  SCM_RETURN(Scm_StringIncompleteToComplete(str));")

(define-cproc string-size (str)         ;gauche specific
  (assert (string? str))
  "  SCM_RETURN(SCM_MAKE_INT(SCM_STRING_SIZE(str)));")

(define-cproc string-byte-ref (str k &optional fallback)   ;gauche specific
  (assert (string? str))
  (assert (small-integer? k))
  "  int r;
  if (!SCM_UNBOUNDP(fallback) && (k < 0 || k >= SCM_STRING_SIZE(str))) {
    SCM_RETURN(fallback);
  } else {
    r = Scm_StringByteRef(str, k);
    SCM_RETURN(SCM_MAKE_INT(r));
  }")

(define-cproc string-byte-set! (str k b) ;gauche specific
  (assert (string? str))
  (assert (small-integer? k))
  (assert (small-integer? b))
  "  SCM_RETURN(Scm_StringByteSet(str, k, b));")

(define-cproc string-substitute! (target start str)
  (assert (string? target))
  (assert (string? str))
  (assert (small-integer? start))
  "  ScmObj r = Scm_StringSubstitute(target, start, str);
  if (!SCM_STRINGP(r)) Scm_Error(\"argument out of range: (%d %S)\", start, str);
  SCM_RETURN(r);")

(define-cproc %maybe-substring (str &optional start end)
  (assert (string? str))
  "  SCM_RETURN(Scm_MaybeSubstring(str, start, end));")

(define-symbol infix "sym_infix")
(define-symbol strict-infix "sym_strict_infix")
(define-symbol suffix "sym_suffix")
(define-symbol prefix "sym_prefix")

(define-cproc string-join (strs &optional (delim " ") grammer)
  (assert (list? strs))
  (assert (string? delim))
  "  int gm = 0;
  if (SCM_UNBOUNDP(grammer) || SCM_UNDEFINEDP(grammer) || grammer == sym_infix)
    gm = SCM_STRING_JOIN_INFIX;
  else if (grammer == sym_strict_infix)
    gm = SCM_STRING_JOIN_STRICT_INFIX;
  else if (grammer == sym_suffix)
    gm = SCM_STRING_JOIN_SUFFIX;
  else if (grammer == sym_prefix)
    gm = SCM_STRING_JOIN_PREFIX;
  else Scm_Error(\"invalid grammer specification: %S\", grammer);
  SCM_RETURN(Scm_StringJoin(strs, delim, gm));")

(define-cproc %hash-string (str bound) ; for SRFI-13
  (assert (string? str))
  "  unsigned long modulo = 0;
  if (SCM_UNDEFINEDP(bound)) modulo = SCM_SMALL_INT_MAX;
  else if (SCM_INTP(bound)) modulo = SCM_INT_VALUE(bound);
  else if (SCM_BIGNUMP(bound)) modulo = Scm_BignumToUI(SCM_BIGNUM(bound));
  if (modulo == 0) Scm_Error(\"argument out of domain: %S\", bound);
  SCM_RETURN(Scm_MakeInteger(Scm_HashString(str, modulo)));")

;; TODO: allow string/charset/regexp in ch
(define-cproc string-split (s ch)
  (assert (string? s))
  (assert (char? ch))
  "  SCM_RETURN(Scm_StringSplitByChar(s, ch));")

;; primitive scanner
(define-symbol index   "sym_index")
(define-symbol before  "sym_before")
(define-symbol after   "sym_after")
(define-symbol before* "sym_before2")
(define-symbol after*  "sym_after2")
(define-symbol both    "sym_both")

(define-cproc string-scan (s1 s2 &optional (mode (c "sym_index")))
  (assert (string? s1))
  "  int retmode = 0;
  if (mode == sym_index)         retmode = SCM_STRING_SCAN_INDEX;
  else if (mode == sym_before)   retmode = SCM_STRING_SCAN_BEFORE;
  else if (mode == sym_after)    retmode = SCM_STRING_SCAN_AFTER;
  else if (mode == sym_before2)  retmode = SCM_STRING_SCAN_BEFORE2;
  else if (mode == sym_after2)   retmode = SCM_STRING_SCAN_AFTER2;
  else if (mode == sym_both)     retmode = SCM_STRING_SCAN_BOTH;
  else {
    Scm_Error(\"bad value in mode argumet: %S, must be one of 'index, 'before, 'after, 'before*, 'after* or 'both.\", mode);
  }
  if (SCM_STRINGP(s2)) {
     SCM_RETURN(Scm_StringScan(s1, SCM_STRING(s2), retmode));
  } else if (SCM_CHARP(s2)) {
     SCM_RETURN(Scm_StringScanChar(s1, SCM_CHAR_VALUE(s2), retmode));
  } else {
     Scm_Error(\"bad type of argument for s2: %S, must be either string or character\", s2);
     SCM_RETURN(SCM_UNDEFINED); /* dummy */
  }")
  

;; string pointer
(define-type "string-pointer" string-pointer?
  "ScmStringPointer*" "SCM_STRING_POINTERP" "SCM_STRING_POINTER")

(define-cproc make-string-pointer (str &optional (index 0) (start 0) (end -1))
  (assert (string? str))
  (assert (small-integer? index))
  (assert (small-integer? start))
  (assert (small-integer? end))
  "  SCM_RETURN(Scm_MakeStringPointer(str, index, start, end));")
(define-cproc string-pointer? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRING_POINTERP(obj)));")

(define-cproc string-pointer-next! (sp)
  (assert (string-pointer? sp))
  "  SCM_RETURN(Scm_StringPointerNext(sp));")
(define-cproc string-pointer-prev! (sp)
  (assert (string-pointer? sp))
  "  SCM_RETURN(Scm_StringPointerPrev(sp));")
(define-cproc string-pointer-set! (sp index)
  (assert (string-pointer? sp))
  (assert (small-integer? index))
  "  SCM_RETURN(Scm_StringPointerSet(sp, index));")
(define-cproc string-pointer-substring (sp &keyword (after #f))
  (assert (string-pointer? sp))
  "  SCM_RETURN(Scm_StringPointerSubstring(sp, !SCM_FALSEP(after)));")
(define-cproc string-pointer-index (sp)
  (assert (string-pointer? sp))
  "  SCM_RETURN(Scm_MakeInteger(sp->index));")

;; Regexp
(define-cproc string->regexp (str)
  (assert (string? str))
  "  SCM_RETURN(Scm_RegComp(str));")

(define-cproc rxmatch (regexp str)
  (assert (string? str))
  "  ScmRegexp *rx = NULL;
  if (SCM_STRINGP(regexp)) rx = SCM_REGEXP(Scm_RegComp(SCM_STRING(regexp)));
  else if (SCM_REGEXPP(regexp)) rx = SCM_REGEXP(regexp);
  else Scm_Error(\"regexp required, but got %S\", regexp);
  SCM_RETURN(Scm_RegExec(rx, str));")

(define-cproc rxmatch-substring (match &optional (i 0))
  (assert (small-integer? i))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchSubstr(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-start (match &optional (i 0))
  (assert (small-integer? i))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchStart(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-end (match &optional (i 0))
  (assert (small-integer? i))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchEnd(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-before (match &optional (i 0))
  (assert (small-integer? i))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchBefore(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-after (match &optional (i 0))
  (assert (small-integer? i))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchAfter(SCM_REGMATCH(match), i));")

;; for debug
(if "SCM_DEBUG_HELPER"
(define-cproc %regexp-dump (rx)
  "  if (!SCM_REGEXPP(rx)) Scm_Error(\"regexp required, but got %S\", rx);
  Scm_RegDump(SCM_REGEXP(rx));  SCM_RETURN(SCM_UNDEFINED);")
)

(if "SCM_DEBUG_HELPER"
(define-cproc %regmatch-dump (rm)
  "  if (!SCM_REGMATCHP(rm)) Scm_Error(\"regmatch required, but got %S\", rm);
  Scm_RegMatchDump(SCM_REGMATCH(rm));  SCM_RETURN(SCM_UNDEFINED);")
)

;;
;; 6.3.6  Vectors
;;

(define-cproc vector-copy (v &optional (start 0) (end -1))
  (assert (vector? v))
  (assert (small-integer? start))
  (assert (small-integer? end))
  "SCM_RETURN(Scm_VectorCopy(v, start, end));")

;; weak vector
(define-cproc make-weak-vector (size)
  (assert (small-integer? size))
  "SCM_RETURN(Scm_MakeWeakVector(size));")

(define-cproc weak-vector-length (wv)
  (assert (weak-vector? wv))
  "SCM_RETURN(Scm_MakeInteger(wv->size));")

(define-cproc weak-vector-ref (wv index &optional fallback)
  (assert (weak-vector? wv))
  (assert (small-integer? index))
  "SCM_RETURN(Scm_WeakVectorRef(wv, index, fallback));")
  
(define-cproc weak-vector-set! (wv index val)
  (assert (weak-vector? wv))
  (assert (small-integer? index))
  "SCM_RETURN(Scm_WeakVectorSet(wv, index, val));")
  

;;
;; 6.4  Control Features
;;

(define-cproc setter (proc)             ;SRFI-17
  (assert (procedure? proc))
  (inliner "SCM_VM_SETTER")
  "  SCM_RETURN(Scm_Setter(proc));"
  (setter (proc setter)
    (assert (procedure? proc))
    (assert (procedure? setter))
    "  Scm_SetterSet(proc, setter, FALSE); SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc identity (val)            ;sometimes useful
  "SCM_RETURN(val);")

;;
;; 6.6.1  Ports
;;

;; String port
(define-cproc open-input-string (string) ;SRFI-6
  (assert (string? string))
  "  SCM_RETURN(Scm_MakeInputStringPort(string));")

(define-cproc open-output-string ()      ;SRFI-6
  "  SCM_RETURN(Scm_MakeOutputStringPort());")

(define-cproc get-output-string (oport) ;SRFI-6
  (assert (output-port? oport))
  "  if (SCM_PORT_TYPE(oport) != SCM_PORT_OSTR)
        Scm_Error(\"output string port required, but got: %S\", oport);
  SCM_RETURN(Scm_GetOutputString(oport));")

;; Buffered port
;; NB: the interface may be changed soon!!
"static int bufport_closer(ScmPort *p)
 {
    if (SCM_PORT_DIR(p) == SCM_PORT_OUTPUT) {
       ScmObj scmflusher = SCM_OBJ(p->src.buf.data);
       int siz = (int)(p->src.buf.current - p->src.buf.buffer);
       if (siz > 0) Scm_Apply(scmflusher, SCM_LIST1(Scm_MakeString(p->src.buf.buffer, siz, siz, SCM_MAKSTR_INCOMPLETE|SCM_MAKSTR_COPYING)));
       Scm_Apply(scmflusher, SCM_LIST1(SCM_FALSE));
    }
    return 0;
 }"

"static int bufport_filler(ScmPort *p, int cnt)
 {
    ScmObj scmfiller, r;  int siz;
    scmfiller = SCM_OBJ(p->src.buf.data);
    /* no need to use VMApply; we're in the C callback */
    r = Scm_Apply(scmfiller, SCM_LIST1(Scm_MakeInteger(cnt)));
    if (SCM_EOFP(r) || SCM_FALSEP(r)) {
       return 0;
    } else if (!SCM_STRINGP(r)) {
       Scm_Error(\"buffered port callback procedure returned non-string: %S\", r);
    }
    siz = SCM_STRING_SIZE(r);
    if (siz > cnt) siz = cnt; /* for safety */
    memcpy(p->src.buf.end, SCM_STRING_START(r), siz);
    return SCM_STRING_SIZE(r);
 }"

(define-cproc open-input-buffered-port (filler buffer-size)
  (assert (procedure? filler))
  (assert (small-integer? buffer-size))
  "  ScmPortBuffer bufrec;
  bufrec.size = buffer_size;
  bufrec.buffer = NULL;
  bufrec.mode = SCM_PORT_BUFFER_FULL;
  bufrec.filler = bufport_filler;
  bufrec.flusher = NULL;
  bufrec.closer = bufport_closer;
  bufrec.ready = NULL;
  bufrec.filenum = NULL;
  bufrec.data = (void*)filler;
  SCM_RETURN(Scm_MakeBufferedPort(SCM_FALSE, SCM_PORT_INPUT, TRUE, &bufrec));
  ")

"static int bufport_flusher(ScmPort *p, int cnt)
 {
     ScmObj scmflusher, s;
     scmflusher = SCM_OBJ(p->src.buf.data);
     s = Scm_MakeString(p->src.buf.buffer, cnt, cnt, SCM_MAKSTR_INCOMPLETE|SCM_MAKSTR_COPYING);
     Scm_Apply(scmflusher, SCM_LIST1(s));
     return cnt;
 }"

(define-cproc open-output-buffered-port (flusher buffer-size)
  (assert (procedure? flusher))
  (assert (small-integer? buffer-size))
  "  ScmPortBuffer bufrec;
  bufrec.size = buffer_size;
  bufrec.buffer = NULL;
  bufrec.mode = SCM_PORT_BUFFER_FULL;
  bufrec.filler = NULL;
  bufrec.flusher = bufport_flusher;
  bufrec.closer = bufport_closer;
  bufrec.ready = NULL;
  bufrec.filenum = NULL;
  bufrec.data = (void*)flusher;
  SCM_RETURN(Scm_MakeBufferedPort(SCM_FALSE, SCM_PORT_OUTPUT, TRUE, &bufrec));
  ")

(define-cproc flush (&optional (oport (current-output-port)))
  (assert (output-port? oport))
  "  Scm_Flush(oport); SCM_RETURN(SCM_UNDEFINED);")

(define-cproc flush-all-ports ()
  "  Scm_FlushAllPorts(FALSE); SCM_RETURN(SCM_UNDEFINED);")

(define-cproc port-closed? (obj)
  (assert (port? obj))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_PORT_CLOSED_P(obj)));")

(define-cproc current-error-port ()     ;gauche extention
  "  SCM_RETURN(SCM_OBJ(SCM_CURERR));")

(define-cproc standard-input-port ()
  "  SCM_RETURN(Scm_Stdin());")

(define-cproc standard-output-port ()
  "  SCM_RETURN(Scm_Stdout());")

(define-cproc standard-error-port ()
  "  SCM_RETURN(Scm_Stderr());")

(define-cproc with-input-from-port (port thunk)
  (assert (input-port? port))
  (assert (procedure? thunk))
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CURIN, FALSE));")

(define-cproc with-output-to-port (port thunk)
  (assert (output-port? port))
  (assert (procedure? thunk))
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CUROUT, FALSE));")

(define-cproc with-error-to-port (port thunk)
  (assert (output-port? port))
  (assert (procedure? thunk))
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CURERR, FALSE));")

(define-cproc port-name (port)
  (assert (port? port))
  "  SCM_RETURN(Scm_PortName(port));")

(define-cproc port-current-line (port)
  (assert (port? port))
  "  int i = Scm_PortLine(port);
  SCM_RETURN(Scm_MakeInteger(i));")

(define-cproc port-current-column (port)
  (assert (port? port))
  "  int i = Scm_PortPosition(port);
  SCM_RETURN(Scm_MakeInteger(i));")

(define-cproc port-file-number (port)
  (assert (port? port))
  "  int i = Scm_PortFileNo(port);
  SCM_RETURN((i < 0)? SCM_FALSE : Scm_MakeInteger(i));")

(define-symbol file "sym_file")
(define-symbol string "sym_string")
(define-symbol proc "sym_proc")
(define-cproc port-type (port)
  (assert (port? port))
  "ScmObj type = SCM_FALSE;
   switch (SCM_PORT_TYPE(port)) {
     case SCM_PORT_FILE: type = sym_file; break;
     case SCM_PORT_PROC: type = sym_proc; break;
     case SCM_PORT_OSTR:;
     case SCM_PORT_ISTR: type = sym_string; break;
   }
   SCM_RETURN(type);")

;; NB: these are also in stdlib.stub -- can we merge them?
(define-cproc port-buffering (port)
  (assert (port? port))
  "SCM_RETURN(Scm_GetBufferingMode(port));"
  (setter (port mode)
    (assert (port? port))
    "if (SCM_PORT_TYPE(port) != SCM_PORT_FILE) {
       Scm_Error(\"can't set buffering mode to non-buffered port: %S\", port);
     }
     port->src.buf.mode = Scm_BufferingMode(mode, port->direction, -1);
     SCM_RETURN(SCM_UNDEFINED);")
  )

;; Open port from fd
(define-cproc open-input-fd-port (fd &keyword (buffering #f)
                                              (owner? #f)
                                              (name #f))
  (assert (small-integer? fd))
  (assert (boolean? owner?))
  "int bufmode = Scm_BufferingMode(buffering, SCM_PORT_INPUT, SCM_PORT_BUFFER_FULL);
   if (fd < 0) Scm_Error(\"bad file descriptor: %d\", fd);
   return Scm_MakePortWithFd(name, SCM_PORT_INPUT, fd, bufmode, ownerP);")

(define-cproc open-output-fd-port (fd &keyword (buffering #f)
                                               (owner? #f)
                                               (name #f))
  (assert (small-integer? fd))
  (assert (boolean? owner?))
  "int bufmode = Scm_BufferingMode(buffering, SCM_PORT_OUTPUT, SCM_PORT_BUFFER_FULL);
   if (fd < 0) Scm_Error(\"bad file descriptor: %d\", fd);
   return Scm_MakePortWithFd(name, SCM_PORT_OUTPUT, fd, bufmode, ownerP);")

;; transfer units for copy-port
(define-symbol char "sym_char")
(define-symbol byte "sym_byte")
"#define COPY_PORT_BUFSIZ 1024"

(define-cproc copy-port (src dst &keyword (unit 0))
  (assert (input-port? src))
  (assert (output-port? dst))
  "  int ncopied = 0, bufsiz; char buf[COPY_PORT_BUFSIZ], *p = buf;
  if (SCM_SYMBOLP(unit)) {
    if (SCM_EQ(unit, sym_char)) {
      ScmChar c;
      for (;;) {
        SCM_GETC(c, src); if (c == EOF) break; SCM_PUTC(c, dst); ncopied++;
      }
    } else if (SCM_EQ(unit, sym_byte)) {
      int b;
      for (;;) {
        SCM_GETB(b, src); if (b == EOF) break; SCM_PUTB(b, dst); ncopied++;
      }
    } else {
      Scm_Error(\"unknown unit specification: %S\", unit);
    }
  } else if (!(SCM_INTP(unit) && (bufsiz = SCM_INT_VALUE(unit)) >= 0)) {
    Scm_Error(\"unit must be 'char, 'byte, or zero or positive integer: %S\", unit);
  } else {
    if (bufsiz == 0) bufsiz = COPY_PORT_BUFSIZ;
    else if (bufsiz > COPY_PORT_BUFSIZ) p = SCM_NEW_ATOMIC2(char*, bufsiz);
    for (;;) {
      int nread = Scm_Getz(p, bufsiz, src);
      if (nread <= 0) break;
      Scm_Putz(p, nread, dst);
      ncopied += nread;
    }
  }
  SCM_RETURN(SCM_MAKE_INT(ncopied));")

(define-cproc port->string (port)       ;scsh, stk
  (assert (input-port? port))
  "  ScmChar ch; ScmPort *out = SCM_PORT(Scm_MakeOutputStringPort());
  for (;;) {
    SCM_GETC(ch, port);
    if (ch == EOF) break;
    SCM_PUTC(ch, out);
  }
  SCM_RETURN(Scm_GetOutputString(out));")

(define-cproc port->byte-string (port)
  (assert (input-port? port))
  ;; TODO: use chunked I/O if appropriate
  " int b; ScmPort *out = SCM_PORT(Scm_MakeOutputStringPort());
  for (;;) {
    SCM_GETB(b, port);
    if (b == EOF) break;
    SCM_PUTB(b, out);
  }
  SCM_RETURN(Scm_GetOutputString(out));")

;;
;; 6.6.2  Input
;;

(define-cproc read-byte (&optional (port (current-input-port)))
  (assert (input-port? port))
  "  int b; SCM_GETB(b, port);
  SCM_RETURN((b < 0)? SCM_EOF : SCM_MAKE_INT(b));")

(define-cproc read-line (&optional (port (current-input-port)))
  (assert (input-port? port))
  "  SCM_RETURN(Scm_ReadLine(port));")

(define-cproc read-block (bytes &optional (port (current-input-port)))
  (assert (input-port? port))
  (assert (small-integer? bytes))
  "  char *buf; int nread;
  if (bytes <= 0) Scm_Error(\"bytes must be non-zero positive integer: %d\", bytes);
  buf = SCM_NEW_ATOMIC2(char*, bytes);
  nread = Scm_Getz(buf, bytes, port);
  if (nread <= 0) {
    SCM_RETURN(SCM_EOF);
  } else {
    SCM_RETURN(Scm_MakeString(buf, nread, nread, SCM_MAKSTR_INCOMPLETE));
  }")

(define-cproc read-list (closer &optional (port (current-input-port)))
  (assert (char? closer))
  "SCM_RETURN(Scm_ReadList(port, closer));")

(define-cproc define-reader-ctor (symbol proc)
  "  SCM_RETURN(Scm_DefineReaderCtor(symbol, proc));")

;;
;; 6.6.3  Output
;;

(define-cproc write-byte (byte &optional (port (current-output-port)))
  (assert (small-integer? byte))
  (assert (output-port? port))
  "  if (byte < 0 || byte > 255) Scm_Error(\"argument out of range: %d\", byte);
  SCM_PUTB(byte, port);
  SCM_RETURN(SCM_MAKE_INT(1));")

(define-cproc write-limited (obj limit &optional (port (current-output-port)))
  (assert (small-integer? limit))
  "  int n = Scm_WriteLimited(obj, port, SCM_WRITE_WRITE, limit);
  SCM_RETURN(SCM_MAKE_INT(n));")

(define-cproc write* (obj &optional (port (current-output-port)))
  "  int n = Scm_WriteCircular(obj, SCM_PORT(port), SCM_WRITE_WRITE, 0);
  SCM_RETURN(SCM_MAKE_INT(n));")

;;
;; 6.6.4  System Interface
;;

(define-cproc %add-load-path (path &optional (afterp #f))
  (assert (string? path))
  "  const char *cpath = Scm_GetStringConst(path);
  SCM_RETURN(Scm_AddLoadPath(cpath, !SCM_FALSEP(afterp)));")

(define-cproc dynamic-load (file &keyword
                                 (init-function #f)
                                 (export-symbols #f))
  (assert (string? file))
  "  SCM_RETURN(Scm_DynLoad(file, init_function, !SCM_FALSEP(export_symbols)));")

(define-cproc %require (feature)
  "  SCM_RETURN(Scm_Require(feature));")
(define-cproc provide (feature)
  "  SCM_RETURN(Scm_Provide(feature));")
(define-cproc provided? (feature)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_ProvidedP(feature)));")

(define-cproc %make-autoload (sym path &optional import-from)
  (assert (symbol? sym))
  (assert (string? path))
  "ScmSymbol *from = SCM_SYMBOLP(import_from)? SCM_SYMBOL(import_from) : NULL;
   SCM_RETURN(Scm_MakeAutoload(sym, path, from));")

(define-cproc undefined ()
  "  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc undefined? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_UNDEFINEDP(obj)));")

(define-cproc warn (fmt &rest args)
  (assert (string? fmt))
  "  Scm_FWarn(fmt, args); SCM_RETURN(SCM_UNDEFINED);")

;;
;; Hashtable
;;

;; TODO: support user-defined hashfn and cmpfn
(define-cproc make-hash-table (&optional (type (c "sym_eq")))
  (assert (symbol? type))
  "  ScmHashProc htype = 0;
  if (SCM_OBJ(type) == sym_eq)             htype = (ScmHashProc)SCM_HASH_ADDRESS;
  else if (SCM_OBJ(type) == sym_eqv)       htype = (ScmHashProc)SCM_HASH_EQV;
  else if (SCM_OBJ(type) == sym_equal)     htype = (ScmHashProc)SCM_HASH_EQUAL;
  else if (SCM_OBJ(type) == sym_string_eq) htype = (ScmHashProc)SCM_HASH_STRING;
  else {
    Scm_Error(\"unsupported hash type: %S\", type);
  }
  SCM_RETURN(Scm_MakeHashTable(htype, NULL, 0));")

(define-cproc hash-table? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_HASHTABLEP(obj)));")

(define-cproc hash-table-type (hash)
  (assert (hash-table? hash))
  "switch (hash->type) {
   case SCM_HASH_ADDRESS: SCM_RETURN(sym_eq);
   case SCM_HASH_EQV:     SCM_RETURN(sym_eqv);
   case SCM_HASH_EQUAL:   SCM_RETURN(sym_equal);
   case SCM_HASH_STRING:  SCM_RETURN(sym_string_eq);
   default: SCM_RETURN(SCM_FALSE);  /* TODO: need to think over */
  }")

(define-cproc hash-table-get (hash key &optional defval)
  (assert (hash-table? hash))
  "  ScmHashEntry *e = Scm_HashTableGet(hash, key);
  if (!e || e->value == SCM_UNBOUND) {
    if (defval != SCM_UNBOUND) SCM_RETURN(defval);
    else Scm_Error(\"hash table doesn't have an entry for key %S\", key);
  }
  SCM_RETURN(e->value);")

(define-cproc hash-table-put! (hash key value)
  (assert (hash-table? hash))
  "  Scm_HashTablePut(hash, key, value);
  SCM_RETURN(SCM_UNDEFINED);")

;; this is hash-table-remove! in STk.  I use `delete' for
;; it's consistent with SRFI-1 and dbm-delete!.
(define-cproc hash-table-delete! (hash key)
  (assert (hash-table? hash))
  "ScmHashEntry *e = Scm_HashTableDelete(hash, key);
  SCM_RETURN(SCM_MAKE_BOOL(e != NULL));")

(define-cproc hash-table-exists? (hash key)
  (assert (hash-table? hash))
  " if (Scm_HashTableGet(hash, key) != NULL) 
    SCM_RETURN(SCM_TRUE);
  else
    SCM_RETURN(SCM_FALSE);")

(define-cproc hash-table-push! (hash key value)
  (assert (hash-table? hash))
  "ScmHashEntry *e = Scm_HashTableAdd(hash, key, SCM_UNBOUND);
  if (SCM_UNBOUNDP(e->value)) e->value = SCM_LIST1(value);
  else                        e->value = Scm_Cons(value, e->value);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc hash-table-pop! (hash key &optional fallback)
  (assert (hash-table? hash))
  "ScmHashEntry *e = Scm_HashTableGet(hash, key); ScmObj r;
  if (e == NULL) {
    if (SCM_UNBOUNDP(fallback)) {
      Scm_Error(\"hash table doesn't have an entry for key %S\", key);
    }
    r = fallback;
  } else if (!SCM_PAIRP(e->value)) {
    if (SCM_UNBOUNDP(fallback)) {
      Scm_Error(\"hash table value for key %S is not a pair: %S\", key, e->value);
    }
    r = fallback;
  } else {
    r = SCM_CAR(e->value); e->value = SCM_CDR(e->value);
  }
  SCM_RETURN(r);")

"static ScmObj hash_table_iter(ScmObj *args, int nargs, void *data)
 {
   ScmHashIter *iter = (ScmHashIter*)data;
   ScmHashEntry *e = Scm_HashIterNext(iter);
   if (e == NULL) SCM_RETURN(Scm_Values2(SCM_EOF, SCM_EOF));
   else SCM_RETURN(Scm_Values2(e->key, e->value));
 }"

(define-cproc %hash-table-iter (hash)
  (assert (hash-table? hash))
  "ScmHashIter *iter = SCM_NEW(ScmHashIter);
  Scm_HashIterInit(hash, iter);
  SCM_RETURN(Scm_MakeSubr(hash_table_iter, iter, 0, 0, SCM_MAKE_STR(\"hash-table-iterator\")));")

(define-cproc hash-table-keys (hash)
  (assert (hash-table? hash))
  "  SCM_RETURN(Scm_HashTableKeys(hash));")

(define-cproc hash-table-values (hash)
  (assert (hash-table? hash))
  "  SCM_RETURN(Scm_HashTableValues(hash));")

(define-cproc hash-table-stat (hash)
  (assert (hash-table? hash))
  "  SCM_RETURN(Scm_HashTableStat(hash));")

;;
;; Modules
;;

(define-cproc module? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_MODULEP(obj)));")

(define-cproc module-name (mod)
  (assert (module? mod))
  "  SCM_RETURN(SCM_OBJ(SCM_MODULE(mod)->name));")

(define-cproc module-parent (mod)
  (assert (module? mod))
  "  SCM_RETURN(mod->parent? SCM_OBJ(mod->parent) : SCM_FALSE);")

(define-cproc module-imports (mod)
  (assert (module? mod))
  "  SCM_RETURN(mod->imported);")

(define-cproc module-exports (mod)
  (assert (module? mod))
  "  SCM_RETURN(mod->exported);")

(define-cproc module-table (mod)
  (assert (module? mod))
  "  SCM_RETURN(SCM_OBJ(mod->table));")

(define-cproc find-module (name)
  (assert (symbol? name))
  "  SCM_RETURN(Scm_FindModule(name, FALSE));")

(define-cproc all-modules ()
  "  SCM_RETURN(Scm_AllModules());")

(define-cproc %export-all ()
  "  SCM_RETURN(Scm_ExportAll(SCM_CURRENT_MODULE()));")

;;
;; Gauche extentions
;;

;; Utility procedure
(define-cproc format (port fmt &rest args)
  (assert (string? fmt))
  "  SCM_RETURN(Scm_Format(port, fmt, args));")

(define-cproc exit (&optional (code 0))
  (assert (small-integer? code))
  "  Scm_Exit(code);
  SCM_RETURN(SCM_UNDEFINED);")

;;
;; Inspecting feature
;;

;; Obtain info about gauche itself
(define-cproc gauche-version ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_VERSION));")
(define-cproc gauche-architecture ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_ARCH));")
(define-cproc gauche-library-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_LIB_DIR));")
(define-cproc gauche-architecture-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_ARCH_DIR));")
(define-cproc gauche-site-library-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_SITE_LIB_DIR));")
(define-cproc gauche-site-architecture-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_SITE_ARCH_DIR));")

;; GC stuff
(define-cproc gc ()
  "  GC_gcollect();  SCM_RETURN(SCM_UNDEFINED);")

(define-keyword total-heap-size "key_total_heap_size")
(define-keyword free-bytes      "key_free_bytes")
(define-keyword bytes-since-gc  "key_bytes_since_gc")
(define-keyword total-bytes     "key_total_bytes")

(define-cproc gc-stat ()
  "  ScmObj h = SCM_NIL, t = SCM_NIL;
  SCM_APPEND(h, t, SCM_LIST2(key_total_heap_size,
                             Scm_MakeIntegerFromUI(GC_get_heap_size())));
  SCM_APPEND(h, t, SCM_LIST2(key_free_bytes,
                             Scm_MakeIntegerFromUI(GC_get_free_bytes())));
  SCM_APPEND(h, t, SCM_LIST2(key_bytes_since_gc,
                             Scm_MakeIntegerFromUI(GC_get_bytes_since_gc())));
  SCM_APPEND(h, t, SCM_LIST2(key_total_bytes,
                             Scm_MakeIntegerFromUI(GC_get_total_bytes())));
  SCM_RETURN(h);")

;; Misc.  WARNING: API may change
(define-cproc closure-code (clo)
  (assert (closure? clo))
  "  SCM_RETURN(clo->code);")

(define-cproc procedure-info (proc)
  (assert (procedure? proc))
  "  SCM_RETURN(SCM_PROCEDURE_INFO(proc));")



;; Local variables:
;; mode: scheme
;; end:
