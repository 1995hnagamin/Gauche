;;;
;;; extlib.stub - extra built-ins
;;;  
;;;   Copyright (c) 2000-2008  Shiro Kawai  <shiro@acm.org>
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: extlib.stub,v 1.310 2008-06-09 17:51:16 shirok Exp $
;;;

"
#include <fcntl.h>
#include <gauche/arch.h>
#include <gauche/class.h>
#include <gauche/vminsn.h>
#include <gauche/regexp.h>
#include <gauche/bignum.h>
"

;;
;; Macros
;;

(define-cproc macroexpand (form)
  (expr <top> (Scm_VMMacroExpand form SCM_NIL FALSE)))
(define-cproc macroexpand-1 (form)
  (expr <top> (Scm_VMMacroExpand form SCM_NIL TRUE)))

;;
;; 6.1  Equivalence predicates
;;

;; to pass the cmpmode argument
(define-symbol eq?    "sym_eq")
(define-symbol eqv?   "sym_eqv")
(define-symbol equal? "sym_equal")

"static int getcmpmode(ScmObj opt)
 { if (SCM_UNBOUNDP(opt) || opt == sym_equal) return SCM_CMP_EQUAL;
   if (opt == sym_eq) return SCM_CMP_EQ;
   if (opt == sym_eqv) return SCM_CMP_EQV;
   Scm_Error(\"unrecognized compare mode: %S\", opt);
   return 0; /* dummy */ }"

(define-cproc compare (x y) (call <fixnum> "Scm_Compare"))

;;
;; 6.2  Numbers
;;

(define-cproc ash (num cnt::<fixnum>) (call "Scm_Ash"))

(define-cproc lognot (x) (call "Scm_LogNot"))

(define-cise-stmt logop
  [(_ fn)
   `(let* ((r (,fn x y)))
      (for-each (lambda (v) (set! r (,fn r v))) args)
      (result r))])

(define-cproc logand (x y &rest args) (body <top> (logop Scm_LogAnd)))
(define-cproc logior (x y &rest args) (body <top> (logop Scm_LogIor)))
(define-cproc logxor (x y &rest args) (body <top> (logop Scm_LogXor)))

(define-cproc logcount (n)
  (body <int>
        (cond
         [(SCM_EQ n (SCM_MAKE_INT 0)) (result 0)]
         [(SCM_INTP n)
          (let* ((z :: ScmBits (cast ScmBits (cast long (SCM_INT_VALUE n)))))
            (if (> (SCM_INT_VALUE n) 0)
              (result (Scm_BitsCount1 (& z) 0 SCM_WORD_BITS))
              (result (Scm_BitsCount0 (& z) 0 SCM_WORD_BITS))))]
         [(SCM_BIGNUMP n)
          (result (Scm_BignumLogCount (SCM_BIGNUM n)))]
         [else
          (SCM_TYPE_ERROR n "exact integer")
          (result 0)])))

(define-cproc fixnum? (x) (call <boolean> "SCM_INTP"))
(define-cproc bignum? (x) (call <boolean> "SCM_BIGNUMP"))
(define-cproc flonum? (x) (call <boolean> "SCM_FLONUMP"))

(define-cproc finite?   (x::<number>) (call <boolean> "Scm_FiniteP"))
(define-cproc infinite? (x::<number>) (call <boolean> "Scm_InfiniteP"))
(define-cproc nan?      (x::<number>) (call <boolean> "Scm_NanP"))

;; Names are from R6RS.
(define-cproc fixnum-width ()    (expr <int> "SCM_SMALL_INT_SIZE"))
(define-cproc least-fixnum ()    (expr <long> "SCM_SMALL_INT_MIN"))
(define-cproc greatest-fixnum () (expr <long> "SCM_SMALL_INT_MAX"))

;; As of 0.8.8 we started to support exact rational numbers.  Some existing
;; code may count on exact integer division to be coerced to flonum
;; if it isn't produce a whole number, and such programs start
;; running very slowly on 0.8.8 by introducing unintentional exact
;; rational arithmetic.
;;
;; For the smooth transition, we provide the original behavior as
;; inexact-/.  If the program uses compat.no-rational, '/' is overridden
;; by inexact-/ and the old code behaves the same.
(define-cproc inexact-/ (arg1 &rest args)
  (body <top>
        (cond ((SCM_NULLP args)
               (result (Scm_ReciprocalInexact arg1)))
              (else
               (for-each (lambda (x) (set! arg1 (Scm_DivInexact arg1 x))) args)
               (result arg1)))))

;; Inexact arithmetics.  Useful for speed-sensitive code to avoid
;; accidental use of bignum or ratnum.   We might want to optimize
;; these more, even adding special VM insns for them.
(define-cproc +. (&rest args)
  (body <top>
        (let* ((a '0.0))
          (for-each (lambda (x) (set! a (Scm_Add a (Scm_ExactToInexact x))))
                    args)
          (result a))))
(define-cproc *. (&rest args)
  (body <top>
        (let* ((a '1.0))
          (for-each (lambda (x) (set! a (Scm_Mul a (Scm_ExactToInexact x))))
                    args)
          (result a))))
(define-cproc -. (arg1 &rest args)
  (body <top>
        (cond
         ((SCM_NULLP args) (result (Scm_Negate (Scm_ExactToInexact arg1))))
         (else (for-each (lambda (x)
                           (set! arg1 (Scm_Sub arg1 (Scm_ExactToInexact x))))
                         args)
               (result arg1)))))
(define-cproc /. (arg1 &rest args)
  (body <top>
        (cond
         ((SCM_NULLP args) (result (Scm_Reciprocal (Scm_ExactToInexact arg1))))
         (else (for-each (lambda (x)
                           (set! arg1 (Scm_Div arg1 (Scm_ExactToInexact x))))
                         args)
               (result arg1)))))

(define-cproc clamp (x &optional (min #f) (max #f))
  (body <top>
        (let* ((r x) (maybe_exact :: int (SCM_EXACTP x)))
          (unless (SCM_REALP x) (SCM_TYPE_ERROR x "real number"))
          (cond ((SCM_EXACTP min)
                 (when (< (Scm_NumCmp x min) 0) (set! r min)))
                ((SCM_FLONUMP min)
                 (set! maybe_exact FALSE)
                 (when (< (Scm_NumCmp x min) 0) (set! r min)))
                ((not (SCM_FALSEP min))
                 (SCM_TYPE_ERROR min "real number or #f")))
          (cond ((SCM_EXACTP max)
                 (when (> (Scm_NumCmp x max) 0) (set! r max)))
                ((SCM_FLONUMP max)
                 (set! maybe_exact FALSE)
                 (when (> (Scm_NumCmp x max) 0) (set! r max)))
                ((not (SCM_FALSEP max))
                 (SCM_TYPE_ERROR max "real number or #f")))
          (if (and (not maybe_exact) (SCM_EXACTP r))
            (return (Scm_ExactToInexact r))
            (return r)))))

(define-cproc floor->exact (num)
  (expr <top> (Scm_RoundToExact num SCM_ROUND_FLOOR)))
(define-cproc ceiling->exact (num)
  (expr <top> (Scm_RoundToExact num SCM_ROUND_CEIL)))
(define-cproc truncate->exact (num)
  (expr <top> (Scm_RoundToExact num SCM_ROUND_TRUNC)))
(define-cproc round->exact (num)
  (expr <top> (Scm_RoundToExact num SCM_ROUND_ROUND)))

(define-cproc decode-float (num)        ;from ChezScheme
  (body <top>
        (cond ((SCM_FLONUMP num)
               (let* ((exp :: int) (sign :: int)
                      (f (Scm_DecodeFlonum (SCM_FLONUM_VALUE num)
                                           (& exp) (& sign)))
                      (v (Scm_MakeVector 3 '#f)))
                 (set! (SCM_VECTOR_ELEMENT v 0) f
                       (SCM_VECTOR_ELEMENT v 1) (Scm_MakeInteger exp)
                       (SCM_VECTOR_ELEMENT v 2) (Scm_MakeInteger sign))
                 (result v)))
              ((SCM_INTP num)
               (let* ((v (Scm_MakeVector 3 '#f)))
                 (set! (SCM_VECTOR_ELEMENT v 0) (Scm_Abs num)
                       (SCM_VECTOR_ELEMENT v 1) (Scm_MakeInteger 0)
                       (SCM_VECTOR_ELEMENT v 2) (Scm_MakeInteger (Scm_Sign num)))
                 (result v)))
              (else
               (SCM_TYPE_ERROR num "real number")
               (result SCM_UNDEFINED)))))

;; just for debug...
(when "SCM_DEBUG_HELPER"
  (define-cproc %bignum-dump (obj)
    (body <void>
          (when (SCM_BIGNUMP obj)
            (Scm_DumpBignum (SCM_BIGNUM obj) SCM_CUROUT)))))

(define-cproc min&max (arg0 &rest args)
  (body (<top> <top>)
        (Scm_MinMax arg0 args (& SCM_RESULT0) (& SCM_RESULT1))))

(define-cproc quotient&remainder (n1 n2)
  (body (<top> <top>)
        (set! SCM_RESULT0 (Scm_Quotient n1 n2 (& SCM_RESULT1)))))

;;
;; 6.3.1  Booleans
;;

;; a convenient coercer
(define-cproc boolean (obj)
  (call <boolean> "!SCM_FALSEP"))

;;
;; 6.3.2  Pairs and lists
;;

(define-cproc proper-list? (obj)        ; SRFI-1
  (call <boolean> "SCM_PROPER_LIST_P"))

(define-cproc dotted-list? (obj)        ; SRFI-1
  (call <boolean> "SCM_DOTTED_LIST_P"))

(define-cproc circular-list? (obj)      ; SRFI-1
  (call <boolean> "SCM_CIRCULAR_LIST_P"))

(define-cproc make-list (len::<fixnum> &optional (fill #f)) ; SRFI-1
  (call "Scm_MakeList"))

(define-cproc acons (caa cda cd)
  (call "Scm_Acons"))

(define-cproc last-pair (list)          ; SRFI-1
  (call "Scm_LastPair"))

(define-cproc list-copy (list)          ; SRFI-1
  (call "Scm_CopyList"))

(define-cproc list* (&rest args)
  (inliner LIST-STAR)
  (body <top>
        (let* ((head '()) (tail '()))
          (when (SCM_PAIRP args)
            (pair-for-each (lambda (cp)
                             (unless (SCM_PAIRP (SCM_CDR cp))
                               (if (SCM_NULLP head)
                                 (set! head (SCM_CAR cp))
                                 (SCM_SET_CDR tail (SCM_CAR cp)))
                               (break))
                             (SCM_APPEND1 head tail (SCM_CAR cp)))
                           args))
          (result head))))

(define-cproc %delete (obj list::<list> &optional cmpmode)
  (expr <top> (Scm_Delete obj list (getcmpmode cmpmode))))

(define-cproc %delete! (obj list::<list> &optional cmpmode)
  (expr <top> (Scm_DeleteX obj list (getcmpmode cmpmode))))

(define-cproc %delete-duplicates (list::<list> &optional cmpmode)
  (expr <top> (Scm_DeleteDuplicates list (getcmpmode cmpmode))))

(define-cproc %delete-duplicates! (list::<list> &optional cmpmode)
  (expr <top> (Scm_DeleteDuplicatesX list (getcmpmode cmpmode))))

(define-cproc %alist-delete (elt list::<list> &optional cmpmode)
  (expr <top> (Scm_AssocDelete elt list (getcmpmode cmpmode))))

(define-cproc %alist-delete! (elt list::<list> &optional cmpmode)
  (expr <top> (Scm_AssocDeleteX elt list (getcmpmode cmpmode))))

(define-cproc append! (&rest list)
  (body <top>
        (let* ((h '()) (t '()))
          (pair-for-each (lambda (cp)
                           ;; allow non-list argument at the last position
                           (when (and (not (SCM_PAIRP (SCM_CAR cp)))
                                      (SCM_NULLP (SCM_CDR cp)))
                             (if (SCM_NULLP h)
                               (set! h (SCM_CAR cp))
                               (SCM_SET_CDR t (SCM_CAR cp)))
                             (break))
                           (SCM_APPEND h t (SCM_CAR cp)))
                         list)
          (result h))))

(define-cproc reverse! (list)
  (call "Scm_ReverseX"))

;; Scheme version of 'sort' handles the case when comparison function
;; is given.
(define-cproc %sort (seq)
  (body <top>
        (cond
         ((SCM_VECTORP seq)
          (let* ((r (Scm_VectorCopy (SCM_VECTOR seq) 0 -1 SCM_UNDEFINED)))
            (Scm_SortArray (SCM_VECTOR_ELEMENTS r) (SCM_VECTOR_SIZE r) '#f)
            (result r)))
         ((>= (Scm_Length seq) 0)
          (result (Scm_SortList seq '#f)))
         (else
          (SCM_TYPE_ERROR seq "proper list or vector")
          (result SCM_UNDEFINED)))))

(define-cproc %sort! (seq)
  (body <top>
        (cond
         ((SCM_VECTORP seq)
          (Scm_SortArray (SCM_VECTOR_ELEMENTS seq) (SCM_VECTOR_SIZE seq) '#f)
          (result seq))
         ((>= (Scm_Length seq) 0)
          (result (Scm_SortListX seq '#f)))
         (else
          (SCM_TYPE_ERROR seq "proper list or vector")
          (result SCM_UNDEFINED)))))

(define-cproc monotonic-merge (start sequences::<list>)
  (call "Scm_MonotonicMerge"))

;;
;; 6.3.3  Symbols
;;

(define-cproc gensym (&optional (prefix::<string>? #f))
  (call "Scm_Gensym"))

;; keywords
(define-cproc keyword? (obj) (call <boolean> "SCM_KEYWORDP"))

(define-cproc make-keyword (name)
  (body <top>
        (let* ((sname :: ScmString* NULL))
          (cond ((SCM_STRINGP name) (set! sname (SCM_STRING name)))
                ((SCM_SYMBOLP name) (set! sname (SCM_SYMBOL_NAME name)))
                (else (SCM_TYPE_ERROR name "string or symbol")))
          (result (Scm_MakeKeyword sname)))))

(define-cproc get-keyword (key list &optional fallback)
  (call "Scm_GetKeyword"))

(define-cproc delete-keyword (key list)
  (call "Scm_DeleteKeyword"))

(define-cproc delete-keyword! (key list)
  (call "Scm_DeleteKeywordX"))

(define-cproc keyword->string (key::<keyword>)
  (expr "SCM_OBJ(SCM_KEYWORD_NAME(key))"))

;; identifiers
(define-cproc identifier? (obj)
  (inliner IDENTIFIERP)
  (call <boolean> "SCM_IDENTIFIERP"))

(define-cproc identifier->symbol (obj::<identifier>)
  (expr "SCM_OBJ(SCM_IDENTIFIER(obj)->name)"))

;;
;; 6.3.4  Characters
;;

(define-cproc digit->integer (ch::<char> &optional (radix::<fixnum> 10))
  (body <top>
        (let* ((r :: int))
          (when (or (< radix 2) (> radix 36))
            (Scm_Error "radix must be between 2 and 36, but got %d" radix))
          (set! r (Scm_DigitToInt ch radix))
          (result (?: (>= r 0) (SCM_MAKE_INT r) '#f)))))

(define-cproc integer->digit (n::<fixnum> &optional (radix::<fixnum> 10))
  (body <top>
        (let* ((r :: ScmChar))
          (when (or (< radix 2) (> radix 36))
            (Scm_Error "radix must be between 2 and 36, but got %d" radix))
          (set! r (Scm_IntToDigit n radix))
          (result (?: (== r SCM_CHAR_INVALID) '#f (SCM_MAKE_CHAR r))))))

(define-cproc ucs->char (n::<int>)
  (body <top>
        (let* ((ch :: ScmChar (Scm_UcsToChar n)))
          (result (?: (== ch SCM_CHAR_INVALID) '#f (SCM_MAKE_CHAR ch))))))

(define-cproc char->ucs (c::<char>)
  (body <top>
        (let* ((ucs :: int (Scm_CharToUcs c)))
          (result (?: (< ucs 0) '#f (Scm_MakeInteger ucs))))))

(define-cproc gauche-character-encoding ()
  (call "Scm_CharEncodingName"))

(define-cproc supported-character-encodings ()
  (expr <top> (Scm_CStringArrayToList (Scm_SupportedCharacterEncodings) -1 0)))

(define-cproc supported-character-encoding? (encoding::<const-cstring>)
  (call <boolean> "Scm_SupportedCharacterEncodingP"))

;; character sets (SRFI-14)
;;   not all of srfi-14 functions are defined in C.  you need to load
;;   srfi-14.scm to get a full set of functions.

(define-constant *char-code-max* (c "Scm_MakeInteger(SCM_CHAR_MAX)"))

(define-cproc char-set? (obj) (call <boolean> "SCM_CHARSETP"))

"static void char_set_add(ScmCharSet *cs, ScmObj chars)
 {  ScmObj cp; ScmChar ch;
  SCM_FOR_EACH(cp, chars) {
    if (!SCM_CHARP(SCM_CAR(cp)))
      Scm_Error(\"character required, but got %S\", SCM_CAR(cp));
    ch = SCM_CHAR_VALUE(SCM_CAR(cp));
    Scm_CharSetAddRange(cs, ch, ch);
  }
 }"

(define-cproc %char-set-equal? (x::<char-set> y::<char-set>)
  (call <boolean> "Scm_CharSetEq"))

(define-cproc %char-set<=? (x::<char-set> y::<char-set>)
  (call <boolean> "Scm_CharSetLE"))

(define-cproc char-set (&rest chars)
  (body <char-set>
        (let* ((cs :: ScmCharSet* (SCM_CHARSET (Scm_MakeEmptyCharSet))))
          (char_set_add cs chars)
          (result cs))))

(define-cproc char-set-copy (cs::<char-set>)
  (call "Scm_CharSetCopy"))

(define-cproc read-char-set (port::<input-port>
                             &keyword (error::<boolean> #t)
                                      (posix-bracket::<boolean> #t))
  (expr <top> (Scm_CharSetRead port NULL error posix-bracket)))

(define-cproc %char-set-add-chars! (cs::<char-set> chars::<list>)
  (body <char-set>
        (char_set_add cs chars)
        (result cs)))

(define-cproc %char-set-add-range! (cs::<char-set> from to)
  (body <top>
        (let* ((f :: long -1) (t :: long -1))
          (cond ((SCM_INTP from) (set! f (SCM_INT_VALUE from)))
                ((SCM_CHARP from) (set! f (SCM_CHAR_VALUE from))))
          (when (< f 0)
            (SCM_TYPE_ERROR from "character or positive exact integer"))
          (when (> f SCM_CHAR_MAX)
            (Scm_Error "'from' argument out of range: %S" from))
          (cond ((SCM_INTP to) (set! t (SCM_INT_VALUE to)))
                ((SCM_CHARP to) (set! t (SCM_CHAR_VALUE to))))
          (when (< t 0)
            (SCM_TYPE_ERROR to "character or positive exact integer"))
          (when (> t SCM_CHAR_MAX)
            (Scm_Error "'to' argument out of range: %S" to))
          (result (Scm_CharSetAddRange cs (cast ScmChar f) (cast ScmChar t)))))
  )
          
(define-cproc %char-set-add! (dst::<char-set> src::<char-set>)
  (call "Scm_CharSetAdd"))

(define-cproc char-set-contains? (cs::<char-set> ch::<char>)
  (call <boolean> "Scm_CharSetContains"))

(define-cproc %char-set-complement! (cs::<char-set>)
  (call "Scm_CharSetComplement"))

(define-cproc %char-set-ranges (cs::<char-set>)
  (call "Scm_CharSetRanges"))

(define-cproc %char-set-predefined (num::<fixnum>)
  (call "Scm_GetStandardCharSet"))

;; for debug
(when "SCM_DEBUG_HELPER"
  (define-cproc %char-set-dump (cs::<char-set>)
    (body <void> (Scm_CharSetDump cs SCM_CUROUT)))
  )

;;
;; 6.3.5 Strings
;;

(define-cproc string-incomplete? (obj)    ;gauche specific
  (expr <boolean> "SCM_STRINGP(obj)&&SCM_STRING_INCOMPLETE_P(obj)"))
(define-cproc string-immutable? (obj)   ;gauche specific
  (expr <boolean> "SCM_STRINGP(obj)&&SCM_STRING_IMMUTABLE_P(obj)"))

;; DEPRECATED, only kept for backward compatibility.
;; We allocate a new string and swap the body, in order to avoid MT-hazard.
;; (So it is _not_ allocation-free, and we no longer have reason to keep
;; this procedure.)
(define-cproc string-incomplete->complete! (str::<string>)
  (body <top>
        (let* ((s (Scm_StringIncompleteToComplete str SCM_ILLEGAL_CHAR_REJECT
                                                  (SCM_CHAR 0))))
          (unless (SCM_FALSEP s) (set! (-> str body) (SCM_STRING_BODY s)))
          (result s))))
;         "ScmObj s = Scm_StringIncompleteToComplete(str, SCM_ILLEGAL_CHAR_REJECT, SCM_CHAR(0));"
;         "if (!SCM_FALSEP(s)) str->body = SCM_STRING_BODY(s);"
;         "SCM_RESULT = s;"))

(define-cproc string-complete->incomplete (str::<string>)
  (call "Scm_StringCompleteToIncomplete"))

(define-cproc string-incomplete->complete (str::<string>
                                           &optional (handling #f))
  (body <top>
        (let* ((h :: int 0)
               (sub :: ScmChar (SCM_CHAR 0)))
          (cond ((SCM_EQ handling ':omit) (set! h SCM_ILLEGAL_CHAR_OMIT))
                ((SCM_FALSEP handling)    (set! h SCM_ILLEGAL_CHAR_REJECT))
                ((SCM_CHARP handling)     (set! h SCM_ILLEGAL_CHAR_REPLACE)
                                          (set! sub (SCM_CHAR_VALUE handling)))
                (else
                 (SCM_TYPE_ERROR handling ":omit, #f, or a character")))
          (result (Scm_StringIncompleteToComplete str h sub)))))

(define-cproc string-size (str::<string>)
  (expr <fixnum> (SCM_STRING_BODY_SIZE (SCM_STRING_BODY str))))

(define-cproc make-byte-string (size::<fixnum> &optional (byte::<fixnum> 0))
  (body <top>
        (let* ((s :: char*))
          (when (< size 0) (Scm_Error "size out of bound: %d" size))
          (set! s (SCM_NEW_ATOMIC2 (C: char*) size))
          (memset s byte size)
          (result (Scm_MakeString s size size SCM_STRING_INCOMPLETE)))))

(define-cproc string-byte-ref (str::<string> k::<fixnum> &optional fallback)
  (body <top>
        (let* ((r :: int (Scm_StringByteRef str k (SCM_UNBOUNDP fallback))))
          (result (?: (< r 0) fallback (SCM_MAKE_INT r))))))

(define-cproc byte-substring (str::<string> start::<fixnum> end::<fixnum>)
  (expr <top> (Scm_Substring str start end TRUE)))

(define-cproc %string-replace-body! (target::<string> source::<string>)
  (expr <top> (Scm_StringReplaceBody target (SCM_STRING_BODY source))))

(define-cproc %maybe-substring (str::<string> &optional start end)
  (call "Scm_MaybeSubstring"))

(define-cproc string-join (strs::<list>
                           &optional (delim::<string> " ") (grammer infix))
  (body
   <top>
   (let* ((gm :: int 0))
     (cond
      ((SCM_EQ grammer 'infix) (set! gm SCM_STRING_JOIN_INFIX))
      ((SCM_EQ grammer 'strict-infix) (set! gm SCM_STRING_JOIN_STRICT_INFIX))
      ((SCM_EQ grammer 'suffix) (set! gm SCM_STRING_JOIN_SUFFIX))
      ((SCM_EQ grammer 'prefix) (set! gm SCM_STRING_JOIN_PREFIX))
      (else (SCM_TYPE_ERROR grammer "one of the symbols infix, strict-infix, suffix, or prefix")))
     (result (Scm_StringJoin strs delim gm)))))

(define-cproc %hash-string (str::<string> bound) ; for SRFI-13
  (body <ulong>
        (let* ((modulo :: u_long 0))
          (cond ((SCM_UNDEFINEDP bound) (set! modulo SCM_SMALL_INT_MAX))
                ((SCM_INTP bound) (set! modulo (SCM_INT_VALUE bound)))
                ((SCM_BIGNUMP bound)
                 (set! modulo (Scm_BignumToUI (SCM_BIGNUM bound) SCM_CLAMP_BOTH
                                              NULL))))
          (when (== modulo 0) (Scm_Error "argument out of domain: %S" bound))
          (result (Scm_HashString str modulo)))))

;; see lib/gauche/string for generic string-split
(define-cproc %string-split-by-char (s::<string> ch::<char>)
  (call "Scm_StringSplitByChar"))

;; primitive scanner
(define-cproc string-scan (s1::<string> s2 &optional (mode index))
  (body <top>
        (let* ((rmode :: int 0))
          (cond
           ((SCM_EQ mode 'index)   (set! rmode SCM_STRING_SCAN_INDEX))
           ((SCM_EQ mode 'before)  (set! rmode SCM_STRING_SCAN_BEFORE))
           ((SCM_EQ mode 'after)   (set! rmode SCM_STRING_SCAN_AFTER))
           ((SCM_EQ mode 'before*) (set! rmode SCM_STRING_SCAN_BEFORE2))
           ((SCM_EQ mode 'after*)  (set! rmode SCM_STRING_SCAN_AFTER2))
           ((SCM_EQ mode 'both)    (set! rmode SCM_STRING_SCAN_BOTH))
           (else (Scm_Error "bad value in mode argumet: %S, must be one of 'index, 'before, 'after, 'before*, 'after* or 'both." mode)))
          (cond
           ((SCM_STRINGP s2)
            (result (Scm_StringScan s1 (SCM_STRING s2) rmode)))
           ((SCM_CHARP s2)
            (result (Scm_StringScanChar s1 (SCM_CHAR_VALUE s2) rmode)))
           (else
            (Scm_Error "bad type of argument for s2: %S, must be either string or character" s2)
            (result SCM_UNDEFINED))))))
                                       
;; string pointer
(define-type <string-pointer> "ScmStringPointer*" "string pointer"
  "SCM_STRING_POINTERP" "SCM_STRING_POINTER")

(define-cproc make-string-pointer (str::<string>
                                   &optional (index::<fixnum> 0)
                                             (start::<fixnum> 0)
                                             (end::<fixnum> -1))
  (call "Scm_MakeStringPointer"))
(define-cproc string-pointer? (obj)
  (call <boolean> "SCM_STRING_POINTERP"))

(define-cproc string-pointer-ref (sp::<string-pointer>)
  (call "Scm_StringPointerRef"))
(define-cproc string-pointer-next! (sp::<string-pointer>)
  (call "Scm_StringPointerNext"))
(define-cproc string-pointer-prev! (sp::<string-pointer>)
  (call "Scm_StringPointerPrev"))
(define-cproc string-pointer-set! (sp::<string-pointer> index::<fixnum>)
  (call "Scm_StringPointerSet"))
(define-cproc string-pointer-substring (sp::<string-pointer>
                                        &keyword (after #f))
  (expr <top> (Scm_StringPointerSubstring sp (not (SCM_FALSEP after)))))
(define-cproc string-pointer-index (sp::<string-pointer>)
  (expr <int> (-> sp index)))
(define-cproc string-pointer-copy (sp::<string-pointer>)
  (call "Scm_StringPointerCopy"))
(define-cproc string-pointer-byte-index (sp::<string-pointer>)
  (expr <int> (cast int (- (-> sp current) (-> sp start)))))

(if "SCM_DEBUG_HELPER"
    (define-cproc %string-pointer-dump (sp::<string-pointer>)
      (call <void> "Scm_StringPointerDump"))
    )

;; Regexp
(define-cproc regexp? (obj)    (call <boolean> "SCM_REGEXPP"))
(define-cproc regmatch? (obj)  (call <boolean> "SCM_REGMATCHP"))

(define-cproc string->regexp (str::<string> &keyword (case-fold #f))
  (body <top>
        (let* ((flags :: int
                      (?: (SCM_BOOL_VALUE case-fold) SCM_REGEXP_CASE_FOLD 0)))
          (result (Scm_RegComp str flags)))))
(define-cproc regexp->string (regexp::<regexp>)
  (expr <top> (?: (-> regexp pattern) (SCM_OBJ (-> regexp pattern)) '#f)))
(define-cproc regexp-case-fold? (regexp::<regexp>)
  (expr <boolean> (logand (-> regexp flags) SCM_REGEXP_CASE_FOLD)))

(define-cproc regexp-parse (str::<string> &keyword (case-fold #f))
  (body <top>
        (let* ((flags :: int
                      (?: (SCM_BOOL_VALUE case-fold) SCM_REGEXP_CASE_FOLD 0)))
          (result (Scm_RegComp str (logior flags SCM_REGEXP_PARSE_ONLY))))))
(define-cproc regexp-compile (ast)
  (call "Scm_RegCompFromAST"))
(define-cproc regexp-optimize (ast)
  (call "Scm_RegOptimizeAST"))

(define-cproc rxmatch (regexp str::<string>)
  (body <top>
        (let* ((rx :: ScmRegexp* NULL))
          (cond ((SCM_STRINGP regexp)
                 (set! rx (SCM_REGEXP (Scm_RegComp (SCM_STRING regexp) 0))))
                ((SCM_REGEXPP regexp)
                 (set! rx (SCM_REGEXP regexp)))
                (else (SCM_TYPE_ERROR regexp "regexp")))
          (result (Scm_RegExec rx str)))))

(define-cise-stmt rxmatchop
  [(_ (exp ...)) (template exp)]
  [(_ fn)        (template `(,fn (SCM_REGMATCH match) obj))]
  :where
  (define (template result)
    `(cond ((SCM_FALSEP match) (result '#f))
           ((SCM_REGMATCHP match) (result ,result))
           (else (SCM_TYPE_ERROR match "regmatch object or #f")
                 (result SCM_UNDEFINED)))))

(define-cproc rxmatch-substring (match &optional (obj 0)) 
  (body <top> (rxmatchop Scm_RegMatchSubstr)))
(define-cproc rxmatch-start (match &optional (obj 0))
  (body <top> (rxmatchop Scm_RegMatchStart)))
(define-cproc rxmatch-end (match &optional (obj 0))
  (body <top> (rxmatchop Scm_RegMatchEnd)))
(define-cproc rxmatch-before (match &optional (obj 0))
  (body <top> (rxmatchop Scm_RegMatchBefore)))
(define-cproc rxmatch-after (match &optional (obj 0))
  (body <top> (rxmatchop Scm_RegMatchAfter)))
(define-cproc rxmatch-num-matches (match)
  (body <top>
        (if (SCM_FALSEP match)
          (result (SCM_MAKE_INT 0))
          (rxmatchop (SCM_MAKE_INT (-> (SCM_REGMATCH match) numMatches))))))

;; for debug
(when "SCM_DEBUG_HELPER"
  (define-cproc %regexp-dump (rx::<regexp>)
    (call <void> "Scm_RegDump"))
  (define-cproc %regmatch-dump (rm::<regmatch>)
    (call <void> "Scm_RegMatchDump"))
  )

;;
;; 6.3.6  Vectors
;;

(define-cproc vector-copy (v::<vector>
                           &optional
                           (start::<fixnum> 0) (end::<fixnum> -1) fill)
  (call "Scm_VectorCopy"))

;; weak vector
(define-cproc make-weak-vector (size::<fixnum>)
  (call "Scm_MakeWeakVector"))

(define-cproc weak-vector-length (wv::<weak-vector>)
  (expr <int> "wv->size"))

(define-cproc weak-vector-ref (wv::<weak-vector> index::<fixnum>
                               &optional fallback)
  (call "Scm_WeakVectorRef"))
  
(define-cproc weak-vector-set! (wv::<weak-vector> index::<fixnum> val)
  (call "Scm_WeakVectorSet"))

;;
;; 6.4  Control Features
;;

(define-cproc setter (proc) ;SRFI-17
  (inliner SETTER)
  (call "Scm_Setter")
  (setter (proc::<procedure> setter::<procedure>)
          (body <void> (Scm_SetterSet proc setter FALSE))))

(define-cproc has-setter? (proc)
  (call <boolean> "Scm_HasSetter"))

(define-cproc identity (val)            ;sometimes useful
  (expr "val"))

(define-cproc promise? (obj)
  (expr <boolean> (SCM_XTYPEP obj SCM_CLASS_PROMISE)))

(define-cproc eager (obj)               ;srfi-45
  (expr <top> (Scm_MakePromise TRUE obj)))

(define-cproc promise-kind (p::<promise>)
  (expr <top> (-> p kind))
  (setter (p::<promise> obj)
          (body <void> (set! (-> p kind) obj))))

;;
;; 6.6.1  Ports
;;

(define-cproc eof-object ()             ;R6RS
  (expr "SCM_EOF"))

;; open-input-file and open-output-file are defined in Scheme.
;; these are core procedures

(define-cproc %open-input-file (path::<string>
                                &keyword
                                (if-does-not-exist :error)
                                (buffering #f)
                                (element-type :character)
                                )
  (body <top>
        (let* ((ignerr :: int FALSE))
          (cond ((SCM_FALSEP if-does-not-exist) (set! ignerr TRUE))
                ((not (SCM_EQ if-does-not-exist ':error))
                 (Scm_TypeError ":if-does-not-exist" ":error or #f"
                                if-does-not-exist)))
          (let* ((bufmode :: int
                          (Scm_BufferingMode buffering SCM_PORT_INPUT
                                             SCM_PORT_BUFFER_FULL))
                 (o       (Scm_OpenFilePort (Scm_GetStringConst path)
                                            O_RDONLY bufmode 0)))
            (when (and (SCM_FALSEP o) (not ignerr))
              (Scm_SysError "couldn't open input file: %S" path))
            (result o)))))

(define-cproc %open-output-file (path::<string>
                                 &keyword
                                 (if-exists :supersede)
                                 (if-does-not-exist :create)
                                 (mode::<fixnum> #o666)
                                 (buffering #f)
                                 (element-type :character)
                                 )
  (body
   <top>
   (let* ((ignerr :: int FALSE)
          (flags  :: int O_WRONLY))
     ;; check if-exists flag
     (cond
      ((SCM_EQ if-exists ':append) (logior= flags O_APPEND))
      ((SCM_EQ if-exists ':error)
       (logior= flags O_EXCL)
       (when (SCM_EQ if-does-not-exist ':error)
         (Scm_Error "bad flag combination: :if-exists and :if-does-not-exist can't be :error the same time.")))
      ((SCM_EQ if-exists ':supersede) (logior= flags O_TRUNC))
      ((SCM_EQ if-exists ':overwrite)) ; no need to add flags
      ((SCM_FALSEP if-exists)
       (logior= flags O_EXCL) (set! ignerr TRUE))
      (else
       (Scm_TypeError ":if-exists" ":supersede, :overwrite, :append, :error or #f" if-exists)))
     ;; check if-does-not-exist flag
     (cond
      ((SCM_EQ if-does-not-exist ':create) (logior= flags O_CREAT))
      ((SCM_FALSEP if-does-not-exist) (set! ignerr TRUE))
      ((SCM_EQ if-does-not-exist ':error)) ; no need to add flags
      (else
       (Scm_TypeError ":if-does-not-exist" ":error, :create or #f"
                      if-does-not-exist)))
     (let* ((bufmode :: int
                     (Scm_BufferingMode buffering SCM_PORT_OUTPUT
                                        SCM_PORT_BUFFER_FULL))
            (o       (Scm_OpenFilePort (Scm_GetStringConst path)
                                       flags bufmode mode)))
       (when (and (not ignerr) (== o SCM_FALSE))
         (Scm_Error "couldn't open output file: %S" path))
       (result o)))))

;; String port (srfi-6)
(define-cproc open-input-string (string::<string>
                                 &keyword (private?::<boolean> #f))
  (call "Scm_MakeInputStringPort"))

(define-cproc open-output-string (&keyword (private?::<boolean> #f))
  (call "Scm_MakeOutputStringPort"))

(define-cproc get-output-string (oport::<output-port>) ;SRFI-6
  (expr "Scm_GetOutputString(oport, 0)"))

(define-cproc get-output-byte-string (oport::<output-port>)
  (expr "Scm_GetOutputString(oport, SCM_STRING_INCOMPLETE)"))

(define-cproc get-remaining-input-string (iport::<input-port>)
  (expr "Scm_GetRemainingInputString(iport, 0)"))

(define-cproc open-coding-aware-port (iport::<input-port>)
  (call "Scm_MakeCodingAwarePort"))

;; Buffered port
;; NB: the interface may be changed soon!!
"static void bufport_closer(ScmPort *p)
 {
    if (SCM_PORT_DIR(p) == SCM_PORT_OUTPUT) {
       ScmObj scmflusher = SCM_OBJ(p->src.buf.data);
       int siz = (int)(p->src.buf.current - p->src.buf.buffer);
       if (siz > 0) Scm_ApplyRec(scmflusher, SCM_LIST1(Scm_MakeString(p->src.buf.buffer, siz, siz, SCM_STRING_INCOMPLETE|SCM_STRING_COPYING)));
       Scm_ApplyRec(scmflusher, SCM_LIST1(SCM_FALSE));
    }
 }"

"static int bufport_filler(ScmPort *p, int cnt)
 {
    ScmObj scmfiller, r;  int siz;
    const ScmStringBody *b;
    scmfiller = SCM_OBJ(p->src.buf.data);
    /* no need to use VMApply; we're in the C callback */
    r = Scm_ApplyRec(scmfiller, SCM_LIST1(Scm_MakeInteger(cnt)));
    if (SCM_EOFP(r) || SCM_FALSEP(r)) {
       return 0;
    } else if (!SCM_STRINGP(r)) {
       Scm_Error(\"buffered port callback procedure returned non-string: %S\", r);
    }
    b = SCM_STRING_BODY(r);
    siz = SCM_STRING_BODY_SIZE(b);
    if (siz > cnt) siz = cnt; /* for safety */
    memcpy(p->src.buf.end, SCM_STRING_BODY_START(b), siz);
    return SCM_STRING_BODY_SIZE(b);
 }"

(define-cproc open-input-buffered-port (filler::<procedure>
                                        buffer-size::<fixnum>)
  "  ScmPortBuffer bufrec;
  bufrec.size = buffer_size;
  bufrec.buffer = NULL;
  bufrec.mode = SCM_PORT_BUFFER_FULL;
  bufrec.filler = bufport_filler;
  bufrec.flusher = NULL;
  bufrec.closer = bufport_closer;
  bufrec.ready = NULL;
  bufrec.filenum = NULL;
  bufrec.data = (void*)filler;
  SCM_RETURN(Scm_MakeBufferedPort(SCM_CLASS_PORT, SCM_FALSE, SCM_PORT_INPUT, TRUE, &bufrec));
  ")

"static int bufport_flusher(ScmPort *p, int cnt, int forcep)
 {
     ScmObj scmflusher, s;
     scmflusher = SCM_OBJ(p->src.buf.data);
     s = Scm_MakeString(p->src.buf.buffer, cnt, cnt, SCM_STRING_INCOMPLETE|SCM_STRING_COPYING);
     Scm_ApplyRec(scmflusher, SCM_LIST1(s));
     return cnt;
 }"

(define-cproc open-output-buffered-port (flusher::<procedure>
                                         buffer-size::<fixnum>)
  "  ScmPortBuffer bufrec;
  bufrec.size = buffer_size;
  bufrec.buffer = NULL;
  bufrec.mode = SCM_PORT_BUFFER_FULL;
  bufrec.filler = NULL;
  bufrec.flusher = bufport_flusher;
  bufrec.closer = bufport_closer;
  bufrec.ready = NULL;
  bufrec.filenum = NULL;
  bufrec.data = (void*)flusher;
  SCM_RETURN(Scm_MakeBufferedPort(SCM_CLASS_PORT, SCM_FALSE, SCM_PORT_OUTPUT, TRUE, &bufrec));
  ")

(define-cproc flush (&optional (oport::<output-port> (current-output-port)))
  (call <void> "Scm_Flush"))

(define-cproc flush-all-ports ()
  (body <void> "Scm_FlushAllPorts(FALSE);"))

(define-cproc port-closed? (obj::<port>)
  (call <boolean> "SCM_PORT_CLOSED_P"))

(define-cproc port-case-fold-set! (port::<port> flag::<boolean>)
  (body <void>
        (if flag
          (logior= (SCM_PORT_FLAGS port) SCM_PORT_CASE_FOLD)
          (logand= (SCM_PORT_FLAGS port) (lognot SCM_PORT_CASE_FOLD)))))

(define-cproc current-error-port (&optional newport)
  (body "if (SCM_OPORTP(newport)) {"
        "  SCM_RESULT = Scm_SetCurrentErrorPort(SCM_PORT(newport));"
        "} else if (!SCM_UNBOUNDP(newport)) {"
        "  Scm_TypeError(\"current-error-port\", \"output port\", newport);"
        "  SCM_RESULT = SCM_UNDEFINED;"
        "} else {"
        "  SCM_RESULT = SCM_OBJ(SCM_CURERR);"
        "}"))

(define-cproc standard-input-port ()
  (call "Scm_Stdin"))

(define-cproc standard-output-port ()
  (call "Scm_Stdout"))

(define-cproc standard-error-port ()
  (call "Scm_Stderr"))

(define-cproc port-name (port::<port>)
  (call "Scm_PortName"))

(define-cproc port-current-line (port::<port>)
  (call <fixnum> "Scm_PortLine"))

(define-cproc port-file-number (port::<port>)
  "  int i = Scm_PortFileNo(port);
  SCM_RETURN((i < 0)? SCM_FALSE : Scm_MakeInteger(i));")

(when "!defined(GAUCHE_WINDOWS)"
  (define-cproc port-fd-dup! (dst::<port> src::<port>)
    (call <void> "Scm_PortFdDup"))
  )

(define-enum SEEK_SET)
(define-enum SEEK_CUR)
(define-enum SEEK_END)

(define-cproc port-seek (port::<port> offset::<integer>
                         &optional (whence::<fixnum> (c "SCM_MAKE_INT(SEEK_SET)")))
  (call "Scm_PortSeek"))

(define-cproc port-type (port::<port>)
  (body <top>
        (case (SCM_PORT_TYPE port)
          ((SCM_PORT_FILE) (result 'file))
          ((SCM_PORT_PROC) (result 'proc))
          ((SCM_PORT_OSTR SCM_PORT_ISTR) (result 'string))
          (else (result '#f)))))

(define-cproc port-buffering (port::<port>)
  (call "Scm_GetBufferingMode")
  (setter (port::<port> mode)
    "if (SCM_PORT_TYPE(port) != SCM_PORT_FILE) {
       Scm_Error(\"can't set buffering mode to non-buffered port: %S\", port);
     }
     port->src.buf.mode = Scm_BufferingMode(mode, port->direction, -1);
     SCM_RETURN(SCM_UNDEFINED);")
  )

;; Open port from fd
(define-cproc open-input-fd-port (fd::<fixnum>
                                  &keyword (buffering #f)
                                           (owner?::<boolean> #f)
                                           (name #f))
  "int bufmode = Scm_BufferingMode(buffering, SCM_PORT_INPUT, SCM_PORT_BUFFER_FULL);
   if (fd < 0) Scm_Error(\"bad file descriptor: %d\", fd);
   return Scm_MakePortWithFd(name, SCM_PORT_INPUT, fd, bufmode, ownerP);")

(define-cproc open-output-fd-port (fd::<fixnum>
                                   &keyword (buffering #f)
                                            (owner?::<boolean> #f)
                                            (name #f))
  (body <top>
        (let* ((bufmode :: int (Scm_BufferingMode buffering SCM_PORT_OUTPUT
                                                  SCM_PORT_BUFFER_FULL)))
          (when (< fd 0) (Scm_Error "bad file descriptor: %d" fd))
          (result (Scm_MakePortWithFd name SCM_PORT_OUTPUT fd bufmode owner?)))))
          
;; Unsafe port operations
(define-cproc with-port-locking (port::<port> proc)
  (call "Scm_VMWithPortLocking"))

(define-cproc port->byte-string (port::<input-port>)
  (body <top>
        (let* ((ds :: ScmDString) (|buf[1024]| :: char))
          (Scm_DStringInit (& ds))
          (loop (let* ((nbytes :: int (Scm_Getz buf 1024 port)))
                  (when (<= nbytes 0) (break))
                  (Scm_DStringPutz (& ds) buf nbytes)))
          (result (Scm_DStringGet (& ds) SCM_STRING_INCOMPLETE)))))

;;
;; 6.6.2  Input
;;

(define-cproc byte-ready? (port::<input-port>)
  (call <boolean> "Scm_ByteReady"))

(define-cproc read-byte (&optional (port::<input-port> (current-input-port)))
  (body <top>
        (let* ((b :: int))
          (SCM_GETB b port)
          (result (?: (< b 0) SCM_EOF (SCM_MAKE_INT b))))))

(define-cproc peek-byte (&optional (port::<input-port> (current-input-port)))
  (body <top>
        (let* ((b :: int (Scm_Peekb port)))
          (result (?: (< b 0) SCM_EOF (SCM_MAKE_INT b))))))

(define-cproc read-line (&optional (port::<input-port> (current-input-port))
                                   (allowbytestr #f))
  (body <top>
        (let* ((r (Scm_ReadLine port)))
          (when (and (SCM_FALSEP allowbytestr)
                     (SCM_STRINGP r)
                     (SCM_STRING_INCOMPLETE_P r))
            (Scm_ReadError port "read-line: encountered illegal byte sequence: %S" r))
          (result r))))

(define-cproc read-block (bytes::<fixnum>
                          &optional (port::<input-port> (current-input-port)))
  "  char *buf; int nread;
  if (bytes < 0) Scm_Error(\"bytes must be non-negative integer: %d\", bytes);
  if (bytes == 0) SCM_RETURN(Scm_MakeString(\"\", 0, 0, 0));
  buf = SCM_NEW_ATOMIC2(char*, bytes+1);
  nread = Scm_Getz(buf, bytes, port);
  if (nread <= 0) {
    SCM_RETURN(SCM_EOF);
  } else {
    SCM_ASSERT(nread <= bytes);
    buf[nread] = '\\0';
    SCM_RETURN(Scm_MakeString(buf, nread, nread, SCM_STRING_INCOMPLETE));
  }")

(define-cproc read-list (closer::<char>
                         &optional (port (current-input-port)))
  "SCM_RETURN(Scm_ReadList(port, closer));")

(define-cproc define-reader-ctor (symbol proc &optional (finisher #f))
  (call "Scm_DefineReaderCtor"))

(define-cproc define-reader-directive (symbol proc)
  (call "Scm_DefineReaderDirective"))

(define-type <read-context> "ScmReadContext*" "read context"
  "SCM_READ_CONTEXT_P" "SCM_READ_CONTEXT" "")

(define-type <read-reference> "ScmReadReference*" "read reference"
  "SCM_READ_REFERENCE_P" "SCM_READ_REFERENCE" "")

(define-cproc read-reference? (obj)
  (call <boolean> "SCM_READ_REFERENCE_P"))

(define-cproc read-reference-has-value? (ref::<read-reference>)
  (expr <boolean> "!SCM_UNBOUNDP(ref->value)"))

(define-cproc read-reference-value (ref::<read-reference>)
  "if (SCM_UNBOUNDP(ref->value))
    Scm_Error(\"read reference hasn't been resolved\");
  SCM_RETURN(ref->value);")

;;
;; 6.6.3  Output
;;

(define-cproc write-byte (byte::<fixnum>
                          &optional (port::<output-port> (current-output-port)))
  "  if (byte < 0 || byte > 255) Scm_Error(\"argument out of range: %d\", byte);
  SCM_PUTB(byte, port);
  SCM_RETURN(SCM_MAKE_INT(1));")

(define-cproc write-limited (obj limit::<fixnum>
                             &optional (port (current-output-port)))
  "  int n = Scm_WriteLimited(obj, port, SCM_WRITE_WRITE, limit);
  SCM_RETURN(SCM_MAKE_INT(n));")

(define-cproc write* (obj &optional (port (current-output-port)))
  "  int n = Scm_WriteCircular(obj, port, SCM_WRITE_WRITE, 0);
  SCM_RETURN(SCM_MAKE_INT(n));")

;;
;; 6.6.4  System Interface
;;

(define-cproc %add-load-path (path::<string> &optional (afterp #f))
  "  const char *cpath = Scm_GetStringConst(path);
  SCM_RETURN(Scm_AddLoadPath(cpath, !SCM_FALSEP(afterp)));")

(define-cproc dynamic-load (file::<string>
                            &keyword (init-function #f)
                                     (export-symbols #f))
  (expr "Scm_DynLoad(file, init_function, !SCM_FALSEP(export_symbols))"))

(define-cproc %require (feature)
  (expr <boolean> "!Scm_Require(feature, SCM_LOAD_PROPAGATE_ERROR, NULL)"))
(define-cproc provide (feature)   (call "Scm_Provide"))
(define-cproc provided? (feature) (call <boolean> "Scm_ProvidedP"))

(define-cproc %autoload (mod::<module> file-or-module entries)
  (call <void> "Scm_DefineAutoload"))

(define-cproc undefined ()
  (inliner CONSTU)
  "SCM_RETURN(SCM_UNDEFINED);")

(define-cproc undefined? (obj)    (call <boolean> "SCM_UNDEFINEDP"))

(define-cproc warn (fmt::<string> &rest args)
  (call <void> "Scm_FWarn"))

;;
;; Dictionary common macros
;;

(define-cise-stmt dict-check-entry
  [(_ dict key expr)
   `(when ,expr
      (Scm_Error "%S doesn't have an entry for key %S" ,dict ,key))])

(define-cise-stmt dict-get
  [(_ dict referencer)
   `(let* ((v (,referencer ,dict key fallback)))
      (dict-check-entry ,dict key (SCM_UNBOUNDP v))
      (result v))])

(define-cise-expr dict-exists?
  [(_ dict referencer)
   `(not (SCM_UNBOUNDP (,referencer ,dict key SCM_UNBOUND)))])

(define-cise-stmt dict-update!
  [(_ dict searcher xtractor cc) ;; assumes key, proc, and fallback
   `(let* ((e :: ScmDictEntry*)
           (|data[1]| :: void*))
      (cond ((SCM_UNBOUNDP fallback)
             (set! e (,searcher (,xtractor ,dict) (cast intptr_t key)
                                SCM_DICT_GET))
             (dict-check-entry ,dict key (== e NULL)))
            (else
             (set! e (,searcher (,xtractor ,dict) (cast intptr_t key)
                                SCM_DICT_CREATE))
             (unless (-> e value)
               (cast void (SCM_DICT_SET_VALUE e fallback)))))
      (set! (aref data 0) (cast void* e))
      (Scm_VMPushCC ,cc data 1)
      (result (Scm_VMApply1 proc (SCM_DICT_VALUE e))))])

(define-cise-stmt dict-push!
  [(_ dict searcher xtractor)
   `(let* ((e :: ScmDictEntry* (,searcher (,xtractor ,dict )
                                          (cast intptr_t key)
                                          SCM_DICT_CREATE))
           (prev (?: (-> e value) (SCM_DICT_VALUE e) '())))
      (cast void (SCM_DICT_SET_VALUE e (Scm_Cons value prev))))])

(define-cise-stmt dict-pop!
  [(_ dict searcher xtractor)
   `(let* ((e :: ScmDictEntry* (,searcher (,xtractor ,dict)
                                          (cast intptr_t key)
                                          SCM_DICT_GET)))
      (cond
       ((not e)
        (dict-check-entry ,dict key (SCM_UNBOUNDP fallback))
        (result fallback))
       ((not (SCM_PAIRP (SCM_DICT_VALUE e)))
        (when (SCM_UNBOUNDP fallback)
          (Scm_Error "%S's value for key %S is not a pair: %S"
                     ,dict key (SCM_DICT_VALUE e)))
        (result fallback))
       (else
        (result (SCM_CAR (SCM_DICT_VALUE e)))
        (cast void (SCM_DICT_SET_VALUE e (SCM_CDR (SCM_DICT_VALUE e)))))))])

;;
;; Hashtable
;;

(define-cise-stmt set-hash-type!
  [(_ cvar scmvar)
   `(cond ((SCM_EQ ,scmvar 'eq?)      (set! ,cvar SCM_HASH_EQ))
          ((SCM_EQ ,scmvar 'eqv?)     (set! ,cvar SCM_HASH_EQV))
          ((SCM_EQ ,scmvar 'equal?)   (set! ,cvar SCM_HASH_EQUAL))
          ((SCM_EQ ,scmvar 'string=?) (set! ,cvar SCM_HASH_STRING))
          (else (Scm_Error "unsupported hash type: %S" ,scmvar)))])

(define-cise-stmt get-hash-type
  [(_ expr)
   `(case ,expr
      ((SCM_HASH_EQ)      (result 'eq?))
      ((SCM_HASH_EQV)     (result 'eqv?))
      ((SCM_HASH_EQUAL)   (result 'equal?))
      ((SCM_HASH_STRING)  (result 'string=?))
      (else (result '#f))           ; TODO: need to think over
      )])

(define-cproc eq-hash (obj)  (call <ulong> "Scm_EqHash"))
(define-cproc eqv-hash (obj) (call <ulong> "Scm_EqvHash"))
(define-cproc hash (obj)     (call <ulong> "Scm_Hash"))
(define-cproc hash-table? (obj) (call <boolean> "SCM_HASH_TABLE_P"))

(define-cproc make-hash-table (&optional (type eq?))
  (body <top>
        (let* ((ctype :: int 0))
          (set-hash-type! ctype type)
          (result (Scm_MakeHashTableSimple ctype 0)))))

(define-cproc hash-table-type (hash::<hash-table>)
  (body <top> (get-hash-type (-> hash type))))

(define-cproc hash-table-num-entries (hash::<hash-table>)
  (expr <int> (Scm_HashCoreNumEntries (SCM_HASH_TABLE_CORE hash))))

(define-cproc hash-table-clear! (hash::<hash-table>)
  (body <void> (Scm_HashCoreClear (SCM_HASH_TABLE_CORE hash))))

(define-cproc hash-table-get (hash::<hash-table> key &optional fallback)
  (body <top>  (dict-get hash Scm_HashTableRef)))

(define-cproc hash-table-put! (hash::<hash-table> key value)
  (body <void> (Scm_HashTableSet hash key value 0)))

;; this is hash-table-remove! in STk.  I use `delete' for
;; it's consistent with SRFI-1 and dbm-delete!.
(define-cproc hash-table-delete! (hash::<hash-table> key)
  (expr <boolean> (not (SCM_UNBOUNDP (Scm_HashTableDelete hash key)))))

(define-cproc hash-table-exists? (hash::<hash-table> key)
  (expr <boolean> (dict-exists? hash Scm_HashTableRef)))

"static ScmObj hash_table_update_cc(ScmObj result, void **data)
 {
   ScmDictEntry *e = (ScmDictEntry*)data[0];
   (void)SCM_DICT_SET_VALUE(e, result);
   SCM_RETURN(result);
 }"

(define-cproc hash-table-update! (hash::<hash-table> key proc
                                                     &optional fallback)
  (body <top>  (dict-update! hash Scm_HashCoreSearch SCM_HASH_TABLE_CORE
                             hash_table_update_cc)))

(define-cproc hash-table-push! (hash::<hash-table> key value)
  (body <void> (dict-push! hash Scm_HashCoreSearch SCM_HASH_TABLE_CORE)))

(define-cproc hash-table-pop! (hash::<hash-table> key &optional fallback)
  (body <top>  (dict-pop! hash Scm_HashCoreSearch SCM_HASH_TABLE_CORE)))

"static ScmObj hash_table_iter(ScmObj *args, int nargs, void *data)
 {
   ScmHashIter *iter = (ScmHashIter*)data;
   ScmDictEntry *e = Scm_HashIterNext(iter);
   ScmObj eofval = args[0];
   if (e == NULL) SCM_RETURN(Scm_Values2(eofval, eofval));
   else SCM_RETURN(Scm_Values2(SCM_DICT_KEY(e), SCM_DICT_VALUE(e)));
 }"

(define-cproc %hash-table-iter (hash::<hash-table>)
  (body <top>
        (let* ((iter :: ScmHashIter* (SCM_NEW ScmHashIter)))
          (Scm_HashIterInit iter (SCM_HASH_TABLE_CORE hash))
          (result (Scm_MakeSubr hash_table_iter iter 1 0
                                '"hash-table-iterator")))))

(define-cproc hash-table-copy (hash::<hash-table>)
  (call "Scm_HashTableCopy"))

(define-cproc hash-table-keys (hash::<hash-table>)
  (call "Scm_HashTableKeys"))

(define-cproc hash-table-values (hash::<hash-table>)
  (call "Scm_HashTableValues"))

(define-cproc hash-table-stat (hash::<hash-table>)
  (call "Scm_HashTableStat"))

;;
;; WeakHashTable
;;

;; NB: it turned out the current hash core implementation isn't
;; very good to support key-weak hash table efficiently, so I'm
;; going to reimplement hash core.  I suspend weak hash table
;; development until then.

; (define-cproc make-weak-hash-table (&optional (type eq?)
;                                               (weakness key)
;                                               (default-value #f))
;   (body <top>
;         (let* ((t :: int 0) (w :: int 0))
;           (set-hash-type! t type)
;           (cond ((SCM_EQ weakness 'key)   (set! w SCM_WEAK_KEY))
;                 ((SCM_EQ weakness 'value) (set! w SCM_WEAK_VALUE))
;                 ((SCM_EQ weakness 'both)  (set! w SCM_WEAK_BOTH))
;                 (else (Scm_Error "unsupported weakness: %S" weakness)))
;           (result (Scm_MakeWeakHashTableSimple t w 0 default-value)))))

; (define-cproc weak-hash-table-type (wh::<weak-hash-table>)
;   (body <top> (get-hash-type (-> wh type))))
; (define-cproc weak-hash-table-weakness (wh::<weak-hash-table>)
;   (body <top>
;         (case (-> wh weakness)
;           ((SCM_WEAK_KEY)   (result 'key))
;           ((SCM_WEAK_VALUE) (result 'value))
;           ((SCM_WEAK_BOTH)  (result 'both))
;           (else (Scm_Error "[internal] weak hash %S has unknown weakness: %d"
;                            (-> wh weakness))
;                 (result '#f)))))

; (define-cproc weak-hash-table-num-entries (wh::<weak-hash-table>)
;   (expr <int> (Scm_HashCoreNumEntries (SCM_WEAK_HASH_TABLE_CORE wh))))

; (define-cproc weak-hash-table-clear! (wh::<weak-hash-table>)
;   (body <void> (Scm_HashCoreClear (SCM_WEAK_HASH_TABLE_CORE wh))))

; (define-cproc weak-hash-table-get (wh::<weak-hash-table> key
;                                                          &optional fallback)
;   (body <top>  (dict-get wh Scm_WeakHashTableRef)))

; (define-cproc weak-hash-table-put! (wh::<weak-hash-table> key value)
;   (body <void> (Scm_WeakHashTableSet wh key value 0)))

; (define-cproc weak-hash-table-delete! (wh::<weak-hash-table> key)
;   (expr <boolean> (not (SCM_UNBOUNDP (Scm_WeakHashTableDelete wh key)))))
  
; (define-cproc weak-hash-table-exists? (wh::<weak-hash-table> key)
;   (expr <boolean> (dict-exists? wh Scm_WeakHashTableRef)))

; (define-cproc weak-hash-table-keys (wh::<weak-hash-table>)
;   (call "Scm_WeakHashTableKeys"))

; (define-cproc weak-hash-table-values (wh::<weak-hash-table>)
;   (call "Scm_WeakHashTableValues"))

; "static ScmObj weak_hash_table_iter(ScmObj *args, int nargs, void *data)
;  {
;    ScmWeakHashIter *iter = (ScmWeakHashIter*)data;
;    ScmObj key = args[0], val = args[0]; /* arg0 is eofval */
;    Scm_WeakHashIterNext(iter, &key, &val);
;    SCM_RETURN(Scm_Values2(key, val));
;  }"

; (define-cproc %weak-hash-table-iter (wh::<weak-hash-table>)
;   (body <top>
;         (let* ((iter :: ScmWeakHashIter* (SCM_NEW ScmWeakHashIter)))
;           (Scm_WeakHashIterInit iter wh)
;           (result (Scm_MakeSubr weak_hash_table_iter iter 1 0
;                                 '"weak-hash-table-iterator")))))

;;
;; TreeMap
;;

"static int tree_map_cmp(ScmTreeCore *core, intptr_t x, intptr_t y) 
 {
    ScmObj cmp_proc = SCM_OBJ(core->data);
    ScmObj r = Scm_ApplyRec(cmp_proc, SCM_LIST2(SCM_OBJ(x), SCM_OBJ(y)));
    SCM_RETURN(SCM_INT_VALUE(r));
 }"

(define-cproc %make-tree-map (cmp-proc)
  (expr <top> (Scm_MakeTreeMap tree_map_cmp cmp_proc)))

(define-cproc tree-map-copy (tm::<tree-map>)
  (call "Scm_TreeMapCopy"))

(define-cproc tree-map? (obj)
  (call <boolean> "SCM_TREE_MAP_P"))

(define-cproc tree-map-get (tm::<tree-map> key &optional fallback)
  (body <top>  (dict-get tm Scm_TreeMapRef)))

(define-cproc tree-map-put! (tm::<tree-map> key val)
  (body <void> (Scm_TreeMapSet tm key val 0)))

(define-cproc tree-map-delete! (tm::<tree-map> key)
  (expr <boolean> (not (SCM_UNBOUNDP (Scm_TreeMapDelete tm key)))))

"static ScmObj tree_map_update_cc(ScmObj result, void **data)
 {
   ScmDictEntry *e = (ScmDictEntry*)data[0];
   (void)SCM_DICT_SET_VALUE(e, result);
   SCM_RETURN(result);
 }"

(define-cproc tree-map-update! (tm::<tree-map> key proc &optional fallback)
  (body <top>  (dict-update! tm Scm_TreeCoreSearch SCM_TREE_MAP_CORE
                             tree_map_update_cc)))

(define-cproc tree-map-push! (tm::<tree-map> key value)
  (body <void> (dict-push! tm Scm_TreeCoreSearch SCM_TREE_MAP_CORE)))

(define-cproc tree-map-pop! (tm::<tree-map> key &optional fallback)
  (body <top>  (dict-pop! tm Scm_TreeCoreSearch SCM_TREE_MAP_CORE)))
            
(define-cproc tree-map-exists? (tm::<tree-map> key)
  (expr <boolean> (dict-exists? tm Scm_TreeMapRef)))

(define-cproc tree-map-num-entries (tm::<tree-map>)
  (expr <int> (Scm_TreeCoreNumEntries (SCM_TREE_MAP_CORE tm))))

(define-cproc %tree-map-bound (tm::<tree-map> min::<boolean> pop::<boolean>)
  (body <top>
        (let* ((op :: ScmTreeCoreBoundOp
                   (?: min SCM_TREE_CORE_MIN SCM_TREE_CORE_MAX))
               (e  :: ScmDictEntry*
                   (?: pop
                       (Scm_TreeCorePopBound (SCM_TREE_MAP_CORE tm) op)
                       (Scm_TreeCoreGetBound (SCM_TREE_MAP_CORE tm) op))))
          (if e
            (result (Scm_Cons (SCM_DICT_KEY e) (SCM_DICT_VALUE e)))
            (result '#f)))))

"static ScmObj tree_map_iter(ScmObj *args, int nargs, void *data)
 {
   ScmTreeIter *iter = (ScmTreeIter*)data;
   ScmDictEntry *e;
   if (SCM_FALSEP(args[1])) e = Scm_TreeIterNext(iter);
   else                     e = Scm_TreeIterPrev(iter);
   if (!e) SCM_RETURN(Scm_Values2(args[0], args[0]));
   else    SCM_RETURN(Scm_Values2(SCM_DICT_KEY(e), SCM_DICT_VALUE(e)));
 }"

(define-cproc %tree-map-iter (tm::<tree-map>)
  (body <top>
        (let* ((iter :: ScmTreeIter* (SCM_NEW ScmTreeIter)))
          (Scm_TreeIterInit iter (SCM_TREE_MAP_CORE tm) NULL)
          (result (Scm_MakeSubr tree_map_iter iter 2 0 '"tree-map-iterator")))))

(define-cproc %tree-map-check-consistency (tm::<tree-map>)
  (body <top>
        (Scm_TreeCoreCheckConsistency (SCM_TREE_MAP_CORE tm))
        (result '#t)))

(define-cproc %tree-map-dump (tm::<tree-map>)
  (body <void> (Scm_TreeMapDump tm SCM_CUROUT)))

(define-cproc tree-map-clear! (tm::<tree-map>)
  (body <void> (Scm_TreeCoreClear (SCM_TREE_MAP_CORE tm))))

;;
;; Finds the entry closest to the given key
;;
(define-cise-stmt tree-map-closest-entry
  [(_ inclusive? lh make-result)
   `(let* ([lo :: ScmDictEntry* NULL]
           [hi :: ScmDictEntry* NULL]
           [eq :: ScmDictEntry*
               (Scm_TreeCoreClosestEntries (SCM_TREE_MAP_CORE tm)
                                           (cast intptr_t key)
                                           (& lo) (& hi))])
      (cond
       ,@(if inclusive?
           `([(!= eq NULL)  (,make-result (SCM_DICT_KEY eq) (SCM_DICT_VALUE eq))])
           '())
       [(!= ,lh NULL) (,make-result (SCM_DICT_KEY ,lh) (SCM_DICT_VALUE ,lh))]
       [else          (,make-result key-fb val-fb)]))])

(define-cise-stmt tree-map-closest-key-result
  [(_ k v) `(result ,k)])
(define-cise-stmt tree-map-closest-val-result
  [(_ k v) `(result ,v)])
(define-cise-stmt tree-map-closest-kv-result
  [(_ k v) `(result ,k ,v)])

(define-cproc tree-map-floor
  (tm::<tree-map> key &optional (key-fb #f) (val-fb #f))
  (body (<top> <top>)
        (tree-map-closest-entry #t lo tree-map-closest-kv-result)))
(define-cproc tree-map-floor-key
  (tm::<tree-map> key &optional (key-fb #f))
  (body <top>
        (tree-map-closest-entry #t lo tree-map-closest-key-result)))
(define-cproc tree-map-floor-value
  (tm::<tree-map> key &optional (val-fb #f))
  (body <top>
        (tree-map-closest-entry #t lo tree-map-closest-val-result)))

(define-cproc tree-map-ceiling
  (tm::<tree-map> key &optional (key-fb #f) (val-fb #f))
  (body (<top> <top>)
        (tree-map-closest-entry #t hi tree-map-closest-kv-result)))
(define-cproc tree-map-ceiling-key
  (tm::<tree-map> key &optional (key-fb #f))
  (body <top>
        (tree-map-closest-entry #t hi tree-map-closest-key-result)))
(define-cproc tree-map-ceiling-value
  (tm::<tree-map> key &optional (val-fb #f))
  (body <top>
        (tree-map-closest-entry #t hi tree-map-closest-val-result)))

(define-cproc tree-map-predecessor
  (tm::<tree-map> key &optional (key-fb #f) (val-fb #f))
  (body (<top> <top>)
        (tree-map-closest-entry #f lo tree-map-closest-kv-result)))
(define-cproc tree-map-predecessor-key
  (tm::<tree-map> key &optional (key-fb #f))
  (body <top>
        (tree-map-closest-entry #f lo tree-map-closest-key-result)))
(define-cproc tree-map-predecessor-value
  (tm::<tree-map> key &optional (val-fb #f))
  (body <top>
        (tree-map-closest-entry #f lo tree-map-closest-val-result)))

(define-cproc tree-map-successor
  (tm::<tree-map> key &optional (key-fb #f) (val-fb #f))
  (body (<top> <top>)
        (tree-map-closest-entry #f hi tree-map-closest-kv-result)))
(define-cproc tree-map-successor-key
  (tm::<tree-map> key &optional (key-fb #f))
  (body <top>
        (tree-map-closest-entry #f hi tree-map-closest-key-result)))
(define-cproc tree-map-successor-value
  (tm::<tree-map> key &optional (val-fb #f))
  (body <top>
        (tree-map-closest-entry #f hi tree-map-closest-val-result)))

;;
;; Modules
;;

(define-cproc module? (obj) (call <boolean> "SCM_MODULEP"))

(define-cproc module-name (mod::<module>)
  (expr "SCM_OBJ(SCM_MODULE(mod)->name)"))

(define-cproc module-parents (mod::<module>)
  (expr "mod->parents"))

(define-cproc module-precedence-list (mod::<module>)
  (expr "mod->mpl"))

(define-cproc module-imports (mod::<module>)
  (expr "mod->imported"))

(define-cproc module-exports (mod::<module>)
  (expr "mod->exported"))

(define-cproc module-table (mod::<module>)
  (expr "SCM_OBJ(mod->table)"))

(define-cproc find-module (name::<symbol>)
  (expr <module>? (Scm_FindModule name SCM_FIND_MODULE_QUIET)))

(define-cproc all-modules ()
  (call "Scm_AllModules"))

(define-cproc make-module (name::<symbol>? &keyword (if-exists :error))
  (body <top>
        (let* ((error_if_exists :: int TRUE))
          (cond ((SCM_EQ if-exists ':error) (set! error_if_exists TRUE))
                ((SCM_FALSEP if-exists)     (set! error_if_exists FALSE))
                (else (Scm_TypeError ":if-exists" ":error or #f" if_exists)))
          (result (Scm_MakeModule name error_if_exists)))))

(define-cproc module-name->path (name)
  (body <top>
        (let* ((s :: ScmSymbol* NULL))
          (cond
           ((SCM_SYMBOLP name) (set! s (SCM_SYMBOL name)))
           ((SCM_IDENTIFIERP name) (set! s (-> (SCM_IDENTIFIER name) name)))
           (else (SCM_TYPE_ERROR name "symbol or identifier")))
          (result (Scm_ModuleNameToPath s)))))

(define-cproc path->module-name (path::<string>)
  (call "Scm_PathToModuleName"))

(define-cproc %export-all (module::<module>)
  (call "Scm_ExportAll"))

(define-cproc %extend-module (module::<module> supers::<list>)
  (call "Scm_ExtendModule"))

"static ScmModule *get_module_from_mod_or_name(ScmObj mod_or_name)
 {
   if (SCM_MODULEP(mod_or_name)) return SCM_MODULE(mod_or_name);
   else if (SCM_SYMBOLP(mod_or_name)) {
     return Scm_FindModule(SCM_SYMBOL(mod_or_name), 0);
   } else if (SCM_FALSEP(mod_or_name)) {
     return SCM_CURRENT_MODULE();
   } else {
     Scm_Error(\"module or symbol required, but got: %S\", mod_or_name);
     return NULL;
   }
 }
"

(define-cproc global-variable-bound? (mod-or-name name::<symbol>)
  (expr <boolean>
        (not (SCM_UNBOUNDP
              (Scm_GlobalVariableRef (get_module_from_mod_or_name mod_or_name)
                                     name 0)))))

(define-cproc global-variable-ref (mod_or_name name::<symbol>
                                               &optional
                                               fallback
                                               (stay-in-module::<boolean> #f))
  (body <top>
        (let* ((module :: ScmModule* (get_module_from_mod_or_name mod_or_name))
               (flags  :: int (?: stay_in_module SCM_BINDING_STAY_IN_MODULE 0))
               (r      (Scm_GlobalVariableRef module name flags))
               (r2     (?: (SCM_UNBOUNDP r) fallback r)))
          (when (SCM_UNBOUNDP r2)
            (Scm_Error "global variable %S is not bound in module %S"
                       name module))
          (result r2))))

;;
;; Gauche extentions
;;

;; Utility procedure

(define-cproc %format (port::<output-port> fmt::<string>
                       args shared::<boolean>)
  (call <void> "Scm_Format"))

(define-cproc exit (&optional (code::<fixnum> 0))
  (call <void> "Scm_Exit"))

;;
;; External view of VM.
;;

(define-cclass <thread> "ScmVM" "Scm_VMClass"
  ()
  ((name)
   (specific)
   )
  (printer
   "ScmVM *vm = SCM_VM(obj);
    const char *state;
    switch (vm->state) {
    case SCM_VM_NEW:        state = \"new\"; break;
    case SCM_VM_RUNNABLE:   state = \"runnable\"; break;
    case SCM_VM_BLOCKED:    state = \"blocked\"; break;
    case SCM_VM_TERMINATED: state = \"terminated\"; break;
    default: state = \"(unknown state)\";
    }
    Scm_Printf(port, \"#<thread %S %s %p>\", vm->name, state, vm);")
  )

(define-cproc vm-dump
  (&optional (vm::<thread> (c "SCM_OBJ(Scm_VM())")))
  (body <void> (Scm_VMDump vm)))

(define-cproc vm-get-stack-trace
  (&optional (vm::<thread> (c "SCM_OBJ(Scm_VM())")))
  (expr <top> (Scm_VMGetStack vm)))

(define-cproc vm-get-stack-trace-lite
  (&optional (vm::<thread> (c "SCM_OBJ(Scm_VM())")))
  (expr <top> (Scm_VMGetStackLite vm)))

(define-cproc vm-set-default-exception-handler (vm::<thread> handler)
  (body <void>
        (unless (or (SCM_FALSEP handler) (SCM_PROCEDUREP handler))
          (SCM_TYPE_ERROR handler "a procedure or #f"))
        (set! (-> vm defaultEscapeHandler) handler)))

(define-cproc current-load-history ()
  (expr <top> (-> (Scm_VM) load_history)))
(define-cproc current-load-next ()
  (expr <top> (-> (Scm_VM) load_next)))
(define-cproc current-load-port ()
  (expr <top> (-> (Scm_VM) load_port)))

;; parameter
(define-cproc %vm-make-parameter-slot ()
  (body (<int> <int>)
        (let* ((loc :: ScmParameterLoc))
          (Scm_MakeParameterSlot (Scm_VM) (& loc))
          (set! SCM_RESULT0 (ref loc index)
                SCM_RESULT1 (ref loc id)))))

(define-cproc %vm-parameter-ref (index::<int> id::<int>)
  (body <top>
        (let* ((loc :: ScmParameterLoc))
          (set! (ref loc index) index
                (ref loc id) id)
          (result (Scm_ParameterRef (Scm_VM) (& loc))))))

(define-cproc %vm-parameter-set! (index::<int> id::<int> value)
  (body <top>
        (let* ((loc :: ScmParameterLoc))
          (set! (ref loc index) index
                (ref loc id) id)
          (result (Scm_ParameterSet (Scm_VM) (& loc) value)))))

;;
;; Inspecting feature
;;

;; Obtain info about gauche itself
(define-cproc gauche-version ()
  (expr "SCM_MAKE_STR(GAUCHE_VERSION)"))
(define-cproc gauche-architecture ()
  (expr "SCM_MAKE_STR(GAUCHE_ARCH)"))
(define-cproc gauche-library-directory ()
  (call "Scm_LibraryDirectory"))
(define-cproc gauche-architecture-directory ()
  (call "Scm_ArchitectureDirectory"))
(define-cproc gauche-site-library-directory ()
  (call "Scm_SiteLibraryDirectory"))
(define-cproc gauche-site-architecture-directory ()
  (call "Scm_SiteArchitectureDirectory"))
(define-cproc gauche-dso-suffix ()
  (expr "SCM_MAKE_STR(SHLIB_SO_SUFFIX)"))

;; Other thread stuff is in ext/threads/thrlib.stub
(define-cproc current-thread ()
  (expr "SCM_OBJ(Scm_VM())"))

(define-cproc unwrap-syntax (form)
  (call "Scm_UnwrapSyntax"))

;; foreign pointer
(define-cproc foreign-pointer-attributes (fp::<foreign-pointer>)
  (call "Scm_ForeignPointerAttr"))

(define-cproc foreign-pointer-attribute-get (fp::<foreign-pointer>
                                             key &optional fallback)
  (call "Scm_ForeignPointerAttrGet"))

(define-cproc foreign-pointer-attribute-set (fp::<foreign-pointer>
                                             key value)
  (call "Scm_ForeignPointerAttrSet"))

;;
;; Profiling
;;

;; GC stuff
(define-cproc gc () (call <void> "GC_gcollect"))

(define-cproc gc-stat ()
  (body <top>
        (result
         (list
          (list ':total-heap-size
                (Scm_MakeIntegerFromUI (cast u_long (GC_get_heap_size))))
          (list ':free-bytes
                (Scm_MakeIntegerFromUI (cast u_long (GC_get_free_bytes))))
          (list ':bytes-since-gc
                (Scm_MakeIntegerFromUI (cast u_long (GC_get_bytes_since_gc))))
          (list ':total-bytes
                (Scm_MakeIntegerFromUI (cast u_long (GC_get_total_bytes))))))))

;; Profiler public API
(define-cproc profiler-start () (call <void> "Scm_ProfilerStart"))
(define-cproc profiler-stop  () (call <int>  "Scm_ProfilerStop"))
(define-cproc profiler-reset () (call <void> "Scm_ProfilerReset"))

;; Misc.  WARNING: API may change
(define-cproc subr? (obj)
  (call <boolean> "SCM_SUBRP"))
(define-cproc closure? (obj)
  (call <boolean> "SCM_CLOSUREP"))
(define-cproc toplevel-closure? (obj)
  (expr <boolean>
        (and (SCM_CLOSUREP obj) (== (-> (SCM_CLOSURE obj) env) NULL))))

(define-cproc closure-code (clo::<closure>)
  (expr <top> (-> clo code)))

(define-cproc procedure-info (proc::<procedure>)
  (expr <top> (SCM_PROCEDURE_INFO proc)))


;; Local variables:
;; mode: scheme
;; end:
