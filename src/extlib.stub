;;;
;;; extlib.stub - extra built-ins
;;;
;;;   Copyright (c) 2000-2001 Shiro Kawai (shiro@acm.org)
;;;
;;;   Permission to use, copy, modify, distribute this software and
;;;   accompanying documentation for any purpose is hereby granted,
;;;   provided that existing copyright notices are retained in all
;;;   copies and that this notice is included verbatim in all
;;;   distributions.
;;;   This software is provided as is, without express or implied
;;;   warranty.  In no circumstances the author(s) shall be liable
;;;   for any damages arising out of the use of this software.
;;;
;;; $Id: extlib.stub,v 1.113 2001-11-03 09:56:35 shirok Exp $
;;;

"
#include <gauche/arch.h>
"

;;
;; 6.1  Equivalence predicates
;;

;; to pass the cmpmode argument
(define-symbol eq?    "sym_eq")
(define-symbol eqv?   "sym_eqv")
(define-symbol equal? "sym_equal")

(define-symbol string=? "sym_string_eq") ; used for make-hash-table

"static int getcmpmode(ScmObj opt)
 { if (SCM_UNBOUNDP(opt) || opt == sym_equal) return SCM_CMP_EQUAL;
   if (opt == sym_eq) return SCM_CMP_EQ;
   if (opt == sym_eqv) return SCM_CMP_EQV;
   Scm_Error(\"unrecognized compare mode: %S\", opt);
   return 0; /* dummy */ }"

;;
;; 6.2  Numbers
;;

(define-cproc ash (num cnt)
  (assert (small-integer? cnt))
  "  SCM_RETURN(Scm_Ash(num, cnt));")
(define-cproc lognot (x)
  "  SCM_RETURN(Scm_LogNot(x));")
(define-cproc logand (x y &rest args)
  "  ScmObj cp, r = Scm_LogAnd(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogAnd(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")
(define-cproc logior (x y &rest args)
  "  ScmObj cp, r = Scm_LogIor(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogIor(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")
(define-cproc logxor (x y &rest args)
  "  ScmObj cp, r = Scm_LogXor(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogXor(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")

(define-cproc clamp (x &optional (min #f) (max #f))
  " ScmObj r = x;  int maybe_exact = FALSE;
  if (SCM_EXACTP(x)) maybe_exact = TRUE;
  else if (!SCM_FLONUMP(x)) {
    Scm_Error(\"real number required for x, but got %S\", x);
  }
  if (SCM_EXACTP(min)) {
    if (Scm_NumCmp(x, min) < 0) r = min;
  } else if (SCM_FLONUMP(min)) {
    maybe_exact = FALSE;
    if (Scm_NumCmp(x, min) < 0) r = min;
  } else if (!SCM_FALSEP(min)) {
    Scm_Error(\"real number or #f required for min, but got %S\", min);
  }
  if (SCM_EXACTP(max)) {
    if (Scm_NumCmp(x, max) > 0) r = max;
  } else if (SCM_FLONUMP(max)) {
     maybe_exact = FALSE;
    if (Scm_NumCmp(x, max) > 0) r = max;
  } else if (!SCM_FALSEP(max)) {
    Scm_Error(\"real number or #f required for max, but got %S\", max);
  }
  if (!maybe_exact && SCM_EXACTP(r)) SCM_RETURN(Scm_ExactToInexact(r));
  else SCM_RETURN(r);")

;; just for debug...
(define-cproc %bignum-dump (obj)
  "  if (SCM_BIGNUMP(obj)) Scm_DumpBignum(SCM_BIGNUM(obj), SCM_CUROUT);
  SCM_RETURN(SCM_UNDEFINED);")

;;
;; 6.3.1  Booleans
;;

;;
;; 6.3.2  Pairs and lists
;;

(define-cproc make-list (len &optional (fill #f)) ; SRFI-1
  (assert (small-integer? len))
  "  SCM_RETURN(Scm_MakeList(len, fill));")

(define-cproc acons (caa cda cd)
  "  SCM_RETURN(Scm_Acons(caa, cda, cd));")

(define-cproc last-pair (list)          ; SRFI-1
  (assert (pair? list))
  "  SCM_RETURN(Scm_LastPair(list));")

(define-cproc list-copy (list)          ; SRFI-1
  "  SCM_RETURN(Scm_CopyList(list));")

(define-cproc list* (&rest args)
  (inliner "SCM_VM_LIST_STAR")
  "  ScmObj head = SCM_NIL, tail, cp;
  if (SCM_PAIRP(args)) {
    SCM_FOR_EACH(cp, args) {
      if (!SCM_PAIRP(SCM_CDR(cp))) {
        if (SCM_NULLP(head)) head = SCM_CAR(cp);
        else SCM_SET_CDR(tail, SCM_CAR(cp));
        break;
      }
      SCM_APPEND1(head, tail, SCM_CAR(cp));
    }
  }
  SCM_RETURN(head);")

(define-cproc %delete (obj list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_Delete(obj, list, getcmpmode(cmpmode)));")

(define-cproc %delete! (obj list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_DeleteX(obj, list, getcmpmode(cmpmode)));")

(define-cproc %delete-duplicates (list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_DeleteDuplicates(list, getcmpmode(cmpmode)));")

(define-cproc %delete-duplicates! (list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_DeleteDuplicatesX(list, getcmpmode(cmpmode)));")

(define-cproc %alist-delete (elt list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_AssocDelete(elt, list, getcmpmode(cmpmode)));")

(define-cproc %alist-delete! (elt list &optional cmpmode)
  (assert (list? list))
  "  SCM_RETURN(Scm_AssocDeleteX(elt, list, getcmpmode(cmpmode)));")

;; SRFI-1 has this.
;(define-cproc union (&rest args)        ;use eq? to compare.
;  (assert (list? args))
;  "  ScmObj set, ap;
;  if (SCM_NULLP(args)) SCM_RETURN(SCM_NIL);
;  set = SCM_CAR(args);
;  SCM_FOR_EACH(ap, SCM_CDR(args))
;    set = Scm_Union(set, SCM_CAR(ap));
;  SCM_RETURN(set);")

(define-cproc append! (&rest list)
  "  ScmObj cp, h = SCM_NIL, t;
  SCM_FOR_EACH(cp, list) SCM_APPEND(h, t, SCM_CAR(cp));
  SCM_RETURN(h);")

(define-cproc reverse! (list)
  "  SCM_RETURN(Scm_ReverseX(list));")

(define-cproc sort (list &optional (fn #f))
  "  SCM_RETURN(Scm_SortList(list, fn));")

(define-cproc sort! (list &optional (fn #f))
  "  SCM_RETURN(Scm_SortListX(list, fn));")

;(define-cproc topological-sort (edges)
;  (assert (list? edges))
;  "  SCM_RETURN(Scm_TopologicalSort(edges));")

;; TODO: this doesn't work properly.  Find the cause.
"
static ScmObj monotonic_merge_cb(ScmObj elt, void *data)
{
    ScmObj proc = SCM_OBJ(data);
    return Scm_Apply(proc, SCM_LIST1(elt));
}
"

(define-cproc monotonic-merge (start sequences get-super)
  (assert (list? sequences))
  (assert (procedure? get-super))
  "  SCM_RETURN(Scm_MonotonicMerge(start, sequences,
                                   monotonic_merge_cb, (void*)get_super));")

(define-cproc pair-attributes (pair)
  (assert (pair? pair))
  "  SCM_RETURN(SCM_PAIR_ATTR(pair));")

(define-cproc pair-attribute-get (pair key &optional fallback)
  (assert (pair? pair))
  "  SCM_RETURN(Scm_PairAttrGet(SCM_PAIR(pair), key, fallback));")

(define-cproc pair-attribute-set! (pair key value)
  (assert (pair? pair))
  "  SCM_RETURN(Scm_PairAttrSet(SCM_PAIR(pair), key, value));")

;;
;; 6.3.3  Symbols
;;

(define-cproc symbol-bound? (symbol &optional module)
  (assert (symbol? symbol))
  "  
  if (module == SCM_UNBOUND) {
     module = SCM_OBJ(SCM_CURRENT_MODULE());
  } else if (!SCM_MODULEP(module)) {
     Scm_Error(\"module required, but got %S\", module);
  }
  if (Scm_SymbolValue(SCM_MODULE(module), symbol) == SCM_UNBOUND)
     SCM_RETURN(SCM_FALSE);
  else
     SCM_RETURN(SCM_TRUE);")

(define-cproc gensym (&optional prefix)
  "  ScmString *p = NULL;
  if (prefix != SCM_UNBOUND) {
    if (!SCM_STRINGP(prefix))
      Scm_Error(\"string expected, but got %S\", prefix);
    p = SCM_STRING(prefix);
  }
  SCM_RETURN(Scm_Gensym(p));")

;; keywords
(define-cproc keyword? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_KEYWORDP(obj)));")

(define-cproc make-keyword (name)
  "   ScmString *sname;
  if (SCM_STRINGP(name)) sname = SCM_STRING(name);
  else if (SCM_SYMBOLP(name)) sname = SCM_SYMBOL_NAME(name);
  else Scm_Error(\"string or symbol required, but got %S\", name);
  SCM_RETURN(Scm_MakeKeyword(sname));")

(define-cproc get-keyword (key list &optional fallback)
  "  SCM_RETURN(Scm_GetKeyword(key, list, fallback));")

;; identifiers
(define-cproc identifier? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_IDENTIFIERP(obj)));")

(define-cproc identifier->symbol (obj)
  (assert (identifier? obj))
  "  SCM_RETURN(SCM_OBJ(SCM_IDENTIFIER(obj)->name));")

;;
;; 6.3.4  Characters
;;

(define-cproc digit->integer (ch &optional (radix 10))
  (assert (char? ch))
  (assert (small-integer? radix))
  "  int r;
  if (radix < 2 || radix > 36)
     Scm_Error(\"radix must be between 2 and 36, but got %d\", radix);
  r = Scm_DigitToInt(ch, radix);
  return (r >= 0 ? SCM_MAKE_INT(r) : SCM_FALSE);")

(define-cproc integer->digit (n &optional (radix 10))
  (assert (small-integer? radix))
  (assert (small-integer? n))
  "  ScmChar r;
  if (radix < 2 || radix > 36)
     Scm_Error(\"radix must be between 2 and 36, but got %d\", radix);
  r = Scm_IntToDigit(n, radix);
  return (r == SCM_CHAR_INVALID? SCM_FALSE : SCM_MAKE_CHAR(r));")

(define-cproc gauche-character-encoding ()
  "  SCM_RETURN(Scm_CharEncodingName());")

(define-cproc supported-character-encodings ()
  "  SCM_RETURN(Scm_ConstCStringArrayToList(Scm_SupportedCharacterEncodings(), -1));")

(define-cproc supported-character-encoding? (encoding)
  (assert (string? encoding))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_SupportedCharacterEncodingP(Scm_GetStringConst(encoding))));")

;; character sets (SRFI-14)
;;   not all of srfi-14 functions are defined in C.  you need to load
;;   srfi-14.scm to get a full set of functions.

(define-symbol *char-code-max* "char_code_max"
  "Scm_MakeInteger(SCM_CHAR_MAX)")

(define-cproc char-set? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHARSETP(obj)));")

"static void char_set_add(ScmCharSet *cs, ScmObj chars)
 {  ScmObj cp; ScmChar ch;
  SCM_FOR_EACH(cp, chars) {
    if (!SCM_CHARP(SCM_CAR(cp)))
      Scm_Error(\"character required, but got %S\", SCM_CAR(cp));
    ch = SCM_CHAR_VALUE(SCM_CAR(cp));
    Scm_CharSetAddRange(cs, ch, ch);
  }
 }"

(define-cproc %char-set-equal? (x y)
  (assert (char-set? x))
  (assert (char-set? y))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_CharSetEq(x, y)));")

(define-cproc char-set (&rest chars)
  "  ScmCharSet *cs = SCM_CHARSET(Scm_MakeEmptyCharSet());
  char_set_add(cs, chars);
  SCM_RETURN(SCM_OBJ(cs));")

(define-cproc char-set-copy (cs)
  (assert (char-set? cs))
  "  SCM_RETURN(Scm_CopyCharSet(cs));")

(define-cproc %char-set-add-chars! (cs chars)
  (assert (char-set? cs))
  (assert (list? chars))
  "  char_set_add(cs, chars); SCM_RETURN(SCM_OBJ(cs));")

(define-cproc %char-set-add-range! (cs from to)
  (assert (char-set? cs))
  "  long fromc = -1, toc = -1;
  if (SCM_EXACTP(from)) fromc = Scm_GetInteger(from);
  else if (SCM_CHARP(from)) fromc = SCM_CHAR_VALUE(from);
  if (fromc < 0) Scm_Error(\"character or positive integer required, but got %S\", from);
  if (fromc >= SCM_CHAR_MAX) Scm_Error(\"argument out of range: %S\", from);
  if (SCM_EXACTP(to)) toc = Scm_GetInteger(to);
  else if (SCM_CHARP(to)) toc = SCM_CHAR_VALUE(to);
  if (toc < 0) Scm_Error(\"character or positive integer required, but got %S\", to);
  if (toc >= SCM_CHAR_MAX) Scm_Error(\"argument out of range: %S\", to);
  SCM_RETURN(Scm_CharSetAddRange(cs, (ScmChar)fromc, (ScmChar)toc));")

(define-cproc %char-set-add! (dst src)
  (assert (char-set? dst))
  (assert (char-set? src))
  "  SCM_RETURN(Scm_CharSetAdd(dst, src));")

(define-cproc char-set-contains? (cs ch)
  (assert (char-set? cs))
  (assert (char? ch))
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_CharSetContains(cs, ch)));")

(define-cproc %char-set-complement! (cs)
  (assert (char-set? cs))
  "  SCM_RETURN(Scm_CharSetComplement(cs));")

(define-cproc %char-set-ranges (cs)
  (assert (char-set? cs))
  "  SCM_RETURN(Scm_CharSetRanges(cs));")

(define-cproc %char-set-predefined (num)
  (assert (small-integer? num))
  "  SCM_RETURN(Scm_GetStandardCharSet(num));")

(define-cproc %char-set-dump (cs);for debug
  (assert (char-set? cs))
  "  Scm_CharSetDump(cs, SCM_CUROUT); SCM_RETURN(SCM_UNDEFINED);")

;;
;; 6.3.5 Strings
;;

(define-cproc string-incomplete? (obj)    ;gauche specific
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRINGP(obj)&&SCM_STRING_INCOMPLETE_P(obj)));")
(define-cproc string-immutable? (obj)   ;gauche specific
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRINGP(obj)&&SCM_STRING_IMMUTABLE_P(obj)));")

(define-cproc string-complete->incomplete! (str) ;gauche specific
  (assert (string? str))
  "  SCM_RETURN(Scm_StringCompleteToIncompleteX(str));")
(define-cproc string-incomplete->complete! (str) ;gauche specific
  (assert (string? str))
  "  SCM_RETURN(Scm_StringIncompleteToCompleteX(str));")
(define-cproc string-complete->incomplete (str) ;gauche specific
  (assert (string? str))
  "  SCM_RETURN(Scm_StringCompleteToIncomplete(str));")
(define-cproc string-incomplete->complete (str) ;gauche specific
  (assert (string? str))
  "  SCM_RETURN(Scm_StringIncompleteToComplete(str));")

(define-cproc string-size (str)         ;gauche specific
  (assert (string? str))
  "  SCM_RETURN(SCM_MAKE_INT(SCM_STRING_SIZE(str)));")

(define-cproc string-byte-ref (str k &optional fallback)   ;gauche specific
  (assert (string? str))
  (assert (small-integer? k))
  "  int r;
  if (!SCM_UNBOUNDP(fallback) && (k < 0 || k >= SCM_STRING_SIZE(str))) {
    SCM_RETURN(fallback);
  } else {
    r = Scm_StringByteRef(str, k);
    SCM_RETURN(SCM_MAKE_INT(r));
  }")

(define-cproc string-byte-set! (str k b) ;gauche specific
  (assert (string? str))
  (assert (small-integer? k))
  (assert (small-integer? b))
  "  SCM_RETURN(Scm_StringByteSet(str, k, b));")

(define-cproc string-substitute! (target start str)
  (assert (string? target))
  (assert (string? str))
  (assert (small-integer? start))
  "  ScmObj r = Scm_StringSubstitute(target, start, str);
  if (!SCM_STRINGP(r)) Scm_Error(\"argument out of range: (%d %S)\", start, str);
  SCM_RETURN(r);")

(define-cproc %maybe-substring (str &optional start end)
  (assert (string? str))
  "  SCM_RETURN(Scm_MaybeSubstring(str, start, end));")

(define-symbol infix "sym_infix")
(define-symbol strict-infix "sym_strict_infix")
(define-symbol suffix "sym_suffix")
(define-symbol prefix "sym_prefix")

(define-cproc string-join (strs &optional (delim " ") grammer)
  (assert (list? strs))
  (assert (string? delim))
  "  int gm = 0;
  if (SCM_UNBOUNDP(grammer) || SCM_UNDEFINEDP(grammer) || grammer == sym_infix)
    gm = SCM_STRING_JOIN_INFIX;
  else if (grammer == sym_strict_infix)
    gm = SCM_STRING_JOIN_STRICT_INFIX;
  else if (grammer == sym_suffix)
    gm = SCM_STRING_JOIN_SUFFIX;
  else if (grammer == sym_prefix)
    gm = SCM_STRING_JOIN_PREFIX;
  else Scm_Error(\"invalid grammer specification: %S\", grammer);
  SCM_RETURN(Scm_StringJoin(strs, delim, gm));")

(define-cproc %hash-string (str bound) ; for SRFI-13
  (assert (string? str))
  "  unsigned long modulo = 0;
  if (SCM_UNDEFINEDP(bound)) modulo = SCM_SMALL_INT_MAX;
  else if (SCM_INTP(bound)) modulo = SCM_INT_VALUE(bound);
  else if (SCM_BIGNUMP(bound)) modulo = Scm_BignumToUI(SCM_BIGNUM(bound));
  if (modulo == 0) Scm_Error(\"argument out of domain: %S\", bound);
  SCM_RETURN(Scm_MakeInteger(Scm_HashString(str, modulo)));")

;; TODO: allow string/charset/regexp in ch
(define-cproc string-split (s ch)
  (assert (string? s))
  (assert (char? ch))
  "  SCM_RETURN(Scm_StringSplitByChar(s, ch));")

;; primitive scanner
(define-symbol index   "sym_index")
(define-symbol before  "sym_before")
(define-symbol after   "sym_after")
(define-symbol before* "sym_before2")
(define-symbol after*  "sym_after2")
(define-symbol both    "sym_both")

(define-cproc string-scan (s1 s2 &optional (mode (c "sym_index")))
  (assert (string? s1))
  "  int retmode = 0;
  if (mode == sym_index)         retmode = SCM_STRING_SCAN_INDEX;
  else if (mode == sym_before)   retmode = SCM_STRING_SCAN_BEFORE;
  else if (mode == sym_after)    retmode = SCM_STRING_SCAN_AFTER;
  else if (mode == sym_before2)  retmode = SCM_STRING_SCAN_BEFORE2;
  else if (mode == sym_after2)   retmode = SCM_STRING_SCAN_AFTER2;
  else if (mode == sym_both)     retmode = SCM_STRING_SCAN_BOTH;
  else {
    Scm_Error(\"bad value in mode argumet: %S, must be one of 'index, 'before, 'after, 'before*, 'after* or 'both.\", mode);
  }
  if (SCM_STRINGP(s2)) {
     SCM_RETURN(Scm_StringScan(s1, SCM_STRING(s2), retmode));
  } else if (SCM_CHARP(s2)) {
     SCM_RETURN(Scm_StringScanChar(s1, SCM_CHAR_VALUE(s2), retmode));
  } else {
     Scm_Error(\"bad type of argument for s2: %S, must be either string or character\", s2);
     SCM_RETURN(SCM_UNDEFINED); /* dummy */
  }")
  

;; string pointer
(define-type "string-pointer" string-pointer?
  "ScmStringPointer*" "SCM_STRING_POINTERP" "SCM_STRING_POINTER")

(define-cproc make-string-pointer (str &optional (index 0) (start 0) (end -1))
  (assert (string? str))
  (assert (small-integer? index))
  (assert (small-integer? start))
  (assert (small-integer? end))
  "  SCM_RETURN(Scm_MakeStringPointer(str, index, start, end));")
(define-cproc string-pointer? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRING_POINTERP(obj)));")

(define-cproc string-pointer-next! (sp)
  (assert (string-pointer? sp))
  "  SCM_RETURN(Scm_StringPointerNext(sp));")
(define-cproc string-pointer-prev! (sp)
  (assert (string-pointer? sp))
  "  SCM_RETURN(Scm_StringPointerPrev(sp));")
(define-cproc string-pointer-set! (sp index)
  (assert (string-pointer? sp))
  (assert (small-integer? index))
  "  SCM_RETURN(Scm_StringPointerSet(sp, index));")
(define-cproc string-pointer-substring (sp &keyword (after #f))
  (assert (string-pointer? sp))
  "  SCM_RETURN(Scm_StringPointerSubstring(sp, !SCM_FALSEP(after)));")
(define-cproc string-pointer-index (sp)
  (assert (string-pointer? sp))
  "  SCM_RETURN(Scm_MakeInteger(sp->index));")

;; Regexp
(define-cproc string->regexp (str)
  (assert (string? str))
  "  SCM_RETURN(Scm_RegComp(str));")

(define-cproc rxmatch (regexp str)
  (assert (string? str))
  "  ScmRegexp *rx = NULL;
  if (SCM_STRINGP(regexp)) rx = SCM_REGEXP(Scm_RegComp(SCM_STRING(regexp)));
  else if (SCM_REGEXPP(regexp)) rx = SCM_REGEXP(regexp);
  else Scm_Error(\"regexp required, but got %S\", regexp);
  SCM_RETURN(Scm_RegExec(rx, str));")

(define-cproc rxmatch-substring (match &optional (i 0))
  (assert (small-integer? i))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchSubstr(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-start (match &optional (i 0))
  (assert (small-integer? i))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchStart(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-end (match &optional (i 0))
  (assert (small-integer? i))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchEnd(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-before (match &optional (i 0))
  (assert (small-integer? i))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchBefore(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-after (match &optional (i 0))
  (assert (small-integer? i))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchAfter(SCM_REGMATCH(match), i));")

(define-cproc %regexp-dump (rx)
  "  if (!SCM_REGEXPP(rx)) Scm_Error(\"regexp required, but got %S\", rx);
  Scm_RegDump(SCM_REGEXP(rx));  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc %regmatch-dump (rm)
  "  if (!SCM_REGMATCHP(rm)) Scm_Error(\"regmatch required, but got %S\", rm);
  Scm_RegMatchDump(SCM_REGMATCH(rm));  SCM_RETURN(SCM_UNDEFINED);")

;;
;; 6.3.6  Vectors
;;

;;
;; 6.4  Control Features
;;

(define-cproc setter (proc)             ;SRFI-17
  (assert (procedure? proc))
  (inliner "SCM_VM_SETTER")
  "  SCM_RETURN(Scm_Setter(proc));"
  (setter (proc setter)
    (assert (procedure? proc))
    (assert (procedure? setter))
    "  Scm_SetterSet(proc, setter, FALSE); SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc identity (val)            ;sometimes useful
  "SCM_RETURN(val);")

;;
;; 6.6.1  Ports
;;

(define-cproc open-input-string (string) ;SRFI-6
  (assert (string? string))
  "  SCM_RETURN(Scm_MakeInputStringPort(string));")

(define-cproc open-output-string ()      ;SRFI-6
  "  SCM_RETURN(Scm_MakeOutputStringPort());")

(define-cproc get-output-string (oport) ;SRFI-6
  (assert (output-port? oport))
  "  if (SCM_PORT_TYPE(oport) != SCM_PORT_OSTR)
        Scm_Error(\"output string port required, but got: %S\", oport);
  SCM_RETURN(Scm_GetOutputString(oport));")
 
"static int bufport_filler(char *buf, int siz, void *data)
 {
    /* no need to use VMApply; we're in the C callback */
    ScmObj r = Scm_Apply(SCM_OBJ(data), SCM_LIST1(Scm_MakeInteger(siz)));
    if (SCM_EOFP(r) || SCM_FALSEP(r)) {
       return -1;
    } else if (!SCM_STRINGP(r)) {
       Scm_Error(\"buffered port callback procedure returned non-string: %S\", r);
    }
    memcpy(buf, SCM_STRING_START(r), SCM_STRING_SIZE(r));
    return SCM_STRING_SIZE(r);
 }"

(define-cproc open-input-buffered-port (filler buffer-size)
  (assert (procedure? filler))
  (assert (small-integer? buffer-size))
  "  SCM_RETURN(Scm_MakeBufferedPort(SCM_PORT_INPUT, buffer_size, 0, NULL, bufport_filler, filler));")

"static int bufport_flusher(char *buf, int siz, void *data)
 {
   if (buf == NULL) {
     Scm_Apply(SCM_OBJ(data), SCM_LIST1(SCM_FALSE));
     return 0;
   } else {
     ScmObj s = Scm_MakeString(buf, siz, siz, SCM_MAKSTR_INCOMPLETE|SCM_MAKSTR_COPYING);
     Scm_Apply(SCM_OBJ(data), SCM_LIST1(s));
     return siz;
   }
 }"

(define-cproc open-output-buffered-port (flusher buffer-size)
  (assert (procedure? flusher))
  (assert (small-integer? buffer-size))
  "  SCM_RETURN(Scm_MakeBufferedPort(SCM_PORT_OUTPUT, buffer_size, 0, NULL, bufport_flusher, flusher));")

(define-cproc flush (&optional (oport (current-output-port)))
  (assert (output-port? oport))
  "  Scm_Flush(oport);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc port-closed? (obj)
  (assert (port? obj))
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_PORT_CLOSED_P(obj)));")

(define-cproc current-error-port ()     ;gauche extention
  "  SCM_RETURN(SCM_OBJ(SCM_CURERR));")

(define-cproc standard-input-port ()
  "  SCM_RETURN(Scm_Stdin());")

(define-cproc standard-output-port ()
  "  SCM_RETURN(Scm_Stdout());")

(define-cproc standard-error-port ()
  "  SCM_RETURN(Scm_Stderr());")

(define-cproc with-input-from-port (port thunk)
  (assert (input-port? port))
  (assert (procedure? thunk))
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CURIN, FALSE));")

(define-cproc with-output-to-port (port thunk)
  (assert (output-port? port))
  (assert (procedure? thunk))
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CUROUT, FALSE));")

(define-cproc with-error-to-port (port thunk)
  (assert (output-port? port))
  (assert (procedure? thunk))
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CURERR, FALSE));")

(define-cproc port-name (port)
  (assert (port? port))
  "  SCM_RETURN(Scm_PortName(port));")

(define-cproc port-current-line (port)
  (assert (port? port))
  "  int i = Scm_PortLine(port);
  SCM_RETURN(Scm_MakeInteger(i));")

(define-cproc port-current-column (port)
  (assert (port? port))
  "  int i = Scm_PortPosition(port);
  SCM_RETURN(Scm_MakeInteger(i));")

(define-cproc port-file-number (port)
  (assert (port? port))
  "  int i = Scm_PortFileNo(port);
  SCM_RETURN((i < 0)? SCM_FALSE : Scm_MakeInteger(i));")

;; transfer units for copy-port
(define-symbol char "sym_char")
(define-symbol byte "sym_byte")
"#define COPY_PORT_BUFSIZ 1024"

(define-cproc copy-port (src dst &keyword (unit 0))
  (assert (input-port? src))
  (assert (output-port? dst))
  "  int ncopied = 0, bufsiz; char buf[COPY_PORT_BUFSIZ], *p = buf;
  if (SCM_SYMBOLP(unit)) {
    if (SCM_EQ(unit, sym_char)) {
      ScmChar c;
      for (;;) {
        SCM_GETC(c, src); if (c == EOF) break; SCM_PUTC(c, dst); ncopied++;
      }
    } else if (SCM_EQ(unit, sym_byte)) {
      int b;
      for (;;) {
        SCM_GETB(b, src); if (b == EOF) break; SCM_PUTB(b, dst); ncopied++;
      }
    } else {
      Scm_Error(\"unknown unit specification: %S\", unit);
    }
  } else if (!(SCM_INTP(unit) && (bufsiz = SCM_INT_VALUE(unit)) >= 0)) {
    Scm_Error(\"unit must be 'char, 'byte, or zero or positive integer: %S\", unit);
  } else {
    if (bufsiz == 0) bufsiz = COPY_PORT_BUFSIZ;
    else if (bufsiz > COPY_PORT_BUFSIZ) p = SCM_NEW_ATOMIC2(char*, bufsiz);
    for (;;) {
      int nread = Scm_Getz(p, bufsiz, src);
      if (nread <= 0) break;
      Scm_Putz(p, nread, dst);
      ncopied += nread;
    }
  }
  SCM_RETURN(SCM_MAKE_INT(ncopied));")

(define-cproc port->string (port)       ;scsh, stk
  (assert (input-port? port))
  "  ScmChar ch; ScmPort *out = SCM_PORT(Scm_MakeOutputStringPort());
  for (;;) {
    SCM_GETC(ch, port);
    if (ch == EOF) break;
    SCM_PUTC(ch, out);
  }
  SCM_RETURN(Scm_GetOutputString(out));")

(define-cproc port->byte-string (port)
  (assert (input-port? port))
  ;; TODO: use chunked I/O if appropriate
  " int b; ScmPort *out = SCM_PORT(Scm_MakeOutputStringPort());
  for (;;) {
    SCM_GETB(b, port);
    if (b == EOF) break;
    SCM_PUTB(b, out);
  }
  SCM_RETURN(Scm_GetOutputString(out));")

;;
;; 6.6.2  Input
;;

(define-cproc read-byte (&optional (port (current-input-port)))
  (assert (input-port? port))
  "  int b; SCM_GETB(b, port);
  SCM_RETURN((b < 0)? SCM_EOF : SCM_MAKE_INT(b));")

(define-cproc read-line (&optional (port (current-input-port)))
  (assert (input-port? port))
  "  SCM_RETURN(Scm_ReadLine(port));")

(define-cproc read-block (bytes &optional (port (current-input-port)))
  (assert (input-port? port))
  (assert (small-integer? bytes))
  "  char *buf; int nread;
  if (bytes <= 0) Scm_Error(\"bytes must be non-zero positive integer: %d\", bytes);
  buf = SCM_NEW_ATOMIC2(char*, bytes);
  nread = Scm_Getz(buf, bytes, port);
  if (nread <= 0) {
    SCM_RETURN(SCM_EOF);
  } else {
    SCM_RETURN(Scm_MakeString(buf, nread, nread, SCM_MAKSTR_INCOMPLETE));
  }")

(define-cproc define-reader-ctor (symbol proc)
  "  SCM_RETURN(Scm_DefineReaderCtor(symbol, proc));")

;;
;; 6.6.3  Output
;;

(define-cproc write-byte (byte &optional (port (current-output-port)))
  (assert (small-integer? byte))
  (assert (output-port? port))
  "  if (byte < 0 || byte > 255) Scm_Error(\"argument out of range: %d\", byte);
  SCM_PUTB(byte, port);
  SCM_RETURN(SCM_MAKE_INT(1));")

(define-cproc write-limited (obj limit &optional (port (current-output-port)))
  (assert (small-integer? limit))
  "  int n = Scm_WriteLimited(obj, port, SCM_WRITE_WRITE, limit);
  SCM_RETURN(SCM_MAKE_INT(n));")

(define-cproc write* (obj &optional (port (current-output-port)))
  "  int n = Scm_WriteCircular(obj, port, SCM_WRITE_WRITE, 0);
  SCM_RETURN(SCM_MAKE_INT(n));")

;;
;; 6.6.4  System Interface
;;

(define-cproc load-from-port (port)
  (assert (input-port? port))
  "  SCM_RETURN(Scm_VMLoadFromPort(port));")

(define-cproc %add-load-path (path &optional (afterp #f))
  (assert (string? path))
  "  const char *cpath = Scm_GetStringConst(path);
  SCM_RETURN(Scm_AddLoadPath(cpath, !SCM_FALSEP(afterp)));")

(define-cproc dynamic-load (file &keyword
                                 (init-function #f)
                                 (export-symbols #f))
  (assert (string? file))
  "  SCM_RETURN(Scm_DynLoad(file, init_function, !SCM_FALSEP(export_symbols)));")

(define-cproc %require (feature)
  "  SCM_RETURN(Scm_Require(feature));")
(define-cproc provide (feature)
  "  SCM_RETURN(Scm_Provide(feature));")
(define-cproc provided? (feature)
  "  SCM_RETURN(Scm_ProvidedP(feature));")

(define-cproc %make-autoload (sym path)
  (assert (symbol? sym))
  (assert (string? path))
  "  SCM_RETURN(Scm_MakeAutoload(sym, path));")

(define-cproc undefined ()
  "  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc undefined? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_UNDEFINEDP(obj)));")

;;
;; Hashtable
;;

;; TODO: support user-defined hashfn and cmpfn
(define-cproc make-hash-table (&optional (type (c "sym_eq")))
  (assert (symbol? type))
  "  ScmHashProc htype = 0;
  if (SCM_OBJ(type) == sym_eq)             htype = (ScmHashProc)SCM_HASH_ADDRESS;
  else if (SCM_OBJ(type) == sym_eqv)       htype = (ScmHashProc)SCM_HASH_EQV;
  else if (SCM_OBJ(type) == sym_equal)     htype = (ScmHashProc)SCM_HASH_EQUAL;
  else if (SCM_OBJ(type) == sym_string_eq) htype = (ScmHashProc)SCM_HASH_STRING;
  else {
    Scm_Error(\"unsupported hash type: %S\", type);
  }
  SCM_RETURN(Scm_MakeHashTable(htype, NULL, 0));")

(define-cproc hash-table? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_HASHTABLEP(obj)));")

(define-cproc hash-table-get (hash key &optional defval)
  (assert (hash-table? hash))
  "  ScmHashEntry *e = Scm_HashTableGet(hash, key);
  if (!e || e->value == SCM_UNBOUND) {
    if (defval != SCM_UNBOUND) SCM_RETURN(defval);
    else Scm_Error(\"hash table doesn't have an entry for key %S\", key);
  }
  SCM_RETURN(e->value);")

(define-cproc hash-table-put! (hash key value)
  (assert (hash-table? hash))
  "  Scm_HashTablePut(hash, key, value);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc hash-table-exists? (hash key)
  (assert (hash-table? hash))
  " if (Scm_HashTableGet(hash, key) != NULL) 
    SCM_RETURN(SCM_TRUE);
  else
    SCM_RETURN(SCM_FALSE);")

"static ScmObj hash_table_iter_cc(ScmObj result, void **data)
 {
  ScmHashIter *iter = (ScmHashIter*)(data[0]);
  ScmProcedure *p = SCM_PROCEDURE(data[1]);
  ScmHashEntry *e = Scm_HashIterNext(iter);

  if (e) {
    void *ndata[4]; ndata[0] = iter; ndata[1] = p; ndata[2] = data[2];
    if (SCM_UNDEFINEDP(data[2])) {
      /* for each */
      Scm_VMPushCC(hash_table_iter_cc, ndata, 3);
    } else {
      /* map */
      if (SCM_NULLP(data[3])) {
        ndata[3] = data[2];
      } else {
        SCM_SET_CDR(data[3], SCM_LIST1(result));
        ndata[3] = SCM_CDR(data[3]);
      }
      Scm_VMPushCC(hash_table_iter_cc, ndata, 4);
    }
    SCM_RETURN(Scm_VMApply2(SCM_OBJ(p), e->key, e->value));
  } else {
    /* end */
    if (SCM_UNDEFINEDP(data[2])) {
      SCM_RETURN(SCM_UNDEFINED);
    } else {
      SCM_RETURN(SCM_CDR(data[2]));
    }
  }
 }"

(define-cproc hash-table-for-each (hash proc)
  (assert (hash-table? hash))
  (assert (procedure? proc))
  "  void *data[3];
  ScmHashIter *iter = SCM_NEW(ScmHashIter);
  Scm_HashIterInit(hash, iter);
  data[0] = iter; data[1] = proc; data[2] = SCM_UNDEFINED;
  SCM_RETURN(hash_table_iter_cc(SCM_UNDEFINED, data));")

(define-cproc hash-table-map (hash proc)
  (assert (hash-table? hash))
  (assert (procedure? proc))
  "  void *data[4];
  ScmHashIter *iter = SCM_NEW(ScmHashIter);
  Scm_HashIterInit(hash, iter);
  data[0] = iter; data[1] = proc; data[2] = Scm_Cons(SCM_NIL, SCM_NIL);
  data[3] = SCM_NIL;
  SCM_RETURN(hash_table_iter_cc(SCM_NIL, data));")

(define-cproc hash-table-keys (hash)
  (assert (hash-table? hash))
  "  SCM_RETURN(Scm_HashTableKeys(hash));")

(define-cproc hash-table-values (hash)
  (assert (hash-table? hash))
  "  SCM_RETURN(Scm_HashTableValues(hash));")

(define-cproc hash-table-stat (hash)
  (assert (hash-table? hash))
  "  SCM_RETURN(Scm_HashTableStat(hash));")

;;
;; Modules
;;

(define-cproc module? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_MODULEP(obj)));")

(define-cproc module-name (mod)
  (assert (module? mod))
  "  SCM_RETURN(SCM_OBJ(SCM_MODULE(mod)->name));")

(define-cproc module-parent (mod)
  (assert (module? mod))
  "  SCM_RETURN(mod->parent? SCM_OBJ(mod->parent) : SCM_FALSE);")

(define-cproc module-imports (mod)
  (assert (module? mod))
  "  SCM_RETURN(mod->imported);")

(define-cproc module-exports (mod)
  (assert (module? mod))
  "  SCM_RETURN(mod->exported);")

(define-cproc module-table (mod)
  (assert (module? mod))
  "  SCM_RETURN(SCM_OBJ(mod->table));")

(define-cproc find-module (name)
  (assert (symbol? name))
  "  SCM_RETURN(Scm_FindModule(name, FALSE));")

(define-cproc all-modules ()
  "  SCM_RETURN(Scm_AllModules());")

(define-cproc %export-all ()
  "  SCM_RETURN(Scm_ExportAll(SCM_CURRENT_MODULE()));")

;;
;; Gauche extentions
;;

;; Utility procedure
(define-cproc format (port fmt &rest args)
  (assert (string? fmt))
  "  SCM_RETURN(Scm_Format(port, fmt, args));")

(define-cproc exit (&optional (code 0))
  (assert (small-integer? code))
  "  Scm_Exit(code);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc error (reason &rest args)
  (assert (string? reason))
  "  SCM_RETURN(Scm_SError(reason, args));")

(define-cproc errorf (fmt &rest args)
  "  SCM_RETURN(Scm_FError(fmt, args));")

(define-cproc with-error-handler (handler thunk)
  "  if (!SCM_PROCEDURE_TAKE_NARG_P(handler, 1)) {
    Scm_Error(\"error handler must take at least 1 argument, but got %S\",
              handler);
  }
  if (!SCM_PROCEDURE_TAKE_NARG_P(thunk, 0)) {
    Scm_Error(\"thunk required, but got %S\", thunk);
  }
  SCM_RETURN(Scm_VMWithErrorHandler(handler, thunk));")

;;
;; Inspecting feature
;;

;; Obtain info about gauche itself
(define-cproc gauche-version ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_VERSION));")
(define-cproc gauche-architecture ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_ARCH));")
(define-cproc gauche-library-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_LIB_DIR));")
(define-cproc gauche-architecture-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_ARCH_DIR));")
(define-cproc gauche-site-library-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_SITE_LIB_DIR));")
(define-cproc gauche-site-architecture-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_SITE_ARCH_DIR));")

;; VM stuff
(define-cproc current-vm ()
  "  SCM_RETURN(SCM_OBJ(Scm_VM()));")

(define-cproc vm-dump (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  Scm_VMDump(SCM_VM(vm));
  SCM_RETURN(SCM_UNDEFINED); ")

(define-cproc vm-get-stack-trace (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  SCM_RETURN(Scm_VMGetStack(SCM_VM(vm)));")

(define-cproc vm-get-stack-trace-lite (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  SCM_RETURN(Scm_VMGetStackLite(SCM_VM(vm)));")

(define-cproc vm-set-default-exception-handler (vm handler)
  "  if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  if (!SCM_FALSEP(handler) && !SCM_PROCEDUREP(handler)) {
    Scm_Error(\"a procedure or #f required, but got %S\", handler);
  }
  SCM_VM(vm)->defaultEscapeHandler = handler;
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc vm-instruction? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_VM_INSNP(obj)));")

(define-cproc vm-insn-inspect (obj)
  "  SCM_RETURN(Scm_VMInsnInspect(obj));")

(define-cproc closure-code (clo)
  (assert (closure? clo))
  "  SCM_RETURN(clo->code);")

(define-cproc procedure-info (proc)
  (assert (procedure? proc))
  "  SCM_RETURN(SCM_PROCEDURE_INFO(proc));")

;; Local variables:
;; mode: scheme
;; end:
