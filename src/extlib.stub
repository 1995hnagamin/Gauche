;;;
;;; extlib.stub - extra built-ins
;;;
;;;   Copyright (c) 2000-2002 Shiro Kawai (shiro@acm.org)
;;;
;;;   Permission to use, copy, modify, distribute this software and
;;;   accompanying documentation for any purpose is hereby granted,
;;;   provided that existing copyright notices are retained in all
;;;   copies and that this notice is included verbatim in all
;;;   distributions.
;;;   This software is provided as is, without express or implied
;;;   warranty.  In no circumstances the author(s) shall be liable
;;;   for any damages arising out of the use of this software.
;;;
;;; $Id: extlib.stub,v 1.166 2002-07-24 16:09:17 shirok Exp $
;;;

"
#include <gauche/arch.h>
#include <gauche/class.h>
"

;;
;; Macros
;;

(define-cproc macroexpand (form)
  "SCM_RETURN(Scm_MacroExpand(form, SCM_NIL, FALSE));")
(define-cproc macroexpand-1 (form)
  "SCM_RETURN(Scm_MacroExpand(form, SCM_NIL, TRUE));")

;;
;; 6.1  Equivalence predicates
;;

;; to pass the cmpmode argument
(define-symbol eq?    "sym_eq")
(define-symbol eqv?   "sym_eqv")
(define-symbol equal? "sym_equal")

(define-symbol string=? "sym_string_eq") ; used for make-hash-table

"static int getcmpmode(ScmObj opt)
 { if (SCM_UNBOUNDP(opt) || opt == sym_equal) return SCM_CMP_EQUAL;
   if (opt == sym_eq) return SCM_CMP_EQ;
   if (opt == sym_eqv) return SCM_CMP_EQV;
   Scm_Error(\"unrecognized compare mode: %S\", opt);
   return 0; /* dummy */ }"

(define-cproc compare (x y) (return <fixnum> "Scm_Compare"))

;;
;; 6.2  Numbers
;;

(define-cproc ash (num cnt::<fixnum>)
  (return "Scm_Ash"))

(define-cproc lognot (x) (return "Scm_LogNot"))
(define-cproc logand (x y &rest args)
  "  ScmObj cp, r = Scm_LogAnd(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogAnd(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")
(define-cproc logior (x y &rest args)
  "  ScmObj cp, r = Scm_LogIor(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogIor(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")
(define-cproc logxor (x y &rest args)
  "  ScmObj cp, r = Scm_LogXor(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogXor(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")

(define-cproc clamp (x &optional (min #f) (max #f))
  " ScmObj r = x;  int maybe_exact = FALSE;
  if (SCM_EXACTP(x)) maybe_exact = TRUE;
  else if (!SCM_FLONUMP(x)) {
    Scm_Error(\"real number required for x, but got %S\", x);
  }
  if (SCM_EXACTP(min)) {
    if (Scm_NumCmp(x, min) < 0) r = min;
  } else if (SCM_FLONUMP(min)) {
    maybe_exact = FALSE;
    if (Scm_NumCmp(x, min) < 0) r = min;
  } else if (!SCM_FALSEP(min)) {
    Scm_Error(\"real number or #f required for min, but got %S\", min);
  }
  if (SCM_EXACTP(max)) {
    if (Scm_NumCmp(x, max) > 0) r = max;
  } else if (SCM_FLONUMP(max)) {
     maybe_exact = FALSE;
    if (Scm_NumCmp(x, max) > 0) r = max;
  } else if (!SCM_FALSEP(max)) {
    Scm_Error(\"real number or #f required for max, but got %S\", max);
  }
  if (!maybe_exact && SCM_EXACTP(r)) SCM_RETURN(Scm_ExactToInexact(r));
  else SCM_RETURN(r);")

(define-cproc decode-float (num)        ;from ChezScheme
  "if (SCM_FLONUMP(num)) {
     int exp, sign;
     ScmObj f = Scm_DecodeFlonum(SCM_FLONUM_VALUE(num), &exp, &sign);
     ScmObj v = Scm_MakeVector(3, SCM_FALSE);
     SCM_VECTOR_ELEMENT(v, 0) = f;
     SCM_VECTOR_ELEMENT(v, 1) = Scm_MakeInteger(exp);
     SCM_VECTOR_ELEMENT(v, 2) = Scm_MakeInteger(sign);
     SCM_RETURN(v);
  } else if (SCM_INTP(num)) {
     ScmObj v = Scm_MakeVector(3, SCM_FALSE);
     SCM_VECTOR_ELEMENT(v, 0) = Scm_Abs(num);
     SCM_VECTOR_ELEMENT(v, 1) = Scm_MakeInteger(0);
     SCM_VECTOR_ELEMENT(v, 2) = Scm_MakeInteger(Scm_Sign(num));
     SCM_RETURN(v);
  } else {
     Scm_Error(\"real number required, but got %S\", num);
     SCM_RETURN(SCM_UNDEFINED);
  }")

;; just for debug...
(if "SCM_DEBUG_HELPER"
(define-cproc %bignum-dump (obj)
  "  if (SCM_BIGNUMP(obj)) Scm_DumpBignum(SCM_BIGNUM(obj), SCM_CUROUT);
  SCM_RETURN(SCM_UNDEFINED);")
)

(define-cproc min&max (arg0 &rest args)
  "ScmObj min, max;
   Scm_MinMax(arg0, args, &min, &max);
   SCM_RETURN(Scm_Values2(min, max));")

(define-cproc quotient&remainder (n1 n2)
  "ScmObj q, r;
   q = Scm_Quotient(n1, n2, &r);
   SCM_RETURN(Scm_Values2(q, r));")

;;
;; 6.3.1  Booleans
;;

;;
;; 6.3.2  Pairs and lists
;;

(define-cproc make-list (len::<fixnum> &optional (fill #f)) ; SRFI-1
  (return "Scm_MakeList"))

(define-cproc acons (caa cda cd)
  (return "Scm_Acons"))

(define-cproc last-pair (list)          ; SRFI-1
  (return "Scm_LastPair"))

(define-cproc list-copy (list)          ; SRFI-1
  (return "Scm_CopyList"))

(define-cproc list* (&rest args)
  (inliner "SCM_VM_LIST_STAR")
  "  ScmObj head = SCM_NIL, tail = SCM_NIL, cp;
  if (SCM_PAIRP(args)) {
    SCM_FOR_EACH(cp, args) {
      if (!SCM_PAIRP(SCM_CDR(cp))) {
        if (SCM_NULLP(head)) head = SCM_CAR(cp);
        else SCM_SET_CDR(tail, SCM_CAR(cp));
        break;
      }
      SCM_APPEND1(head, tail, SCM_CAR(cp));
    }
  }
  SCM_RETURN(head);")

(define-cproc %delete (obj list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_Delete(obj, list, getcmpmode(cmpmode)));")

(define-cproc %delete! (obj list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_DeleteX(obj, list, getcmpmode(cmpmode)));")

(define-cproc %delete-duplicates (list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_DeleteDuplicates(list, getcmpmode(cmpmode)));")

(define-cproc %delete-duplicates! (list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_DeleteDuplicatesX(list, getcmpmode(cmpmode)));")

(define-cproc %alist-delete (elt list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_AssocDelete(elt, list, getcmpmode(cmpmode)));")

(define-cproc %alist-delete! (elt list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_AssocDeleteX(elt, list, getcmpmode(cmpmode)));")

;; SRFI-1 has this.
;(define-cproc union (&rest args)        ;use eq? to compare.
;  (assert (list? args))
;  "  ScmObj set, ap;
;  if (SCM_NULLP(args)) SCM_RETURN(SCM_NIL);
;  set = SCM_CAR(args);
;  SCM_FOR_EACH(ap, SCM_CDR(args))
;    set = Scm_Union(set, SCM_CAR(ap));
;  SCM_RETURN(set);")

(define-cproc append! (&rest list)
  "  ScmObj cp, h = SCM_NIL, t = SCM_NIL;
  SCM_FOR_EACH(cp, list) SCM_APPEND(h, t, SCM_CAR(cp));
  SCM_RETURN(h);")

(define-cproc reverse! (list)
  (return "Scm_ReverseX"))

(define-cproc sort (list &optional (fn #f))
  (return "Scm_SortList"))

(define-cproc sort! (list &optional (fn #f))
  (return "Scm_SortListX"))

;(define-cproc topological-sort (edges)
;  (assert (list? edges))
;  "  SCM_RETURN(Scm_TopologicalSort(edges));")

;; TODO: this doesn't work properly.  Find the cause.
"
static ScmObj monotonic_merge_cb(ScmObj elt, void *data)
{
    ScmObj proc = SCM_OBJ(data);
    return Scm_Apply(proc, SCM_LIST1(elt));
}
"

(define-cproc monotonic-merge (start sequences::<list> get-super::<procedure>)
  "  SCM_RETURN(Scm_MonotonicMerge(start, sequences,
                                   monotonic_merge_cb, (void*)get_super));")

(define-cproc pair-attributes (pair::<pair>)
  (return "SCM_PAIR_ATTR"))

(define-cproc pair-attribute-get (pair::<pair> key &optional fallback)
  "  SCM_RETURN(Scm_PairAttrGet(SCM_PAIR(pair), key, fallback));")

(define-cproc pair-attribute-set! (pair::<pair> key value)
  "  SCM_RETURN(Scm_PairAttrSet(SCM_PAIR(pair), key, value));")

;;
;; 6.3.3  Symbols
;;

(define-cproc symbol-bound? (symbol::<symbol> &optional module)
  "  
  if (module == SCM_UNBOUND) {
     module = SCM_OBJ(SCM_CURRENT_MODULE());
  } else if (!SCM_MODULEP(module)) {
     Scm_Error(\"module required, but got %S\", module);
  }
  if (Scm_SymbolValue(SCM_MODULE(module), symbol) == SCM_UNBOUND)
     SCM_RETURN(SCM_FALSE);
  else
     SCM_RETURN(SCM_TRUE);")

(define-cproc gensym (&optional prefix)
  "  ScmString *p = NULL;
  if (prefix != SCM_UNBOUND) {
    if (!SCM_STRINGP(prefix))
      Scm_Error(\"string expected, but got %S\", prefix);
    p = SCM_STRING(prefix);
  }
  SCM_RETURN(Scm_Gensym(p));")

;; keywords
(define-cproc keyword? (obj) (return <boolean> "SCM_KEYWORDP"))

(define-cproc make-keyword (name)
  "   ScmString *sname = NULL;
  if (SCM_STRINGP(name)) sname = SCM_STRING(name);
  else if (SCM_SYMBOLP(name)) sname = SCM_SYMBOL_NAME(name);
  else Scm_Error(\"string or symbol required, but got %S\", name);
  SCM_RETURN(Scm_MakeKeyword(sname));")

(define-cproc get-keyword (key list &optional fallback)
  (return "Scm_GetKeyword"))

;; identifiers
(define-cproc identifier? (obj) (return <boolean> "SCM_IDENTIFIERP"))

(define-cproc identifier->symbol (obj::<identifier>)
  "  SCM_RETURN(SCM_OBJ(SCM_IDENTIFIER(obj)->name));")

;;
;; 6.3.4  Characters
;;

(define-cproc digit->integer (ch::<char> &optional (radix::<fixnum> 10))
  "  int r;
  if (radix < 2 || radix > 36)
     Scm_Error(\"radix must be between 2 and 36, but got %d\", radix);
  r = Scm_DigitToInt(ch, radix);
  return (r >= 0 ? SCM_MAKE_INT(r) : SCM_FALSE);")

(define-cproc integer->digit (n::<fixnum> &optional (radix::<fixnum> 10))
  "  ScmChar r;
  if (radix < 2 || radix > 36)
     Scm_Error(\"radix must be between 2 and 36, but got %d\", radix);
  r = Scm_IntToDigit(n, radix);
  return (r == SCM_CHAR_INVALID? SCM_FALSE : SCM_MAKE_CHAR(r));")

(define-cproc ucs->char (n::<int>)
  "ScmChar ch = Scm_UcsToChar(n);
  if (ch == SCM_CHAR_INVALID) SCM_RETURN(SCM_FALSE);
  else SCM_RETURN(SCM_MAKE_CHAR(ch));")

(define-cproc char->ucs (c::<char>)
  "int ucs = Scm_CharToUcs(c);
  if (ucs < 0) SCM_RETURN(SCM_FALSE);
  else SCM_RETURN(Scm_MakeInteger(ucs));")

(define-cproc gauche-character-encoding ()
  (return "Scm_CharEncodingName"))

(define-cproc supported-character-encodings ()
  "  SCM_RETURN(Scm_ConstCStringArrayToList(Scm_SupportedCharacterEncodings(), -1));")

(define-cproc supported-character-encoding? (encoding::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_SupportedCharacterEncodingP(Scm_GetStringConst(encoding))));")

;; character sets (SRFI-14)
;;   not all of srfi-14 functions are defined in C.  you need to load
;;   srfi-14.scm to get a full set of functions.

(define-const *char-code-max* "char_code_max"
  "Scm_MakeInteger(SCM_CHAR_MAX)")

(define-cproc char-set? (obj) (return <boolean> "SCM_CHARSETP"))

"static void char_set_add(ScmCharSet *cs, ScmObj chars)
 {  ScmObj cp; ScmChar ch;
  SCM_FOR_EACH(cp, chars) {
    if (!SCM_CHARP(SCM_CAR(cp)))
      Scm_Error(\"character required, but got %S\", SCM_CAR(cp));
    ch = SCM_CHAR_VALUE(SCM_CAR(cp));
    Scm_CharSetAddRange(cs, ch, ch);
  }
 }"

(define-cproc %char-set-equal? (x::<char-set> y::<char-set>)
  (return <boolean> "Scm_CharSetEq"))

(define-cproc char-set (&rest chars)
  "  ScmCharSet *cs = SCM_CHARSET(Scm_MakeEmptyCharSet());
  char_set_add(cs, chars);
  SCM_RETURN(SCM_OBJ(cs));")

(define-cproc char-set-copy (cs::<char-set>)
  (return "Scm_CopyCharSet"))

(define-cproc %char-set-add-chars! (cs::<char-set> chars::<list>)
  "  char_set_add(cs, chars); SCM_RETURN(SCM_OBJ(cs));")

(define-cproc %char-set-add-range! (cs::<char-set> from to)
  "  long fromc = -1, toc = -1;
  if (SCM_EXACTP(from)) fromc = Scm_GetInteger(from);
  else if (SCM_CHARP(from)) fromc = SCM_CHAR_VALUE(from);
  if (fromc < 0) Scm_Error(\"character or positive integer required, but got %S\", from);
  if (fromc >= SCM_CHAR_MAX) Scm_Error(\"argument out of range: %S\", from);
  if (SCM_EXACTP(to)) toc = Scm_GetInteger(to);
  else if (SCM_CHARP(to)) toc = SCM_CHAR_VALUE(to);
  if (toc < 0) Scm_Error(\"character or positive integer required, but got %S\", to);
  if (toc >= SCM_CHAR_MAX) Scm_Error(\"argument out of range: %S\", to);
  SCM_RETURN(Scm_CharSetAddRange(cs, (ScmChar)fromc, (ScmChar)toc));")

(define-cproc %char-set-add! (dst::<char-set> src::<char-set>)
  (return "Scm_CharSetAdd"))

(define-cproc char-set-contains? (cs::<char-set> ch::<char>)
  (return <boolean> "Scm_CharSetContains"))

(define-cproc %char-set-complement! (cs::<char-set>)
  (return "Scm_CharSetComplement"))

(define-cproc %char-set-ranges (cs::<char-set>)
  (return "Scm_CharSetRanges"))

(define-cproc %char-set-predefined (num::<fixnum>)
  (return "Scm_GetStandardCharSet"))

;; for debug
(if "SCM_DEBUG_HELPER"
(define-cproc %char-set-dump (cs::<char-set>)
  "Scm_CharSetDump(cs, SCM_CUROUT); SCM_RETURN(SCM_UNDEFINED);")
)

;;
;; 6.3.5 Strings
;;

(define-cproc string-incomplete? (obj)    ;gauche specific
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRINGP(obj)&&SCM_STRING_INCOMPLETE_P(obj)));")
(define-cproc string-immutable? (obj)   ;gauche specific
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRINGP(obj)&&SCM_STRING_IMMUTABLE_P(obj)));")

(define-cproc string-complete->incomplete! (str::<string>) ;gauche specific
  (return "Scm_StringCompleteToIncompleteX"))
(define-cproc string-incomplete->complete! (str::<string>) ;gauche specific
  (return "Scm_StringIncompleteToCompleteX"))
(define-cproc string-complete->incomplete (str::<string>) ;gauche specific
  (return "Scm_StringCompleteToIncomplete"))
(define-cproc string-incomplete->complete (str::<string>) ;gauche specific
  (return "Scm_StringIncompleteToComplete"))

(define-cproc string-size (str::<string>)
  (return <fixnum> "SCM_STRING_SIZE"))

(define-cproc string-byte-ref (str::<string> k::<fixnum> &optional fallback)
  "  int r;
  if (!SCM_UNBOUNDP(fallback) && (k < 0 || k >= SCM_STRING_SIZE(str))) {
    SCM_RETURN(fallback);
  } else {
    r = Scm_StringByteRef(str, k);
    SCM_RETURN(SCM_MAKE_INT(r));
  }")

(define-cproc string-byte-set! (str::<string> k::<fixnum> b::<fixnum>)
  (return "Scm_StringByteSet"))

(define-cproc string-substitute! (target::<string> start::<fixnum> str::<string>)
  "  ScmObj r = Scm_StringSubstitute(target, start, str);
  if (!SCM_STRINGP(r)) Scm_Error(\"argument out of range: (%d %S)\", start, str);
  SCM_RETURN(r);")

(define-cproc %maybe-substring (str::<string> &optional start end)
  (return "Scm_MaybeSubstring"))

(define-symbol infix "sym_infix")
(define-symbol strict-infix "sym_strict_infix")
(define-symbol suffix "sym_suffix")
(define-symbol prefix "sym_prefix")

(define-cproc string-join (strs::<list>
                           &optional (delim::<string> " ") grammer)
  "  int gm = 0;
  if (SCM_UNBOUNDP(grammer) || SCM_UNDEFINEDP(grammer) || grammer == sym_infix)
    gm = SCM_STRING_JOIN_INFIX;
  else if (grammer == sym_strict_infix)
    gm = SCM_STRING_JOIN_STRICT_INFIX;
  else if (grammer == sym_suffix)
    gm = SCM_STRING_JOIN_SUFFIX;
  else if (grammer == sym_prefix)
    gm = SCM_STRING_JOIN_PREFIX;
  else Scm_Error(\"invalid grammer specification: %S\", grammer);
  SCM_RETURN(Scm_StringJoin(strs, delim, gm));")

(define-cproc %hash-string (str::<string> bound) ; for SRFI-13
  "  unsigned long modulo = 0;
  if (SCM_UNDEFINEDP(bound)) modulo = SCM_SMALL_INT_MAX;
  else if (SCM_INTP(bound)) modulo = SCM_INT_VALUE(bound);
  else if (SCM_BIGNUMP(bound)) modulo = Scm_BignumToUI(SCM_BIGNUM(bound));
  if (modulo == 0) Scm_Error(\"argument out of domain: %S\", bound);
  SCM_RETURN(Scm_MakeInteger(Scm_HashString(str, modulo)));")

;; TODO: allow string/charset/regexp in ch
(define-cproc string-split (s::<string> ch::<char>)
  (return "Scm_StringSplitByChar"))

;; primitive scanner
(define-symbol index   "sym_index")
(define-symbol before  "sym_before")
(define-symbol after   "sym_after")
(define-symbol before* "sym_before2")
(define-symbol after*  "sym_after2")
(define-symbol both    "sym_both")

(define-cproc string-scan (s1::<string> s2 &optional (mode (c "sym_index")))
  "  int retmode = 0;
  if (mode == sym_index)         retmode = SCM_STRING_SCAN_INDEX;
  else if (mode == sym_before)   retmode = SCM_STRING_SCAN_BEFORE;
  else if (mode == sym_after)    retmode = SCM_STRING_SCAN_AFTER;
  else if (mode == sym_before2)  retmode = SCM_STRING_SCAN_BEFORE2;
  else if (mode == sym_after2)   retmode = SCM_STRING_SCAN_AFTER2;
  else if (mode == sym_both)     retmode = SCM_STRING_SCAN_BOTH;
  else {
    Scm_Error(\"bad value in mode argumet: %S, must be one of 'index, 'before, 'after, 'before*, 'after* or 'both.\", mode);
  }
  if (SCM_STRINGP(s2)) {
     SCM_RETURN(Scm_StringScan(s1, SCM_STRING(s2), retmode));
  } else if (SCM_CHARP(s2)) {
     SCM_RETURN(Scm_StringScanChar(s1, SCM_CHAR_VALUE(s2), retmode));
  } else {
     Scm_Error(\"bad type of argument for s2: %S, must be either string or character\", s2);
     SCM_RETURN(SCM_UNDEFINED); /* dummy */
  }")
  

;; string pointer
(define-type <string-pointer> "ScmStringPointer*" "string pointer"
  "SCM_STRING_POINTERP" "SCM_STRING_POINTER")

(define-cproc make-string-pointer (str::<string>
                                   &optional (index::<fixnum> 0)
                                             (start::<fixnum> 0)
                                             (end::<fixnum> -1))
  (return "Scm_MakeStringPointer"))
(define-cproc string-pointer? (obj)
  (return <boolean> "SCM_STRING_POINTERP"))

(define-cproc string-pointer-next! (sp::<string-pointer>)
  (return "Scm_StringPointerNext"))
(define-cproc string-pointer-prev! (sp::<string-pointer>)
  (return "Scm_StringPointerPrev"))
(define-cproc string-pointer-set! (sp::<string-pointer> index::<fixnum>)
  (return "Scm_StringPointerSet"))
(define-cproc string-pointer-substring (sp::<string-pointer>
                                        &keyword (after #f))
  "  SCM_RETURN(Scm_StringPointerSubstring(sp, !SCM_FALSEP(after)));")
(define-cproc string-pointer-index (sp::<string-pointer>)
  "  SCM_RETURN(Scm_MakeInteger(sp->index));")

;; Regexp
(define-cproc string->regexp (str::<string>)
  (return "Scm_RegComp"))

(define-cproc rxmatch (regexp str::<string>)
  "  ScmRegexp *rx = NULL;
  if (SCM_STRINGP(regexp)) rx = SCM_REGEXP(Scm_RegComp(SCM_STRING(regexp)));
  else if (SCM_REGEXPP(regexp)) rx = SCM_REGEXP(regexp);
  else Scm_Error(\"regexp required, but got %S\", regexp);
  SCM_RETURN(Scm_RegExec(rx, str));")

(define-cproc rxmatch-substring (match &optional (i::<fixnum> 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchSubstr(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-start (match &optional (i::<fixnum> 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchStart(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-end (match &optional (i::<fixnum> 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchEnd(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-before (match &optional (i::<fixnum> 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchBefore(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-after (match &optional (i::<fixnum> 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchAfter(SCM_REGMATCH(match), i));")

;; for debug
(if "SCM_DEBUG_HELPER"
(define-cproc %regexp-dump (rx)
  "  if (!SCM_REGEXPP(rx)) Scm_Error(\"regexp required, but got %S\", rx);
  Scm_RegDump(SCM_REGEXP(rx));  SCM_RETURN(SCM_UNDEFINED);")
)

(if "SCM_DEBUG_HELPER"
(define-cproc %regmatch-dump (rm)
  "  if (!SCM_REGMATCHP(rm)) Scm_Error(\"regmatch required, but got %S\", rm);
  Scm_RegMatchDump(SCM_REGMATCH(rm));  SCM_RETURN(SCM_UNDEFINED);")
)

;;
;; 6.3.6  Vectors
;;

(define-cproc vector-copy (v::<vector>
                           &optional (start::<fixnum> 0) (end::<fixnum> -1))
  (return "Scm_VectorCopy"))

;; weak vector
(define-cproc make-weak-vector (size::<fixnum>)
  (return "Scm_MakeWeakVector"))

(define-cproc weak-vector-length (wv::<weak-vector>)
  "SCM_RETURN(Scm_MakeInteger(wv->size));")

(define-cproc weak-vector-ref (wv::<weak-vector> index::<fixnum>
                               &optional fallback)
  (return "Scm_WeakVectorRef"))
  
(define-cproc weak-vector-set! (wv::<weak-vector> index::<fixnum> val)
  (return "Scm_WeakVectorSet"))

;;
;; 6.4  Control Features
;;

(define-cproc setter (proc::<procedure>) ;SRFI-17
  (inliner "SCM_VM_SETTER")
  (return "Scm_Setter")
  (setter (proc::<procedure> setter::<procedure>)
    "  Scm_SetterSet(proc, setter, FALSE); SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc identity (val)            ;sometimes useful
  "SCM_RETURN(val);")

;;
;; 6.6.1  Ports
;;

;; String port
(define-cproc open-input-string (string::<string>) ;SRFI-6
  (return "Scm_MakeInputStringPort"))

(define-cproc open-output-string ()      ;SRFI-6
  (return "Scm_MakeOutputStringPort"))

(define-cproc get-output-string (oport::<output-port>) ;SRFI-6
  "  if (SCM_PORT_TYPE(oport) != SCM_PORT_OSTR)
        Scm_Error(\"output string port required, but got: %S\", oport);
  SCM_RETURN(Scm_GetOutputString(oport));")

;; Buffered port
;; NB: the interface may be changed soon!!
"static int bufport_closer(ScmPort *p)
 {
    if (SCM_PORT_DIR(p) == SCM_PORT_OUTPUT) {
       ScmObj scmflusher = SCM_OBJ(p->src.buf.data);
       int siz = (int)(p->src.buf.current - p->src.buf.buffer);
       if (siz > 0) Scm_Apply(scmflusher, SCM_LIST1(Scm_MakeString(p->src.buf.buffer, siz, siz, SCM_MAKSTR_INCOMPLETE|SCM_MAKSTR_COPYING)));
       Scm_Apply(scmflusher, SCM_LIST1(SCM_FALSE));
    }
    return 0;
 }"

"static int bufport_filler(ScmPort *p, int cnt)
 {
    ScmObj scmfiller, r;  int siz;
    scmfiller = SCM_OBJ(p->src.buf.data);
    /* no need to use VMApply; we're in the C callback */
    r = Scm_Apply(scmfiller, SCM_LIST1(Scm_MakeInteger(cnt)));
    if (SCM_EOFP(r) || SCM_FALSEP(r)) {
       return 0;
    } else if (!SCM_STRINGP(r)) {
       Scm_Error(\"buffered port callback procedure returned non-string: %S\", r);
    }
    siz = SCM_STRING_SIZE(r);
    if (siz > cnt) siz = cnt; /* for safety */
    memcpy(p->src.buf.end, SCM_STRING_START(r), siz);
    return SCM_STRING_SIZE(r);
 }"

(define-cproc open-input-buffered-port (filler::<procedure>
                                        buffer-size::<fixnum>)
  "  ScmPortBuffer bufrec;
  bufrec.size = buffer_size;
  bufrec.buffer = NULL;
  bufrec.mode = SCM_PORT_BUFFER_FULL;
  bufrec.filler = bufport_filler;
  bufrec.flusher = NULL;
  bufrec.closer = bufport_closer;
  bufrec.ready = NULL;
  bufrec.filenum = NULL;
  bufrec.data = (void*)filler;
  SCM_RETURN(Scm_MakeBufferedPort(SCM_FALSE, SCM_PORT_INPUT, TRUE, &bufrec));
  ")

"static int bufport_flusher(ScmPort *p, int cnt)
 {
     ScmObj scmflusher, s;
     scmflusher = SCM_OBJ(p->src.buf.data);
     s = Scm_MakeString(p->src.buf.buffer, cnt, cnt, SCM_MAKSTR_INCOMPLETE|SCM_MAKSTR_COPYING);
     Scm_Apply(scmflusher, SCM_LIST1(s));
     return cnt;
 }"

(define-cproc open-output-buffered-port (flusher::<procedure>
                                         buffer-size::<fixnum>)
  "  ScmPortBuffer bufrec;
  bufrec.size = buffer_size;
  bufrec.buffer = NULL;
  bufrec.mode = SCM_PORT_BUFFER_FULL;
  bufrec.filler = NULL;
  bufrec.flusher = bufport_flusher;
  bufrec.closer = bufport_closer;
  bufrec.ready = NULL;
  bufrec.filenum = NULL;
  bufrec.data = (void*)flusher;
  SCM_RETURN(Scm_MakeBufferedPort(SCM_FALSE, SCM_PORT_OUTPUT, TRUE, &bufrec));
  ")

(define-cproc flush (&optional (oport::<output-port> (current-output-port)))
  (return <void> "Scm_Flush"))

(define-cproc flush-all-ports ()
  "  Scm_FlushAllPorts(FALSE); SCM_RETURN(SCM_UNDEFINED);")

(define-cproc port-closed? (obj::<port>)
  (return <boolean> "SCM_PORT_CLOSED_P"))

(define-cproc current-error-port ()     ;gauche extention
  "  SCM_RETURN(SCM_OBJ(SCM_CURERR));")

(define-cproc standard-input-port ()
  (return "Scm_Stdin"))

(define-cproc standard-output-port ()
  (return "Scm_Stdout"))

(define-cproc standard-error-port ()
  (return "Scm_Stderr"))

(define-cproc with-input-from-port (port::<input-port> thunk::<procedure>)
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CURIN, FALSE));")

(define-cproc with-output-to-port (port::<output-port> thunk::<procedure>)
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CUROUT, FALSE));")

(define-cproc with-error-to-port (port::<output-port> thunk::<procedure>)
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CURERR, FALSE));")

(define-cproc port-name (port::<port>)
  (return "Scm_PortName"))

(define-cproc port-current-line (port::<port>)
  (return <fixnum> "Scm_PortLine"))

(define-cproc port-current-column (port::<port>)
  (return <fixnum> "Scm_PortPosition"))

(define-cproc port-file-number (port::<port>)
  "  int i = Scm_PortFileNo(port);
  SCM_RETURN((i < 0)? SCM_FALSE : Scm_MakeInteger(i));")

(define-symbol file "sym_file")
(define-symbol string "sym_string")
(define-symbol proc "sym_proc")
(define-cproc port-type (port::<port>)
  "ScmObj type = SCM_FALSE;
   switch (SCM_PORT_TYPE(port)) {
     case SCM_PORT_FILE: type = sym_file; break;
     case SCM_PORT_PROC: type = sym_proc; break;
     case SCM_PORT_OSTR:;
     case SCM_PORT_ISTR: type = sym_string; break;
   }
   SCM_RETURN(type);")

(define-cproc port-buffering (port::<port>)
  (return "Scm_GetBufferingMode")
  (setter (port::<port> mode)
    "if (SCM_PORT_TYPE(port) != SCM_PORT_FILE) {
       Scm_Error(\"can't set buffering mode to non-buffered port: %S\", port);
     }
     port->src.buf.mode = Scm_BufferingMode(mode, port->direction, -1);
     SCM_RETURN(SCM_UNDEFINED);")
  )

;; Open port from fd
(define-cproc open-input-fd-port (fd::<fixnum>
                                  &keyword (buffering #f)
                                           (owner?::<boolean> #f)
                                           (name #f))
  "int bufmode = Scm_BufferingMode(buffering, SCM_PORT_INPUT, SCM_PORT_BUFFER_FULL);
   if (fd < 0) Scm_Error(\"bad file descriptor: %d\", fd);
   return Scm_MakePortWithFd(name, SCM_PORT_INPUT, fd, bufmode, ownerP);")

(define-cproc open-output-fd-port (fd::<fixnum>
                                   &keyword (buffering #f)
                                            (owner?::<boolean> #f)
                                            (name #f))
  "int bufmode = Scm_BufferingMode(buffering, SCM_PORT_OUTPUT, SCM_PORT_BUFFER_FULL);
   if (fd < 0) Scm_Error(\"bad file descriptor: %d\", fd);
   return Scm_MakePortWithFd(name, SCM_PORT_OUTPUT, fd, bufmode, ownerP);")

;; transfer units for copy-port
(define-symbol char "sym_char")
(define-symbol byte "sym_byte")
"#define COPY_PORT_BUFSIZ 1024"

(define-cproc copy-port (src::<input-port> dst::<output-port>
                                           &keyword (unit 0))
  "  int ncopied = 0, bufsiz; char buf[COPY_PORT_BUFSIZ], *p = buf;
  if (SCM_SYMBOLP(unit)) {
    if (SCM_EQ(unit, sym_char)) {
      ScmChar c;
      for (;;) {
        SCM_GETC(c, src); if (c == EOF) break; SCM_PUTC(c, dst); ncopied++;
      }
    } else if (SCM_EQ(unit, sym_byte)) {
      int b;
      for (;;) {
        SCM_GETB(b, src); if (b == EOF) break; SCM_PUTB(b, dst); ncopied++;
      }
    } else {
      Scm_Error(\"unknown unit specification: %S\", unit);
    }
  } else if (!(SCM_INTP(unit) && (bufsiz = SCM_INT_VALUE(unit)) >= 0)) {
    Scm_Error(\"unit must be 'char, 'byte, or zero or positive integer: %S\", unit);
  } else {
    if (bufsiz == 0) bufsiz = COPY_PORT_BUFSIZ;
    else if (bufsiz > COPY_PORT_BUFSIZ) p = SCM_NEW_ATOMIC2(char*, bufsiz);
    for (;;) {
      int nread = Scm_Getz(p, bufsiz, src);
      if (nread <= 0) break;
      Scm_Putz(p, nread, dst);
      ncopied += nread;
    }
  }
  SCM_RETURN(SCM_MAKE_INT(ncopied));")

(define-cproc port->string (port::<input-port>)       ;scsh, stk
  "  ScmChar ch; ScmPort *out = SCM_PORT(Scm_MakeOutputStringPort());
  for (;;) {
    SCM_GETC(ch, port);
    if (ch == EOF) break;
    SCM_PUTC(ch, out);
  }
  SCM_RETURN(Scm_GetOutputString(out));")

(define-cproc port->byte-string (port::<input-port>)
  ;; TODO: use chunked I/O if appropriate
  " int b; ScmPort *out = SCM_PORT(Scm_MakeOutputStringPort());
  for (;;) {
    SCM_GETB(b, port);
    if (b == EOF) break;
    SCM_PUTB(b, out);
  }
  SCM_RETURN(Scm_GetOutputString(out));")

;;
;; 6.6.2  Input
;;

(define-cproc read-byte (&optional (port::<input-port> (current-input-port)))
  "  int b; SCM_GETB(b, port);
  SCM_RETURN((b < 0)? SCM_EOF : SCM_MAKE_INT(b));")

(define-cproc read-line (&optional (port::<input-port> (current-input-port)))
  (return "Scm_ReadLine"))

(define-cproc read-block (bytes::<fixnum>
                          &optional (port::<input-port> (current-input-port)))
  "  char *buf; int nread;
  if (bytes <= 0) Scm_Error(\"bytes must be non-zero positive integer: %d\", bytes);
  buf = SCM_NEW_ATOMIC2(char*, bytes);
  nread = Scm_Getz(buf, bytes, port);
  if (nread <= 0) {
    SCM_RETURN(SCM_EOF);
  } else {
    SCM_RETURN(Scm_MakeString(buf, nread, nread, SCM_MAKSTR_INCOMPLETE));
  }")

(define-cproc read-list (closer::<char>
                         &optional (port (current-input-port)))
  "SCM_RETURN(Scm_ReadList(port, closer));")

(define-cproc define-reader-ctor (symbol proc)
  (return "Scm_DefineReaderCtor"))

;;
;; 6.6.3  Output
;;

(define-cproc write-byte (byte::<fixnum>
                          &optional (port::<output-port> (current-output-port)))
  "  if (byte < 0 || byte > 255) Scm_Error(\"argument out of range: %d\", byte);
  SCM_PUTB(byte, port);
  SCM_RETURN(SCM_MAKE_INT(1));")

(define-cproc write-limited (obj limit::<fixnum>
                             &optional (port (current-output-port)))
  "  int n = Scm_WriteLimited(obj, port, SCM_WRITE_WRITE, limit);
  SCM_RETURN(SCM_MAKE_INT(n));")

(define-cproc write* (obj &optional (port (current-output-port)))
  "  int n = Scm_WriteCircular(obj, SCM_PORT(port), SCM_WRITE_WRITE, 0);
  SCM_RETURN(SCM_MAKE_INT(n));")

;;
;; 6.6.4  System Interface
;;

(define-cproc %add-load-path (path::<string> &optional (afterp #f))
  "  const char *cpath = Scm_GetStringConst(path);
  SCM_RETURN(Scm_AddLoadPath(cpath, !SCM_FALSEP(afterp)));")

(define-cproc dynamic-load (file::<string>
                            &keyword (init-function #f)
                                     (export-symbols #f))
  "  SCM_RETURN(Scm_DynLoad(file, init_function, !SCM_FALSEP(export_symbols)));")

(define-cproc %require (feature)  (return "Scm_Require"))
(define-cproc provide (feature)   (return "Scm_Provide"))
(define-cproc provided? (feature) (return <boolean> "Scm_ProvidedP"))

(define-cproc %make-autoload (sym::<symbol> path::<string>
                              &optional import-from)
  "ScmSymbol *from = SCM_SYMBOLP(import_from)? SCM_SYMBOL(import_from) : NULL;
   SCM_RETURN(Scm_MakeAutoload(sym, path, from));")

(define-cproc undefined ()
  "  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc undefined? (obj)    (return <boolean> "SCM_UNDEFINEDP"))

(define-cproc warn (fmt::<string> &rest args)
  (return void "Scm_FWarn"))

;;
;; Hashtable
;;

;; TODO: support user-defined hashfn and cmpfn
(define-cproc make-hash-table (&optional (type::<symbol> (c "sym_eq")))
  "  ScmHashProc htype = 0;
  if (SCM_OBJ(type) == sym_eq)             htype = (ScmHashProc)SCM_HASH_ADDRESS;
  else if (SCM_OBJ(type) == sym_eqv)       htype = (ScmHashProc)SCM_HASH_EQV;
  else if (SCM_OBJ(type) == sym_equal)     htype = (ScmHashProc)SCM_HASH_EQUAL;
  else if (SCM_OBJ(type) == sym_string_eq) htype = (ScmHashProc)SCM_HASH_STRING;
  else {
    Scm_Error(\"unsupported hash type: %S\", type);
  }
  SCM_RETURN(Scm_MakeHashTable(htype, NULL, 0));")

(define-cproc hash-table? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_HASHTABLEP(obj)));")

(define-cproc hash-table-type (hash::<hash-table>)
  "switch (hash->type) {
   case SCM_HASH_ADDRESS: SCM_RETURN(sym_eq);
   case SCM_HASH_EQV:     SCM_RETURN(sym_eqv);
   case SCM_HASH_EQUAL:   SCM_RETURN(sym_equal);
   case SCM_HASH_STRING:  SCM_RETURN(sym_string_eq);
   default: SCM_RETURN(SCM_FALSE);  /* TODO: need to think over */
  }")

(define-cproc hash-table-get (hash::<hash-table> key &optional defval)
  "  ScmHashEntry *e = Scm_HashTableGet(hash, key);
  if (!e || e->value == SCM_UNBOUND) {
    if (defval != SCM_UNBOUND) SCM_RETURN(defval);
    else Scm_Error(\"hash table doesn't have an entry for key %S\", key);
  }
  SCM_RETURN(e->value);")

(define-cproc hash-table-put! (hash::<hash-table> key value)
  "  Scm_HashTablePut(hash, key, value);
  SCM_RETURN(SCM_UNDEFINED);")

;; this is hash-table-remove! in STk.  I use `delete' for
;; it's consistent with SRFI-1 and dbm-delete!.
(define-cproc hash-table-delete! (hash::<hash-table> key)
  "ScmHashEntry *e = Scm_HashTableDelete(hash, key);
  SCM_RETURN(SCM_MAKE_BOOL(e != NULL));")

(define-cproc hash-table-exists? (hash::<hash-table> key)
  " if (Scm_HashTableGet(hash, key) != NULL) 
    SCM_RETURN(SCM_TRUE);
  else
    SCM_RETURN(SCM_FALSE);")

(define-cproc hash-table-push! (hash::<hash-table> key value)
  "ScmHashEntry *e = Scm_HashTableAdd(hash, key, SCM_UNBOUND);
  if (SCM_UNBOUNDP(e->value)) e->value = SCM_LIST1(value);
  else                        e->value = Scm_Cons(value, e->value);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc hash-table-pop! (hash::<hash-table> key &optional fallback)
  "ScmHashEntry *e = Scm_HashTableGet(hash, key); ScmObj r;
  if (e == NULL) {
    if (SCM_UNBOUNDP(fallback)) {
      Scm_Error(\"hash table doesn't have an entry for key %S\", key);
    }
    r = fallback;
  } else if (!SCM_PAIRP(e->value)) {
    if (SCM_UNBOUNDP(fallback)) {
      Scm_Error(\"hash table value for key %S is not a pair: %S\", key, e->value);
    }
    r = fallback;
  } else {
    r = SCM_CAR(e->value); e->value = SCM_CDR(e->value);
  }
  SCM_RETURN(r);")

"static ScmObj hash_table_iter(ScmObj *args, int nargs, void *data)
 {
   ScmHashIter *iter = (ScmHashIter*)data;
   ScmHashEntry *e = Scm_HashIterNext(iter);
   if (e == NULL) SCM_RETURN(Scm_Values2(SCM_EOF, SCM_EOF));
   else SCM_RETURN(Scm_Values2(e->key, e->value));
 }"

(define-cproc %hash-table-iter (hash::<hash-table>)
  "ScmHashIter *iter = SCM_NEW(ScmHashIter);
  Scm_HashIterInit(hash, iter);
  SCM_RETURN(Scm_MakeSubr(hash_table_iter, iter, 0, 0, SCM_MAKE_STR(\"hash-table-iterator\")));")

(define-cproc hash-table-keys (hash::<hash-table>)
  (return "Scm_HashTableKeys"))

(define-cproc hash-table-values (hash::<hash-table>)
  (return "Scm_HashTableValues"))

(define-cproc hash-table-stat (hash::<hash-table>)
  (return "Scm_HashTableStat"))

;;
;; Modules
;;

(define-cproc module? (obj) (return <boolean> "SCM_MODULEP"))

(define-cproc module-name (mod::<module>)
  "  SCM_RETURN(SCM_OBJ(SCM_MODULE(mod)->name));")

(define-cproc module-parent (mod::<module>)
  "  SCM_RETURN(mod->parent? SCM_OBJ(mod->parent) : SCM_FALSE);")

(define-cproc module-imports (mod::<module>)
  "  SCM_RETURN(mod->imported);")

(define-cproc module-exports (mod::<module>)
  "  SCM_RETURN(mod->exported);")

(define-cproc module-table (mod::<module>)
  "  SCM_RETURN(SCM_OBJ(mod->table));")

(define-cproc find-module (name::<symbol>)
  "  SCM_RETURN(Scm_FindModule(name, FALSE));")

(define-cproc all-modules ()
  "  SCM_RETURN(Scm_AllModules());")

(define-cproc %export-all ()
  "  SCM_RETURN(Scm_ExportAll(SCM_CURRENT_MODULE()));")

;;
;; Gauche extentions
;;

;; Utility procedure

(define-cproc format (fmt &rest args)
  "ScmObj port = SCM_FALSE;
  if (SCM_OPORTP(fmt) || SCM_BOOLP(fmt)) {
    if (!SCM_PAIRP(args)) {
      Scm_Error(\"wrong number of arguments: format string required after port %S\", fmt);
    }
    port = fmt;
    fmt = SCM_CAR(args);
    args = SCM_CDR(args);
    if (!SCM_STRINGP(fmt)) {
      Scm_Error(\"format string required after port, but got %S\", fmt);
    }
  } else if (!SCM_STRINGP(fmt)) {
    Scm_Error(\"format string required, but got %S\", fmt);
  }
  SCM_RETURN(Scm_Format(port, SCM_STRING(fmt), args));")

(define-cproc exit (&optional (code::<fixnum> 0))
  (return <void> "Scm_Exit"))

;;
;; External view of VM.
;;

(define-cclass <thread> "ScmVM" "Scm_VMClass"
  ()
  ((name)
   (specific)
   )
  (printer
   "ScmVM *vm = SCM_VM(obj);
    const char *state;
    switch (vm->state) {
    case SCM_VM_NEW:        state = \"new\"; break;
    case SCM_VM_RUNNABLE:   state = \"runnable\"; break;
    case SCM_VM_BLOCKED:    state = \"blocked\"; break;
    case SCM_VM_TERMINATED: state = \"terminated\"; break;
    default: state = \"(unknown state)\";
    }
    Scm_Printf(port, \"#<thread %S %s %p>\", vm->name, state, vm);")
  )

(define-cproc vm-dump (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  Scm_VMDump(SCM_VM(vm));
  SCM_RETURN(SCM_UNDEFINED); ")

(define-cproc vm-get-stack-trace (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  SCM_RETURN(Scm_VMGetStack(SCM_VM(vm)));")

(define-cproc vm-get-stack-trace-lite (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  SCM_RETURN(Scm_VMGetStackLite(SCM_VM(vm)));")

(define-cproc vm-set-default-exception-handler (vm handler)
  "  if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  if (!SCM_FALSEP(handler) && !SCM_PROCEDUREP(handler)) {
    Scm_Error(\"a procedure or #f required, but got %S\", handler);
  }
  SCM_VM(vm)->defaultEscapeHandler = handler;
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc vm-instruction? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_VM_INSNP(obj)));")

(define-cproc vm-insn-inspect (obj)
  "  SCM_RETURN(Scm_VMInsnInspect(obj));")

(define-cproc current-load-history ()
  "  SCM_RETURN(Scm_VM()->load_history);")
(define-cproc current-load-next ()
  "  SCM_RETURN(Scm_VM()->load_next);")
(define-cproc current-load-port ()
  "  SCM_RETURN(Scm_VM()->load_port);")

;;
;; Inspecting feature
;;

;; Obtain info about gauche itself
(define-cproc gauche-version ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_VERSION));")
(define-cproc gauche-architecture ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_ARCH));")
(define-cproc gauche-library-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_LIB_DIR));")
(define-cproc gauche-architecture-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_ARCH_DIR));")
(define-cproc gauche-site-library-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_SITE_LIB_DIR));")
(define-cproc gauche-site-architecture-directory ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_SITE_ARCH_DIR));")

;; GC stuff
(define-cproc gc () (return <void> "GC_gcollect"))

(define-keyword total-heap-size "key_total_heap_size")
(define-keyword free-bytes      "key_free_bytes")
(define-keyword bytes-since-gc  "key_bytes_since_gc")
(define-keyword total-bytes     "key_total_bytes")

(define-cproc gc-stat ()
  "  ScmObj h = SCM_NIL, t = SCM_NIL;
  SCM_APPEND(h, t, SCM_LIST2(key_total_heap_size,
                             Scm_MakeIntegerFromUI(GC_get_heap_size())));
  SCM_APPEND(h, t, SCM_LIST2(key_free_bytes,
                             Scm_MakeIntegerFromUI(GC_get_free_bytes())));
  SCM_APPEND(h, t, SCM_LIST2(key_bytes_since_gc,
                             Scm_MakeIntegerFromUI(GC_get_bytes_since_gc())));
  SCM_APPEND(h, t, SCM_LIST2(key_total_bytes,
                             Scm_MakeIntegerFromUI(GC_get_total_bytes())));
  SCM_RETURN(h);")

;; Misc.  WARNING: API may change
(define-cproc closure-code (clo::<closure>)
  "  SCM_RETURN(clo->code);")

(define-cproc procedure-info (proc::<procedure>)
  "  SCM_RETURN(SCM_PROCEDURE_INFO(proc));")



;; Local variables:
;; mode: scheme
;; end:
