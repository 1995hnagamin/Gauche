;;;
;;; gencomp - convert compiled code into static C data
;;;
;;;   Copyright (c) 2004-2005 Shiro Kawai, All rights reserved.
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;;  $Id: gencomp,v 1.5 2005-04-21 00:25:14 shirok Exp $
;;;

;;;
;;; This is a hack to "compile" the Scheme-written compiler into static
;;; C data structure, so that it can be linked into libgauche.
;;;
;;; Eventually this code will grow to a generic tool to create compiled
;;; executable from Scheme; for the time being, however, we concentrate
;;; on making just a compiler work.  So there are quite a few assumptions
;;; in a way the source is written.
;;;

(use srfi-1)
(use srfi-13)
(use gauche.cgen)
(use gauche.vm.insn)
(use gauche.parameter)
(use gauche.sequence)
(use gauche.parseopt)
(use file.util)
(use util.match)
(use util.list)
(use text.tr)

;; we compile things within an anonymous module to avoid interference.
(define compile-module (make-parameter #f))

;; keep the (supposed) name of the current module.  (current-module) syntax
;; is compiled into (find-module ...) expression to lookup this name at
;; runtime.
(define compile-module-name (make-parameter #f))

;; set this true if we want to keep macro definition in the dumped code.
;;  (--keep-macro option)  ;; NOT IMPLEMENTED YET
(define keep-macro-definition (make-parameter #f))

;; compatibility kludge
(define compile       (with-module gauche.internal compile))
(define compile-int   (with-module gauche.internal compile-int))
(define compile-toplevel-lambda
  (with-module gauche.internal compile-toplevel-lambda))
(define %procedure-inliner
  (with-module gauche.internal %procedure-inliner))
(define vm-code->list (with-module gauche.internal vm-code->list))
(define vm-eval-situation
  (with-module gauche.internal vm-eval-situation))

(define-constant SCM_VM_COMPILING 2) ;; must match with vm.h

;;================================================================
;; Entry
;;
(define (main args)
  (let-args (cdr args)
      ((keep-macro "keep-macro" #f)
       . args)
    (keep-macro-definition keep-macro)
    (match args
      ((scmfile) (do-it scmfile))
      (else (print "Usage: gosh gencomp [--keep-macro] <file.scm>")
            (exit 0)))
    0))

(define (do-it scmfile)
  (parameterize ((cgen-current-unit (get-unit scmfile))
                 (compile-module    (make-module #f))
                 (vm-eval-situation SCM_VM_COMPILING))
    (eval '(define-macro (current-module)
             `(find-module ',(with-module user (compile-module-name))))
          (compile-module))
    (cgen-decl "#include <gauche/code.h>")
    (with-input-from-file scmfile
      (lambda ()
        (emit-toplevel-executor
         (reverse (port-fold compile-toplevel-form '() read)))))
    (cgen-emit-c (cgen-current-unit))))

;;================================================================
;; Compiler stuff
;;

;; NOTE:
;;   The code is compiled in the version of the compiler currently
;;   running gencomp (host compiler).  It may differ from the version
;;   of the compiler we're compiling (target compiler), and it becomes
;;   a problem if the two versions of compilers are using different
;;   mappings between mnemonics and codes.
;;
;;   When gencomp generates the C literals for the compiled code, it
;;   uses the following mapping scheme.
;;
;;    1. use vm-code->list to extract mnemonics from the code
;;       compiled by the host compiler.
;;    2. use vm-find-insn-info (in gauche.vm.insn module) to map
;;       mnemonics to the target compiler's code.
;;   
;;   For this scheme to work, the following conditions should be satisfied.
;;
;;    a. gauche.vm.insn should be the one generated from the same
;;       vminsn.scm of the target compiler.
;;    b. all the mnemonics that consists of the code generated by
;;       the host compiler must exists in the target compiler's ISA.
;;
;;   The condition b. implies that if you want to rename an instruction,
;;   you have to take three steps:
;;    (1) add a new instruction of the desired name, compile the
;;        target compiler #1.  (This version of the compiled target
;;        compiler still uses old instruction).
;;    (2) compile the target compiler again, using the target compiler #1,
;;        to generate the target compiler #2.  (This version of
;;        the target compiler uses the new instruction).
;;    (3) remove the old instruction.
;;

;; compile FORM, and conses the toplevel code (something to be
;; executed at toplevel).
(define (compile-toplevel-form form seed)
  (guard (e
          ((<error> e)
           (format (current-error-port) "Error in compiling ~s\n" form)
           (raise e)))
    (match form
      (('define-module mod . body)
       (parameterize ((compile-module-name mod))
         (fold compile-toplevel-form seed body)))
      (('select-module mod)
       (let ((sym (cgen-literal mod)))
         (cgen-init
          (format "  mod = SCM_MODULE(Scm_FindModule(SCM_SYMBOL(~a), TRUE));"
                  (cgen-cexpr sym))
          ;; force the current module to be mod
          "  Scm_VM()->module = mod;"))
       (compile-module-name mod)
       seed)
      (('use mod)
       (eval `(use ,mod) (compile-module)) seed)
      (('export . syms)
       (eval `(export ,@syms) (compile-module)) seed)
      (('provide arg) seed)
      (('define-macro . rest)
       (eval `(define-macro ,@rest) (compile-module)) seed)
      (('define (name . args) . body)
       (compile-toplevel-form `(define ,name (lambda ,args ,@body)) seed))
      (('define (? symbol? name) ('lambda args . body))
       (let* ((closure
               (compile-toplevel-lambda form name args body (compile-module)))
              (code (cgen-literal (closure-code closure)))
              (var  (cgen-literal name)))
         (cgen-init
         (format "  Scm_Define(mod, SCM_SYMBOL(~a), Scm_MakeClosure(~a, NULL));"
                  (cgen-cexpr var) (cgen-cexpr code))))
       seed)
      (else
       (cons (cgen-literal (compile form (compile-module))) seed)))))

;; given list of toplevel compiled codes, generate code in init
;; that calls them.  This is assumed to be the last procedure before
;; calling cgen-emit.
(define (emit-toplevel-executor topcodes)
  (cgen-decl "static ScmCompiledCode *toplevels[] = {")
  (dolist (t topcodes) (cgen-decl "  NULL,"))
  (cgen-decl " NULL /*termination*/" "};")

  (for-each-with-index
   (lambda (index t)
     (cgen-init (format "  toplevels[~a] = SCM_COMPILED_CODE(~a);"
                        index (cgen-cexpr t))))
   topcodes)
  (cgen-init (format "  Scm_VMExecuteToplevels(toplevels);"))
  )

(define (code-name) (gensym "code_vector_"))

;; Literalize compiled code.
;;       
(define-cgen-literal <cgen-scheme-code> <compiled-code>
  ((code-vector :init-keyword :code-vector)
   (code-vector-cname :init-keyword :code-vector-cname)
   (literal-vector :init-keyword :literal-vector)
                  ;; a list of the same size as code-vector, and locations
                  ;; where the code-vector has literals are filled by
                  ;; corresponding <cgen-scheme-value>.
   (arg-info    :init-keyword :arg-info)
                  ;; literal for arg-info of the original compiled code
   (code-name   :init-keyword :code-name)
   (static-record-cname :init-keyword :static-record-cname)
   (inliner     :init-keyword :inliner)
   )
  (make (value)
    (let* ((cv  (vm-code->list value))
           (cvn (gensym "code_vector_"))
           (rec (gensym "code_"))
           (lv  (extract-literals cv))
           (il  (ref value 'intermediate-form))
           )
      (make <cgen-scheme-code> :value value
            :c-name (format "SCM_OBJ(&~a)" rec)
            :code-vector cv :code-vector-cname cvn
            :static-record-cname rec
            :literal-vector lv
            :code-name (cgen-literal (ref value 'name))
            :arg-info (cgen-literal (ref value 'arg-info))
            :inliner (and (vector? il) (cgen-literal il))
            )))
  (decl (self)
    (format #t "static ScmCompiledCode ~a;\n" (ref self 'static-record-cname)))
  (body (self)
    (vectorize-code self)
    (let1 cc (ref self 'value)
      (print "static ScmCompiledCode "(ref self 'static-record-cname)" =")
      (print "    SCM_COMPILED_CODE_CONST_INITIALIZER("
             (ref self 'code-vector-cname)", "
             (length (ref self 'code-vector))", ")
      (print "        "(ref cc 'max-stack)", "
             (ref cc 'required-args)", "
             (ref cc 'optional-args)", "
             (if (cgen-literal-static? (ref self 'code-name))
               (cgen-cexpr (ref self 'code-name))
               "SCM_FALSE")
             ", ")
      (print "        SCM_NIL, "(cgen-cexpr (ref self 'arg-info))", "
             (cgen-cexpr (cgen-literal (ref cc 'parent)))", "
             (if (ref self 'inliner)
               (cgen-cexpr (ref self 'inliner))
               "SCM_FALSE")
             ");"))
    )
  (init (self)
    (unless (cgen-literal-static? (ref self 'code-name))
      (print "  "(ref self 'static-record-cname)".name = "
             (cgen-cexpr (ref self 'code-name))";"))
    (fill-code self))
  (static (self) #t)
  )

(define (extract-literals code)
  (let loop ((code code)
             (lits '()))
    (if (null? code)
      (reverse lits)
      (let* ((insn (car code))
             (info (vm-find-insn-info (car insn))))
        (case (ref info 'operand-type)
          ((none) (loop (cdr code)  (cons #f lits)))
          ((addr) (loop (cddr code) (list* #f #f lits)))
          ((code codes) (loop (cddr code)
                              (list* (cgen-literal (cadr code)) #f lits)))
          ((obj) (loop (cddr code)
                        (list* (cgen-literal (cadr code)) #f lits)))
          ((obj+addr)
           (loop (cdddr code)
                 (list* #f (cgen-literal (cadr code)) #f lits)))
          )))))

(define (vectorize-code code)
  (let ((cv   (ref code 'code-vector))
        (cvn  (ref code 'code-vector-cname))
        (lv   (ref code 'literal-vector)))
    
    (format #t "static ScmWord ~a[] = {\n" cvn)
    (let loop ((cv cv)
               (lv lv)
               (count 0))
      (unless (null? cv)
        (let* ((insn (car cv))
               (info (vm-find-insn-info (car insn))))
          (format #t "  0x~8,'0x,    /* ~3d ~s */\n"
                  (vm-build-insn insn) count insn)
          (case (ref info 'operand-type)
            ((none) (loop (cdr cv) (cdr lv) (+ count 1)))
            ((addr)
             (format #t "  SCM_WORD(&~a[~a]),  /*    ~3d */\n"
                     cvn (cadr cv) (cadr cv))
             (loop (cddr cv) (cddr lv) (+ count 2)))
            ((obj code codes)
             (if (cgen-literal-static? (cadr lv))
               (format #t "  SCM_WORD(~a), /* ~a */\n"
                       (cgen-cexpr (cadr lv)) (cadr cv))
               (format #t "  SCM_WORD(SCM_UNDEFINED), /* ~a (to be filled) */\n"
                       (cadr cv)))
             (loop (cddr cv) (cddr lv) (+ count 2)))
            ((obj+addr)
             (if (cgen-literal-static? (cadr lv))
               (format #t "  SCM_WORD(~a), /* ~a */\n"
                       (cgen-cexpr (cadr lv)) (cadr cv))
               (format #t "  SCM_WORD(SCM_UNDEFINED), /* ~a (to be filled) */\n"
                       (cadr cv)))
             (format #t "  SCM_WORD(&~a[~a]),  /*    ~3d */\n"
                     cvn (caddr cv) (caddr cv))
             (loop (cdddr cv) (cdddr lv) (+ count 3)))
            ))))
    (print "};")))

(define (fill-code code)
  (let ((cvn  (ref code 'code-vector-cname))
        (lv   (ref code 'literal-vector)))
    (for-each-with-index
     (lambda (index lit)
       (when (and lit (not (cgen-literal-static? lit)))
         (print "  "cvn"["index"] = SCM_WORD("(cgen-cexpr lit)");")))
     lv)
    ))

;; NB: this doesn't yet handle identifiers that are inserted by hygienic
;; macro (so that they have different module than the current one).
(define-cgen-literal <cgen-scheme-identifier> <identifier>
  ((id-name   :init-keyword :id-name))
  (make (value)
    (let ((name (ref value 'name))
          (env  (ref value 'env)))
      (unless (null? env)
        (error "identifier with compiler environment can't be compiled" value))
      (make <cgen-scheme-identifier> :value value :c-name (static-obj-cname)
            :id-name (cgen-literal name))))
  (init (self)
    (let ((name (cgen-cexpr (ref self 'id-name)))
          (cname (ref self 'c-name)))
      (print "  "cname" = Scm_MakeIdentifier(SCM_SYMBOL("name"), SCM_NIL);")))
  (static (self) #f)
  )

;; NB: for now, we ignore macros (we assume they are only used within
;; the source file).
(define-cgen-literal <cgen-scheme-macro> <macro>
  ()
  (make (value)
    (make <cgen-scheme-macro> :value value :c-name #f))
  )

(define (get-unit scmfile)
  (make <cgen-unit>
    :name (path-sans-extension scmfile)
    :preamble `(,(format "/* Generated automatically from ~a.  DO NOT EDIT */"
                         scmfile))
    :init-prologue (format "void Scm__Init~a() { ScmModule *mod;"
                           (string-titlecase
                            (string-tr
                             (sys-basename (path-sans-extension scmfile))
                             "-+" "__")))
    ))

;;================================================================
;; Utilities
;;

;; Local variables:
;; mode: scheme
;; end:
